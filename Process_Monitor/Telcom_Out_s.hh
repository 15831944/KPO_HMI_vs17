// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __Telcom__Out_hh__
#define __Telcom__Out_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_Telcom__Out
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_Telcom__Out
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_Telcom__Out
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



struct HeaderType {
  typedef _CORBA_ConstrType_Variable_Var<HeaderType> _var_type;

  
  ::CORBA::String_member MessageLength;

  ::CORBA::String_member MessageId;

  ::CORBA::String_member MessageCount;

  ::CORBA::String_member UnitNo;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef HeaderType::_var_type HeaderType_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< HeaderType,HeaderType_var > HeaderType_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_HeaderType;

_CORBA_MODULE Telegram_Head

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF00

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * Status;

  _CORBA_MODULE_VAR _core_attr const char * RcvMsgId;

  _CORBA_MODULE_VAR _core_attr const char * ErrInf;

  _CORBA_MODULE_VAR _core_attr const char * ErrMess;

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF01

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF01_WATCH_DOG

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF03

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * ProdOrderId;

  _CORBA_MODULE_VAR _core_attr const char * SteelGradeCode;

  _CORBA_MODULE_VAR _core_attr const char * ProdDate;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_ProdDate;

  class t_ProdDate_var;

  class t_ProdDate : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_ProdDate_var _var_type;
    inline t_ProdDate() {}
    inline t_ProdDate(const t_ProdDate& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_ProdDate(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_ProdDate(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_ProdDate& operator = (const t_ProdDate& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_ProdDate_out;

  class t_ProdDate_var {
  public:
    inline t_ProdDate_var() : _pd_seq(0) {}
    inline t_ProdDate_var(t_ProdDate* _s) : _pd_seq(_s) {}
    inline t_ProdDate_var(const t_ProdDate_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_ProdDate(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_ProdDate_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_ProdDate_var& operator = (t_ProdDate* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_ProdDate_var& operator = (const t_ProdDate_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_ProdDate;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_ProdDate* operator -> () { return _pd_seq; }
    inline const t_ProdDate* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_ProdDate& () const { return *_pd_seq; }
#else
    inline operator const t_ProdDate& () const { return *_pd_seq; }
    inline operator t_ProdDate& () { return *_pd_seq; }
#endif
      
    inline const t_ProdDate& in() const { return *_pd_seq; }
    inline t_ProdDate&       inout()    { return *_pd_seq; }
    inline t_ProdDate*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_ProdDate* _retn() { t_ProdDate* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_ProdDate_out;
    
  private:
    t_ProdDate* _pd_seq;
  };

  class t_ProdDate_out {
  public:
    inline t_ProdDate_out(t_ProdDate*& _s) : _data(_s) { _data = 0; }
    inline t_ProdDate_out(t_ProdDate_var& _s)
      : _data(_s._pd_seq) { _s = (t_ProdDate*) 0; }
    inline t_ProdDate_out(const t_ProdDate_out& _s) : _data(_s._data) {}
    inline t_ProdDate_out& operator = (const t_ProdDate_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_ProdDate_out& operator = (t_ProdDate* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_ProdDate*&()  { return _data; }
    inline t_ProdDate*& ptr()       { return _data; }
    inline t_ProdDate* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_ProdDate*& _data;

  private:
    t_ProdDate_out();
    t_ProdDate_out& operator=(const t_ProdDate_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * DepTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_DepTime;

  class t_DepTime_var;

  class t_DepTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_DepTime_var _var_type;
    inline t_DepTime() {}
    inline t_DepTime(const t_DepTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_DepTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_DepTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_DepTime& operator = (const t_DepTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_DepTime_out;

  class t_DepTime_var {
  public:
    inline t_DepTime_var() : _pd_seq(0) {}
    inline t_DepTime_var(t_DepTime* _s) : _pd_seq(_s) {}
    inline t_DepTime_var(const t_DepTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_DepTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_DepTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_DepTime_var& operator = (t_DepTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_DepTime_var& operator = (const t_DepTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_DepTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_DepTime* operator -> () { return _pd_seq; }
    inline const t_DepTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_DepTime& () const { return *_pd_seq; }
#else
    inline operator const t_DepTime& () const { return *_pd_seq; }
    inline operator t_DepTime& () { return *_pd_seq; }
#endif
      
    inline const t_DepTime& in() const { return *_pd_seq; }
    inline t_DepTime&       inout()    { return *_pd_seq; }
    inline t_DepTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_DepTime* _retn() { t_DepTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_DepTime_out;
    
  private:
    t_DepTime* _pd_seq;
  };

  class t_DepTime_out {
  public:
    inline t_DepTime_out(t_DepTime*& _s) : _data(_s) { _data = 0; }
    inline t_DepTime_out(t_DepTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_DepTime*) 0; }
    inline t_DepTime_out(const t_DepTime_out& _s) : _data(_s._data) {}
    inline t_DepTime_out& operator = (const t_DepTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_DepTime_out& operator = (t_DepTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_DepTime*&()  { return _data; }
    inline t_DepTime*& ptr()       { return _data; }
    inline t_DepTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_DepTime*& _data;

  private:
    t_DepTime_out();
    t_DepTime_out& operator=(const t_DepTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * LadleId;

  _CORBA_MODULE_VAR _core_attr const char * ShiftCode;

  _CORBA_MODULE_VAR _core_attr const char * CrewCode;

  _CORBA_MODULE_VAR _core_attr const char * OperCode;

  _CORBA_MODULE_VAR _core_attr const char * RouteCode;

  _CORBA_MODULE_VAR _core_attr const char * AimTemp;

  _CORBA_MODULE_VAR _core_attr const char * UpdateFlag;

  _CORBA_MODULE_VAR _core_attr const char * LadleTareWeight;

  _CORBA_MODULE_VAR _core_attr const char * LadleGrossWeight;

  _CORBA_MODULE_VAR _core_attr const char * SteelWeight;

  _CORBA_MODULE_VAR _core_attr const char * HeatIdCust;

  _CORBA_MODULE_VAR _core_attr const char * TreatIdCust;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF05

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * StirrActivity;

  _CORBA_MODULE_VAR _core_attr const char * StirrGasType;

  _CORBA_MODULE_VAR _core_attr const char * StirrInt;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF06

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF07

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * ModeElec;

  _CORBA_MODULE_VAR _core_attr const char * ModeStirr;

  _CORBA_MODULE_VAR _core_attr const char * ModeMat;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF20

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * AimVoltTap;

  _CORBA_MODULE_VAR _core_attr const char * AimCurveNo;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF20_VOLTAGE_TAP

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * AimVoltTap;

  _CORBA_MODULE_VAR _core_attr const char * AimCurveNo;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF22

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF23

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * ActionFlag;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF25

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * Type;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF30

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * Enabled;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Enabled;

  class t_Enabled_var;

  class t_Enabled : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Enabled_var _var_type;
    inline t_Enabled() {}
    inline t_Enabled(const t_Enabled& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Enabled(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Enabled(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Enabled& operator = (const t_Enabled& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Enabled_out;

  class t_Enabled_var {
  public:
    inline t_Enabled_var() : _pd_seq(0) {}
    inline t_Enabled_var(t_Enabled* _s) : _pd_seq(_s) {}
    inline t_Enabled_var(const t_Enabled_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Enabled(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Enabled_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Enabled_var& operator = (t_Enabled* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Enabled_var& operator = (const t_Enabled_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Enabled;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Enabled* operator -> () { return _pd_seq; }
    inline const t_Enabled* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Enabled& () const { return *_pd_seq; }
#else
    inline operator const t_Enabled& () const { return *_pd_seq; }
    inline operator t_Enabled& () { return *_pd_seq; }
#endif
      
    inline const t_Enabled& in() const { return *_pd_seq; }
    inline t_Enabled&       inout()    { return *_pd_seq; }
    inline t_Enabled*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Enabled* _retn() { t_Enabled* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Enabled_out;
    
  private:
    t_Enabled* _pd_seq;
  };

  class t_Enabled_out {
  public:
    inline t_Enabled_out(t_Enabled*& _s) : _data(_s) { _data = 0; }
    inline t_Enabled_out(t_Enabled_var& _s)
      : _data(_s._pd_seq) { _s = (t_Enabled*) 0; }
    inline t_Enabled_out(const t_Enabled_out& _s) : _data(_s._data) {}
    inline t_Enabled_out& operator = (const t_Enabled_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Enabled_out& operator = (t_Enabled* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Enabled*&()  { return _data; }
    inline t_Enabled*& ptr()       { return _data; }
    inline t_Enabled* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Enabled*& _data;

  private:
    t_Enabled_out();
    t_Enabled_out& operator=(const t_Enabled_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * RemDurStep;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_RemDurStep;

  class t_RemDurStep_var;

  class t_RemDurStep : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef t_RemDurStep_var _var_type;
    inline t_RemDurStep() {}
    inline t_RemDurStep(const t_RemDurStep& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline t_RemDurStep(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline t_RemDurStep(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline t_RemDurStep& operator = (const t_RemDurStep& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class t_RemDurStep_out;

  class t_RemDurStep_var {
  public:
    inline t_RemDurStep_var() : _pd_seq(0) {}
    inline t_RemDurStep_var(t_RemDurStep* _s) : _pd_seq(_s) {}
    inline t_RemDurStep_var(const t_RemDurStep_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_RemDurStep(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_RemDurStep_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_RemDurStep_var& operator = (t_RemDurStep* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_RemDurStep_var& operator = (const t_RemDurStep_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_RemDurStep;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_RemDurStep* operator -> () { return _pd_seq; }
    inline const t_RemDurStep* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_RemDurStep& () const { return *_pd_seq; }
#else
    inline operator const t_RemDurStep& () const { return *_pd_seq; }
    inline operator t_RemDurStep& () { return *_pd_seq; }
#endif
      
    inline const t_RemDurStep& in() const { return *_pd_seq; }
    inline t_RemDurStep&       inout()    { return *_pd_seq; }
    inline t_RemDurStep*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_RemDurStep* _retn() { t_RemDurStep* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_RemDurStep_out;
    
  private:
    t_RemDurStep* _pd_seq;
  };

  class t_RemDurStep_out {
  public:
    inline t_RemDurStep_out(t_RemDurStep*& _s) : _data(_s) { _data = 0; }
    inline t_RemDurStep_out(t_RemDurStep_var& _s)
      : _data(_s._pd_seq) { _s = (t_RemDurStep*) 0; }
    inline t_RemDurStep_out(const t_RemDurStep_out& _s) : _data(_s._data) {}
    inline t_RemDurStep_out& operator = (const t_RemDurStep_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_RemDurStep_out& operator = (t_RemDurStep* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_RemDurStep*&()  { return _data; }
    inline t_RemDurStep*& ptr()       { return _data; }
    inline t_RemDurStep* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_RemDurStep*& _data;

  private:
    t_RemDurStep_out();
    t_RemDurStep_out& operator=(const t_RemDurStep_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * ElecEnergyStep;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_ElecEnergyStep;

  class t_ElecEnergyStep_var;

  class t_ElecEnergyStep : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_ElecEnergyStep_var _var_type;
    inline t_ElecEnergyStep() {}
    inline t_ElecEnergyStep(const t_ElecEnergyStep& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_ElecEnergyStep(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_ElecEnergyStep(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_ElecEnergyStep& operator = (const t_ElecEnergyStep& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_ElecEnergyStep_out;

  class t_ElecEnergyStep_var {
  public:
    inline t_ElecEnergyStep_var() : _pd_seq(0) {}
    inline t_ElecEnergyStep_var(t_ElecEnergyStep* _s) : _pd_seq(_s) {}
    inline t_ElecEnergyStep_var(const t_ElecEnergyStep_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_ElecEnergyStep(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_ElecEnergyStep_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_ElecEnergyStep_var& operator = (t_ElecEnergyStep* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_ElecEnergyStep_var& operator = (const t_ElecEnergyStep_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_ElecEnergyStep;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_ElecEnergyStep* operator -> () { return _pd_seq; }
    inline const t_ElecEnergyStep* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_ElecEnergyStep& () const { return *_pd_seq; }
#else
    inline operator const t_ElecEnergyStep& () const { return *_pd_seq; }
    inline operator t_ElecEnergyStep& () { return *_pd_seq; }
#endif
      
    inline const t_ElecEnergyStep& in() const { return *_pd_seq; }
    inline t_ElecEnergyStep&       inout()    { return *_pd_seq; }
    inline t_ElecEnergyStep*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_ElecEnergyStep* _retn() { t_ElecEnergyStep* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_ElecEnergyStep_out;
    
  private:
    t_ElecEnergyStep* _pd_seq;
  };

  class t_ElecEnergyStep_out {
  public:
    inline t_ElecEnergyStep_out(t_ElecEnergyStep*& _s) : _data(_s) { _data = 0; }
    inline t_ElecEnergyStep_out(t_ElecEnergyStep_var& _s)
      : _data(_s._pd_seq) { _s = (t_ElecEnergyStep*) 0; }
    inline t_ElecEnergyStep_out(const t_ElecEnergyStep_out& _s) : _data(_s._data) {}
    inline t_ElecEnergyStep_out& operator = (const t_ElecEnergyStep_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_ElecEnergyStep_out& operator = (t_ElecEnergyStep* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_ElecEnergyStep*&()  { return _data; }
    inline t_ElecEnergyStep*& ptr()       { return _data; }
    inline t_ElecEnergyStep* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_ElecEnergyStep*& _data;

  private:
    t_ElecEnergyStep_out();
    t_ElecEnergyStep_out& operator=(const t_ElecEnergyStep_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * TempEndStep;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_TempEndStep;

  class t_TempEndStep_var;

  class t_TempEndStep : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_TempEndStep_var _var_type;
    inline t_TempEndStep() {}
    inline t_TempEndStep(const t_TempEndStep& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_TempEndStep(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_TempEndStep(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_TempEndStep& operator = (const t_TempEndStep& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_TempEndStep_out;

  class t_TempEndStep_var {
  public:
    inline t_TempEndStep_var() : _pd_seq(0) {}
    inline t_TempEndStep_var(t_TempEndStep* _s) : _pd_seq(_s) {}
    inline t_TempEndStep_var(const t_TempEndStep_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_TempEndStep(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_TempEndStep_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_TempEndStep_var& operator = (t_TempEndStep* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_TempEndStep_var& operator = (const t_TempEndStep_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_TempEndStep;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_TempEndStep* operator -> () { return _pd_seq; }
    inline const t_TempEndStep* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_TempEndStep& () const { return *_pd_seq; }
#else
    inline operator const t_TempEndStep& () const { return *_pd_seq; }
    inline operator t_TempEndStep& () { return *_pd_seq; }
#endif
      
    inline const t_TempEndStep& in() const { return *_pd_seq; }
    inline t_TempEndStep&       inout()    { return *_pd_seq; }
    inline t_TempEndStep*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_TempEndStep* _retn() { t_TempEndStep* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_TempEndStep_out;
    
  private:
    t_TempEndStep* _pd_seq;
  };

  class t_TempEndStep_out {
  public:
    inline t_TempEndStep_out(t_TempEndStep*& _s) : _data(_s) { _data = 0; }
    inline t_TempEndStep_out(t_TempEndStep_var& _s)
      : _data(_s._pd_seq) { _s = (t_TempEndStep*) 0; }
    inline t_TempEndStep_out(const t_TempEndStep_out& _s) : _data(_s._data) {}
    inline t_TempEndStep_out& operator = (const t_TempEndStep_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_TempEndStep_out& operator = (t_TempEndStep* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_TempEndStep*&()  { return _data; }
    inline t_TempEndStep*& ptr()       { return _data; }
    inline t_TempEndStep* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_TempEndStep*& _data;

  private:
    t_TempEndStep_out();
    t_TempEndStep_out& operator=(const t_TempEndStep_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * AimVoltTap;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_AimVoltTap;

  class t_AimVoltTap_var;

  class t_AimVoltTap : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_AimVoltTap_var _var_type;
    inline t_AimVoltTap() {}
    inline t_AimVoltTap(const t_AimVoltTap& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_AimVoltTap(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_AimVoltTap(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_AimVoltTap& operator = (const t_AimVoltTap& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_AimVoltTap_out;

  class t_AimVoltTap_var {
  public:
    inline t_AimVoltTap_var() : _pd_seq(0) {}
    inline t_AimVoltTap_var(t_AimVoltTap* _s) : _pd_seq(_s) {}
    inline t_AimVoltTap_var(const t_AimVoltTap_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_AimVoltTap(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_AimVoltTap_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_AimVoltTap_var& operator = (t_AimVoltTap* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_AimVoltTap_var& operator = (const t_AimVoltTap_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_AimVoltTap;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_AimVoltTap* operator -> () { return _pd_seq; }
    inline const t_AimVoltTap* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_AimVoltTap& () const { return *_pd_seq; }
#else
    inline operator const t_AimVoltTap& () const { return *_pd_seq; }
    inline operator t_AimVoltTap& () { return *_pd_seq; }
#endif
      
    inline const t_AimVoltTap& in() const { return *_pd_seq; }
    inline t_AimVoltTap&       inout()    { return *_pd_seq; }
    inline t_AimVoltTap*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_AimVoltTap* _retn() { t_AimVoltTap* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_AimVoltTap_out;
    
  private:
    t_AimVoltTap* _pd_seq;
  };

  class t_AimVoltTap_out {
  public:
    inline t_AimVoltTap_out(t_AimVoltTap*& _s) : _data(_s) { _data = 0; }
    inline t_AimVoltTap_out(t_AimVoltTap_var& _s)
      : _data(_s._pd_seq) { _s = (t_AimVoltTap*) 0; }
    inline t_AimVoltTap_out(const t_AimVoltTap_out& _s) : _data(_s._data) {}
    inline t_AimVoltTap_out& operator = (const t_AimVoltTap_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_AimVoltTap_out& operator = (t_AimVoltTap* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_AimVoltTap*&()  { return _data; }
    inline t_AimVoltTap*& ptr()       { return _data; }
    inline t_AimVoltTap* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_AimVoltTap*& _data;

  private:
    t_AimVoltTap_out();
    t_AimVoltTap_out& operator=(const t_AimVoltTap_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * AimCurveNo;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_AimCurveNo;

  class t_AimCurveNo_var;

  class t_AimCurveNo : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_AimCurveNo_var _var_type;
    inline t_AimCurveNo() {}
    inline t_AimCurveNo(const t_AimCurveNo& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_AimCurveNo(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_AimCurveNo(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_AimCurveNo& operator = (const t_AimCurveNo& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_AimCurveNo_out;

  class t_AimCurveNo_var {
  public:
    inline t_AimCurveNo_var() : _pd_seq(0) {}
    inline t_AimCurveNo_var(t_AimCurveNo* _s) : _pd_seq(_s) {}
    inline t_AimCurveNo_var(const t_AimCurveNo_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_AimCurveNo(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_AimCurveNo_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_AimCurveNo_var& operator = (t_AimCurveNo* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_AimCurveNo_var& operator = (const t_AimCurveNo_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_AimCurveNo;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_AimCurveNo* operator -> () { return _pd_seq; }
    inline const t_AimCurveNo* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_AimCurveNo& () const { return *_pd_seq; }
#else
    inline operator const t_AimCurveNo& () const { return *_pd_seq; }
    inline operator t_AimCurveNo& () { return *_pd_seq; }
#endif
      
    inline const t_AimCurveNo& in() const { return *_pd_seq; }
    inline t_AimCurveNo&       inout()    { return *_pd_seq; }
    inline t_AimCurveNo*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_AimCurveNo* _retn() { t_AimCurveNo* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_AimCurveNo_out;
    
  private:
    t_AimCurveNo* _pd_seq;
  };

  class t_AimCurveNo_out {
  public:
    inline t_AimCurveNo_out(t_AimCurveNo*& _s) : _data(_s) { _data = 0; }
    inline t_AimCurveNo_out(t_AimCurveNo_var& _s)
      : _data(_s._pd_seq) { _s = (t_AimCurveNo*) 0; }
    inline t_AimCurveNo_out(const t_AimCurveNo_out& _s) : _data(_s._data) {}
    inline t_AimCurveNo_out& operator = (const t_AimCurveNo_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_AimCurveNo_out& operator = (t_AimCurveNo* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_AimCurveNo*&()  { return _data; }
    inline t_AimCurveNo*& ptr()       { return _data; }
    inline t_AimCurveNo* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_AimCurveNo*& _data;

  private:
    t_AimCurveNo_out();
    t_AimCurveNo_out& operator=(const t_AimCurveNo_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF30_ELEC_PATT

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * ENTRY;

  struct sENTRY {
    typedef _CORBA_ConstrType_Variable_Var<sENTRY> _var_type;

    
    ::CORBA::Long MessageCount;

    ::CORBA::Long MessageIndex;

    ::CORBA::String_member HeatId;

    ::CORBA::String_member TreatId;

    ::CORBA::Long ActivityType;

    ::CORBA::Long StepNo;

    ::CORBA::Long Enabled;

    ::CORBA::Double RemDurStep;

    ::CORBA::Long ElecEnergyStep;

    ::CORBA::Long TempEndStep;

    ::CORBA::Long AimVoltTap;

    ::CORBA::Long AimCurveNo;

    ::CORBA::Long Spare_1;

    ::CORBA::Long Spare_2;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef sENTRY::_var_type sENTRY_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< sENTRY,sENTRY_var > sENTRY_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sENTRY;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_ENTRY;

  class t_ENTRY_var;

  class t_ENTRY : public _CORBA_Unbounded_Sequence< sENTRY >  {
  public:
    typedef t_ENTRY_var _var_type;
    inline t_ENTRY() {}
    inline t_ENTRY(const t_ENTRY& _s)
      : _CORBA_Unbounded_Sequence< sENTRY > (_s) {}

    inline t_ENTRY(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< sENTRY > (_max) {}
    inline t_ENTRY(_CORBA_ULong _max, _CORBA_ULong _len, sENTRY* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< sENTRY > (_max, _len, _val, _rel) {}

  

    inline t_ENTRY& operator = (const t_ENTRY& _s) {
      _CORBA_Unbounded_Sequence< sENTRY > ::operator=(_s);
      return *this;
    }
  };

  class t_ENTRY_out;

  class t_ENTRY_var {
  public:
    inline t_ENTRY_var() : _pd_seq(0) {}
    inline t_ENTRY_var(t_ENTRY* _s) : _pd_seq(_s) {}
    inline t_ENTRY_var(const t_ENTRY_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_ENTRY(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_ENTRY_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_ENTRY_var& operator = (t_ENTRY* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_ENTRY_var& operator = (const t_ENTRY_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_ENTRY;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline sENTRY& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_ENTRY* operator -> () { return _pd_seq; }
    inline const t_ENTRY* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_ENTRY& () const { return *_pd_seq; }
#else
    inline operator const t_ENTRY& () const { return *_pd_seq; }
    inline operator t_ENTRY& () { return *_pd_seq; }
#endif
      
    inline const t_ENTRY& in() const { return *_pd_seq; }
    inline t_ENTRY&       inout()    { return *_pd_seq; }
    inline t_ENTRY*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_ENTRY* _retn() { t_ENTRY* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_ENTRY_out;
    
  private:
    t_ENTRY* _pd_seq;
  };

  class t_ENTRY_out {
  public:
    inline t_ENTRY_out(t_ENTRY*& _s) : _data(_s) { _data = 0; }
    inline t_ENTRY_out(t_ENTRY_var& _s)
      : _data(_s._pd_seq) { _s = (t_ENTRY*) 0; }
    inline t_ENTRY_out(const t_ENTRY_out& _s) : _data(_s._data) {}
    inline t_ENTRY_out& operator = (const t_ENTRY_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_ENTRY_out& operator = (t_ENTRY* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_ENTRY*&()  { return _data; }
    inline t_ENTRY*& ptr()       { return _data; }
    inline t_ENTRY* operator->() { return _data; }

    inline sENTRY& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_ENTRY*& _data;

  private:
    t_ENTRY_out();
    t_ENTRY_out& operator=(const t_ENTRY_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF31

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * PhaseNo;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_PhaseNo;

  class t_PhaseNo_var;

  class t_PhaseNo : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_PhaseNo_var _var_type;
    inline t_PhaseNo() {}
    inline t_PhaseNo(const t_PhaseNo& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_PhaseNo(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_PhaseNo(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_PhaseNo& operator = (const t_PhaseNo& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_PhaseNo_out;

  class t_PhaseNo_var {
  public:
    inline t_PhaseNo_var() : _pd_seq(0) {}
    inline t_PhaseNo_var(t_PhaseNo* _s) : _pd_seq(_s) {}
    inline t_PhaseNo_var(const t_PhaseNo_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_PhaseNo(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_PhaseNo_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_PhaseNo_var& operator = (t_PhaseNo* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_PhaseNo_var& operator = (const t_PhaseNo_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_PhaseNo;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_PhaseNo* operator -> () { return _pd_seq; }
    inline const t_PhaseNo* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_PhaseNo& () const { return *_pd_seq; }
#else
    inline operator const t_PhaseNo& () const { return *_pd_seq; }
    inline operator t_PhaseNo& () { return *_pd_seq; }
#endif
      
    inline const t_PhaseNo& in() const { return *_pd_seq; }
    inline t_PhaseNo&       inout()    { return *_pd_seq; }
    inline t_PhaseNo*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_PhaseNo* _retn() { t_PhaseNo* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_PhaseNo_out;
    
  private:
    t_PhaseNo* _pd_seq;
  };

  class t_PhaseNo_out {
  public:
    inline t_PhaseNo_out(t_PhaseNo*& _s) : _data(_s) { _data = 0; }
    inline t_PhaseNo_out(t_PhaseNo_var& _s)
      : _data(_s._pd_seq) { _s = (t_PhaseNo*) 0; }
    inline t_PhaseNo_out(const t_PhaseNo_out& _s) : _data(_s._data) {}
    inline t_PhaseNo_out& operator = (const t_PhaseNo_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_PhaseNo_out& operator = (t_PhaseNo* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_PhaseNo*&()  { return _data; }
    inline t_PhaseNo*& ptr()       { return _data; }
    inline t_PhaseNo* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_PhaseNo*& _data;

  private:
    t_PhaseNo_out();
    t_PhaseNo_out& operator=(const t_PhaseNo_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Enabled;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Enabled;

  class t_Enabled_var;

  class t_Enabled : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Enabled_var _var_type;
    inline t_Enabled() {}
    inline t_Enabled(const t_Enabled& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Enabled(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Enabled(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Enabled& operator = (const t_Enabled& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Enabled_out;

  class t_Enabled_var {
  public:
    inline t_Enabled_var() : _pd_seq(0) {}
    inline t_Enabled_var(t_Enabled* _s) : _pd_seq(_s) {}
    inline t_Enabled_var(const t_Enabled_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Enabled(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Enabled_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Enabled_var& operator = (t_Enabled* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Enabled_var& operator = (const t_Enabled_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Enabled;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Enabled* operator -> () { return _pd_seq; }
    inline const t_Enabled* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Enabled& () const { return *_pd_seq; }
#else
    inline operator const t_Enabled& () const { return *_pd_seq; }
    inline operator t_Enabled& () { return *_pd_seq; }
#endif
      
    inline const t_Enabled& in() const { return *_pd_seq; }
    inline t_Enabled&       inout()    { return *_pd_seq; }
    inline t_Enabled*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Enabled* _retn() { t_Enabled* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Enabled_out;
    
  private:
    t_Enabled* _pd_seq;
  };

  class t_Enabled_out {
  public:
    inline t_Enabled_out(t_Enabled*& _s) : _data(_s) { _data = 0; }
    inline t_Enabled_out(t_Enabled_var& _s)
      : _data(_s._pd_seq) { _s = (t_Enabled*) 0; }
    inline t_Enabled_out(const t_Enabled_out& _s) : _data(_s._data) {}
    inline t_Enabled_out& operator = (const t_Enabled_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Enabled_out& operator = (t_Enabled* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Enabled*&()  { return _data; }
    inline t_Enabled*& ptr()       { return _data; }
    inline t_Enabled* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Enabled*& _data;

  private:
    t_Enabled_out();
    t_Enabled_out& operator=(const t_Enabled_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Duration;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Duration;

  class t_Duration_var;

  class t_Duration : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef t_Duration_var _var_type;
    inline t_Duration() {}
    inline t_Duration(const t_Duration& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline t_Duration(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline t_Duration(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline t_Duration& operator = (const t_Duration& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class t_Duration_out;

  class t_Duration_var {
  public:
    inline t_Duration_var() : _pd_seq(0) {}
    inline t_Duration_var(t_Duration* _s) : _pd_seq(_s) {}
    inline t_Duration_var(const t_Duration_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Duration(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Duration_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Duration_var& operator = (t_Duration* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Duration_var& operator = (const t_Duration_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Duration;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Duration* operator -> () { return _pd_seq; }
    inline const t_Duration* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Duration& () const { return *_pd_seq; }
#else
    inline operator const t_Duration& () const { return *_pd_seq; }
    inline operator t_Duration& () { return *_pd_seq; }
#endif
      
    inline const t_Duration& in() const { return *_pd_seq; }
    inline t_Duration&       inout()    { return *_pd_seq; }
    inline t_Duration*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Duration* _retn() { t_Duration* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Duration_out;
    
  private:
    t_Duration* _pd_seq;
  };

  class t_Duration_out {
  public:
    inline t_Duration_out(t_Duration*& _s) : _data(_s) { _data = 0; }
    inline t_Duration_out(t_Duration_var& _s)
      : _data(_s._pd_seq) { _s = (t_Duration*) 0; }
    inline t_Duration_out(const t_Duration_out& _s) : _data(_s._data) {}
    inline t_Duration_out& operator = (const t_Duration_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Duration_out& operator = (t_Duration* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Duration*&()  { return _data; }
    inline t_Duration*& ptr()       { return _data; }
    inline t_Duration* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Duration*& _data;

  private:
    t_Duration_out();
    t_Duration_out& operator=(const t_Duration_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * StirrInt;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_StirrInt;

  class t_StirrInt_var;

  class t_StirrInt : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_StirrInt_var _var_type;
    inline t_StirrInt() {}
    inline t_StirrInt(const t_StirrInt& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_StirrInt(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_StirrInt(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_StirrInt& operator = (const t_StirrInt& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_StirrInt_out;

  class t_StirrInt_var {
  public:
    inline t_StirrInt_var() : _pd_seq(0) {}
    inline t_StirrInt_var(t_StirrInt* _s) : _pd_seq(_s) {}
    inline t_StirrInt_var(const t_StirrInt_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_StirrInt(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_StirrInt_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_StirrInt_var& operator = (t_StirrInt* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_StirrInt_var& operator = (const t_StirrInt_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_StirrInt;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_StirrInt* operator -> () { return _pd_seq; }
    inline const t_StirrInt* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_StirrInt& () const { return *_pd_seq; }
#else
    inline operator const t_StirrInt& () const { return *_pd_seq; }
    inline operator t_StirrInt& () { return *_pd_seq; }
#endif
      
    inline const t_StirrInt& in() const { return *_pd_seq; }
    inline t_StirrInt&       inout()    { return *_pd_seq; }
    inline t_StirrInt*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_StirrInt* _retn() { t_StirrInt* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_StirrInt_out;
    
  private:
    t_StirrInt* _pd_seq;
  };

  class t_StirrInt_out {
  public:
    inline t_StirrInt_out(t_StirrInt*& _s) : _data(_s) { _data = 0; }
    inline t_StirrInt_out(t_StirrInt_var& _s)
      : _data(_s._pd_seq) { _s = (t_StirrInt*) 0; }
    inline t_StirrInt_out(const t_StirrInt_out& _s) : _data(_s._data) {}
    inline t_StirrInt_out& operator = (const t_StirrInt_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_StirrInt_out& operator = (t_StirrInt* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_StirrInt*&()  { return _data; }
    inline t_StirrInt*& ptr()       { return _data; }
    inline t_StirrInt* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_StirrInt*& _data;

  private:
    t_StirrInt_out();
    t_StirrInt_out& operator=(const t_StirrInt_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * StirrGasFlow;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_StirrGasFlow;

  class t_StirrGasFlow_var;

  class t_StirrGasFlow : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef t_StirrGasFlow_var _var_type;
    inline t_StirrGasFlow() {}
    inline t_StirrGasFlow(const t_StirrGasFlow& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline t_StirrGasFlow(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline t_StirrGasFlow(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline t_StirrGasFlow& operator = (const t_StirrGasFlow& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class t_StirrGasFlow_out;

  class t_StirrGasFlow_var {
  public:
    inline t_StirrGasFlow_var() : _pd_seq(0) {}
    inline t_StirrGasFlow_var(t_StirrGasFlow* _s) : _pd_seq(_s) {}
    inline t_StirrGasFlow_var(const t_StirrGasFlow_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_StirrGasFlow(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_StirrGasFlow_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_StirrGasFlow_var& operator = (t_StirrGasFlow* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_StirrGasFlow_var& operator = (const t_StirrGasFlow_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_StirrGasFlow;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_StirrGasFlow* operator -> () { return _pd_seq; }
    inline const t_StirrGasFlow* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_StirrGasFlow& () const { return *_pd_seq; }
#else
    inline operator const t_StirrGasFlow& () const { return *_pd_seq; }
    inline operator t_StirrGasFlow& () { return *_pd_seq; }
#endif
      
    inline const t_StirrGasFlow& in() const { return *_pd_seq; }
    inline t_StirrGasFlow&       inout()    { return *_pd_seq; }
    inline t_StirrGasFlow*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_StirrGasFlow* _retn() { t_StirrGasFlow* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_StirrGasFlow_out;
    
  private:
    t_StirrGasFlow* _pd_seq;
  };

  class t_StirrGasFlow_out {
  public:
    inline t_StirrGasFlow_out(t_StirrGasFlow*& _s) : _data(_s) { _data = 0; }
    inline t_StirrGasFlow_out(t_StirrGasFlow_var& _s)
      : _data(_s._pd_seq) { _s = (t_StirrGasFlow*) 0; }
    inline t_StirrGasFlow_out(const t_StirrGasFlow_out& _s) : _data(_s._data) {}
    inline t_StirrGasFlow_out& operator = (const t_StirrGasFlow_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_StirrGasFlow_out& operator = (t_StirrGasFlow* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_StirrGasFlow*&()  { return _data; }
    inline t_StirrGasFlow*& ptr()       { return _data; }
    inline t_StirrGasFlow* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_StirrGasFlow*& _data;

  private:
    t_StirrGasFlow_out();
    t_StirrGasFlow_out& operator=(const t_StirrGasFlow_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * StirrGasType;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_StirrGasType;

  class t_StirrGasType_var;

  class t_StirrGasType : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_StirrGasType_var _var_type;
    inline t_StirrGasType() {}
    inline t_StirrGasType(const t_StirrGasType& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_StirrGasType(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_StirrGasType(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_StirrGasType& operator = (const t_StirrGasType& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_StirrGasType_out;

  class t_StirrGasType_var {
  public:
    inline t_StirrGasType_var() : _pd_seq(0) {}
    inline t_StirrGasType_var(t_StirrGasType* _s) : _pd_seq(_s) {}
    inline t_StirrGasType_var(const t_StirrGasType_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_StirrGasType(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_StirrGasType_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_StirrGasType_var& operator = (t_StirrGasType* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_StirrGasType_var& operator = (const t_StirrGasType_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_StirrGasType;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_StirrGasType* operator -> () { return _pd_seq; }
    inline const t_StirrGasType* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_StirrGasType& () const { return *_pd_seq; }
#else
    inline operator const t_StirrGasType& () const { return *_pd_seq; }
    inline operator t_StirrGasType& () { return *_pd_seq; }
#endif
      
    inline const t_StirrGasType& in() const { return *_pd_seq; }
    inline t_StirrGasType&       inout()    { return *_pd_seq; }
    inline t_StirrGasType*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_StirrGasType* _retn() { t_StirrGasType* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_StirrGasType_out;
    
  private:
    t_StirrGasType* _pd_seq;
  };

  class t_StirrGasType_out {
  public:
    inline t_StirrGasType_out(t_StirrGasType*& _s) : _data(_s) { _data = 0; }
    inline t_StirrGasType_out(t_StirrGasType_var& _s)
      : _data(_s._pd_seq) { _s = (t_StirrGasType*) 0; }
    inline t_StirrGasType_out(const t_StirrGasType_out& _s) : _data(_s._data) {}
    inline t_StirrGasType_out& operator = (const t_StirrGasType_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_StirrGasType_out& operator = (t_StirrGasType* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_StirrGasType*&()  { return _data; }
    inline t_StirrGasType*& ptr()       { return _data; }
    inline t_StirrGasType* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_StirrGasType*& _data;

  private:
    t_StirrGasType_out();
    t_StirrGasType_out& operator=(const t_StirrGasType_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * StepPriority;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_StepPriority;

  class t_StepPriority_var;

  class t_StepPriority : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_StepPriority_var _var_type;
    inline t_StepPriority() {}
    inline t_StepPriority(const t_StepPriority& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_StepPriority(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_StepPriority(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_StepPriority& operator = (const t_StepPriority& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_StepPriority_out;

  class t_StepPriority_var {
  public:
    inline t_StepPriority_var() : _pd_seq(0) {}
    inline t_StepPriority_var(t_StepPriority* _s) : _pd_seq(_s) {}
    inline t_StepPriority_var(const t_StepPriority_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_StepPriority(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_StepPriority_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_StepPriority_var& operator = (t_StepPriority* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_StepPriority_var& operator = (const t_StepPriority_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_StepPriority;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_StepPriority* operator -> () { return _pd_seq; }
    inline const t_StepPriority* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_StepPriority& () const { return *_pd_seq; }
#else
    inline operator const t_StepPriority& () const { return *_pd_seq; }
    inline operator t_StepPriority& () { return *_pd_seq; }
#endif
      
    inline const t_StepPriority& in() const { return *_pd_seq; }
    inline t_StepPriority&       inout()    { return *_pd_seq; }
    inline t_StepPriority*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_StepPriority* _retn() { t_StepPriority* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_StepPriority_out;
    
  private:
    t_StepPriority* _pd_seq;
  };

  class t_StepPriority_out {
  public:
    inline t_StepPriority_out(t_StepPriority*& _s) : _data(_s) { _data = 0; }
    inline t_StepPriority_out(t_StepPriority_var& _s)
      : _data(_s._pd_seq) { _s = (t_StepPriority*) 0; }
    inline t_StepPriority_out(const t_StepPriority_out& _s) : _data(_s._data) {}
    inline t_StepPriority_out& operator = (const t_StepPriority_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_StepPriority_out& operator = (t_StepPriority* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_StepPriority*&()  { return _data; }
    inline t_StepPriority*& ptr()       { return _data; }
    inline t_StepPriority* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_StepPriority*& _data;

  private:
    t_StepPriority_out();
    t_StepPriority_out& operator=(const t_StepPriority_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF31_STIRR_PATT

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * ENTRY;

  struct sENTRY {
    typedef _CORBA_ConstrType_Variable_Var<sENTRY> _var_type;

    
    ::CORBA::Long MessageCount;

    ::CORBA::Long MessageIndex;

    ::CORBA::String_member HeatId;

    ::CORBA::String_member TreatId;

    ::CORBA::Long PhaseNo;

    ::CORBA::Long Enabled;

    ::CORBA::Double Duration;

    ::CORBA::Long StirrInt;

    ::CORBA::Double StirrGasFlow;

    ::CORBA::Long StirrGasType;

    ::CORBA::Long StepPriority;

    ::CORBA::Long Spare_1;

    ::CORBA::Long Spare_2;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef sENTRY::_var_type sENTRY_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< sENTRY,sENTRY_var > sENTRY_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sENTRY;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_ENTRY;

  class t_ENTRY_var;

  class t_ENTRY : public _CORBA_Unbounded_Sequence< sENTRY >  {
  public:
    typedef t_ENTRY_var _var_type;
    inline t_ENTRY() {}
    inline t_ENTRY(const t_ENTRY& _s)
      : _CORBA_Unbounded_Sequence< sENTRY > (_s) {}

    inline t_ENTRY(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< sENTRY > (_max) {}
    inline t_ENTRY(_CORBA_ULong _max, _CORBA_ULong _len, sENTRY* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< sENTRY > (_max, _len, _val, _rel) {}

  

    inline t_ENTRY& operator = (const t_ENTRY& _s) {
      _CORBA_Unbounded_Sequence< sENTRY > ::operator=(_s);
      return *this;
    }
  };

  class t_ENTRY_out;

  class t_ENTRY_var {
  public:
    inline t_ENTRY_var() : _pd_seq(0) {}
    inline t_ENTRY_var(t_ENTRY* _s) : _pd_seq(_s) {}
    inline t_ENTRY_var(const t_ENTRY_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_ENTRY(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_ENTRY_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_ENTRY_var& operator = (t_ENTRY* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_ENTRY_var& operator = (const t_ENTRY_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_ENTRY;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline sENTRY& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_ENTRY* operator -> () { return _pd_seq; }
    inline const t_ENTRY* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_ENTRY& () const { return *_pd_seq; }
#else
    inline operator const t_ENTRY& () const { return *_pd_seq; }
    inline operator t_ENTRY& () { return *_pd_seq; }
#endif
      
    inline const t_ENTRY& in() const { return *_pd_seq; }
    inline t_ENTRY&       inout()    { return *_pd_seq; }
    inline t_ENTRY*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_ENTRY* _retn() { t_ENTRY* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_ENTRY_out;
    
  private:
    t_ENTRY* _pd_seq;
  };

  class t_ENTRY_out {
  public:
    inline t_ENTRY_out(t_ENTRY*& _s) : _data(_s) { _data = 0; }
    inline t_ENTRY_out(t_ENTRY_var& _s)
      : _data(_s._pd_seq) { _s = (t_ENTRY*) 0; }
    inline t_ENTRY_out(const t_ENTRY_out& _s) : _data(_s._data) {}
    inline t_ENTRY_out& operator = (const t_ENTRY_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_ENTRY_out& operator = (t_ENTRY* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_ENTRY*&()  { return _data; }
    inline t_ENTRY*& ptr()       { return _data; }
    inline t_ENTRY* operator->() { return _data; }

    inline sENTRY& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_ENTRY*& _data;

  private:
    t_ENTRY_out();
    t_ENTRY_out& operator=(const t_ENTRY_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF40

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * ParamName;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_ParamName;

  class t_ParamName_var;

  class t_ParamName : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef t_ParamName_var _var_type;
    inline t_ParamName() {}
    inline t_ParamName(const t_ParamName& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline t_ParamName(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline t_ParamName(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline t_ParamName& operator = (const t_ParamName& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class t_ParamName_out;

  class t_ParamName_var {
  public:
    inline t_ParamName_var() : _pd_seq(0) {}
    inline t_ParamName_var(t_ParamName* _s) : _pd_seq(_s) {}
    inline t_ParamName_var(const t_ParamName_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_ParamName(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_ParamName_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_ParamName_var& operator = (t_ParamName* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_ParamName_var& operator = (const t_ParamName_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_ParamName;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_ParamName* operator -> () { return _pd_seq; }
    inline const t_ParamName* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_ParamName& () const { return *_pd_seq; }
#else
    inline operator const t_ParamName& () const { return *_pd_seq; }
    inline operator t_ParamName& () { return *_pd_seq; }
#endif
      
    inline const t_ParamName& in() const { return *_pd_seq; }
    inline t_ParamName&       inout()    { return *_pd_seq; }
    inline t_ParamName*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_ParamName* _retn() { t_ParamName* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_ParamName_out;
    
  private:
    t_ParamName* _pd_seq;
  };

  class t_ParamName_out {
  public:
    inline t_ParamName_out(t_ParamName*& _s) : _data(_s) { _data = 0; }
    inline t_ParamName_out(t_ParamName_var& _s)
      : _data(_s._pd_seq) { _s = (t_ParamName*) 0; }
    inline t_ParamName_out(const t_ParamName_out& _s) : _data(_s._data) {}
    inline t_ParamName_out& operator = (const t_ParamName_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_ParamName_out& operator = (t_ParamName* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_ParamName*&()  { return _data; }
    inline t_ParamName*& ptr()       { return _data; }
    inline t_ParamName* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_ParamName*& _data;

  private:
    t_ParamName_out();
    t_ParamName_out& operator=(const t_ParamName_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * ParamValue;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_ParamValue;

  class t_ParamValue_var;

  class t_ParamValue : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef t_ParamValue_var _var_type;
    inline t_ParamValue() {}
    inline t_ParamValue(const t_ParamValue& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline t_ParamValue(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline t_ParamValue(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline t_ParamValue& operator = (const t_ParamValue& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class t_ParamValue_out;

  class t_ParamValue_var {
  public:
    inline t_ParamValue_var() : _pd_seq(0) {}
    inline t_ParamValue_var(t_ParamValue* _s) : _pd_seq(_s) {}
    inline t_ParamValue_var(const t_ParamValue_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_ParamValue(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_ParamValue_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_ParamValue_var& operator = (t_ParamValue* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_ParamValue_var& operator = (const t_ParamValue_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_ParamValue;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_ParamValue* operator -> () { return _pd_seq; }
    inline const t_ParamValue* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_ParamValue& () const { return *_pd_seq; }
#else
    inline operator const t_ParamValue& () const { return *_pd_seq; }
    inline operator t_ParamValue& () { return *_pd_seq; }
#endif
      
    inline const t_ParamValue& in() const { return *_pd_seq; }
    inline t_ParamValue&       inout()    { return *_pd_seq; }
    inline t_ParamValue*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_ParamValue* _retn() { t_ParamValue* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_ParamValue_out;
    
  private:
    t_ParamValue* _pd_seq;
  };

  class t_ParamValue_out {
  public:
    inline t_ParamValue_out(t_ParamValue*& _s) : _data(_s) { _data = 0; }
    inline t_ParamValue_out(t_ParamValue_var& _s)
      : _data(_s._pd_seq) { _s = (t_ParamValue*) 0; }
    inline t_ParamValue_out(const t_ParamValue_out& _s) : _data(_s._data) {}
    inline t_ParamValue_out& operator = (const t_ParamValue_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_ParamValue_out& operator = (t_ParamValue* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_ParamValue*&()  { return _data; }
    inline t_ParamValue*& ptr()       { return _data; }
    inline t_ParamValue* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_ParamValue*& _data;

  private:
    t_ParamValue_out();
    t_ParamValue_out& operator=(const t_ParamValue_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF70

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * Source;

  _CORBA_MODULE_VAR _core_attr const char * RecipeNo;

  _CORBA_MODULE_VAR _core_attr const char * MatCode;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_MatCode;

  class t_MatCode_var;

  class t_MatCode : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef t_MatCode_var _var_type;
    inline t_MatCode() {}
    inline t_MatCode(const t_MatCode& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline t_MatCode(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline t_MatCode(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline t_MatCode& operator = (const t_MatCode& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class t_MatCode_out;

  class t_MatCode_var {
  public:
    inline t_MatCode_var() : _pd_seq(0) {}
    inline t_MatCode_var(t_MatCode* _s) : _pd_seq(_s) {}
    inline t_MatCode_var(const t_MatCode_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_MatCode(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_MatCode_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_MatCode_var& operator = (t_MatCode* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_MatCode_var& operator = (const t_MatCode_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_MatCode;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_MatCode* operator -> () { return _pd_seq; }
    inline const t_MatCode* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_MatCode& () const { return *_pd_seq; }
#else
    inline operator const t_MatCode& () const { return *_pd_seq; }
    inline operator t_MatCode& () { return *_pd_seq; }
#endif
      
    inline const t_MatCode& in() const { return *_pd_seq; }
    inline t_MatCode&       inout()    { return *_pd_seq; }
    inline t_MatCode*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_MatCode* _retn() { t_MatCode* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_MatCode_out;
    
  private:
    t_MatCode* _pd_seq;
  };

  class t_MatCode_out {
  public:
    inline t_MatCode_out(t_MatCode*& _s) : _data(_s) { _data = 0; }
    inline t_MatCode_out(t_MatCode_var& _s)
      : _data(_s._pd_seq) { _s = (t_MatCode*) 0; }
    inline t_MatCode_out(const t_MatCode_out& _s) : _data(_s._data) {}
    inline t_MatCode_out& operator = (const t_MatCode_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_MatCode_out& operator = (t_MatCode* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_MatCode*&()  { return _data; }
    inline t_MatCode*& ptr()       { return _data; }
    inline t_MatCode* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_MatCode*& _data;

  private:
    t_MatCode_out();
    t_MatCode_out& operator=(const t_MatCode_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * MatWeight;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_MatWeight;

  class t_MatWeight_var;

  class t_MatWeight : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_MatWeight_var _var_type;
    inline t_MatWeight() {}
    inline t_MatWeight(const t_MatWeight& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_MatWeight(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_MatWeight(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_MatWeight& operator = (const t_MatWeight& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_MatWeight_out;

  class t_MatWeight_var {
  public:
    inline t_MatWeight_var() : _pd_seq(0) {}
    inline t_MatWeight_var(t_MatWeight* _s) : _pd_seq(_s) {}
    inline t_MatWeight_var(const t_MatWeight_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_MatWeight(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_MatWeight_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_MatWeight_var& operator = (t_MatWeight* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_MatWeight_var& operator = (const t_MatWeight_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_MatWeight;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_MatWeight* operator -> () { return _pd_seq; }
    inline const t_MatWeight* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_MatWeight& () const { return *_pd_seq; }
#else
    inline operator const t_MatWeight& () const { return *_pd_seq; }
    inline operator t_MatWeight& () { return *_pd_seq; }
#endif
      
    inline const t_MatWeight& in() const { return *_pd_seq; }
    inline t_MatWeight&       inout()    { return *_pd_seq; }
    inline t_MatWeight*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_MatWeight* _retn() { t_MatWeight* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_MatWeight_out;
    
  private:
    t_MatWeight* _pd_seq;
  };

  class t_MatWeight_out {
  public:
    inline t_MatWeight_out(t_MatWeight*& _s) : _data(_s) { _data = 0; }
    inline t_MatWeight_out(t_MatWeight_var& _s)
      : _data(_s._pd_seq) { _s = (t_MatWeight*) 0; }
    inline t_MatWeight_out(const t_MatWeight_out& _s) : _data(_s._data) {}
    inline t_MatWeight_out& operator = (const t_MatWeight_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_MatWeight_out& operator = (t_MatWeight* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_MatWeight*&()  { return _data; }
    inline t_MatWeight*& ptr()       { return _data; }
    inline t_MatWeight* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_MatWeight*& _data;

  private:
    t_MatWeight_out();
    t_MatWeight_out& operator=(const t_MatWeight_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * MatSequence;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_MatSequence;

  class t_MatSequence_var;

  class t_MatSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_MatSequence_var _var_type;
    inline t_MatSequence() {}
    inline t_MatSequence(const t_MatSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_MatSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_MatSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_MatSequence& operator = (const t_MatSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_MatSequence_out;

  class t_MatSequence_var {
  public:
    inline t_MatSequence_var() : _pd_seq(0) {}
    inline t_MatSequence_var(t_MatSequence* _s) : _pd_seq(_s) {}
    inline t_MatSequence_var(const t_MatSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_MatSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_MatSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_MatSequence_var& operator = (t_MatSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_MatSequence_var& operator = (const t_MatSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_MatSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_MatSequence* operator -> () { return _pd_seq; }
    inline const t_MatSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_MatSequence& () const { return *_pd_seq; }
#else
    inline operator const t_MatSequence& () const { return *_pd_seq; }
    inline operator t_MatSequence& () { return *_pd_seq; }
#endif
      
    inline const t_MatSequence& in() const { return *_pd_seq; }
    inline t_MatSequence&       inout()    { return *_pd_seq; }
    inline t_MatSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_MatSequence* _retn() { t_MatSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_MatSequence_out;
    
  private:
    t_MatSequence* _pd_seq;
  };

  class t_MatSequence_out {
  public:
    inline t_MatSequence_out(t_MatSequence*& _s) : _data(_s) { _data = 0; }
    inline t_MatSequence_out(t_MatSequence_var& _s)
      : _data(_s._pd_seq) { _s = (t_MatSequence*) 0; }
    inline t_MatSequence_out(const t_MatSequence_out& _s) : _data(_s._data) {}
    inline t_MatSequence_out& operator = (const t_MatSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_MatSequence_out& operator = (t_MatSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_MatSequence*&()  { return _data; }
    inline t_MatSequence*& ptr()       { return _data; }
    inline t_MatSequence* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_MatSequence*& _data;

  private:
    t_MatSequence_out();
    t_MatSequence_out& operator=(const t_MatSequence_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * FeedRate;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_FeedRate;

  class t_FeedRate_var;

  class t_FeedRate : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_FeedRate_var _var_type;
    inline t_FeedRate() {}
    inline t_FeedRate(const t_FeedRate& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_FeedRate(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_FeedRate(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_FeedRate& operator = (const t_FeedRate& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_FeedRate_out;

  class t_FeedRate_var {
  public:
    inline t_FeedRate_var() : _pd_seq(0) {}
    inline t_FeedRate_var(t_FeedRate* _s) : _pd_seq(_s) {}
    inline t_FeedRate_var(const t_FeedRate_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_FeedRate(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_FeedRate_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_FeedRate_var& operator = (t_FeedRate* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_FeedRate_var& operator = (const t_FeedRate_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_FeedRate;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_FeedRate* operator -> () { return _pd_seq; }
    inline const t_FeedRate* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_FeedRate& () const { return *_pd_seq; }
#else
    inline operator const t_FeedRate& () const { return *_pd_seq; }
    inline operator t_FeedRate& () { return *_pd_seq; }
#endif
      
    inline const t_FeedRate& in() const { return *_pd_seq; }
    inline t_FeedRate&       inout()    { return *_pd_seq; }
    inline t_FeedRate*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_FeedRate* _retn() { t_FeedRate* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_FeedRate_out;
    
  private:
    t_FeedRate* _pd_seq;
  };

  class t_FeedRate_out {
  public:
    inline t_FeedRate_out(t_FeedRate*& _s) : _data(_s) { _data = 0; }
    inline t_FeedRate_out(t_FeedRate_var& _s)
      : _data(_s._pd_seq) { _s = (t_FeedRate*) 0; }
    inline t_FeedRate_out(const t_FeedRate_out& _s) : _data(_s._data) {}
    inline t_FeedRate_out& operator = (const t_FeedRate_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_FeedRate_out& operator = (t_FeedRate* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_FeedRate*&()  { return _data; }
    inline t_FeedRate*& ptr()       { return _data; }
    inline t_FeedRate* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_FeedRate*& _data;

  private:
    t_FeedRate_out();
    t_FeedRate_out& operator=(const t_FeedRate_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF70_MAT_HANDL

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * ENTRY;

  struct sENTRY {
    typedef _CORBA_ConstrType_Variable_Var<sENTRY> _var_type;

    
    ::CORBA::Long MessageCount;

    ::CORBA::Long MessageIndex;

    ::CORBA::String_member HeatId;

    ::CORBA::String_member TreatId;

    ::CORBA::Long Source;

    ::CORBA::Long RecipeNo;

    ::CORBA::String_member MatCode;

    ::CORBA::Long MatWeight;

    ::CORBA::Long MatSequence;

    ::CORBA::Long FeedRate;

    ::CORBA::Long Spare_1;

    ::CORBA::Long Spare_2;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef sENTRY::_var_type sENTRY_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< sENTRY,sENTRY_var > sENTRY_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sENTRY;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_ENTRY;

  class t_ENTRY_var;

  class t_ENTRY : public _CORBA_Unbounded_Sequence< sENTRY >  {
  public:
    typedef t_ENTRY_var _var_type;
    inline t_ENTRY() {}
    inline t_ENTRY(const t_ENTRY& _s)
      : _CORBA_Unbounded_Sequence< sENTRY > (_s) {}

    inline t_ENTRY(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< sENTRY > (_max) {}
    inline t_ENTRY(_CORBA_ULong _max, _CORBA_ULong _len, sENTRY* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< sENTRY > (_max, _len, _val, _rel) {}

  

    inline t_ENTRY& operator = (const t_ENTRY& _s) {
      _CORBA_Unbounded_Sequence< sENTRY > ::operator=(_s);
      return *this;
    }
  };

  class t_ENTRY_out;

  class t_ENTRY_var {
  public:
    inline t_ENTRY_var() : _pd_seq(0) {}
    inline t_ENTRY_var(t_ENTRY* _s) : _pd_seq(_s) {}
    inline t_ENTRY_var(const t_ENTRY_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_ENTRY(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_ENTRY_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_ENTRY_var& operator = (t_ENTRY* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_ENTRY_var& operator = (const t_ENTRY_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_ENTRY;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline sENTRY& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_ENTRY* operator -> () { return _pd_seq; }
    inline const t_ENTRY* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_ENTRY& () const { return *_pd_seq; }
#else
    inline operator const t_ENTRY& () const { return *_pd_seq; }
    inline operator t_ENTRY& () { return *_pd_seq; }
#endif
      
    inline const t_ENTRY& in() const { return *_pd_seq; }
    inline t_ENTRY&       inout()    { return *_pd_seq; }
    inline t_ENTRY*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_ENTRY* _retn() { t_ENTRY* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_ENTRY_out;
    
  private:
    t_ENTRY* _pd_seq;
  };

  class t_ENTRY_out {
  public:
    inline t_ENTRY_out(t_ENTRY*& _s) : _data(_s) { _data = 0; }
    inline t_ENTRY_out(t_ENTRY_var& _s)
      : _data(_s._pd_seq) { _s = (t_ENTRY*) 0; }
    inline t_ENTRY_out(const t_ENTRY_out& _s) : _data(_s._data) {}
    inline t_ENTRY_out& operator = (const t_ENTRY_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_ENTRY_out& operator = (t_ENTRY* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_ENTRY*&()  { return _data; }
    inline t_ENTRY*& ptr()       { return _data; }
    inline t_ENTRY* operator->() { return _data; }

    inline sENTRY& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_ENTRY*& _data;

  private:
    t_ENTRY_out();
    t_ENTRY_out& operator=(const t_ENTRY_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF71

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_L2LF72

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END



_CORBA_MODULE POA_Telegram_Head
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF00
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF01
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF01_WATCH_DOG
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF03
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF05
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF06
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF07
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF20
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF20_VOLTAGE_TAP
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF22
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF23
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF25
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF30
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF30_ELEC_PATT
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF31
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF31_STIRR_PATT
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF40
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF70
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF70_MAT_HANDL
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF71
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_L2LF72
_CORBA_MODULE_BEG

_CORBA_MODULE_END



_CORBA_MODULE OBV_Telegram_Head
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF00
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF01
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF01_WATCH_DOG
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF03
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF05
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF06
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF07
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF20
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF20_VOLTAGE_TAP
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF22
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF23
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF25
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF30
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF30_ELEC_PATT
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF31
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF31_STIRR_PATT
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF40
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF70
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF70_MAT_HANDL
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF71
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_L2LF72
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const HeaderType& _s);
extern void operator<<=(::CORBA::Any& _a, HeaderType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, HeaderType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const HeaderType*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF01::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF01::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF01::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF01::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF03::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF03::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF03::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF03::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF03::t_ProdDate& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF03::t_ProdDate* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF03::t_ProdDate*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF03::t_ProdDate*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF03::t_DepTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF03::t_DepTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF03::t_DepTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF03::t_DepTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF03::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF03::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF03::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF03::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF05::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF05::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF05::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF05::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF05::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF05::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF05::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF05::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF06::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF06::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF06::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF06::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF06::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF06::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF06::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF06::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF07::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF07::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF07::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF07::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF07::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF07::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF07::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF07::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF20::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF20::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF20::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF20::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF20::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF20::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF20::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF20::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF22::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF22::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF22::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF22::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF22::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF22::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF22::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF22::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF23::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF23::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF23::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF23::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF23::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF23::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF23::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF23::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF25::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF25::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF25::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF25::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF25::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF25::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF25::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF25::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF30::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF30::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF30::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF30::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF30::t_Enabled& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF30::t_Enabled* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF30::t_Enabled*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF30::t_Enabled*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF30::t_RemDurStep& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF30::t_RemDurStep* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF30::t_RemDurStep*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF30::t_RemDurStep*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF30::t_ElecEnergyStep& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF30::t_ElecEnergyStep* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF30::t_ElecEnergyStep*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF30::t_ElecEnergyStep*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF30::t_TempEndStep& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF30::t_TempEndStep* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF30::t_TempEndStep*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF30::t_TempEndStep*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF30::t_AimVoltTap& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF30::t_AimVoltTap* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF30::t_AimVoltTap*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF30::t_AimVoltTap*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF30::t_AimCurveNo& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF30::t_AimCurveNo* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF30::t_AimCurveNo*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF30::t_AimCurveNo*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF30::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF30::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF30::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF30::t_Spare*& _sp);

extern void operator<<=(::CORBA::Any& _a, const Telegram_L2LF30_ELEC_PATT::sENTRY& _s);
extern void operator<<=(::CORBA::Any& _a, Telegram_L2LF30_ELEC_PATT::sENTRY* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF30_ELEC_PATT::sENTRY*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF30_ELEC_PATT::sENTRY*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF30_ELEC_PATT::t_ENTRY& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF30_ELEC_PATT::t_ENTRY* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF30_ELEC_PATT::t_ENTRY*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF30_ELEC_PATT::t_ENTRY*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF31::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF31::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF31::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF31::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF31::t_PhaseNo& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF31::t_PhaseNo* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF31::t_PhaseNo*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF31::t_PhaseNo*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF31::t_Enabled& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF31::t_Enabled* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF31::t_Enabled*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF31::t_Enabled*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF31::t_Duration& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF31::t_Duration* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF31::t_Duration*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF31::t_Duration*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF31::t_StirrInt& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF31::t_StirrInt* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF31::t_StirrInt*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF31::t_StirrInt*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF31::t_StirrGasFlow& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF31::t_StirrGasFlow* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF31::t_StirrGasFlow*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF31::t_StirrGasFlow*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF31::t_StirrGasType& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF31::t_StirrGasType* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF31::t_StirrGasType*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF31::t_StirrGasType*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF31::t_StepPriority& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF31::t_StepPriority* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF31::t_StepPriority*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF31::t_StepPriority*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF31::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF31::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF31::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF31::t_Spare*& _sp);

extern void operator<<=(::CORBA::Any& _a, const Telegram_L2LF31_STIRR_PATT::sENTRY& _s);
extern void operator<<=(::CORBA::Any& _a, Telegram_L2LF31_STIRR_PATT::sENTRY* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF31_STIRR_PATT::sENTRY*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF31_STIRR_PATT::sENTRY*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF31_STIRR_PATT::t_ENTRY& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF31_STIRR_PATT::t_ENTRY* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF31_STIRR_PATT::t_ENTRY*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF31_STIRR_PATT::t_ENTRY*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF40::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF40::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF40::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF40::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF40::t_ParamName& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF40::t_ParamName* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF40::t_ParamName*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF40::t_ParamName*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF40::t_ParamValue& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF40::t_ParamValue* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF40::t_ParamValue*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF40::t_ParamValue*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF40::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF40::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF40::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF40::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF70::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF70::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF70::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF70::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF70::t_MatCode& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF70::t_MatCode* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF70::t_MatCode*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF70::t_MatCode*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF70::t_MatWeight& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF70::t_MatWeight* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF70::t_MatWeight*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF70::t_MatWeight*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF70::t_MatSequence& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF70::t_MatSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF70::t_MatSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF70::t_MatSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF70::t_FeedRate& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF70::t_FeedRate* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF70::t_FeedRate*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF70::t_FeedRate*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF70::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF70::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF70::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF70::t_Spare*& _sp);

extern void operator<<=(::CORBA::Any& _a, const Telegram_L2LF70_MAT_HANDL::sENTRY& _s);
extern void operator<<=(::CORBA::Any& _a, Telegram_L2LF70_MAT_HANDL::sENTRY* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF70_MAT_HANDL::sENTRY*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF70_MAT_HANDL::sENTRY*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF70_MAT_HANDL::t_ENTRY& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF70_MAT_HANDL::t_ENTRY* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF70_MAT_HANDL::t_ENTRY*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF70_MAT_HANDL::t_ENTRY*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF71::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF71::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF71::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF71::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF71::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF71::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF71::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF71::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF72::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF72::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF72::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF72::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_L2LF72::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_L2LF72::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_L2LF72::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_L2LF72::t_Spare*& _sp);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_Telcom__Out
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_Telcom__Out
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_Telcom__Out
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_Telcom__Out
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_Telcom__Out
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_Telcom__Out
#endif

#endif  // __Telcom__Out_hh__

