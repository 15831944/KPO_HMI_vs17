// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __Telcom__In_hh__
#define __Telcom__In_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_Telcom__In
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_Telcom__In
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_Telcom__In
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



struct HeaderType {
  typedef _CORBA_ConstrType_Variable_Var<HeaderType> _var_type;

  
  ::CORBA::String_member MessageLength;

  ::CORBA::String_member MessageId;

  ::CORBA::String_member MessageCount;

  ::CORBA::String_member UnitNo;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef HeaderType::_var_type HeaderType_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< HeaderType,HeaderType_var > HeaderType_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_HeaderType;

_CORBA_MODULE Telegram_Head

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL200

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * Status;

  _CORBA_MODULE_VAR _core_attr const char * RcvMsgId;

  _CORBA_MODULE_VAR _core_attr const char * ErrInf;

  _CORBA_MODULE_VAR _core_attr const char * ErrMess;

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL201

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Address;

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL203

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * LadleId;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * ProdOrderId;

  _CORBA_MODULE_VAR _core_attr const char * SteelGradeCode;

  _CORBA_MODULE_VAR _core_attr const char * AimTemp;

  _CORBA_MODULE_VAR _core_attr const char * AimWeight;

  _CORBA_MODULE_VAR _core_attr const char * HeatIdCust;

  _CORBA_MODULE_VAR _core_attr const char * TreatIdCust;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL204

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * LadleId;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL205

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * LadleId;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * ActionFlag;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL206

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL209

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * SampleType;

  _CORBA_MODULE_VAR _core_attr const char * SampleCounter;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL211

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * MeasType;

  _CORBA_MODULE_VAR _core_attr const char * MeasNo;

  _CORBA_MODULE_VAR _core_attr const char * Temp;

  _CORBA_MODULE_VAR _core_attr const char * ConcO2;

  _CORBA_MODULE_VAR _core_attr const char * ConcAl;

  _CORBA_MODULE_VAR _core_attr const char * ConcC;

  _CORBA_MODULE_VAR _core_attr const char * ConcFeO;

  _CORBA_MODULE_VAR _core_attr const char * ConcMnO;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL212

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * AimTemp;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL213

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * AimDepTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_AimDepTime;

  class t_AimDepTime_var;

  class t_AimDepTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_AimDepTime_var _var_type;
    inline t_AimDepTime() {}
    inline t_AimDepTime(const t_AimDepTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_AimDepTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_AimDepTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_AimDepTime& operator = (const t_AimDepTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_AimDepTime_out;

  class t_AimDepTime_var {
  public:
    inline t_AimDepTime_var() : _pd_seq(0) {}
    inline t_AimDepTime_var(t_AimDepTime* _s) : _pd_seq(_s) {}
    inline t_AimDepTime_var(const t_AimDepTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_AimDepTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_AimDepTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_AimDepTime_var& operator = (t_AimDepTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_AimDepTime_var& operator = (const t_AimDepTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_AimDepTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_AimDepTime* operator -> () { return _pd_seq; }
    inline const t_AimDepTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_AimDepTime& () const { return *_pd_seq; }
#else
    inline operator const t_AimDepTime& () const { return *_pd_seq; }
    inline operator t_AimDepTime& () { return *_pd_seq; }
#endif
      
    inline const t_AimDepTime& in() const { return *_pd_seq; }
    inline t_AimDepTime&       inout()    { return *_pd_seq; }
    inline t_AimDepTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_AimDepTime* _retn() { t_AimDepTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_AimDepTime_out;
    
  private:
    t_AimDepTime* _pd_seq;
  };

  class t_AimDepTime_out {
  public:
    inline t_AimDepTime_out(t_AimDepTime*& _s) : _data(_s) { _data = 0; }
    inline t_AimDepTime_out(t_AimDepTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_AimDepTime*) 0; }
    inline t_AimDepTime_out(const t_AimDepTime_out& _s) : _data(_s._data) {}
    inline t_AimDepTime_out& operator = (const t_AimDepTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_AimDepTime_out& operator = (t_AimDepTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_AimDepTime*&()  { return _data; }
    inline t_AimDepTime*& ptr()       { return _data; }
    inline t_AimDepTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_AimDepTime*& _data;

  private:
    t_AimDepTime_out();
    t_AimDepTime_out& operator=(const t_AimDepTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL217

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * DelayCode;

  _CORBA_MODULE_VAR _core_attr const char * DelayStartTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_DelayStartTime;

  class t_DelayStartTime_var;

  class t_DelayStartTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_DelayStartTime_var _var_type;
    inline t_DelayStartTime() {}
    inline t_DelayStartTime(const t_DelayStartTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_DelayStartTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_DelayStartTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_DelayStartTime& operator = (const t_DelayStartTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_DelayStartTime_out;

  class t_DelayStartTime_var {
  public:
    inline t_DelayStartTime_var() : _pd_seq(0) {}
    inline t_DelayStartTime_var(t_DelayStartTime* _s) : _pd_seq(_s) {}
    inline t_DelayStartTime_var(const t_DelayStartTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_DelayStartTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_DelayStartTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_DelayStartTime_var& operator = (t_DelayStartTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_DelayStartTime_var& operator = (const t_DelayStartTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_DelayStartTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_DelayStartTime* operator -> () { return _pd_seq; }
    inline const t_DelayStartTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_DelayStartTime& () const { return *_pd_seq; }
#else
    inline operator const t_DelayStartTime& () const { return *_pd_seq; }
    inline operator t_DelayStartTime& () { return *_pd_seq; }
#endif
      
    inline const t_DelayStartTime& in() const { return *_pd_seq; }
    inline t_DelayStartTime&       inout()    { return *_pd_seq; }
    inline t_DelayStartTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_DelayStartTime* _retn() { t_DelayStartTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_DelayStartTime_out;
    
  private:
    t_DelayStartTime* _pd_seq;
  };

  class t_DelayStartTime_out {
  public:
    inline t_DelayStartTime_out(t_DelayStartTime*& _s) : _data(_s) { _data = 0; }
    inline t_DelayStartTime_out(t_DelayStartTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_DelayStartTime*) 0; }
    inline t_DelayStartTime_out(const t_DelayStartTime_out& _s) : _data(_s._data) {}
    inline t_DelayStartTime_out& operator = (const t_DelayStartTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_DelayStartTime_out& operator = (t_DelayStartTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_DelayStartTime*&()  { return _data; }
    inline t_DelayStartTime*& ptr()       { return _data; }
    inline t_DelayStartTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_DelayStartTime*& _data;

  private:
    t_DelayStartTime_out();
    t_DelayStartTime_out& operator=(const t_DelayStartTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * DelayEndTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_DelayEndTime;

  class t_DelayEndTime_var;

  class t_DelayEndTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_DelayEndTime_var _var_type;
    inline t_DelayEndTime() {}
    inline t_DelayEndTime(const t_DelayEndTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_DelayEndTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_DelayEndTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_DelayEndTime& operator = (const t_DelayEndTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_DelayEndTime_out;

  class t_DelayEndTime_var {
  public:
    inline t_DelayEndTime_var() : _pd_seq(0) {}
    inline t_DelayEndTime_var(t_DelayEndTime* _s) : _pd_seq(_s) {}
    inline t_DelayEndTime_var(const t_DelayEndTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_DelayEndTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_DelayEndTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_DelayEndTime_var& operator = (t_DelayEndTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_DelayEndTime_var& operator = (const t_DelayEndTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_DelayEndTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_DelayEndTime* operator -> () { return _pd_seq; }
    inline const t_DelayEndTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_DelayEndTime& () const { return *_pd_seq; }
#else
    inline operator const t_DelayEndTime& () const { return *_pd_seq; }
    inline operator t_DelayEndTime& () { return *_pd_seq; }
#endif
      
    inline const t_DelayEndTime& in() const { return *_pd_seq; }
    inline t_DelayEndTime&       inout()    { return *_pd_seq; }
    inline t_DelayEndTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_DelayEndTime* _retn() { t_DelayEndTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_DelayEndTime_out;
    
  private:
    t_DelayEndTime* _pd_seq;
  };

  class t_DelayEndTime_out {
  public:
    inline t_DelayEndTime_out(t_DelayEndTime*& _s) : _data(_s) { _data = 0; }
    inline t_DelayEndTime_out(t_DelayEndTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_DelayEndTime*) 0; }
    inline t_DelayEndTime_out(const t_DelayEndTime_out& _s) : _data(_s._data) {}
    inline t_DelayEndTime_out& operator = (const t_DelayEndTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_DelayEndTime_out& operator = (t_DelayEndTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_DelayEndTime*&()  { return _data; }
    inline t_DelayEndTime*& ptr()       { return _data; }
    inline t_DelayEndTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_DelayEndTime*& _data;

  private:
    t_DelayEndTime_out();
    t_DelayEndTime_out& operator=(const t_DelayEndTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL220

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * ModeElec;

  _CORBA_MODULE_VAR _core_attr const char * ModeStirr;

  _CORBA_MODULE_VAR _core_attr const char * ModeMat;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL221

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * GantryPos;

  _CORBA_MODULE_VAR _core_attr const char * RoofPos;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL222

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * FurnBreakOn;

  _CORBA_MODULE_VAR _core_attr const char * FurnPowerOn;

  _CORBA_MODULE_VAR _core_attr const char * TapChanger;

  _CORBA_MODULE_VAR _core_attr const char * ElecPos;

  _CORBA_MODULE_VAR _core_attr const char * GantryPos;

  _CORBA_MODULE_VAR _core_attr const char * ElecHydSys;

  _CORBA_MODULE_VAR _core_attr const char * ElecVoltTap;

  _CORBA_MODULE_VAR _core_attr const char * ElecCurvNo;

  _CORBA_MODULE_VAR _core_attr const char * ElecCons;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL223

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * ElecVoltTap;

  _CORBA_MODULE_VAR _core_attr const char * ElecCurvNo;

  _CORBA_MODULE_VAR _core_attr const char * ElecCons;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL224

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * PlugNo;

  _CORBA_MODULE_VAR _core_attr const char * StirrGasType;

  _CORBA_MODULE_VAR _core_attr const char * StirrStat;

  _CORBA_MODULE_VAR _core_attr const char * BypassStat;

  _CORBA_MODULE_VAR _core_attr const char * PlugDefect;

  _CORBA_MODULE_VAR _core_attr const char * StirrGasCons;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL225

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * StirrGasType;

  _CORBA_MODULE_VAR _core_attr const char * StirrStat;

  _CORBA_MODULE_VAR _core_attr const char * StirrGasCons;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL226

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * StirrGasType;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_StirrGasType;

  class t_StirrGasType_var;

  class t_StirrGasType : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_StirrGasType_var _var_type;
    inline t_StirrGasType() {}
    inline t_StirrGasType(const t_StirrGasType& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_StirrGasType(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_StirrGasType(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_StirrGasType& operator = (const t_StirrGasType& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_StirrGasType_out;

  class t_StirrGasType_var {
  public:
    inline t_StirrGasType_var() : _pd_seq(0) {}
    inline t_StirrGasType_var(t_StirrGasType* _s) : _pd_seq(_s) {}
    inline t_StirrGasType_var(const t_StirrGasType_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_StirrGasType(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_StirrGasType_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_StirrGasType_var& operator = (t_StirrGasType* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_StirrGasType_var& operator = (const t_StirrGasType_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_StirrGasType;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_StirrGasType* operator -> () { return _pd_seq; }
    inline const t_StirrGasType* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_StirrGasType& () const { return *_pd_seq; }
#else
    inline operator const t_StirrGasType& () const { return *_pd_seq; }
    inline operator t_StirrGasType& () { return *_pd_seq; }
#endif
      
    inline const t_StirrGasType& in() const { return *_pd_seq; }
    inline t_StirrGasType&       inout()    { return *_pd_seq; }
    inline t_StirrGasType*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_StirrGasType* _retn() { t_StirrGasType* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_StirrGasType_out;
    
  private:
    t_StirrGasType* _pd_seq;
  };

  class t_StirrGasType_out {
  public:
    inline t_StirrGasType_out(t_StirrGasType*& _s) : _data(_s) { _data = 0; }
    inline t_StirrGasType_out(t_StirrGasType_var& _s)
      : _data(_s._pd_seq) { _s = (t_StirrGasType*) 0; }
    inline t_StirrGasType_out(const t_StirrGasType_out& _s) : _data(_s._data) {}
    inline t_StirrGasType_out& operator = (const t_StirrGasType_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_StirrGasType_out& operator = (t_StirrGasType* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_StirrGasType*&()  { return _data; }
    inline t_StirrGasType*& ptr()       { return _data; }
    inline t_StirrGasType* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_StirrGasType*& _data;

  private:
    t_StirrGasType_out();
    t_StirrGasType_out& operator=(const t_StirrGasType_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * StirrInt;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_StirrInt;

  class t_StirrInt_var;

  class t_StirrInt : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_StirrInt_var _var_type;
    inline t_StirrInt() {}
    inline t_StirrInt(const t_StirrInt& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_StirrInt(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_StirrInt(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_StirrInt& operator = (const t_StirrInt& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_StirrInt_out;

  class t_StirrInt_var {
  public:
    inline t_StirrInt_var() : _pd_seq(0) {}
    inline t_StirrInt_var(t_StirrInt* _s) : _pd_seq(_s) {}
    inline t_StirrInt_var(const t_StirrInt_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_StirrInt(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_StirrInt_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_StirrInt_var& operator = (t_StirrInt* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_StirrInt_var& operator = (const t_StirrInt_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_StirrInt;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_StirrInt* operator -> () { return _pd_seq; }
    inline const t_StirrInt* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_StirrInt& () const { return *_pd_seq; }
#else
    inline operator const t_StirrInt& () const { return *_pd_seq; }
    inline operator t_StirrInt& () { return *_pd_seq; }
#endif
      
    inline const t_StirrInt& in() const { return *_pd_seq; }
    inline t_StirrInt&       inout()    { return *_pd_seq; }
    inline t_StirrInt*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_StirrInt* _retn() { t_StirrInt* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_StirrInt_out;
    
  private:
    t_StirrInt* _pd_seq;
  };

  class t_StirrInt_out {
  public:
    inline t_StirrInt_out(t_StirrInt*& _s) : _data(_s) { _data = 0; }
    inline t_StirrInt_out(t_StirrInt_var& _s)
      : _data(_s._pd_seq) { _s = (t_StirrInt*) 0; }
    inline t_StirrInt_out(const t_StirrInt_out& _s) : _data(_s._data) {}
    inline t_StirrInt_out& operator = (const t_StirrInt_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_StirrInt_out& operator = (t_StirrInt* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_StirrInt*&()  { return _data; }
    inline t_StirrInt*& ptr()       { return _data; }
    inline t_StirrInt* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_StirrInt*& _data;

  private:
    t_StirrInt_out();
    t_StirrInt_out& operator=(const t_StirrInt_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * FlowAct;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_FlowAct;

  class t_FlowAct_var;

  class t_FlowAct : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef t_FlowAct_var _var_type;
    inline t_FlowAct() {}
    inline t_FlowAct(const t_FlowAct& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline t_FlowAct(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline t_FlowAct(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline t_FlowAct& operator = (const t_FlowAct& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class t_FlowAct_out;

  class t_FlowAct_var {
  public:
    inline t_FlowAct_var() : _pd_seq(0) {}
    inline t_FlowAct_var(t_FlowAct* _s) : _pd_seq(_s) {}
    inline t_FlowAct_var(const t_FlowAct_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_FlowAct(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_FlowAct_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_FlowAct_var& operator = (t_FlowAct* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_FlowAct_var& operator = (const t_FlowAct_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_FlowAct;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_FlowAct* operator -> () { return _pd_seq; }
    inline const t_FlowAct* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_FlowAct& () const { return *_pd_seq; }
#else
    inline operator const t_FlowAct& () const { return *_pd_seq; }
    inline operator t_FlowAct& () { return *_pd_seq; }
#endif
      
    inline const t_FlowAct& in() const { return *_pd_seq; }
    inline t_FlowAct&       inout()    { return *_pd_seq; }
    inline t_FlowAct*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_FlowAct* _retn() { t_FlowAct* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_FlowAct_out;
    
  private:
    t_FlowAct* _pd_seq;
  };

  class t_FlowAct_out {
  public:
    inline t_FlowAct_out(t_FlowAct*& _s) : _data(_s) { _data = 0; }
    inline t_FlowAct_out(t_FlowAct_var& _s)
      : _data(_s._pd_seq) { _s = (t_FlowAct*) 0; }
    inline t_FlowAct_out(const t_FlowAct_out& _s) : _data(_s._data) {}
    inline t_FlowAct_out& operator = (const t_FlowAct_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_FlowAct_out& operator = (t_FlowAct* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_FlowAct*&()  { return _data; }
    inline t_FlowAct*& ptr()       { return _data; }
    inline t_FlowAct* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_FlowAct*& _data;

  private:
    t_FlowAct_out();
    t_FlowAct_out& operator=(const t_FlowAct_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Pressure;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Pressure;

  class t_Pressure_var;

  class t_Pressure : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef t_Pressure_var _var_type;
    inline t_Pressure() {}
    inline t_Pressure(const t_Pressure& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline t_Pressure(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline t_Pressure(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline t_Pressure& operator = (const t_Pressure& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class t_Pressure_out;

  class t_Pressure_var {
  public:
    inline t_Pressure_var() : _pd_seq(0) {}
    inline t_Pressure_var(t_Pressure* _s) : _pd_seq(_s) {}
    inline t_Pressure_var(const t_Pressure_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Pressure(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Pressure_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Pressure_var& operator = (t_Pressure* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Pressure_var& operator = (const t_Pressure_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Pressure;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Pressure* operator -> () { return _pd_seq; }
    inline const t_Pressure* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Pressure& () const { return *_pd_seq; }
#else
    inline operator const t_Pressure& () const { return *_pd_seq; }
    inline operator t_Pressure& () { return *_pd_seq; }
#endif
      
    inline const t_Pressure& in() const { return *_pd_seq; }
    inline t_Pressure&       inout()    { return *_pd_seq; }
    inline t_Pressure*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Pressure* _retn() { t_Pressure* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Pressure_out;
    
  private:
    t_Pressure* _pd_seq;
  };

  class t_Pressure_out {
  public:
    inline t_Pressure_out(t_Pressure*& _s) : _data(_s) { _data = 0; }
    inline t_Pressure_out(t_Pressure_var& _s)
      : _data(_s._pd_seq) { _s = (t_Pressure*) 0; }
    inline t_Pressure_out(const t_Pressure_out& _s) : _data(_s._data) {}
    inline t_Pressure_out& operator = (const t_Pressure_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Pressure_out& operator = (t_Pressure* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Pressure*&()  { return _data; }
    inline t_Pressure*& ptr()       { return _data; }
    inline t_Pressure* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Pressure*& _data;

  private:
    t_Pressure_out();
    t_Pressure_out& operator=(const t_Pressure_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * StirrGasCons;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_StirrGasCons;

  class t_StirrGasCons_var;

  class t_StirrGasCons : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef t_StirrGasCons_var _var_type;
    inline t_StirrGasCons() {}
    inline t_StirrGasCons(const t_StirrGasCons& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline t_StirrGasCons(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline t_StirrGasCons(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline t_StirrGasCons& operator = (const t_StirrGasCons& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class t_StirrGasCons_out;

  class t_StirrGasCons_var {
  public:
    inline t_StirrGasCons_var() : _pd_seq(0) {}
    inline t_StirrGasCons_var(t_StirrGasCons* _s) : _pd_seq(_s) {}
    inline t_StirrGasCons_var(const t_StirrGasCons_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_StirrGasCons(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_StirrGasCons_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_StirrGasCons_var& operator = (t_StirrGasCons* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_StirrGasCons_var& operator = (const t_StirrGasCons_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_StirrGasCons;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_StirrGasCons* operator -> () { return _pd_seq; }
    inline const t_StirrGasCons* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_StirrGasCons& () const { return *_pd_seq; }
#else
    inline operator const t_StirrGasCons& () const { return *_pd_seq; }
    inline operator t_StirrGasCons& () { return *_pd_seq; }
#endif
      
    inline const t_StirrGasCons& in() const { return *_pd_seq; }
    inline t_StirrGasCons&       inout()    { return *_pd_seq; }
    inline t_StirrGasCons*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_StirrGasCons* _retn() { t_StirrGasCons* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_StirrGasCons_out;
    
  private:
    t_StirrGasCons* _pd_seq;
  };

  class t_StirrGasCons_out {
  public:
    inline t_StirrGasCons_out(t_StirrGasCons*& _s) : _data(_s) { _data = 0; }
    inline t_StirrGasCons_out(t_StirrGasCons_var& _s)
      : _data(_s._pd_seq) { _s = (t_StirrGasCons*) 0; }
    inline t_StirrGasCons_out(const t_StirrGasCons_out& _s) : _data(_s._data) {}
    inline t_StirrGasCons_out& operator = (const t_StirrGasCons_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_StirrGasCons_out& operator = (t_StirrGasCons* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_StirrGasCons*&()  { return _data; }
    inline t_StirrGasCons*& ptr()       { return _data; }
    inline t_StirrGasCons* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_StirrGasCons*& _data;

  private:
    t_StirrGasCons_out();
    t_StirrGasCons_out& operator=(const t_StirrGasCons_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL230

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * RoofWaterInlet;

  _CORBA_MODULE_VAR _core_attr const char * RoofWaterOutlet;

  _CORBA_MODULE_VAR _core_attr const char * RoofWaterFlow;

  _CORBA_MODULE_VAR _core_attr const char * WGWaterInlet;

  _CORBA_MODULE_VAR _core_attr const char * WGWaterOutlet;

  _CORBA_MODULE_VAR _core_attr const char * WGWaterFlow;

  _CORBA_MODULE_VAR _core_attr const char * ElecCons;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL240

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * ParamName;

  _CORBA_MODULE_VAR _core_attr const char * ParamValue;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL260

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * Target;

  _CORBA_MODULE_VAR _core_attr const char * Source;

  _CORBA_MODULE_VAR _core_attr const char * RecipeNo;

  _CORBA_MODULE_VAR _core_attr const char * BatchStat;

  _CORBA_MODULE_VAR _core_attr const char * MatCode;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_MatCode;

  class t_MatCode_var;

  class t_MatCode : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef t_MatCode_var _var_type;
    inline t_MatCode() {}
    inline t_MatCode(const t_MatCode& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline t_MatCode(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline t_MatCode(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline t_MatCode& operator = (const t_MatCode& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class t_MatCode_out;

  class t_MatCode_var {
  public:
    inline t_MatCode_var() : _pd_seq(0) {}
    inline t_MatCode_var(t_MatCode* _s) : _pd_seq(_s) {}
    inline t_MatCode_var(const t_MatCode_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_MatCode(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_MatCode_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_MatCode_var& operator = (t_MatCode* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_MatCode_var& operator = (const t_MatCode_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_MatCode;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_MatCode* operator -> () { return _pd_seq; }
    inline const t_MatCode* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_MatCode& () const { return *_pd_seq; }
#else
    inline operator const t_MatCode& () const { return *_pd_seq; }
    inline operator t_MatCode& () { return *_pd_seq; }
#endif
      
    inline const t_MatCode& in() const { return *_pd_seq; }
    inline t_MatCode&       inout()    { return *_pd_seq; }
    inline t_MatCode*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_MatCode* _retn() { t_MatCode* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_MatCode_out;
    
  private:
    t_MatCode* _pd_seq;
  };

  class t_MatCode_out {
  public:
    inline t_MatCode_out(t_MatCode*& _s) : _data(_s) { _data = 0; }
    inline t_MatCode_out(t_MatCode_var& _s)
      : _data(_s._pd_seq) { _s = (t_MatCode*) 0; }
    inline t_MatCode_out(const t_MatCode_out& _s) : _data(_s._data) {}
    inline t_MatCode_out& operator = (const t_MatCode_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_MatCode_out& operator = (t_MatCode* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_MatCode*&()  { return _data; }
    inline t_MatCode*& ptr()       { return _data; }
    inline t_MatCode* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_MatCode*& _data;

  private:
    t_MatCode_out();
    t_MatCode_out& operator=(const t_MatCode_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * MatWeight;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_MatWeight;

  class t_MatWeight_var;

  class t_MatWeight : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef t_MatWeight_var _var_type;
    inline t_MatWeight() {}
    inline t_MatWeight(const t_MatWeight& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline t_MatWeight(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline t_MatWeight(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline t_MatWeight& operator = (const t_MatWeight& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class t_MatWeight_out;

  class t_MatWeight_var {
  public:
    inline t_MatWeight_var() : _pd_seq(0) {}
    inline t_MatWeight_var(t_MatWeight* _s) : _pd_seq(_s) {}
    inline t_MatWeight_var(const t_MatWeight_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_MatWeight(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_MatWeight_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_MatWeight_var& operator = (t_MatWeight* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_MatWeight_var& operator = (const t_MatWeight_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_MatWeight;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_MatWeight* operator -> () { return _pd_seq; }
    inline const t_MatWeight* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_MatWeight& () const { return *_pd_seq; }
#else
    inline operator const t_MatWeight& () const { return *_pd_seq; }
    inline operator t_MatWeight& () { return *_pd_seq; }
#endif
      
    inline const t_MatWeight& in() const { return *_pd_seq; }
    inline t_MatWeight&       inout()    { return *_pd_seq; }
    inline t_MatWeight*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_MatWeight* _retn() { t_MatWeight* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_MatWeight_out;
    
  private:
    t_MatWeight* _pd_seq;
  };

  class t_MatWeight_out {
  public:
    inline t_MatWeight_out(t_MatWeight*& _s) : _data(_s) { _data = 0; }
    inline t_MatWeight_out(t_MatWeight_var& _s)
      : _data(_s._pd_seq) { _s = (t_MatWeight*) 0; }
    inline t_MatWeight_out(const t_MatWeight_out& _s) : _data(_s._data) {}
    inline t_MatWeight_out& operator = (const t_MatWeight_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_MatWeight_out& operator = (t_MatWeight* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_MatWeight*&()  { return _data; }
    inline t_MatWeight*& ptr()       { return _data; }
    inline t_MatWeight* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_MatWeight*& _data;

  private:
    t_MatWeight_out();
    t_MatWeight_out& operator=(const t_MatWeight_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * SourceNo;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_SourceNo;

  class t_SourceNo_var;

  class t_SourceNo : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_SourceNo_var _var_type;
    inline t_SourceNo() {}
    inline t_SourceNo(const t_SourceNo& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_SourceNo(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_SourceNo(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_SourceNo& operator = (const t_SourceNo& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_SourceNo_out;

  class t_SourceNo_var {
  public:
    inline t_SourceNo_var() : _pd_seq(0) {}
    inline t_SourceNo_var(t_SourceNo* _s) : _pd_seq(_s) {}
    inline t_SourceNo_var(const t_SourceNo_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_SourceNo(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_SourceNo_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_SourceNo_var& operator = (t_SourceNo* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_SourceNo_var& operator = (const t_SourceNo_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_SourceNo;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_SourceNo* operator -> () { return _pd_seq; }
    inline const t_SourceNo* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_SourceNo& () const { return *_pd_seq; }
#else
    inline operator const t_SourceNo& () const { return *_pd_seq; }
    inline operator t_SourceNo& () { return *_pd_seq; }
#endif
      
    inline const t_SourceNo& in() const { return *_pd_seq; }
    inline t_SourceNo&       inout()    { return *_pd_seq; }
    inline t_SourceNo*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_SourceNo* _retn() { t_SourceNo* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_SourceNo_out;
    
  private:
    t_SourceNo* _pd_seq;
  };

  class t_SourceNo_out {
  public:
    inline t_SourceNo_out(t_SourceNo*& _s) : _data(_s) { _data = 0; }
    inline t_SourceNo_out(t_SourceNo_var& _s)
      : _data(_s._pd_seq) { _s = (t_SourceNo*) 0; }
    inline t_SourceNo_out(const t_SourceNo_out& _s) : _data(_s._data) {}
    inline t_SourceNo_out& operator = (const t_SourceNo_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_SourceNo_out& operator = (t_SourceNo* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_SourceNo*&()  { return _data; }
    inline t_SourceNo*& ptr()       { return _data; }
    inline t_SourceNo* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_SourceNo*& _data;

  private:
    t_SourceNo_out();
    t_SourceNo_out& operator=(const t_SourceNo_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * FeedingRate;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_FeedingRate;

  class t_FeedingRate_var;

  class t_FeedingRate : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef t_FeedingRate_var _var_type;
    inline t_FeedingRate() {}
    inline t_FeedingRate(const t_FeedingRate& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline t_FeedingRate(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline t_FeedingRate(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline t_FeedingRate& operator = (const t_FeedingRate& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class t_FeedingRate_out;

  class t_FeedingRate_var {
  public:
    inline t_FeedingRate_var() : _pd_seq(0) {}
    inline t_FeedingRate_var(t_FeedingRate* _s) : _pd_seq(_s) {}
    inline t_FeedingRate_var(const t_FeedingRate_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_FeedingRate(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_FeedingRate_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_FeedingRate_var& operator = (t_FeedingRate* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_FeedingRate_var& operator = (const t_FeedingRate_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_FeedingRate;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_FeedingRate* operator -> () { return _pd_seq; }
    inline const t_FeedingRate* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_FeedingRate& () const { return *_pd_seq; }
#else
    inline operator const t_FeedingRate& () const { return *_pd_seq; }
    inline operator t_FeedingRate& () { return *_pd_seq; }
#endif
      
    inline const t_FeedingRate& in() const { return *_pd_seq; }
    inline t_FeedingRate&       inout()    { return *_pd_seq; }
    inline t_FeedingRate*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_FeedingRate* _retn() { t_FeedingRate* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_FeedingRate_out;
    
  private:
    t_FeedingRate* _pd_seq;
  };

  class t_FeedingRate_out {
  public:
    inline t_FeedingRate_out(t_FeedingRate*& _s) : _data(_s) { _data = 0; }
    inline t_FeedingRate_out(t_FeedingRate_var& _s)
      : _data(_s._pd_seq) { _s = (t_FeedingRate*) 0; }
    inline t_FeedingRate_out(const t_FeedingRate_out& _s) : _data(_s._data) {}
    inline t_FeedingRate_out& operator = (const t_FeedingRate_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_FeedingRate_out& operator = (t_FeedingRate* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_FeedingRate*&()  { return _data; }
    inline t_FeedingRate*& ptr()       { return _data; }
    inline t_FeedingRate* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_FeedingRate*& _data;

  private:
    t_FeedingRate_out();
    t_FeedingRate_out& operator=(const t_FeedingRate_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL261

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * ActionFlag;

  _CORBA_MODULE_VAR _core_attr const char * MatCode;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_MatCode;

  class t_MatCode_var;

  class t_MatCode : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef t_MatCode_var _var_type;
    inline t_MatCode() {}
    inline t_MatCode(const t_MatCode& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline t_MatCode(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline t_MatCode(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline t_MatCode& operator = (const t_MatCode& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class t_MatCode_out;

  class t_MatCode_var {
  public:
    inline t_MatCode_var() : _pd_seq(0) {}
    inline t_MatCode_var(t_MatCode* _s) : _pd_seq(_s) {}
    inline t_MatCode_var(const t_MatCode_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_MatCode(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_MatCode_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_MatCode_var& operator = (t_MatCode* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_MatCode_var& operator = (const t_MatCode_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_MatCode;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_MatCode* operator -> () { return _pd_seq; }
    inline const t_MatCode* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_MatCode& () const { return *_pd_seq; }
#else
    inline operator const t_MatCode& () const { return *_pd_seq; }
    inline operator t_MatCode& () { return *_pd_seq; }
#endif
      
    inline const t_MatCode& in() const { return *_pd_seq; }
    inline t_MatCode&       inout()    { return *_pd_seq; }
    inline t_MatCode*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_MatCode* _retn() { t_MatCode* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_MatCode_out;
    
  private:
    t_MatCode* _pd_seq;
  };

  class t_MatCode_out {
  public:
    inline t_MatCode_out(t_MatCode*& _s) : _data(_s) { _data = 0; }
    inline t_MatCode_out(t_MatCode_var& _s)
      : _data(_s._pd_seq) { _s = (t_MatCode*) 0; }
    inline t_MatCode_out(const t_MatCode_out& _s) : _data(_s._data) {}
    inline t_MatCode_out& operator = (const t_MatCode_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_MatCode_out& operator = (t_MatCode* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_MatCode*&()  { return _data; }
    inline t_MatCode*& ptr()       { return _data; }
    inline t_MatCode* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_MatCode*& _data;

  private:
    t_MatCode_out();
    t_MatCode_out& operator=(const t_MatCode_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * MinWeight;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_MinWeight;

  class t_MinWeight_var;

  class t_MinWeight : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef t_MinWeight_var _var_type;
    inline t_MinWeight() {}
    inline t_MinWeight(const t_MinWeight& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline t_MinWeight(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline t_MinWeight(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline t_MinWeight& operator = (const t_MinWeight& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class t_MinWeight_out;

  class t_MinWeight_var {
  public:
    inline t_MinWeight_var() : _pd_seq(0) {}
    inline t_MinWeight_var(t_MinWeight* _s) : _pd_seq(_s) {}
    inline t_MinWeight_var(const t_MinWeight_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_MinWeight(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_MinWeight_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_MinWeight_var& operator = (t_MinWeight* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_MinWeight_var& operator = (const t_MinWeight_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_MinWeight;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_MinWeight* operator -> () { return _pd_seq; }
    inline const t_MinWeight* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_MinWeight& () const { return *_pd_seq; }
#else
    inline operator const t_MinWeight& () const { return *_pd_seq; }
    inline operator t_MinWeight& () { return *_pd_seq; }
#endif
      
    inline const t_MinWeight& in() const { return *_pd_seq; }
    inline t_MinWeight&       inout()    { return *_pd_seq; }
    inline t_MinWeight*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_MinWeight* _retn() { t_MinWeight* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_MinWeight_out;
    
  private:
    t_MinWeight* _pd_seq;
  };

  class t_MinWeight_out {
  public:
    inline t_MinWeight_out(t_MinWeight*& _s) : _data(_s) { _data = 0; }
    inline t_MinWeight_out(t_MinWeight_var& _s)
      : _data(_s._pd_seq) { _s = (t_MinWeight*) 0; }
    inline t_MinWeight_out(const t_MinWeight_out& _s) : _data(_s._data) {}
    inline t_MinWeight_out& operator = (const t_MinWeight_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_MinWeight_out& operator = (t_MinWeight* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_MinWeight*&()  { return _data; }
    inline t_MinWeight*& ptr()       { return _data; }
    inline t_MinWeight* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_MinWeight*& _data;

  private:
    t_MinWeight_out();
    t_MinWeight_out& operator=(const t_MinWeight_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * SourceNo;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_SourceNo;

  class t_SourceNo_var;

  class t_SourceNo : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_SourceNo_var _var_type;
    inline t_SourceNo() {}
    inline t_SourceNo(const t_SourceNo& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_SourceNo(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_SourceNo(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_SourceNo& operator = (const t_SourceNo& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_SourceNo_out;

  class t_SourceNo_var {
  public:
    inline t_SourceNo_var() : _pd_seq(0) {}
    inline t_SourceNo_var(t_SourceNo* _s) : _pd_seq(_s) {}
    inline t_SourceNo_var(const t_SourceNo_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_SourceNo(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_SourceNo_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_SourceNo_var& operator = (t_SourceNo* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_SourceNo_var& operator = (const t_SourceNo_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_SourceNo;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_SourceNo* operator -> () { return _pd_seq; }
    inline const t_SourceNo* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_SourceNo& () const { return *_pd_seq; }
#else
    inline operator const t_SourceNo& () const { return *_pd_seq; }
    inline operator t_SourceNo& () { return *_pd_seq; }
#endif
      
    inline const t_SourceNo& in() const { return *_pd_seq; }
    inline t_SourceNo&       inout()    { return *_pd_seq; }
    inline t_SourceNo*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_SourceNo* _retn() { t_SourceNo* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_SourceNo_out;
    
  private:
    t_SourceNo* _pd_seq;
  };

  class t_SourceNo_out {
  public:
    inline t_SourceNo_out(t_SourceNo*& _s) : _data(_s) { _data = 0; }
    inline t_SourceNo_out(t_SourceNo_var& _s)
      : _data(_s._pd_seq) { _s = (t_SourceNo*) 0; }
    inline t_SourceNo_out(const t_SourceNo_out& _s) : _data(_s._data) {}
    inline t_SourceNo_out& operator = (const t_SourceNo_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_SourceNo_out& operator = (t_SourceNo* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_SourceNo*&()  { return _data; }
    inline t_SourceNo*& ptr()       { return _data; }
    inline t_SourceNo* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_SourceNo*& _data;

  private:
    t_SourceNo_out();
    t_SourceNo_out& operator=(const t_SourceNo_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Source;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Source;

  class t_Source_var;

  class t_Source : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Source_var _var_type;
    inline t_Source() {}
    inline t_Source(const t_Source& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Source(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Source(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Source& operator = (const t_Source& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Source_out;

  class t_Source_var {
  public:
    inline t_Source_var() : _pd_seq(0) {}
    inline t_Source_var(t_Source* _s) : _pd_seq(_s) {}
    inline t_Source_var(const t_Source_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Source(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Source_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Source_var& operator = (t_Source* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Source_var& operator = (const t_Source_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Source;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Source* operator -> () { return _pd_seq; }
    inline const t_Source* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Source& () const { return *_pd_seq; }
#else
    inline operator const t_Source& () const { return *_pd_seq; }
    inline operator t_Source& () { return *_pd_seq; }
#endif
      
    inline const t_Source& in() const { return *_pd_seq; }
    inline t_Source&       inout()    { return *_pd_seq; }
    inline t_Source*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Source* _retn() { t_Source* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Source_out;
    
  private:
    t_Source* _pd_seq;
  };

  class t_Source_out {
  public:
    inline t_Source_out(t_Source*& _s) : _data(_s) { _data = 0; }
    inline t_Source_out(t_Source_var& _s)
      : _data(_s._pd_seq) { _s = (t_Source*) 0; }
    inline t_Source_out(const t_Source_out& _s) : _data(_s._data) {}
    inline t_Source_out& operator = (const t_Source_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Source_out& operator = (t_Source* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Source*&()  { return _data; }
    inline t_Source*& ptr()       { return _data; }
    inline t_Source* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Source*& _data;

  private:
    t_Source_out();
    t_Source_out& operator=(const t_Source_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL270

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * LadleId;

  _CORBA_MODULE_VAR _core_attr const char * WeighingStat;

  _CORBA_MODULE_VAR _core_attr const char * Weight;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE Telegram_LFL281

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _core_attr const char * MessageLength;

  _CORBA_MODULE_VAR _core_attr const char * MessageId;

  _CORBA_MODULE_VAR _core_attr const char * MessageCount;

  _CORBA_MODULE_VAR _core_attr const char * UnitNo;

  _CORBA_MODULE_VAR _core_attr const char * CreateTime;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_CreateTime;

  class t_CreateTime_var;

  class t_CreateTime : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_CreateTime_var _var_type;
    inline t_CreateTime() {}
    inline t_CreateTime(const t_CreateTime& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_CreateTime(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_CreateTime(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_CreateTime& operator = (const t_CreateTime& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_CreateTime_out;

  class t_CreateTime_var {
  public:
    inline t_CreateTime_var() : _pd_seq(0) {}
    inline t_CreateTime_var(t_CreateTime* _s) : _pd_seq(_s) {}
    inline t_CreateTime_var(const t_CreateTime_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_CreateTime(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_CreateTime_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_CreateTime_var& operator = (t_CreateTime* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_CreateTime_var& operator = (const t_CreateTime_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_CreateTime;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_CreateTime* operator -> () { return _pd_seq; }
    inline const t_CreateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_CreateTime& () const { return *_pd_seq; }
#else
    inline operator const t_CreateTime& () const { return *_pd_seq; }
    inline operator t_CreateTime& () { return *_pd_seq; }
#endif
      
    inline const t_CreateTime& in() const { return *_pd_seq; }
    inline t_CreateTime&       inout()    { return *_pd_seq; }
    inline t_CreateTime*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_CreateTime* _retn() { t_CreateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_CreateTime_out;
    
  private:
    t_CreateTime* _pd_seq;
  };

  class t_CreateTime_out {
  public:
    inline t_CreateTime_out(t_CreateTime*& _s) : _data(_s) { _data = 0; }
    inline t_CreateTime_out(t_CreateTime_var& _s)
      : _data(_s._pd_seq) { _s = (t_CreateTime*) 0; }
    inline t_CreateTime_out(const t_CreateTime_out& _s) : _data(_s._data) {}
    inline t_CreateTime_out& operator = (const t_CreateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_CreateTime_out& operator = (t_CreateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_CreateTime*&()  { return _data; }
    inline t_CreateTime*& ptr()       { return _data; }
    inline t_CreateTime* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_CreateTime*& _data;

  private:
    t_CreateTime_out();
    t_CreateTime_out& operator=(const t_CreateTime_var&);
  };

  _CORBA_MODULE_VAR _core_attr const char * HeatId;

  _CORBA_MODULE_VAR _core_attr const char * TreatId;

  _CORBA_MODULE_VAR _core_attr const char * LadleId;

  _CORBA_MODULE_VAR _core_attr const char * CarNo;

  _CORBA_MODULE_VAR _core_attr const char * StepNo;

  _CORBA_MODULE_VAR _core_attr const char * Spare;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_t_Spare;

  class t_Spare_var;

  class t_Spare : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef t_Spare_var _var_type;
    inline t_Spare() {}
    inline t_Spare(const t_Spare& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline t_Spare(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline t_Spare(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline t_Spare& operator = (const t_Spare& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class t_Spare_out;

  class t_Spare_var {
  public:
    inline t_Spare_var() : _pd_seq(0) {}
    inline t_Spare_var(t_Spare* _s) : _pd_seq(_s) {}
    inline t_Spare_var(const t_Spare_var& _s) {
      if (_s._pd_seq)  _pd_seq = new t_Spare(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~t_Spare_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline t_Spare_var& operator = (t_Spare* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline t_Spare_var& operator = (const t_Spare_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new t_Spare;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline t_Spare* operator -> () { return _pd_seq; }
    inline const t_Spare* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator t_Spare& () const { return *_pd_seq; }
#else
    inline operator const t_Spare& () const { return *_pd_seq; }
    inline operator t_Spare& () { return *_pd_seq; }
#endif
      
    inline const t_Spare& in() const { return *_pd_seq; }
    inline t_Spare&       inout()    { return *_pd_seq; }
    inline t_Spare*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline t_Spare* _retn() { t_Spare* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class t_Spare_out;
    
  private:
    t_Spare* _pd_seq;
  };

  class t_Spare_out {
  public:
    inline t_Spare_out(t_Spare*& _s) : _data(_s) { _data = 0; }
    inline t_Spare_out(t_Spare_var& _s)
      : _data(_s._pd_seq) { _s = (t_Spare*) 0; }
    inline t_Spare_out(const t_Spare_out& _s) : _data(_s._data) {}
    inline t_Spare_out& operator = (const t_Spare_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline t_Spare_out& operator = (t_Spare* _s) {
      _data = _s;
      return *this;
    }
    inline operator t_Spare*&()  { return _data; }
    inline t_Spare*& ptr()       { return _data; }
    inline t_Spare* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    t_Spare*& _data;

  private:
    t_Spare_out();
    t_Spare_out& operator=(const t_Spare_var&);
  };

_CORBA_MODULE_END



_CORBA_MODULE POA_Telegram_Head
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL200
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL201
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL203
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL204
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL205
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL206
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL209
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL211
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL212
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL213
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL217
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL220
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL221
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL222
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL223
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL224
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL225
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL226
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL230
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL240
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL260
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL261
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL270
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_Telegram_LFL281
_CORBA_MODULE_BEG

_CORBA_MODULE_END



_CORBA_MODULE OBV_Telegram_Head
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL200
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL201
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL203
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL204
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL205
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL206
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL209
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL211
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL212
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL213
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL217
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL220
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL221
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL222
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL223
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL224
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL225
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL226
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL230
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL240
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL260
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL261
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL270
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_Telegram_LFL281
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const HeaderType& _s);
extern void operator<<=(::CORBA::Any& _a, HeaderType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, HeaderType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const HeaderType*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL201::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL201::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL201::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL201::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL203::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL203::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL203::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL203::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL203::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL203::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL203::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL203::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL204::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL204::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL204::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL204::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL204::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL204::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL204::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL204::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL205::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL205::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL205::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL205::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL205::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL205::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL205::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL205::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL206::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL206::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL206::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL206::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL206::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL206::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL206::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL206::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL209::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL209::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL209::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL209::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL209::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL209::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL209::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL209::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL211::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL211::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL211::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL211::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL211::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL211::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL211::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL211::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL212::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL212::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL212::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL212::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL212::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL212::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL212::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL212::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL213::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL213::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL213::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL213::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL213::t_AimDepTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL213::t_AimDepTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL213::t_AimDepTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL213::t_AimDepTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL213::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL213::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL213::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL213::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL217::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL217::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL217::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL217::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL217::t_DelayStartTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL217::t_DelayStartTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL217::t_DelayStartTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL217::t_DelayStartTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL217::t_DelayEndTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL217::t_DelayEndTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL217::t_DelayEndTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL217::t_DelayEndTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL217::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL217::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL217::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL217::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL220::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL220::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL220::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL220::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL220::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL220::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL220::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL220::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL221::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL221::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL221::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL221::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL221::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL221::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL221::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL221::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL222::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL222::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL222::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL222::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL222::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL222::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL222::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL222::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL223::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL223::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL223::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL223::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL223::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL223::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL223::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL223::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL224::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL224::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL224::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL224::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL224::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL224::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL224::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL224::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL225::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL225::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL225::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL225::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL225::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL225::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL225::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL225::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL226::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL226::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL226::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL226::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL226::t_StirrGasType& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL226::t_StirrGasType* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL226::t_StirrGasType*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL226::t_StirrGasType*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL226::t_StirrInt& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL226::t_StirrInt* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL226::t_StirrInt*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL226::t_StirrInt*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL226::t_FlowAct& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL226::t_FlowAct* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL226::t_FlowAct*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL226::t_FlowAct*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL226::t_Pressure& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL226::t_Pressure* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL226::t_Pressure*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL226::t_Pressure*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL226::t_StirrGasCons& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL226::t_StirrGasCons* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL226::t_StirrGasCons*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL226::t_StirrGasCons*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL226::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL226::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL226::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL226::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL230::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL230::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL230::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL230::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL230::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL230::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL230::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL230::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL240::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL240::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL240::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL240::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL240::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL240::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL240::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL240::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL260::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL260::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL260::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL260::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL260::t_MatCode& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL260::t_MatCode* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL260::t_MatCode*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL260::t_MatCode*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL260::t_MatWeight& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL260::t_MatWeight* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL260::t_MatWeight*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL260::t_MatWeight*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL260::t_SourceNo& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL260::t_SourceNo* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL260::t_SourceNo*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL260::t_SourceNo*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL260::t_FeedingRate& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL260::t_FeedingRate* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL260::t_FeedingRate*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL260::t_FeedingRate*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL260::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL260::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL260::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL260::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL261::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL261::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL261::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL261::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL261::t_MatCode& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL261::t_MatCode* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL261::t_MatCode*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL261::t_MatCode*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL261::t_MinWeight& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL261::t_MinWeight* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL261::t_MinWeight*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL261::t_MinWeight*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL261::t_SourceNo& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL261::t_SourceNo* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL261::t_SourceNo*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL261::t_SourceNo*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL261::t_Source& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL261::t_Source* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL261::t_Source*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL261::t_Source*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL261::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL261::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL261::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL261::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL270::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL270::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL270::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL270::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL270::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL270::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL270::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL270::t_Spare*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL281::t_CreateTime& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL281::t_CreateTime* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL281::t_CreateTime*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL281::t_CreateTime*& _sp);

void operator<<=(::CORBA::Any& _a, const Telegram_LFL281::t_Spare& _s);
void operator<<=(::CORBA::Any& _a, Telegram_LFL281::t_Spare* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Telegram_LFL281::t_Spare*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Telegram_LFL281::t_Spare*& _sp);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_Telcom__In
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_Telcom__In
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_Telcom__In
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_Telcom__In
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_Telcom__In
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_Telcom__In
#endif

#endif  // __Telcom__In_hh__

