//## Copyright (C) 2009 SMS Siemag AG, Germany 
//## Version generated by (DB)ClassCodeUtility BETA 0.6.0 

#include "iSMC_DataDefinitions_s.hh"
#include "cCBS_StdInitBase.h"
#include "CDM_ProductManagementInterface_Impl.h"
#include "CSMC_EventLogFrameController.h"
#include "CDataConversion.h"
#include "CHeatDataConverter.h"
#include "CEquipmentData.h"
#include "CHeatStatusContainer.h"
#include "CHeatIDCust.h"
#include "CGasDataHandler.h"
#include "CSMC_RecipeHandler.h"

//Definition classes
#include "DEF_GC_MEASUREMENT_TYPE.h"
#include "DEF_GC_MEASUREMENT_NAME.h"
#include "DEF_GC_MEASUREMENT_ORIGIN.h"
#include "DEF_GC_MEASUREMENT_NAME_SCOPE.h"
#include "DEF_GC_HEAT_STATUS.h"
#include "DEF_GC_ACTION_DEF.h"
#include "DEF_GC_PP_ORDER_SINGLE_AIMS.h"
#include "DEF_GC_LADLE_TYPE.h"
#include "DEF_GC_RECIPE_SOURCE.h"
#include "DEF_GC_SAMPLEMODE.h"
#include "DEF_GC_SAMPLEUSABLE.h"
#include "DEF_GC_THERM_STAT.h"
#include "DEF_GC_PLANT_DEF.h"
#include "DEF_GC_PARAM_TYPE.h"
#include "DEF_GC_RECIPE_STATUS.h"
#include "DEF_GC_LADLE_PARTS.h"
#include "DEF_GC_PRODPRAC_DEF.h"
#include "DEF_GC_SCRAP_CONTAINER_STATUS.h"
#include "DEF_GC_SCRAP_CONT_ORDER_STATUS.h"
#include "DEF_GC_CHARGE_DEST.h"
#include "DEF_GC_COUNTER_TYPE.h"
#include "DEF_GC_STATUS.h"
#include "DEF_GC_STIRR_GAS_TYPE.h"


//HD tables
#include "CHD_ACTION.h"
#include "CHD_COOLWATER.h"
#include "CHD_GRADE.h"
#include "CHD_GRADE_ANL.h"
#include "CHD_GRADE_EQUIV.h"
#include "CHD_HEAT_DATA_PRODPRAC.h"
#include "CHD_GRADE_SINGLE_AIMS.h"
#include "CHD_PHASE_RES.h"
#include "CHD_PHASE_RES_ANL.h"
#include "CHD_PHASE_RES_PLANT.h"
#include "CHD_PARAM.h"
#include "CHD_PARAM_MATRIX.h"
#include "CHD_HEAT_DATA.h"
#include "CHD_RESTRI.h"
#include "CHD_RESTRI_ENTRY.h"
#include "CHD_DELAYS.h"
// table removed #include "CHD_EQUIP_MOUNT.h"
#include "CHD_LADLE.h"
#include "CHD_LADLE_LIFE_DATA.h"
#include "CHD_RECIPE.h"
#include "CHD_RECIPE_ENTRY.h"
#include "CHD_WASTEGAS_CYCL_MEAS_DATA.h"
#include "CHD_SAMPLE.h"
#include "CHD_SAMPLE_ENTRY.h"
#include "CHD_SAMPLE_REF.h"
#include "CHD_TAPCH_DATA.h"
#include "CHD_TREATMODE.h"
#include "CHD_TREATMODE_ENTRY.h"
#include "CHD_MAT_FEED.h"
#include "CHD_MAT_FEED_RES.h"
#include "CHD_HEAT_DATA_MAT_FEED.h"
#include "CHD_MAT_FEED_CYCL_MEAS_DATA.h"

#include "CHD_ELEC_SYSTEM.h"

//GT tables
#include "CGT_PARAM.h"
#include "CGT_GRADE_PRODPRAC.h"
#include "CGT_MAT_PURP.h"
#include "CGT_MAT_FEED.h"
#include "CGT_RESTRI.h"
#include "CGT_EQUIV.h"

//GC tables
#include "CGC_LADLE_PARTS.h"
#include "CGC_PLANTGROUP.h"
#include "CGC_HEAT_STATUS.h"
#include "CGCC_TRANSLATE_VALUE.h"
#include "CGC_PHASE.h"
#include "CGC_Plantgroup_Container.h"
#include "CGC_Plant_Container.h"
#include "CGCC_TRANSLATE_VALUE.h"
#include "CGT_GRADE_SINGLE_AIMS.h"
#include "CGC_Ladle_Def_Container.h"
#include "CGC_RECIPE_L1.h"
#include "CGC_SCRAP_CONTAINER.h"

//PP tables
#include "CPP_HEAT_PLANT.h"
#include "CPP_HEAT.h"
#include "CPP_ORDER.h"
#include "CPP_ORDER_SINGLE_AIMS.h"

//PD tables
#include "CPD_PRETREATDATA.h"
#include "CPD_HEAT_DATA.h"
#include "CPD_TAPCH_DATA.h"
#include "CPD_HEAT_DATA_PRODPRAC.h"
#include "CPD_HEAT_DATA_LIQADD.h"
#include "CPD_HEAT_REF.h"
#include "CPD_HEAT_PLANT_REF.h"
#include "CPD_SAMPLE.h"
#include "CPD_SAMPLE_ENTRY.h"
#include "CPD_SAMPLE_REF.h"
#include "CPD_DELAYS.h"
#include "CPD_LADLE.h"
#include "CPD_RECIPE.h"
#include "CPD_RECIPE_ENTRY.h"
#include "CPD_ACTION.h"
#include "CPD_PLANTSTATUS.h"
#include "CPD_PLANTSTATUS_PLANT.h"
#include "CPD_PHASE_RES.h"
#include "CPD_PHASE_RES_ANL.h"
#include "CPD_HOTHEEL.h"
#include "CPD_HEAT_DATA_MAT_FEED.h"
#include "CPD_MAT_AVAIL.h"
#include "CPD_LADLE_LIFE_DATA.h"
#include "CPD_SCRAP_CONTAINER.h"
#include "CPD_SCRAP_CONTAINER_ENTRY.h"
#include "CPD_SCRAP_CONTAINER_ORDER.h"
#include "CPD_SCRAP_CONTAINER_ORDER_ENTRY.h"

#include "CTreatID.h"

#include "CDM_DBManager.h"


CDM_DBManager::CDM_DBManager(CDM_DBManagerTask* _task)
: m_pDM_DBManagerTask(_task)
{
  resetLastError();
  m_pGC_Plantgroup_Container  = new CGC_Plantgroup_Container(m_pDM_DBManagerTask->getStdConnection());
  m_pGC_Plant_Container       = new CGC_Plant_Container(m_pDM_DBManagerTask->getStdConnection());
  m_pGCC_TRANSLATE_VALUE      = new CGCC_TRANSLATE_VALUE(m_pDM_DBManagerTask->getStdConnection());
  m_pHeatStatusContainer      = new CHeatStatusContainer(m_pDM_DBManagerTask->getStdConnection());
}

CDM_DBManager::~CDM_DBManager()
{
  if(m_pGC_Plantgroup_Container) { m_pGC_Plantgroup_Container = 0 ; delete m_pGC_Plantgroup_Container;  }
  if(m_pGC_Plant_Container)      { m_pGC_Plant_Container = 0      ; delete m_pGC_Plant_Container;  }
  if(m_pGCC_TRANSLATE_VALUE)     { m_pGCC_TRANSLATE_VALUE = 0     ; delete m_pGCC_TRANSLATE_VALUE;  }
  if(m_pHeatStatusContainer)     { m_pHeatStatusContainer = 0     ; delete m_pHeatStatusContainer;  }
}

void CDM_DBManager::init()
{
  cCBS_StdInitBase *pStdInitBase = cCBS_StdInitBase::getInstance();
  std::string Plant;

  if ( pStdInitBase->replaceWithEntry(m_pDM_DBManagerTask->getTaskName(), "Plant", Plant) ||
       pStdInitBase->getEntry("PLANT", "Plant", Plant) )
  {
    CGC_HEAT_STATUS       GC_HEAT_STATUS     (m_pDM_DBManagerTask->getStdConnection());
    CHeatStatusContainer  HeatStatusContainer(m_pDM_DBManagerTask->getStdConnection());

    //==== Getting Departure Heat Status No
    m_HeatStatus.Departure = HeatStatusContainer.getHeatStatus(Plant, DEF_GC_HEAT_STATUS::LadleDeparture );

    //==== Getting Planned Status No
    m_HeatStatus.Planned = HeatStatusContainer.getHeatStatus(Plant, DEF_GC_HEAT_STATUS::Planned );

    if ( m_HeatStatus.Planned == -1 )
    {
      m_HeatStatus.Planned = 1; // planned state is always 1
      log("Used Planned = 1 status per default",0);
    }

    //==== Getting Announce Heat Status No
    m_HeatStatus.Announced = HeatStatusContainer.getHeatStatus(Plant, DEF_GC_HEAT_STATUS::HeatAnnounced );

    //==== Getting Tapping Status No
    m_HeatStatus.Tapping = HeatStatusContainer.getHeatStatus(Plant, DEF_GC_HEAT_STATUS::Tapping );

    //==== Getting TreatmentStart Status No
    m_HeatStatus.TreatmentStart = HeatStatusContainer.getHeatStatus(Plant, DEF_GC_HEAT_STATUS::TreatmentStart );

    //==== Getting TreatmentEnd Status No
    m_HeatStatus.TreatmentEnd = HeatStatusContainer.getHeatStatus(Plant, DEF_GC_HEAT_STATUS::TreatmentEnd );

		
    //==== Getting Blowing Status No
    m_HeatStatus.Blowing = HeatStatusContainer.getHeatStatus(Plant, DEF_GC_HEAT_STATUS::Blowing );

    //==== Getting Melting Status No
    m_HeatStatus.Melting = HeatStatusContainer.getHeatStatus(Plant, DEF_GC_HEAT_STATUS::Melting );

    //======================= update the heat stack  ==============================
    setHeatStack();  
    //======================= update the heat stack  ==============================
  }
  else
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage, "No Plant", "CDM_DBManager::init()", "Read ini file");
  }

  if ( !pStdInitBase->getEntry("EventLog", "TranslationLang", m_TranslationLang))
  {
    m_TranslationLang = "E";
    log("Translation Language not defined in ini, using 'E' as default",2);
  }
}

bool CDM_DBManager::setHeatStack()
{
  log("++++++ CDM_DBManager::setHeatStack",3);

  bool RetValue = true;

  if ( m_pDM_DBManagerTask )
  {
    CDM_PlantManagementInterface_Impl* pPlantManagementInterface = m_pDM_DBManagerTask->getpPlantManagementInterface();
    cCBS_StdInitBase *pStdInitBase = cCBS_StdInitBase::getInstance();

    seqHeatStack SeqHeatStack;
    sHeatStack   HeatStack;
    std::string PlantId;
    std::string Plant;
    long PlantNo = 0;
    std::string HeatId;
    std::string TreatId;
    std::string HeatIdCust;
    std::string TreatIdCust;
    std::string OrderId;
    long ScrapOrder     = 0; // not ordered
    long HotMetalOrder  = 0; // not ordered
    long HeatStat       = 0;

    // first read plant information from sHeatInfo &HeatInfo if available
    // otherwise read data from ini file

    pStdInitBase->getEntry("PLANT", "PlantId", PlantId);

    if ( !PlantId.empty() )
    {
      splitPlantPlantNo(PlantId, Plant, PlantNo);

      CPD_HEAT_DATA               PD_HEAT_DATA              (m_pDM_DBManagerTask->getStdConnection());
      CPD_HEAT_PLANT_REF          PD_HEAT_PLANT_REF         (m_pDM_DBManagerTask->getStdConnection());
      //CPD_HEAT_REF                PD_HEAT_REF               (m_pDM_DBManagerTask->getStdConnection());

      std::stringstream Message;
      long Heats = 0;

      //===========  find heat in treatment  =============================================

      Message << "HEAT STACK " << PlantId << " Heats in treatment: ";

      if ( PD_HEAT_DATA.selectHeatsInTreatment(Plant, PlantNo) )
      {
        Heats = PD_HEAT_DATA.getLastRow();
        Message << Heats << "[";

        for ( long a = 1; a <= Heats; a++ )
        {
          HeatId    = PD_HEAT_DATA.getHEATID(a);
          TreatId   = PD_HEAT_DATA.getTREATID(a);
          OrderId   = PD_HEAT_DATA.getPRODORDERID_ACT(a);

          if ( PD_HEAT_PLANT_REF.selectValidData(HeatId, TreatId, Plant) )
          {
            HeatIdCust  = PD_HEAT_PLANT_REF.getHEATID_CUST(1);
            TreatIdCust = PD_HEAT_PLANT_REF.getTREATID_CUST(1);
            HeatStat    = PD_HEAT_PLANT_REF.getSTATUSNO(1);
          }
          
          // check if HeatStat is in range of plant specific states

          if (HeatStat >= m_HeatStatus.Announced && 
              HeatStat < m_HeatStatus.Departure)
          {
            HeatStack.Plant                = Plant.c_str();
            HeatStack.PlantNo              = PlantNo;
            HeatStack.HeatId               = HeatId.c_str();
            HeatStack.TreatId              = TreatId.c_str();
            HeatStack.ExternalHeatID       = HeatIdCust.c_str();
            HeatStack.ExternalTreatID      = TreatIdCust.c_str();
            HeatStack.OrderId              = OrderId.c_str();
            HeatStack.HeatStatus           = HeatStat;
            HeatStack.HotMetalOrderStatus  = HotMetalOrder;
            HeatStack.ScrapOrderStatus     = ScrapOrder;

            if ( !checkHeatInStack(SeqHeatStack, HeatStack) )
            {
              CIntfData::insert(SeqHeatStack, HeatStack);
            }
          }
        }

        Message << "]";
      }
      else
      {
        Message << Heats;
      }

      log(Message.str(), 3);
      Message.str(std::string());
      Heats = 0;
      //==================================================================================

      //===========  find anounced heats but not in treatment  ===========================

      Message << "HEAT STACK " << PlantId << " Announced Heats: ";

      if ( PD_HEAT_DATA.selectHeatsAnnounced(Plant, PlantNo) )
      {
        Heats = PD_HEAT_DATA.getLastRow();
        Message << Heats << "[";

        for ( long a = 1; a <= Heats; a++ )
        {
          HeatId    = PD_HEAT_DATA.getHEATID(a);
          TreatId   = PD_HEAT_DATA.getTREATID(a);
          OrderId   = PD_HEAT_DATA.getPRODORDERID_ACT(a);

          if ( PD_HEAT_PLANT_REF.selectValidData(HeatId, TreatId, Plant) )
          {
            HeatIdCust  = PD_HEAT_PLANT_REF.getHEATID_CUST(1);
            TreatIdCust = PD_HEAT_PLANT_REF.getTREATID_CUST(1);
            HeatStat    = PD_HEAT_PLANT_REF.getSTATUSNO(1);
          }

          if (HeatStat >= m_HeatStatus.Announced && 
              HeatStat < m_HeatStatus.Departure)
          {
            HeatStack.Plant                = Plant.c_str();
            HeatStack.PlantNo              = PlantNo;
            HeatStack.HeatId               = HeatId.c_str();
            HeatStack.TreatId              = TreatId.c_str();
            HeatStack.ExternalHeatID       = HeatIdCust.c_str();
            HeatStack.ExternalTreatID      = TreatIdCust.c_str();
            HeatStack.OrderId              = OrderId.c_str();
            HeatStack.HeatStatus           = HeatStat;
            HeatStack.HotMetalOrderStatus  = HotMetalOrder;
            HeatStack.ScrapOrderStatus     = ScrapOrder;

            if ( !checkHeatInStack(SeqHeatStack, HeatStack) )
            {
              CIntfData::insert(SeqHeatStack, HeatStack);
            }

            Message << HeatId << " " << TreatId << " " << OrderId << ", ";
          }
        }

        Message << "]";
      }
      else
      {
        Message << Heats;
      }

      log(Message.str(), 3);
      Message.str(std::string());
      Heats = 0;
      //==================================================================================

    }
    else
    {
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ExceptionCaught(sMessage, "No PlantId", "CDM_DBManager::setHeatStack()", "Read ini file");

      RetValue = false;
    }

    if ( pPlantManagementInterface )
    {
      pPlantManagementInterface->setHeatStack(DEF_PLANT::Furnace, DATA::HeatStack, SeqHeatStack);

      log(CIntfData::getContent(CIntfData::ToAny(SeqHeatStack)),4);
    }
    else
    {
      RetValue = false;
    }
  }
  else
  {
    RetValue = false;
  }

  return RetValue;
}

bool CDM_DBManager::checkHeatInStack(seqHeatStack& SeqHeatStack, sHeatStack NewHeatStack)
{
  bool RetValue = false;

  for ( long i = 0 ; i < CIntfData::getLength(SeqHeatStack); ++i )
  {
    sHeatStack HeatStack;

    CIntfData::getAt(HeatStack, SeqHeatStack, i );

    if ( std::string(HeatStack.HeatId)   == std::string(NewHeatStack.HeatId)  && 
         std::string(HeatStack.TreatId)  == std::string(NewHeatStack.TreatId) && 
         std::string(HeatStack.Plant)    == std::string(NewHeatStack.Plant)   && 
         HeatStack.PlantNo               == NewHeatStack.PlantNo )
    {
      RetValue = true;
      break;
    }
  }

  return RetValue;
}

//this structure need to be initialize, otherwize some random would exist and lead to error for save
void CDM_DBManager::initialSampleRef(sSampleRef &pSample)
{
  log("++++++ CDM_DBManager::initialSampleRef",3);

  pSample.mAluminium = -1;
  pSample.mCarbon = -1;
  pSample.mCelogSlag = -1;
  pSample.mEMF = -1;
  pSample.mHydrogen = -1;
  pSample.mOxygen = -1;
  pSample.mSlag = -1;
  pSample.mSlagCalc = -1;
  pSample.mSteel = -1;
  pSample.mSteelCalc = -1;
  pSample.mTemp = -1;
  pSample.mTempCalc = -1;
}

bool CDM_DBManager::copyHDAction(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDAction",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHD_ACTION HD_ACTION(m_pDM_DBManagerTask->getStdConnection());
    RetValue = RetValue && HD_ACTION.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::copyHDCoolWater(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDCoolWater",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHD_COOLWATER m_pHD_CoolWater(m_pDM_DBManagerTask->getStdConnection());
    RetValue = RetValue && m_pHD_CoolWater.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::copyHDDelays(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDDelays",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHD_DELAYS m_HDDelay(m_pDM_DBManagerTask->getStdConnection());

    RetValue = RetValue && m_HDDelay.copy(HeatInfo.Plant, HeatInfo.PlantNo, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::copyHDElecSystem(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDElecSystem",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHD_ELEC_SYSTEM HD_ELEC_SYSTEM (m_pDM_DBManagerTask->getStdConnection());
    RetValue = RetValue && HD_ELEC_SYSTEM.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

//bool CDM_DBManager::copyHDEquipMount(sHeatInfo &HeatInfo, bool Commit)
//{
//  log("++++++ CDM_DBManager::copyHDEquipMount",3);
//
//  bool RetValue = (m_pDM_DBManagerTask != NULL);
//  if (RetValue)
//  {
//    // CHD_EQUIP_MOUNT HD_EQUIP_MOUNT(m_pDM_DBManagerTask->getStdConnection());
//
//    // RetValue = RetValue && HD_EQUIP_MOUNT.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, Commit, m_lastError);
//  }
//  return RetValue;
//}

bool CDM_DBManager::copyHDGrades(sHeatInfo &HeatInfo, const std::string &SteelGrade, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDGrades",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {  
    CHD_GRADE               HD_GRADE(m_pDM_DBManagerTask->getStdConnection());
    CHD_GRADE_ANL           HD_GRADE_ANL(m_pDM_DBManagerTask->getStdConnection());
    CHD_GRADE_EQUIV         HD_GRADE_EQUIV(m_pDM_DBManagerTask->getStdConnection());
    CHD_GRADE_SINGLE_AIMS   HD_GRADE_SINGLE_AIMS(m_pDM_DBManagerTask->getStdConnection());
    CHD_HEAT_DATA_PRODPRAC  HD_HEAT_DATA_PRODPRAC(m_pDM_DBManagerTask->getStdConnection());

    std::string SteelGrade = SteelGrade;
    if (SteelGrade.empty() || SteelGrade == DEF::Inv_String )
    {
      //if SteelGrade is empty get it from database
      RetValue = getActSteelGrade(HeatInfo, SteelGrade);  
    }    
    //delete rows from HD_GRADE_ANL first if any
    if (RetValue && HD_GRADE_ANL.exists(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      RetValue = HD_GRADE_ANL.deleteRows();
    //delete rows from HD_HEAT_DATA_PRODPRAC first if any
    if (RetValue && HD_HEAT_DATA_PRODPRAC.exists(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      RetValue = HD_HEAT_DATA_PRODPRAC.deleteRows();
    //delete rows from HD_GRADE_Single_AIMS first if any
    if (RetValue && HD_GRADE_SINGLE_AIMS.exists(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      RetValue = HD_GRADE_SINGLE_AIMS.deleteRows();

    RetValue = RetValue && HD_GRADE.copy(SteelGrade, HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
    RetValue = RetValue && HD_GRADE_ANL.copy(SteelGrade, HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
    RetValue = RetValue && HD_GRADE_EQUIV.copy(SteelGrade, HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);

    if ( !RetValue)
    {
      checkLastError();
      setLastError("ERROR_ON_GRADE_DEFINITION", 0, "" );
    }

    RetValue = RetValue && HD_HEAT_DATA_PRODPRAC.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);

    if ( !RetValue)
    {
      checkLastError();
      setLastError("ERROR_ON_PRECTICE_DEFINITION", 0, "" );
    }

    RetValue = RetValue && HD_GRADE_SINGLE_AIMS.copy(SteelGrade, HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);

    if ( !RetValue)
    {
      checkLastError();
      setLastError("ERROR_ON_SINGEL_AIMS_DEFINITION", 0, "" );
    }
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::copyHDHeatData(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDHeatData",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHD_HEAT_DATA HD_HEAT_DATA(m_pDM_DBManagerTask->getStdConnection());

    RetValue = RetValue && HD_HEAT_DATA.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::checkHDHeatData(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::checkHDHeatData",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  if (RetValue)
  {
    CHD_HEAT_DATA HD_HEAT_DATA(m_pDM_DBManagerTask->getStdConnection());

    bool CheckNullValues = false;
    cCBS_StdInitBase *pStdInitBase = cCBS_StdInitBase::getInstance();
    pStdInitBase->replaceWithEntry("ProcessControl", "CheckNullValues", CheckNullValues);

    if ( CheckNullValues )
    {
      HD_HEAT_DATA.checkNULLValues(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant);
    }
  }

  checkLastError();

  return RetValue;
}




bool CDM_DBManager::copyHDHeatDataMatFeed(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDHeatDataMatFeed",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  if (RetValue)
  {
    CHD_HEAT_DATA_MAT_FEED            HD_HEAT_DATA_MAT_FEED             (m_pDM_DBManagerTask->getStdConnection());

    RetValue = RetValue && HD_HEAT_DATA_MAT_FEED.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError); 
  }

  checkLastError();


  return RetValue;
}

bool CDM_DBManager::copyHDLadleLifeData(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDLadleLifeData and HDLadle",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHD_LADLE           HD_LADLE(m_pDM_DBManagerTask->getStdConnection());
    CHD_LADLE_LIFE_DATA HD_LADLE_LIFE_DATA(m_pDM_DBManagerTask->getStdConnection());
    // First HD_LADLE
    RetValue = RetValue && HD_LADLE.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, Commit, m_lastError);

    if ( !RetValue)
    {
      checkLastError();
      setLastError("ERROR_ON_LADLE_DEFINITION", 0, "");
    }

    // Second HD_LADLE_LIFE_DATA
    RetValue = RetValue && HD_LADLE_LIFE_DATA.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, Commit, m_lastError);

    if ( !RetValue)
    {
      checkLastError();
      setLastError("ERROR_ON_LADLE_LIFE_DATA_DEFINITION", 0, "" );
    }
  }

  return RetValue;
}

bool CDM_DBManager::copyHDMatFeed(sHeatInfo &HeatInfo, const std::string &SteelGrade, long &pTreatModeNo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDMatFeed",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  long mPracNo      = -1;
  long mLiqAdd      = 0;
  long mFraction    = 0;

  RetValue = CDM_DBManager::getPracNo(HeatInfo, DEF_GC_PRODPRAC_DEF::Process, mPracNo);

  if (RetValue)
  {
    CHD_MAT_FEED                HD_MAT_FEED                 (m_pDM_DBManagerTask->getStdConnection());
    CHD_HEAT_DATA               HD_HEAT_DATA                (m_pDM_DBManagerTask->getStdConnection());

    if (HD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
    {
      std::string OrderId = HD_HEAT_DATA.getPRODORDERID_ACT(1);

      RetValue = RetValue && CDM_DBManager::getLiqAddAmount(HeatInfo.Plant, OrderId, mLiqAdd, mFraction);
    }
    else
    {
      RetValue = false;

      std::string SearchKey = HeatInfo.HeatId + " " + HeatInfo.TreatId + " " + HeatInfo.Plant;
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorSearchingData(sMessage, SearchKey.c_str(), "HD_HEAT_DATA");
    }

    RetValue = RetValue && HD_MAT_FEED.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, mPracNo, pTreatModeNo, mFraction, Commit, m_lastError); 

    if ( !RetValue)
    {
      checkLastError();
      setLastError("ERROR_ON_MATERIAL_FEEDING_DEFINITION", 0, "" );
    }
  }

  return RetValue;
}

bool CDM_DBManager::copyHDMatFeedCyclicMeasData(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDMatFeedCyclicMeasData",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  if (RetValue)
  {
    CHD_MAT_FEED_CYCL_MEAS_DATA HD_MAT_FEED_CYCL_MEAS_DATA  (m_pDM_DBManagerTask->getStdConnection());

    RetValue = RetValue && HD_MAT_FEED_CYCL_MEAS_DATA.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, Commit, m_lastError); 
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::copyHDMatFeedRes(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDMatFeedRes",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  if (RetValue)
  {
    CHD_MAT_FEED_RES    HD_MAT_FEED_RES             (m_pDM_DBManagerTask->getStdConnection());

    RetValue = RetValue && HD_MAT_FEED_RES.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::copyHDParams(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDParams",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHD_PARAM         HD_PARAM(m_pDM_DBManagerTask->getStdConnection());
    CHD_PARAM_MATRIX  HD_PARAM_MATRIX(m_pDM_DBManagerTask->getStdConnection());
    CGC_PLANTGROUP    GC_PLANTGROUP(m_pDM_DBManagerTask->getStdConnection());

    std::vector<long> mGroupNo;
    //Getting UNITGROUPNO from GC_PLANTGROUP
    RetValue = GC_PLANTGROUP.selectByPlant(HeatInfo.Plant, HeatInfo.PlantNo);
    if (RetValue)
    {
      long count = GC_PLANTGROUP.getLastRow();
      for (long i = 1; i <= count; i++)
        mGroupNo.push_back(GC_PLANTGROUP.getUNITGROUPNO(i));
    }
    else // No UNITGROUPNO found in GC_PLANTGROUP
    {
      setLastError("NO_DATA_FOUND", 0, GC_PLANTGROUP.getActStatement());
    }

    //get actual SteelGrade
    std::string SteelGrade = "";
    RetValue = RetValue && getActSteelGrade(HeatInfo, SteelGrade);
    //Get the PracNo for Parameter
    long mPracNo = -1;
    RetValue = RetValue && getPracNo(HeatInfo, DEF_GC_PRODPRAC_DEF::Parameter, mPracNo); 

    //delete rows from HD_PARAM_MATRIX first if any
    if (RetValue && HD_PARAM_MATRIX.exists(mGroupNo, HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      RetValue = HD_PARAM_MATRIX.deleteData(mGroupNo, HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);

    RetValue = RetValue && HD_PARAM.copy(mGroupNo, HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, mPracNo, Commit, m_lastError);
    RetValue = RetValue && HD_PARAM_MATRIX.copy(mGroupNo, HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, mPracNo, Commit, m_lastError);

    if ( !RetValue)
    {
      checkLastError();
      setLastError("ERROR_ON_PARAMETER_DEFINITION", 0, "" );
    }
  }

  return RetValue;
}

bool CDM_DBManager::copyHDPhaseRes(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDPhaseRes",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHD_PHASE_RES       HD_PHASE_RES      (m_pDM_DBManagerTask->getStdConnection());
    CHD_PHASE_RES_ANL   HD_PHASE_RES_ANL  (m_pDM_DBManagerTask->getStdConnection());
    CHD_PHASE_RES_PLANT HD_PHASE_RES_PLANT(m_pDM_DBManagerTask->getStdConnection());

    //delete rows from PHASE_RES_ANL first if any
    if (RetValue && HD_PHASE_RES_ANL.exists(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      RetValue = HD_PHASE_RES_ANL.deleteRows();
    //delete rows from PHASE_RES_PLANT first if any
    if (RetValue && HD_PHASE_RES_PLANT.exists(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      RetValue = HD_PHASE_RES_PLANT.deleteRows();

    if (!HD_PHASE_RES.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError))
      log("copy HD_PHASE_RES faild!",1);
    if (!HD_PHASE_RES_ANL.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError))
      log("copy HD_PHASE_RES_ANL faild!",1);
    if (!HD_PHASE_RES_PLANT.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError))
      log("copy HD_PHASE_RES_PLANT faild!",1);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::copyHDRecipes(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDRecipes",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHD_RECIPE        HD_RECIPE       (m_pDM_DBManagerTask->getStdConnection());
    CHD_RECIPE_ENTRY  HD_RECIPE_ENTRY (m_pDM_DBManagerTask->getStdConnection());

    //delete rows from HD_RESTRI_ENTRY first if any
    if (RetValue && HD_RECIPE_ENTRY.exists(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      RetValue = HD_RECIPE_ENTRY.deleteRows();

    RetValue = RetValue && HD_RECIPE.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
    RetValue = RetValue && HD_RECIPE_ENTRY.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);

    if ( !RetValue)
    {
      checkLastError();
      setLastError("ERROR_ON_RECIPE_DEFINITION", 0, "" );
    }

  }

  return RetValue;
}

bool CDM_DBManager::copyHDRestris(sHeatInfo &HeatInfo, long &pTreatModeNo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDRestris",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    long mPracNo        = -1;
    long mLiqAdd        = 0;
    long mFraction      = 0;
    std::string DescrPP = DEF_GC_PRODPRAC_DEF::Restriction;

    RetValue = RetValue && getPracNo(HeatInfo, DEF_GC_PRODPRAC_DEF::Restriction, mPracNo);
    if (RetValue)
    {
      CHD_HEAT_DATA     HD_HEAT_DATA    (m_pDM_DBManagerTask->getStdConnection());
      CHD_RESTRI        HD_RESTRI       (m_pDM_DBManagerTask->getStdConnection());
      CHD_RESTRI_ENTRY  HD_RESTRI_ENTRY (m_pDM_DBManagerTask->getStdConnection());

      if (HD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      {
        std::string OrderId = HD_HEAT_DATA.getPRODORDERID_ACT(1);

        RetValue = RetValue && CDM_DBManager::getLiqAddAmount(HeatInfo.Plant, OrderId, mLiqAdd, mFraction);
      }
      else
      {
        RetValue = false;

        std::string SearchKey = HeatInfo.HeatId + " " + HeatInfo.TreatId + " " + HeatInfo.Plant;
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorSearchingData(sMessage, SearchKey.c_str(), "HD_HEAT_DATA");
      }
  
      // restriction entry is mandantory for model data support of recipes
      RetValue = RetValue && HD_RESTRI.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, DescrPP, mPracNo, pTreatModeNo, mFraction, Commit, m_lastError);

      if ( !HD_RESTRI.exists(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, DescrPP ) )
      {
        RetValue = false;

        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorHandlingRestriction(sMessage, DescrPP.c_str(), HeatInfo.Plant.c_str(), mPracNo, pTreatModeNo );
      }

      RetValue = RetValue && HD_RESTRI_ENTRY.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, DescrPP, mPracNo, pTreatModeNo, mFraction, Commit, m_lastError);

      if ( !RetValue)
      { 
        checkLastError();
        setLastError("ERROR_ON_RESTRICTION_DEFINITION", 0, "", 1 );
      }
    }
  }
 

  return RetValue;
}

bool CDM_DBManager::copyHDSamples(sHeatInfo &HeatInfo, long SAMPLE_COUNTER, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDSamples",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_HEAT_DATA    PD_HEAT_DATA   (m_pDM_DBManagerTask->getStdConnection());
    CPD_SAMPLE       PD_SAMPLE      (m_pDM_DBManagerTask->getStdConnection());
    CPD_SAMPLE_REF   PD_SAMPLE_REF  (m_pDM_DBManagerTask->getStdConnection());
    CHD_SAMPLE       HD_SAMPLE      (m_pDM_DBManagerTask->getStdConnection());
    CHD_SAMPLE_ENTRY HD_SAMPLE_ENTRY(m_pDM_DBManagerTask->getStdConnection());
    CHD_SAMPLE_REF   HD_SAMPLE_REF  (m_pDM_DBManagerTask->getStdConnection()); 

    //get the sample counts from the PD_SAMPLE_REF
    if ( SAMPLE_COUNTER != CSMC_DBData::unspecLong )
    {
      RetValue = RetValue && HD_SAMPLE_REF.copy(HeatInfo.HeatId,HeatInfo.TreatId, HeatInfo.Plant,Commit,m_lastError);

      RetValue = RetValue && HD_SAMPLE.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, SAMPLE_COUNTER, Commit, m_lastError);
      RetValue = RetValue && HD_SAMPLE_ENTRY.copy(SAMPLE_COUNTER, Commit, m_lastError);
    }
    else
    {
      // check if sample can be taken from PD_HEAT_DATA
      RetValue = RetValue && PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant);

      if ( RetValue )
      {
        std::vector<long> SampleCounterList;

        long SAMPLE_REF = PD_HEAT_DATA.getSAMPLE_REF(1);

        if ( SAMPLE_REF != CSMC_DBData::unspecLong )
        {
          RetValue = RetValue && HD_SAMPLE_REF.copy(HeatInfo.HeatId,HeatInfo.TreatId, HeatInfo.Plant, Commit,m_lastError);

          SampleCounterList = PD_SAMPLE_REF.getSampleCounterList(SAMPLE_REF);

          if(SampleCounterList.size() > 0)
          {
            RetValue = RetValue && HD_SAMPLE.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, SampleCounterList, Commit, m_lastError);
            RetValue = RetValue && HD_SAMPLE_ENTRY.copy(SampleCounterList, Commit, m_lastError);

            if ( !RetValue)
            {
              checkLastError();
            }
          }
        }
      }
      else
      {
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_DBReadError(sMessage,"HEATID - TREATID - PLANT","PD_SAMPLE_REF","");

        setLastError("NO_DATA_FOUND", 0, PD_SAMPLE_REF.getActStatement() );
      }
    }
  }

  return RetValue;
}

bool CDM_DBManager::copyHDTablesOnHeatEnd(sHeatInfo &HeatInfo, const std::string &SteelGrade, const long &pSample_Counter, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDTablesOnHeatEnd",3);

  bool RetValue = true;

  RetValue = RetValue && copyHDHeatData(HeatInfo, false);
  RetValue = RetValue && checkHDHeatData(HeatInfo, false);

  RetValue = RetValue && copyHDElecSystem(HeatInfo, false);
  RetValue = RetValue && copyHDAction(HeatInfo, false);
  RetValue = RetValue && copyHDCoolWater(HeatInfo, false);
  RetValue = RetValue && copyHDDelays(HeatInfo, false);
//  RetValue = RetValue && copyHDEquipMount(HeatInfo, false);
  RetValue = RetValue && copyHDLadleLifeData(HeatInfo, false);
  RetValue = RetValue && copyHDPhaseRes(HeatInfo, false);
  RetValue = RetValue && copyHDRecipes(HeatInfo, false);
  RetValue = RetValue && copyHDParams(HeatInfo, false);

  RetValue = RetValue && copyHDWastegasCyclMeasData(HeatInfo, false);
  RetValue = RetValue && copyHDTapchData(HeatInfo,false);

  RetValue = RetValue && copyHDMatFeedRes(HeatInfo, false);
  RetValue = RetValue && copyHDHeatDataMatFeed(HeatInfo, false);

  RetValue = RetValue && copyHDMatFeedCyclicMeasData(HeatInfo,false);

  RetValue = RetValue && copyHDGrades(HeatInfo, SteelGrade, false);

  RetValue = RetValue && copyHDSamples(HeatInfo, CSMC_DBData::unspecLong, false);

  return RetValue;
}

bool CDM_DBManager::copyHDTapchData(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDTapchData",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHD_TAPCH_DATA m_HDTapchData(m_pDM_DBManagerTask->getStdConnection());

    RetValue = RetValue && m_HDTapchData.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);

    if ( !RetValue)
    {
      checkLastError();
      setLastError("ERROR_ON_TAP_CHANGE_DEFINITION", 0, m_HDTapchData.getActStatement() );
    }

  }

  return RetValue;
}

bool CDM_DBManager::copyHDTreatmode(sHeatInfo &HeatInfo, const std::string &OrderId, long &pTreatModeNo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDTreatmode",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHD_TREATMODE         HD_TREATMODE        (m_pDM_DBManagerTask->getStdConnection());
    CHD_TREATMODE_ENTRY   HD_TREATMODE_ENTRY  (m_pDM_DBManagerTask->getStdConnection());

    RetValue = RetValue && HD_TREATMODE.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, pTreatModeNo, Commit, m_lastError);
    RetValue = RetValue && HD_TREATMODE_ENTRY.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, pTreatModeNo,Commit, m_lastError); 

    if ( !RetValue)
    {
      setLastError("ERROR_ON_TREATMODE_DEFINITION", 0, HD_TREATMODE.getActStatement() );
    }

  }

  return RetValue;
}

bool CDM_DBManager::copyHDWastegasCyclMeasData(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::copyHDWastegasCyclMeasData",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHD_WASTEGAS_CYCL_MEAS_DATA m_HDWastegasCyclMeasData(m_pDM_DBManagerTask->getStdConnection());

    RetValue = RetValue && m_HDWastegasCyclMeasData.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, Commit, m_lastError); 
  }

  return RetValue;
}

//Entry new Sample Analysis
bool CDM_DBManager::addSampleAnalysis(sHeatInfo &HeatInfo, seqAnalysis& SeqAnalysis, long LadleNo, const std::string& LadleType, CDateTime SampleTime, long SampleType, long SampleNo, long SampleMode, long SampleOrigin, const std::string& SampleLocation, long& SampleRef, long& SampleCounter, const std::string& SampleId, const std::string& OrderId, bool OverWriteSampleTime, const std::string& User, bool Commit)
{
  log("++++++ CDM_DBManager::addSampleAnalysis",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  if (RetValue)
  {
    CPD_SAMPLE        PD_SAMPLE       (m_pDM_DBManagerTask->getStdConnection());
    CPD_SAMPLE_ENTRY  PD_SAMPLE_ENTRY (m_pDM_DBManagerTask->getStdConnection());
    CPD_SAMPLE_REF    PD_SAMPLE_REF   (m_pDM_DBManagerTask->getStdConnection());

    long SampleUsable     = 1;
    bool updateSampleNo   = false;

    SampleMode   = CDataConversion::SetInvalidToDefault(SampleMode, DEF_GC_SAMPLEMODE::automatic);
    SampleOrigin = CDataConversion::SetInvalidToDefault(SampleOrigin,DEF_GC_MEASUREMENT_ORIGIN::Measured);//SampleMode SARS

    CDM_ProductManagementInterface_Impl *dataProvider = m_pDM_DBManagerTask->getpProductManagementInterface();
    double DurSinceA = dataProvider->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatAnnounce);
    double DurSinceS = dataProvider->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatStart);

    CDateTime Now;
    CDateTime RecTimeLab;

    if ( SampleRef == CSMC_DBData::unspecLong || !PD_SAMPLE_REF.select(SampleRef))
    {
      SampleRef = PD_SAMPLE_REF.insertNewSAMPLE_REF(Commit,m_lastError);
    }

    // analysis may be an update for already used sample (sample has analysis/sample data)
    if ( SampleType != DEF::Inv_Long && 
         SampleNo   != DEF::Inv_Long &&  
         PD_SAMPLE.selectUsedHeatSample(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, SampleType, SampleNo) )
    {
      SampleCounter = PD_SAMPLE.getSAMPLE_COUNTER(1);
    }
    // analysis cannot be associated
    // find youngest usable heat sample that has no analysis (sample taken)
    else if ( SampleType != DEF::Inv_Long && 
              PD_SAMPLE.selectLastSampleWithoutAnalysis(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, SampleType) )
    {
      // there is only one attempt to find the oldest sample without sample data
      SampleCounter = PD_SAMPLE.getSAMPLE_COUNTER(1); 

      // update of sampleno is required now.
      updateSampleNo  = true;
    }
    // try to identify existing Sample data first
    // analysis must be added to existing sample
    else if ( SampleType != DEF::Inv_Long && 
              SampleNo   != DEF::Inv_Long &&  
              PD_SAMPLE.selectUsableHeatSample(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, SampleType, SampleNo) )
    {
      SampleCounter = PD_SAMPLE.getSAMPLE_COUNTER(1);
    }

    // regard equivalences for further usage !
    // SeqAnalysis given as reference will be updated by equivalence data
    handleEquivalences(HeatInfo,SeqAnalysis);

    // no SampleCounter found, so analysis is "stand alone" withou any sample taken
    if ( SampleCounter == CSMC_DBData::unspecLong )
    {
      // receive next Sample_Counter fur further use.
      SampleCounter = PD_SAMPLE.insertAnalysis(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, SampleOrigin,
                                                     SampleType, SampleNo, SeqAnalysis, Commit, m_lastError);
      SampleUsable    = 2;
    }
    else
    {
      // update existing sample 
      PD_SAMPLE.updateAnalysis(SampleCounter, SeqAnalysis, Commit, m_lastError);
    }

    if ( SampleCounter != CSMC_DBData::unspecLong )
    {
      // most relevant action was successful !
      RetValue = true;

      // update methods do not perform commit statement !
      if ( PD_SAMPLE.updateSampleDetails(SampleCounter, OrderId, SampleMode,SampleLocation, SampleUsable, User, SampleId, SampleOrigin)  && 
           PD_SAMPLE.updateSampleTimes(SampleCounter,SampleTime,Now,RecTimeLab,DurSinceA,DurSinceS, OverWriteSampleTime)     )
      {
        // update sample no if required
        if ( updateSampleNo )
        {
          PD_SAMPLE.updateSampleDetails(SampleCounter,SampleNo);
        }

        // now update references in PD_SAMPLE_REF
        // for Steel Sample, update PD_SAMPLE_REF.STEEL, a.s.o.
        RetValue = RetValue && PD_SAMPLE_REF.writeSAMPLE_REF(SampleRef,SampleCounter,SampleType, Commit, m_lastError);

        // set internal heatid and treatid at PD_SAMPLE !!!
        RetValue = RetValue && PD_SAMPLE.updateSampleHeatData(SampleCounter,HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, m_lastError);
      }
      else
      {
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_DBWriteError(sMessage, "" , "PD_SAMPLE", "update failure");
      }
    }
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::addSampleAnalysisAndTemp(sHeatInfo &HeatInfo, double MeasValue, seqAnalysis &SeqAnalysis, long LadleNo, const std::string& LadleType, CDateTime SampleTime, long SampleType, long SampleNo, long SampleMode, long SampleOrigin, const std::string& SampleLocation, long& SampleRef, long& SampleCounter, const std::string& SampleId, const std::string& OrderId, bool OverWriteSampleTime, const std::string& User, bool Commit)
{
  log("++++++ CDM_DBManager::addSampleAnalysisAndTemp",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  if (RetValue)
  {
    CPD_SAMPLE        PD_SAMPLE(m_pDM_DBManagerTask->getStdConnection());

    CDM_ProductManagementInterface_Impl *dataProvider = m_pDM_DBManagerTask->getpProductManagementInterface();
    double DurSinceA = dataProvider->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatAnnounce);
    double DurSinceS = dataProvider->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatStart);

    CDateTime Now;

    long SampleCounter = PD_SAMPLE.insertAnalysis(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, SampleOrigin, SampleType, SampleNo, SeqAnalysis, Commit, m_lastError  );

    if ( SampleCounter != CSMC_DBData::unspecLong )
    {
      seqSample ActSample;
      CSMC_DataProvider_Impl::insertSampleValue(ActSample, DEF_GC_MEASUREMENT_NAME::Temp, MeasValue);

      RetValue = RetValue && PD_SAMPLE.updateSampleDetails(SampleCounter, OrderId, SampleMode, SampleLocation, 1, User, SampleId, SampleOrigin );
      RetValue = RetValue && PD_SAMPLE.updateSampleTimes(SampleCounter, SampleTime, Now, CSMC_DBData::unspecDate , DurSinceA, DurSinceS, OverWriteSampleTime);

      RetValue = RetValue && PD_SAMPLE.updateSample(SampleCounter, ActSample, Commit, m_lastError );
    }

  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::addSampleAndTemp(sHeatInfo &HeatInfo, double MeasValue, long LadleNo, const std::string& LadleType, CDateTime SampleTime, long SampleType, long SampleNo, long SampleMode, long SampleOrigin, const std::string& SampleLocation, long& SampleCounter, const std::string& SampleId, const std::string& OrderId, bool OverWriteSampleTime, const std::string& User, bool Commit)
{
  log("++++++ CDM_DBManager::addSampleAndTemp",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  if (RetValue)
  {
    CPD_SAMPLE        PD_SAMPLE(m_pDM_DBManagerTask->getStdConnection());

    CDM_ProductManagementInterface_Impl *dataProvider = m_pDM_DBManagerTask->getpProductManagementInterface();
    double DurSinceA = dataProvider->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatAnnounce);
    double DurSinceS = dataProvider->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatStart);

    CDateTime Now;

    seqSample ActSample;
    CSMC_DataProvider_Impl::insertSampleValue(ActSample, DEF_GC_MEASUREMENT_NAME::Temp, MeasValue);

    long SampleCounter = PD_SAMPLE.insertSample(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, SampleOrigin, SampleType, SampleNo, ActSample, Commit, m_lastError  );

    if ( SampleCounter != CSMC_DBData::unspecLong )
    {

      RetValue = RetValue && PD_SAMPLE.updateSampleDetails(SampleCounter, OrderId, SampleMode, SampleLocation, 1, User, SampleId, SampleOrigin );
      RetValue = RetValue && PD_SAMPLE.updateSampleTimes(SampleCounter, SampleTime, Now, CSMC_DBData::unspecDate , DurSinceA, DurSinceS, OverWriteSampleTime);
    }
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::addSampleAnalysisRef(sHeatInfo &HeatInfo, const std::string &UserCode, sPDData &PDData, long &SampleRef, bool Commit)
{
  log("++++++ CDM_DBManager::addSampleAnalysisRef",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_SAMPLE_REF        PD_SAMPLE_REF       (m_pDM_DBManagerTask->getStdConnection());

    std::string LadleType = ""; //auxilary variable used for getLadle method
    long SAMPLE_COUNTER = CSMC_DBData::unspecLong;

    //Check if Sample change
    if ( PDData.SteelAnalysis.length() > 0 )
    {
      log("++++++ CDM_DBManager::addSampleAnalysisRef: addSteelSample", 4);
      // only pretreatdata sample
      SAMPLE_COUNTER = PD_SAMPLE_REF.getSampleCounter(PDData.SampleRef,DEF_GC_MEASUREMENT_TYPE::Steel);      
  
      //Add Steel Analysis
      RetValue = RetValue && addSampleAnalysis(HeatInfo, PDData.SteelAnalysis, PDData.LadleNo, PDData.LadleType, PDData.SteelSampleTime, DEF_GC_MEASUREMENT_TYPE::Steel, PDData.SampleNo, PDData.SampleMode, PDData.SampleOrigin, PDData.SampleLocation, SampleRef, SAMPLE_COUNTER, CSMC_DBData::unspecString, CSMC_DBData::unspecString, PDData.OverWriteSampleTime, UserCode, Commit);
    }

    //Check if Temperature change
    if (  PDData.Temp != DEF::Inv_Double )
    {
      log("++++++ CDM_DBManager::addSampleAnalysisRef: addTempValue", 4);
      // only pretreatdata sample
      SAMPLE_COUNTER = PD_SAMPLE_REF.getSampleCounter(PDData.SampleRef,DEF_GC_MEASUREMENT_TYPE::Temp);      

      //Add Temp
      RetValue = RetValue && addSampleValue(HeatInfo, PDData.Temp, DEF_GC_MEASUREMENT_NAME::Temp, PDData.LadleNo, PDData.LadleType, PDData.TempTime, DEF_GC_MEASUREMENT_TYPE::Temp, PDData.SampleNo, PDData.SampleMode, PDData.SampleOrigin, PDData.SampleLocation, SampleRef, SAMPLE_COUNTER, CSMC_DBData::unspecString, CSMC_DBData::unspecString, PDData.OverWriteSampleTime, UserCode, Commit);
    }

    // check if slag sample is set
    if ( PDData.SlagAnalysis.length() > 0 )
    {
      log("++++++ CDM_DBManager::addSampleAnalysisRef: addSlagSample", 4);
      // only pretreatdata sample
      SAMPLE_COUNTER = PD_SAMPLE_REF.getSampleCounter(PDData.SampleRef,DEF_GC_MEASUREMENT_TYPE::Slag);      

      //Add Slag Analysis
      RetValue = RetValue && addSampleAnalysis(HeatInfo, PDData.SlagAnalysis, PDData.LadleNo, PDData.LadleType, PDData.SlagSampleTime, DEF_GC_MEASUREMENT_TYPE::Slag, PDData.SampleNo, PDData.SampleMode, PDData.SampleOrigin, PDData.SampleLocation, SampleRef, SAMPLE_COUNTER, CSMC_DBData::unspecString, CSMC_DBData::unspecString, PDData.OverWriteSampleTime, UserCode, Commit);
    }
  }

  return RetValue;
}

bool CDM_DBManager::addSampleValue(sHeatInfo &HeatInfo, double MeasValue, const std::string& MeasName, long LadleNo, const std::string& LadleType, CDateTime SampleTime, long SampleType, long SampleNo, long SampleMode, long SampleOrigin, const std::string& SampleLocation, long& SampleRef, long& SampleCounter, const std::string& SampleId, const std::string& OrderId, bool OverWriteSampleTime, const std::string& User, bool Commit)
{
  log("++++++ CDM_DBManager::addSampleValue",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_SAMPLE        PD_SAMPLE     (m_pDM_DBManagerTask->getStdConnection());
    CPD_SAMPLE_REF    PD_SAMPLE_REF (m_pDM_DBManagerTask->getStdConnection());

    seqSample ActSample;
    
    CSMC_DataProvider_Impl::insertSampleValue(ActSample, MeasName, MeasValue);

    CDM_ProductManagementInterface_Impl *dataProvider = m_pDM_DBManagerTask->getpProductManagementInterface();
    double DurSinceA = dataProvider->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatAnnounce);
    double DurSinceS = dataProvider->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatStart);

    CDateTime Now;

    // analysis may be an update for already used sample (sample has analysis/sample data)
    if ( SampleType != DEF::Inv_Long && 
         SampleNo   != DEF::Inv_Long &&  
         PD_SAMPLE.selectUsedHeatSample(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, SampleType, SampleNo) )
    {
      SampleCounter = PD_SAMPLE.getSAMPLE_COUNTER(1);
    }
    // analysis cannot be associated
    // find youngest usable heat sample that has no analysis
    else if ( SampleType != DEF::Inv_Long && 
              PD_SAMPLE.selectLastSampleWithoutAnalysis(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, SampleType) )
    {
      // there is only one attempt to find the oldest sample without sample data
      SampleCounter = PD_SAMPLE.getSAMPLE_COUNTER(1); 

    }
    // try to identify existing Sample data first
    // analysis must be added to existing sample
    else if ( SampleType != DEF::Inv_Long && 
              SampleNo   != DEF::Inv_Long &&  
              PD_SAMPLE.selectUsableHeatSample(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, SampleType, SampleNo) )
    {
      SampleCounter = PD_SAMPLE.getSAMPLE_COUNTER(1);
    }


    if ( SampleRef == CSMC_DBData::unspecLong || !PD_SAMPLE_REF.select(SampleRef))
    {
      SampleRef = PD_SAMPLE_REF.insertNewSAMPLE_REF(Commit,m_lastError);
    }

    // no SampleCounter found, so analysis is "stand alone" withou any sample taken
    if ( SampleCounter == CSMC_DBData::unspecLong )
    {
      // receive next Sample_Counter fur further use.
      SampleCounter = PD_SAMPLE.insertSample(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, SampleOrigin, SampleType, SampleNo, ActSample, Commit, m_lastError );
    }
    else
    {
      // update existing sample 
      PD_SAMPLE.updateSample(SampleCounter, ActSample, Commit, m_lastError);
    }

    if ( SampleCounter != CSMC_DBData::unspecLong )
    {
      RetValue = RetValue && PD_SAMPLE.updateSampleDetails(SampleCounter, OrderId, SampleMode, SampleLocation, 1, User, SampleId, SampleOrigin );
      RetValue = RetValue && PD_SAMPLE.updateSampleTimes(SampleCounter, SampleTime, Now, CSMC_DBData::unspecDate, DurSinceA, DurSinceS, OverWriteSampleTime);

      // now update references in PD_SAMPLE_REF
      RetValue = RetValue && PD_SAMPLE_REF.writeSAMPLE_REF(SampleRef, SampleCounter, SampleType, Commit, m_lastError);

      // set internal heatid and treatid at PD_SAMPLE !!!
      RetValue = RetValue && PD_SAMPLE.updateSampleHeatData(SampleCounter,HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, m_lastError);
    }
  }

  checkLastError();

  return RetValue;
}


bool CDM_DBManager::addAnalysisHotMetal(sHeatInfo &HeatInfo, const std::string &ProdOrderId, sPDData &PDData, long HotMetalCounter, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_DBManager::addAnalysisHotMetal",3);

  // ===================================================================================
  // Store analysis if received
  // A sample counter in pd_sample will be created
  // In case of invalid sample reference new one will be returned
  // ===================================================================================

  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();

  bool result = (m_pDM_DBManagerTask != NULL);
  if (result)
  {
    // ===================================================================================
    // If analysis is received
    // ===================================================================================
    if ( PDData.HMAnalysis.length() > 0 )
    {
      CPD_SAMPLE_REF  PD_SAMPLE_REF (m_pDM_DBManagerTask->getStdConnection());
      CPD_SAMPLE      PD_SAMPLE     (m_pDM_DBManagerTask->getStdConnection());

      long SampleCounterHotMetal  = -1;
      CDateTime Now; // to set rectime lab

      SampleCounterHotMetal = PD_SAMPLE.insertAnalysis(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, PDData.SampleOrigin, DEF_GC_MEASUREMENT_TYPE::HM, PDData.SampleNo, PDData.HMAnalysis, Commit, m_lastError);
      if ( SampleCounterHotMetal == CSMC_DBData::unspecLong )
      {
        SampleCounterHotMetal = -1;
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_DBWriteError(sMessage, "", "PD_SAMPLE", PD_SAMPLE.getActStatement().c_str());

        result = false;
      }
      else
      {
        // get max hot metal sample no of a hot metal to increase by 1
        long HMSampleNo = 1;
        if ( HotMetalCounter != DEF::Inv_Long && !CDataConversion::LongToString(HotMetalCounter).empty() )
        {
          HMSampleNo = PD_SAMPLE.getHighestHMSampleNo(CDataConversion::LongToString(HotMetalCounter));
          if ( HMSampleNo != CSMC_DBData::unspecLong )
          {
            // increase by 1
            HMSampleNo = HMSampleNo + 1;
          }
          else
          {
            HMSampleNo = 1;
          }
        }

        // update some more details
        if ( PD_SAMPLE.select(SampleCounterHotMetal) )
        {
          PD_SAMPLE.setPRODORDERID(ProdOrderId);
          PD_SAMPLE.setSAMPLETIME(PDData.HMSampleTime);
          PD_SAMPLE.setRECTIMELAB(Now);

          if ( checkLadleData(PDData.LadleNo, PDData.LadleType, "", "UNKNOWN_HOT_METAL_LADLE") )
          {
            PD_SAMPLE.setLADLENO(PDData.LadleNo);
            PD_SAMPLE.setLADLETYPE(PDData.LadleType);
          }

          PD_SAMPLE.setSAMPLENO(HMSampleNo);
          PD_SAMPLE.setHM_ID(CDataConversion::LongToString(HotMetalCounter));

          result = result && PD_SAMPLE.update();
        }
      }

      if ( !result )
      {
        m_lastError = PD_SAMPLE.getLastError();
      }

      // check and maybe get next sample ref only if necessary
      if ( result )
      {
        if ( PDData.SampleRef == DEF::Inv_Long || !PD_SAMPLE_REF.select(PDData.SampleRef) )
        {
          log("Create new sample_ref to set temperature sample counter!", 3);

          PDData.SampleRef = PD_SAMPLE_REF.insertNewSAMPLE_REF(Commit, m_lastError);
          if ( PDData.SampleRef == CSMC_DBData::unspecLong )
          {
            result = false;
          }
        }

        if ( SampleCounterHotMetal > -1 )
          result = result && PD_SAMPLE_REF.updateSAMPLE_REF(PDData.SampleRef, SampleCounterHotMetal, DEF_GC_MEASUREMENT_TYPE::HM, Commit, m_lastError);
      }
    }//if ( PDData.HMAnalysis.length() > 0 )
  }

  checkLastError();

  return result;
}


bool CDM_DBManager::addTemperatureHotMetal(sHeatInfo &HeatInfo, const std::string &ProdOrderId, sPDData &PDData, long HotMetalCounter, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_DBManager::addTemperatureHotMetal",3);

  // ===================================================================================
  // Store temperature if value is valid
  // A sample counter in pd_sample will be created
  // In case of invalid sample_ref new one will be returned
  // ===================================================================================

  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();

  bool result = (m_pDM_DBManagerTask != NULL);
  if (result)
  {
    // ===================================================================================
    // If temperature is received
    // ===================================================================================
    if ( PDData.Temp != DEF::Inv_Double )
    {
      CPD_SAMPLE_REF  PD_SAMPLE_REF (m_pDM_DBManagerTask->getStdConnection());
      CPD_SAMPLE      PD_SAMPLE     (m_pDM_DBManagerTask->getStdConnection());

      long SampleCounterTemp = -1;
      //CDateTime Now;

      seqSample SeqSample;
      sSample SampleDetail;
      SampleDetail.MeasName   = DEF_GC_MEASUREMENT_NAME::Temp.c_str();
      SampleDetail.MeasValue  = PDData.Temp;
      CIntfData::insert(SeqSample,SampleDetail);
      SampleCounterTemp = PD_SAMPLE.insertSample(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, PDData.SampleOrigin, DEF_GC_MEASUREMENT_TYPE::HM, PDData.SampleNo, SeqSample, Commit, m_lastError);
      if ( SampleCounterTemp == CSMC_DBData::unspecLong )
      {
        SampleCounterTemp = -1;
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_DBWriteError(sMessage, "", "PD_SAMPLE", PD_SAMPLE.getActStatement().c_str());

        result = false;
      }
      else
      {
        // get max hot metal sample no of a hot metal to increase by 1
        long HMSampleNo = 1;
        if ( HotMetalCounter != DEF::Inv_Long && !CDataConversion::LongToString(HotMetalCounter).empty() )
        {
          HMSampleNo = PD_SAMPLE.getHighestHMSampleNo(CDataConversion::LongToString(HotMetalCounter));
          if ( HMSampleNo != CSMC_DBData::unspecLong )
          {
            // increase by 1
            HMSampleNo = HMSampleNo + 1;
          }
          else
          {
            HMSampleNo = 1;
          }
        }

        if ( PD_SAMPLE.select(SampleCounterTemp) )
        {
          PD_SAMPLE.setPRODORDERID(ProdOrderId);
          PD_SAMPLE.setSAMPLETIME(PDData.TempTime);

          if ( checkLadleData(PDData.LadleNo, PDData.LadleType, "", "UNKNOWN_HOT_METAL_LADLE") )
          {
            PD_SAMPLE.setLADLENO(PDData.LadleNo);
            PD_SAMPLE.setLADLETYPE(PDData.LadleType);
          }

          PD_SAMPLE.setSAMPLENO(HMSampleNo);
          PD_SAMPLE.setHM_ID(CDataConversion::LongToString(HotMetalCounter));

          result = result && PD_SAMPLE.update();
        }
      }

      if ( !result )
      {
        m_lastError = PD_SAMPLE.getLastError();
      }

      // check and maybe get next sample ref only if necessary
      if ( result )
      {
        if ( PDData.SampleRef == DEF::Inv_Long || 
             !PD_SAMPLE_REF.select(PDData.SampleRef) )
        {
          log("Create new sample_ref to set temperature sample counter!", 3);

          PDData.SampleRef = PD_SAMPLE_REF.insertNewSAMPLE_REF(Commit, m_lastError);
          if ( PDData.SampleRef == CSMC_DBData::unspecLong )
          {
            result = false;
          }
        }

        if ( SampleCounterTemp > -1 )
        {
          result = result && PD_SAMPLE_REF.updateSAMPLE_REF(PDData.SampleRef, SampleCounterTemp, DEF_GC_MEASUREMENT_TYPE::Temp, Commit, m_lastError);
        }
      }

    }// if ( PDData.Temp != DEF::Inv_Double )
  }

  checkLastError();

  return result;
}

bool CDM_DBManager::handleEquivalences(sHeatInfo &HeatInfo, seqAnalysis & SeqAnalysis)
{
  bool result = (m_pDM_DBManagerTask != NULL);
  if (result)
  {
    CPD_HEAT_DATA PD_HEAT_DATA  (m_pDM_DBManagerTask->getStdConnection());
    CHD_GRADE_ANL HD_GRADE_ANL  (m_pDM_DBManagerTask->getStdConnection());
    CGT_EQUIV     GT_EQUIV      (m_pDM_DBManagerTask->getStdConnection());

    std::string STEELGRADECODE_ACT;

    // ***************************************************
    // select some PD and PP Data first
    // ***************************************************
    if ( PD_HEAT_DATA.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant) )
    {
      STEELGRADECODE_ACT  = PD_HEAT_DATA.getSTEELGRADECODE_ACT(1);
    }

    //  get list of elements from HD_GRADE_ANL
    //std::set<std::string> ENAMEList = HD_GRADE_ANL.getENAMEList(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,STEELGRADECODE_ACT,CSMC_DBData::unspecString, DEF_GC_MEASUREMENT_NAME_SCOPE::Equiv);
    std::set<std::string> ENAMEList = GT_EQUIV.getEQUIVList();
    std::set<std::string>::iterator it;

    for( it = ENAMEList.begin(); it != ENAMEList.end(); ++it )
    {
      std::string ENAME = *it;

      // is there an equivalence defined for this element?
      double EquivValue = GT_EQUIV.getEquivValue(ENAME, SeqAnalysis);

      // update SeqAnalysis if valid value is detected
      if ( EquivValue != CSMC_DBData::unspecDouble )
      {
        sAnalysis   Analysis;
        seqAnalysis SeqAnalysisSource;
        sAnalysis   AnalysisSource;
        
        AnalysisSource.Element        = ENAME.c_str();
        AnalysisSource.Concentration  = EquivValue;

        CIntfData::insert(SeqAnalysisSource,AnalysisSource);

        UPDATE_SEQ(&SeqAnalysisSource,AnalysisSource,&SeqAnalysis,Analysis,Element,std::string);
      }
    }
  }

  return result;
}



bool CDM_DBManager::changeHotHeelData(sHeatInfo &HeatInfo, long& sampleRef, double SteelMass, double SlagMass, bool Commit)
{
  log("++++++ CDM_DBManager::changeHotHeelData",3);

  bool RetValue  = true;
  CPD_HOTHEEL     PD_HOTHEEL    (m_pDM_DBManagerTask->getStdConnection());

  RetValue = RetValue && PD_HOTHEEL.write(HeatInfo.Plant,HeatInfo.PlantNo,HeatInfo.HeatId,HeatInfo.TreatId,sampleRef,SteelMass,SlagMass,Commit,m_lastError);

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::checkLadleData(long LadleNo, const std::string& LadleType, const std::string& HMIClientId, const std::string& ERROR_MESSAGE )
{
  log("++++++ CDM_DBManager::checkLadleData",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  RetValue = RetValue && (m_pDM_DBManagerTask->getStdConnection() != NULL);

  if (RetValue)
  {
    // invalid data may not be checked againt GC table -> we will proceed with programm
    // this will force setting database field to NULL in most cases

    if ( LadleType == CSMC_DBData::unspecString || 
         LadleNo   == CSMC_DBData::unspecLong )
    {
      setLastError(ERROR_MESSAGE, 5001, "", 1);

      RetValue = true;
    }
    else
    {
      CGC_Ladle_Def_Container GC_Ladle_Def_Container(m_pDM_DBManagerTask->getStdConnection());

      if ( !GC_Ladle_Def_Container.isValidLadle(LadleNo, LadleType) )
      {
        std::string Error = ERROR_MESSAGE + " " + LadleType + CDataConversion::LongToString(LadleNo);

        setLastError(Error, 5002, "", 1);

        RetValue = false;
      }
    }
  }

  return RetValue;
}

bool CDM_DBManager::checkContainerData(long ContainerNo, const std::string& ContainerType, const std::string& HMIClientId, const std::string& ERROR_MESSAGE )
{
  log("++++++ CDM_DBManager::checkContainerData",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  RetValue = RetValue && (m_pDM_DBManagerTask->getStdConnection() != NULL);

  if (RetValue)
  {
    // invalid data have to checked againt GC table -> we will not proceed with programm
    // this will force setting database field to NULL in most cases but ContainerNo and ContainerType are PK
    if ( ContainerType == CSMC_DBData::unspecString || 
         ContainerNo   == CSMC_DBData::unspecLong )
    {
      setLastError(ERROR_MESSAGE, 5001, "", 1);

      RetValue = false;
    }
    else
    {
      CGC_SCRAP_CONTAINER GC_SCRAP_CONTAINER(m_pDM_DBManagerTask->getStdConnection());

      if ( !GC_SCRAP_CONTAINER.isValidContainer(ContainerNo, ContainerType) )
      {
        std::string Error = ERROR_MESSAGE + " " + ContainerType + CDataConversion::LongToString(ContainerNo);

        setLastError(Error, 5002, "", 1);

        RetValue = false;
      }
    }
  }

  return RetValue;
}

bool CDM_DBManager::getActSteelGrade(sHeatInfo &HeatInfo, std::string &SteelGrade)
{
  log("++++++ CDM_DBManager::getActSteelGrade",3);

  CPD_HEAT_DATA PD_HEAT_DATA  (m_pDM_DBManagerTask->getStdConnection());
  CPP_ORDER     PP_ORDER      (m_pDM_DBManagerTask->getStdConnection()); 

  //Get Steelgrade
  if (PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant)) //From PD_HEAT_DATA first
  {
    SteelGrade = PD_HEAT_DATA.getSTEELGRADECODE_ACT(1);
  }
  if (SteelGrade.empty())
  {
    //Than PP_ORDER
    if (PP_ORDER.selectUseHeatId(HeatInfo.HeatId))
    {
      SteelGrade = PP_ORDER.getSTEELGRADECODE(1);
    }
  }

  if (SteelGrade.empty()) //if SteeGrade is empty set Last Error
  {
    setLastError("NO_STEEL_GRADE_FOUND", 0, PD_HEAT_DATA.getActStatement() + " " +  PP_ORDER.getActStatement(), 1); 
  }

  return !SteelGrade.empty();
}

bool CDM_DBManager::getAimTemperature(const std::string& PLANT, const std::string& OrderId, long& AimTemp)
{
  log("++++++ CDM_DBManager::getAimTemperature",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  RetValue = RetValue && (m_pDM_DBManagerTask->getStdConnection() != NULL);
  if (RetValue)
  {
    CPP_ORDER_SINGLE_AIMS PP_ORDER_SINGLE_AIMS(m_pDM_DBManagerTask->getStdConnection());

    if(PP_ORDER_SINGLE_AIMS.select(OrderId, PLANT, 1, DEF_GC_PP_ORDER_SINGLE_AIMS::AIMTEMP))
    {
      AimTemp = CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1));
      RetValue = true;
    }
    else
    {
      setLastError("NO_AIM_TEMPERATURE_DEFINED", 0, PP_ORDER_SINGLE_AIMS.getActStatement(), 1);
      RetValue = false;
    }
  }

  return RetValue;
}

bool CDM_DBManager::getAimWeight(const std::string& PLANT, const std::string& OrderId, long& AimWeight)
{
  log("++++++ CDM_DBManager::getAimWeight",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  RetValue = RetValue && (m_pDM_DBManagerTask->getStdConnection() != NULL);
  if (RetValue)
  {
    CPP_ORDER_SINGLE_AIMS PP_ORDER_SINGLE_AIMS(m_pDM_DBManagerTask->getStdConnection());

    if(PP_ORDER_SINGLE_AIMS.select(OrderId, PLANT, 1, DEF_GC_PP_ORDER_SINGLE_AIMS::AIMSTEEL))
    {
      AimWeight = CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1));
      RetValue = true;
    }
    else
    {
      setLastError("NO_AIM_WEIGHT_DEFINED ORDER_ID_ERROR " + OrderId, 0, PP_ORDER_SINGLE_AIMS.getActStatement(), 1);
      RetValue = false;
    }
  }

  return RetValue;
}

// obsolete
bool CDM_DBManager::getConstraintTran(std::string &pTranslation)
{
  log("++++++ CDM_DBManager::getConstraintTran",3);

  pTranslation.clear();
  if (m_pDM_DBManagerTask != NULL)
  {
    std::string constraint;

    //extract the constraint name from the ORA error
    // like "L2SMC.FK_PD_HEATDATA_PD_LADLE"
    std::string::size_type iposS = m_lastError.m_MessageText.find("(") + 1; 
    std::string::size_type iposE = m_lastError.m_MessageText.find(")");
    if (iposS != std::string::npos && iposE != std::string::npos)
      constraint = m_lastError.m_MessageText.substr(iposS, iposE-iposS);  

    // now cut "L2SMC."
    std::string::size_type Dot = constraint.find(".");
    if (Dot != std::string::npos)
      constraint = constraint.substr(Dot +1);

    //if the constraint was found try to get the translation for it
    if (!constraint.empty())
    {
      if (m_pGCC_TRANSLATE_VALUE->select(constraint, m_TranslationLang))
        pTranslation = m_pGCC_TRANSLATE_VALUE->getTEXT(1);
    }
  }
  return !pTranslation.empty();
}

bool CDM_DBManager::getTranslation(CSMC_Error * pSMC_Error)
{
  bool RetValue = false; 

  log("++++++ CDM_DBManager::getTranslation",3);

  if (m_pDM_DBManagerTask != NULL)
  {
    // iteration for pSMC_Error->m_MessageText to find text elements that can be translated
    // message text could contain several items to be translated !

    std::vector<std::string> List;
    std::vector<std::string>::iterator it;

    std::string ActValue = pSMC_Error->m_MessageText;

    while (!ActValue.empty())
    {
      std::string ActSubstr = ActValue;

      std::basic_string <char>::size_type pos = ActValue.find(" ");

      if ( std::string::npos != pos )
      {
        ActSubstr = ActValue.substr(0,pos );
        ActValue = ActValue.substr(pos+1,ActValue.length());
      }
      else
      {
        ActValue.erase();
      }
      
      // cut off "(" and ")" if part of substring
      ActSubstr = CDataConversion::Trim(ActSubstr, "(");
      ActSubstr = CDataConversion::Trim(ActSubstr, ")");

      // trim ActValue
      ActSubstr = CDataConversion::Trim(ActSubstr, " ");

      if (m_pGCC_TRANSLATE_VALUE->select(ActSubstr, m_TranslationLang))
      {
        List.push_back( m_pGCC_TRANSLATE_VALUE->getTEXT(1) );
        RetValue = true; 
      }
      else
      {
        List.push_back( ActSubstr );
      }
    }

    ActValue.erase();

    for ( it = List.begin(); it != List.end(); ++it )
    {

      ActValue += (*it) + " ";
    }

    pSMC_Error->m_MessageText = ActValue;
  }

  return RetValue;
}


//get Ladle information from PD_HEAT_DATA_LIQADD table
bool CDM_DBManager::getLadleFromLiqAdd(sHeatInfo &HeatInfo, long LiqAddNo, long &LadleNo, std::string &LadleType)
{
  log("++++++ CDM_DBManager::getLadleFromLiqAdd",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_HEAT_DATA_LIQADD PD_HEAT_DATA_LIQADD(m_pDM_DBManagerTask->getStdConnection());
    RetValue = PD_HEAT_DATA_LIQADD.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, LiqAddNo);
    if (RetValue)
    {
      LadleNo = PD_HEAT_DATA_LIQADD.getLADLENO(1);
      LadleType = PD_HEAT_DATA_LIQADD.getLADLETYPE(1);
    }
  }
  return RetValue;
}

//get Ladle information from PD_PRETREATDATA table
bool CDM_DBManager::getLadleFromPretreat(long PretreatCounter, long &LadleNo, std::string &LadleType)
{
  log("++++++ CDM_DBManager::getLadleFromPretreat",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_PRETREATDATA PD_PRETREATDATA(m_pDM_DBManagerTask->getStdConnection());
    RetValue = PD_PRETREATDATA.select(PretreatCounter);
    if (RetValue)
    {
      LadleNo   = PD_PRETREATDATA.getLADLENO(1);
      LadleType = PD_PRETREATDATA.getLADLETYPE(1);
    }
  }
  return RetValue;
}

bool CDM_DBManager::getLiqAddAmount(const std::string& PLANT, const std::string& OrderId, long& LiqAddAmount, long& Fraction)
{
  log("++++++ CDM_DBManager::getLiqAddAmount(const std::string& PLANT, const std::string& OrderId, long& LiqAddAmount, long& Fraction)",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  RetValue = RetValue && (m_pDM_DBManagerTask->getStdConnection() != NULL);

  if (RetValue)
  {
    CPP_ORDER_SINGLE_AIMS PP_ORDER_SINGLE_AIMS(m_pDM_DBManagerTask->getStdConnection());

    if ( PP_ORDER_SINGLE_AIMS.select(OrderId, PLANT, 1, DEF_GC_PP_ORDER_SINGLE_AIMS::LIQADD) )
    {
      LiqAddAmount = CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1));
    }
    else
    {
      LiqAddAmount = CSMC_DBData::unspecLong;
    }

    long AimSteel = CSMC_DBData::unspecLong ;

    if ( PP_ORDER_SINGLE_AIMS.select(OrderId, PLANT, 1, DEF_GC_PP_ORDER_SINGLE_AIMS::AIMSTEEL) )
    {
      AimSteel = CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1));
    }

    if( AimSteel     != 0 && 
        AimSteel     != CSMC_DBData::unspecLong && 
        LiqAddAmount != CSMC_DBData::unspecLong )
    {
      Fraction = long( double(LiqAddAmount)/double(AimSteel) * 100.);
    }
    else
    {
      Fraction = 0;
    }
  }
  return RetValue;
}

bool CDM_DBManager::getOrderByHeat(sHeatInfo &HeatInfo, std::string &Order)
{
  bool RetValue = true;

  CPD_HEAT_DATA   PD_HEAT_DATA    (m_pDM_DBManagerTask->getStdConnection());

  //Get Order from PD_HEAT_DATA first
  if ( PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant) )
  {
    Order = PD_HEAT_DATA.getPRODORDERID_ACT(1);
  }

  if ( Order.empty() || Order == CSMC_DBData::unspecString )
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DBReadError(sMessage, "PRODORDERID_ACT", "PD_HEAT_DATA", PD_HEAT_DATA.getActStatement().c_str());
  }

  //Than PP_ORDER
  if ( Order.empty() || Order == CSMC_DBData::unspecString )
  {
    CPP_ORDER     PP_ORDER    (m_pDM_DBManagerTask->getStdConnection()); 
    if ( PP_ORDER.selectUseHeatId(HeatInfo.HeatId) )
    {
      Order = PP_ORDER.getPRODORDERID(1);
    }

    if ( Order.empty() || Order == CSMC_DBData::unspecString )
    {
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_DBReadError(sMessage, "PRODORDERID", "PP_ORDER", PP_ORDER.getActStatement().c_str());
    }
  }

  if ( Order.empty() || Order == CSMC_DBData::unspecString )
  {
    RetValue = false;
  }

  return RetValue;
}


bool CDM_DBManager::getPlantNoByHeatIDTreatID( const std::string HeatId, const std::string TreatID,const std::string PlantID,long& lngPlantNO )
{
  log("++++++ CDM_DBManager::getPlantNoByHeatIDTreatID",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHeatDataConverter  m_pHeatDataConverter(m_pDM_DBManagerTask->getStdConnection());

    RetValue = RetValue && m_pHeatDataConverter.getHeatPlantNo(HeatId,TreatID,PlantID,lngPlantNO);
  }
  return RetValue;
}

long CDM_DBManager::getPlantNoFromHeatTreatID(const std::string HeatID,const std::string TreatID,const std::string  PlantID )
{
  log("++++++ CDM_DBManager::getPlantNoFromHeatTreatID",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {

    CPD_HEAT_PLANT_REF PD_HEAT_PLANT_REF(m_pDM_DBManagerTask->getStdConnection());

    if( PD_HEAT_PLANT_REF.select(HeatID,TreatID,PlantID ))
    {
      return PD_HEAT_PLANT_REF.getPLANTNO(1);
    }
  }
  return 1;
}

bool CDM_DBManager::getPracNo(sHeatInfo &HeatInfo, const std::string &Description, long &PracNo)
{
  log("++++++ CDM_DBManager::getPracNo",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_HEAT_DATA_PRODPRAC  PD_HEAT_DATA_PRODPRAC  (m_pDM_DBManagerTask->getStdConnection());

    RetValue = PD_HEAT_DATA_PRODPRAC.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant,  Description);
    if (RetValue)
      PracNo = PD_HEAT_DATA_PRODPRAC.getPRODPRACID_MOD(1);
    else
    {
      setLastError("NO_PRACTICE_NUMBER", 0, PD_HEAT_DATA_PRODPRAC.getActStatement(), 1);
    }
  }
  return RetValue;
}


bool CDM_DBManager::getTreatmentMode(sHeatInfo &HeatInfo, const std::string& OrderId, long& TreatMode)
{
  bool RetValue = true;

  TreatMode = 0;

  return RetValue;
}

bool CDM_DBManager::handleAction(sHeatInfo &HeatInfo, const long ActionNo, bool Commit)
{
  return handleAction(HeatInfo, ActionNo, HeatInfo.Plant, "", false,  false, Commit);
}


bool CDM_DBManager::handleAction(sHeatInfo &HeatInfo, const long ActionNo, std::string ActionUnit, std::string ActionValue, bool UniqueAction,  bool UniqueValue, bool Commit)
{
  log("++++++ CDM_DBManager::handleAction",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    // to get all data base errors
    CDM_ProductManagementInterface_Impl *dataProvider = m_pDM_DBManagerTask->getpProductManagementInterface();

    CPD_ACTION    PD_ACTION      (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA PD_HEAT_DATA   (m_pDM_DBManagerTask->getStdConnection());

    seqGasData TotalMetAmount = CIntfData::ToCORBAType(dataProvider->getGasData(HeatInfo.ProductId.c_str(), DATA::TotalMetAmount));

    double DurSinceHeatAnnounce = dataProvider->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatAnnounce);
    double DurSinceHeatStart    = dataProvider->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatStart);
    double ElecCons             = dataProvider->getDouble(HeatInfo.ProductId, DATA::ElecCons);

    sMetTimeStamp MetTimeStamp;
    MetTimeStamp.O2_Moment   = DEF::Inv_Double;
    MetTimeStamp.Ar_Moment   = DEF::Inv_Double;
    MetTimeStamp.N2_Moment   = DEF::Inv_Double;
    MetTimeStamp.Elec_Moment = CDataConversion::SetInvalidToDefault(ElecCons,DEF::Inv_Double);
    MetTimeStamp.DurSinceHeatAnnouncement = CDataConversion::SetInvalidToDefault(DurSinceHeatAnnounce,0);
    MetTimeStamp.DurSinceStartOfHeat      = CDataConversion::SetInvalidToDefault(DurSinceHeatStart,0);

    if ( CIntfData::getLength(TotalMetAmount) > 0 )
    {
      CGasDataHandler GasDataHandler(TotalMetAmount);
      MetTimeStamp.O2_Moment = GasDataHandler.getGasData(DEF_GAS::O2);
      MetTimeStamp.Ar_Moment = GasDataHandler.getGasData(DEF_GAS::Ar);
      MetTimeStamp.N2_Moment = GasDataHandler.getGasData(DEF_GAS::N2);
    }

    // to avoid integrity constraint
    if ( PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant ) )
    {
      if ( UniqueValue)
      {
        if ( !PD_ACTION.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, ActionNo, CSMC_DBData::unspecDate) )
        {
          // insert action this is an update!!
          RetValue = RetValue && PD_ACTION.UpdateOrInsertAction(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, ActionNo, ActionUnit, ActionValue, 1, MetTimeStamp, UniqueAction, Commit, m_lastError);
        }
      }
      else
      {
        RetValue = RetValue && PD_ACTION.UpdateOrInsertAction(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, ActionNo, ActionUnit, ActionValue, 1, MetTimeStamp, UniqueAction, Commit, m_lastError);
      }
    }

    if (!RetValue)
    {
      log(m_lastError,3);
    }
  }

  checkLastError();

  return RetValue;
}

void CDM_DBManager::handleError(CEventMessage &Event, const std::string &HMIClientId)
{
  log("++++++ CDM_DBManager::handleError",3);

  // first check if error from other mothods was set during execution.
  checkLastError();

  if ( m_SMC_ErrorHandler.isError() )
  {
    std::vector<CSMC_Error*> ErrorList = m_SMC_ErrorHandler.getErrorList();
    std::vector<CSMC_Error*>::iterator it;

    for ( it = ErrorList.begin() ; it != ErrorList.end() ; ++it )
    {
      CSMC_Error * pSMC_Error = (*it);

      std::string ErrCode = CDataConversion::IntToString(pSMC_Error->m_NativeErrorCode);

      //init EventLogMessage
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);

      if (pSMC_Error->m_MessageText.empty())
      {
        pSMC_Error->m_MessageText = "UNKNOWN_ERROR";
      }

      if (pSMC_Error->m_SQLState.empty())
      {
        cCBS_StdInitBase *pStdInitBase = cCBS_StdInitBase::getInstance();
        std::string Plant;
        pStdInitBase->getEntry("PLANT", "Plant", Plant);
    
        if ( m_pDM_DBManagerTask )
        {
          pStdInitBase->replaceWithEntry(m_pDM_DBManagerTask->getTaskName(), "Plant", Plant);
        }

        pSMC_Error->m_SQLState = Plant;
      }

      if (!HMIClientId.empty() && HMIClientId != DEF::Inv_String)
      {
        //send user eventlog

        //try to get translation for the error
        getTranslation(pSMC_Error);
         
        // sMessage.opAckn   = pSMC_Error->m_OpAcknowledge; //trigger the Popup window in HMI
        sMessage.opAckn   = 1; //trigger the Popup window in HMI
        sMessage.eventId  = 30000;
        sMessage.spare3   = HMIClientId;              //Identification of the HMI client
        sendEventLog(sMessage, ErrCode, pSMC_Error->m_MessageText, pSMC_Error->m_SQLState);
      }
      else
      {
        //sMessage.opAckn   = pSMC_Error->m_OpAcknowledge; //trigger the Popup window in HMI
        sMessage.opAckn   = 1; //trigger the Popup window in HMI
        sMessage.eventId  = 30000;
        sMessage.spare3   = "AnyClient";              //Identification of the HMI client

        //send administrator eventlog
        sendEventLog(sMessage, ErrCode, pSMC_Error->m_MessageText, pSMC_Error->m_SQLState); 
      }
    }

    m_SMC_ErrorHandler.resetErrorList();
  }
}

void CDM_DBManager::handleInformation(CEventMessage &Event, const std::string &HMIClientId, bool ForceAcknowledge /* = false*/)
{
  log("++++++ CDM_DBManager::handleInformation",3);

  if ( m_SMC_ErrorHandler.isError() )
  {
    std::vector<CSMC_Error*> ErrorList = m_SMC_ErrorHandler.getErrorList();
    std::vector<CSMC_Error*>::iterator it;

    for ( it = ErrorList.begin() ; it != ErrorList.end() ; ++it )
    {
      CSMC_Error * pSMC_Error = (*it);

      std::string ErrCode = CDataConversion::IntToString(pSMC_Error->m_NativeErrorCode);

      //init EventLogMessage
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);

      if (pSMC_Error->m_MessageText.empty())
      {
        pSMC_Error->m_MessageText = "UNKNOWN_ERROR";
      }

      if (pSMC_Error->m_SQLState.empty())
      {
        cCBS_StdInitBase *pStdInitBase = cCBS_StdInitBase::getInstance();
        std::string Plant;
        pStdInitBase->getEntry("PLANT", "Plant", Plant);
    
        if ( m_pDM_DBManagerTask )
        {
          pStdInitBase->replaceWithEntry(m_pDM_DBManagerTask->getTaskName(), "Plant", Plant);
        }

        pSMC_Error->m_SQLState = Plant;
      }

      if (!HMIClientId.empty() && HMIClientId != DEF::Inv_String)
      {
        //send user eventlog

        //try to get translation for the error
        getTranslation(pSMC_Error);
       
        if ( ForceAcknowledge )
        {
          sMessage.severity = c_e_warning;
          sMessage.opAckn   = 1; //trigger the Popup window in HMI
        }
        else
        {
          sMessage.severity = c_e_info;
          sMessage.opAckn   = pSMC_Error->m_OpAcknowledge; //trigger the Popup window in HMI
        }

        sMessage.eventId  = 20000;
        sMessage.spare3   = HMIClientId;              //Identification of the HMI client
        sendEventLog(sMessage, ErrCode, pSMC_Error->m_MessageText, pSMC_Error->m_SQLState);
      }
      else
      {
        if ( ForceAcknowledge )
        {
          sMessage.severity = c_e_warning;
          sMessage.opAckn   = 1; //trigger the Popup window in HMI
        }
        else
        {
          sMessage.severity = c_e_info;
          sMessage.opAckn   = pSMC_Error->m_OpAcknowledge; //trigger the Popup window in HMI
        }
        sMessage.eventId  = 20000;
        sMessage.spare3   = "AnyClient";              //Identification of the HMI client

        //send administrator eventlog
        sendEventLog(sMessage, ErrCode, pSMC_Error->m_MessageText, pSMC_Error->m_SQLState); 
      }
    }

    m_SMC_ErrorHandler.resetErrorList();
  }
}

bool CDM_DBManager::handleLadleLifeData(long LadleNo, const std::string& LadleType, long Action, bool Commit)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);

  std::vector<std::string> LadlePartCodes;

  // in case of tapping end increase all ladle parts
  if ( LadleType != CSMC_DBData::unspecString )
  {
    if ( Action    == DEF_GC_ACTION_DEF::TappingEnd )
    {
      CGC_LADLE_PARTS GC_LADLE_PARTS(m_pDM_DBManagerTask->getStdConnection());
      LadlePartCodes = GC_LADLE_PARTS.getLadlePartCodes(LadleType);
    }
  }

  if ( LadleNo    != CSMC_DBData::unspecLong &&
       LadleType  != CSMC_DBData::unspecString )
  {
    CPD_LADLE_LIFE_DATA PD_LADLE_LIFE_DATA(m_pDM_DBManagerTask->getStdConnection());

    RetValue = PD_LADLE_LIFE_DATA.incrLife(LadleNo, LadleType, LadlePartCodes, Commit);
  }

  return RetValue;
}

bool CDM_DBManager::handleMatAvailibiltyChange( std::string Plant,long PlantNo,seqMaterials &sqMat,bool IsContainAllMat,bool Commit)
{
  log("++++++ CDM_DBManager::handleMatAvailibiltyChange",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    RetValue = updateMaterialPurpose(Plant,PlantNo,sqMat,IsContainAllMat,Commit);
    RetValue = RetValue && updateMaterialAmount(Plant,PlantNo,sqMat,IsContainAllMat,Commit);
  }
  return RetValue;
}

bool CDM_DBManager::handleMatFeedingStart(sHeatInfo &HeatInfo, seqBatch& sqMatFeedingBatch, bool Commit)
{
  log("++++++ CDM_DBManager::handleMatFeedingStart",3);

  bool RetValue  = true;

  long seqLength = CIntfData::getLength(sqMatFeedingBatch);
  if (seqLength > 0)
  {
    CPD_HEAT_DATA_MAT_FEED PD_HEAT_DATA_MAT_FEED(m_pDM_DBManagerTask->getStdConnection());

    CDateTime Now;
    for(int i =0; i< seqLength; i++)
    {
      sBatch sBatchMatFeedingData;
      CIntfData::getAt(sBatchMatFeedingData,sqMatFeedingBatch,i);

      PD_HEAT_DATA_MAT_FEED.setHEATID(HeatInfo.HeatId);
      PD_HEAT_DATA_MAT_FEED.setTREATID(HeatInfo.TreatId);
      PD_HEAT_DATA_MAT_FEED.setPLANT(HeatInfo.Plant);
      PD_HEAT_DATA_MAT_FEED.setFEEDERNO(sBatchMatFeedingData.Source);
      PD_HEAT_DATA_MAT_FEED.setMAT_CODE((std::string)sBatchMatFeedingData.MatCode);
      PD_HEAT_DATA_MAT_FEED.setFEEDINGRATE(sBatchMatFeedingData.MatFeedSpeed);
      PD_HEAT_DATA_MAT_FEED.setMAT_WEIGHT(sBatchMatFeedingData.Mass);
      PD_HEAT_DATA_MAT_FEED.setSTARTTIME(Now);

      RetValue = RetValue && PD_HEAT_DATA_MAT_FEED.insert();
    }

    if(Commit)
    {
      PD_HEAT_DATA_MAT_FEED.commit();
    }
  }
  return RetValue;
}

bool CDM_DBManager::handleMatFeedingStop(sHeatInfo &HeatInfo, seqBatch& sqMatFeedingBatch, bool Commit)
{
  log("++++++ CDM_DBManager::handleMatFeedingStop",3);

  bool RetValue  = true;

  CPD_HEAT_DATA_MAT_FEED PD_HEAT_DATA_MAT_FEED(m_pDM_DBManagerTask->getStdConnection());

  long seqLength = CIntfData::getLength(sqMatFeedingBatch);
  CDateTime Now;
  for(int i =0; i< seqLength; i++)
  {
    sBatch sBatchMatFeedingData;
    CIntfData::getAt(sBatchMatFeedingData,sqMatFeedingBatch,i);

    long SourceNo = sBatchMatFeedingData.Source;
    std::string strMatCode = sBatchMatFeedingData.MatCode;
    double      FeedingRate = sBatchMatFeedingData.MatFeedSpeed;
    double      MatWeight = sBatchMatFeedingData.Mass;

    if(PD_HEAT_DATA_MAT_FEED.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,SourceNo,strMatCode,CSMC_DBData::unspecDate))
    {
      for( long i = 1 ; i <= PD_HEAT_DATA_MAT_FEED.getLastRow(); ++i )
      {
        CDateTime STARTTIME   = PD_HEAT_DATA_MAT_FEED.getSTARTTIME(i);
        CDateTime ENDTIME     = PD_HEAT_DATA_MAT_FEED.getENDTIME(i);

        if ( ENDTIME == CSMC_DBData::unspecDate  )
        {
          if(PD_HEAT_DATA_MAT_FEED.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,SourceNo,strMatCode,STARTTIME))
          {
            PD_HEAT_DATA_MAT_FEED.setENDTIME(Now);

            if ( FeedingRate != DEF::Inv_Double && FeedingRate > 0. )
            {
              PD_HEAT_DATA_MAT_FEED.setFEEDINGRATE(FeedingRate);
            }

            if ( MatWeight != DEF::Inv_Double && MatWeight > 0. )
            {
              PD_HEAT_DATA_MAT_FEED.setMAT_WEIGHT(MatWeight);
            }

            RetValue = RetValue && PD_HEAT_DATA_MAT_FEED.update();
          }
        }
      }// for( long i = 1 ; i <= PD_HEAT_DATA_MAT_FEED.getLastRow(); ++i )

      if(Commit)
      {
        PD_HEAT_DATA_MAT_FEED.commit();
      }
    }// if(PD_HEAT_DATA_MAT_FEED.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,SourceNo,strMatCode,CSMC_DBData::unspecDate))
  }// for(int i =0; i< seqLength; i++)

  return RetValue;
}

bool CDM_DBManager::handlePDHeatStatus(sHeatInfo &HeatInfo, long Status, const std::string &UserCode, const long& TreatmentPosition, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDHeatStatus",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_HEAT_DATA       PD_HEAT_DATA      (m_pDM_DBManagerTask->getStdConnection());
    CPD_LADLE           PD_LADLE          (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_REF        PD_HEAT_REF       (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_PLANT_REF  PD_HEAT_PLANT_REF (m_pDM_DBManagerTask->getStdConnection());
    CPD_PLANTSTATUS     PD_PLANTSTATUS    (m_pDM_DBManagerTask->getStdConnection());

    CDateTime ExtreatmentEnd;

    std::string SteelGrade      = CSMC_DBData::unspecString;
    std::string ProductOrderID  = CSMC_DBData::unspecString;
    std::string LadleType       = CSMC_DBData::unspecString;
    double LadleTareWeight      = CSMC_DBData::unspecDouble;
    double SteelMass            = CSMC_DBData::unspecDouble;
    double SlagMass             = CSMC_DBData::unspecDouble;
    long LadleNo                = CSMC_DBData::unspecLong;

    //Set status and TreatEnd_act time
    RetValue = RetValue && PD_HEAT_REF.switchHeatStatusNo(HeatInfo.HeatId, Status, UserCode, false, Commit, m_lastError);

    // always set status at PD_HEAT_PLANT_REF because thuis is the superset od states
    RetValue = RetValue && PD_HEAT_PLANT_REF.setStatus(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Status, false, Commit, m_lastError);

    if ( !RetValue )
    {
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorHeatStatusChange(sMessage, HeatInfo.HeatId.c_str(), HeatInfo.TreatId.c_str(), HeatInfo.Plant.c_str(), CDataConversion::LongToString(Status).c_str());
    }

     // dSteelMass = dataProvider->getDouble(ProductID, DATA::SteelMassAct);
     // dSlagMass  = dataProvider->getDouble(ProductID, DATA::SlagMass);

    if( PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId,HeatInfo.Plant) )
    {
      ExtreatmentEnd    = PD_HEAT_DATA.getTREATEND_MOD(1);
      SteelGrade        = PD_HEAT_DATA.getSTEELGRADECODE_ACT(1);
      ProductOrderID    = PD_HEAT_DATA.getPRODORDERID_ACT(1);
      SteelMass         = PD_HEAT_DATA.getSTEELMASS(1);
      SlagMass          = PD_HEAT_DATA.getSLAGMASS(1);
      LadleNo           = PD_HEAT_DATA.getLADLENO(1);
      LadleType         = PD_HEAT_DATA.getLADLETYPE(1);

      SteelGrade     = CDataConversion::SetInvalidToDefault(SteelGrade,PD_HEAT_DATA.getSTEELGRADECODE_PLAN(1));
      ProductOrderID = CDataConversion::SetInvalidToDefault(ProductOrderID,PD_HEAT_DATA.getPRODORDERID_PLAN(1));

      if ( LadleNo != DEF::Inv_Long && LadleType != DEF::Inv_String )
      {
        if( PD_LADLE.select(LadleNo, LadleType) )
        {
          LadleTareWeight = PD_LADLE.getTAREWEIGHT(1);
        }
      }
    }  

    if ( TreatmentPosition != CSMC_DBData::unspecLong )
    {
      RetValue = RetValue && PD_PLANTSTATUS.updatePlantStatus(HeatInfo.Plant, HeatInfo.PlantNo, HeatInfo.HeatId, HeatInfo.TreatId, 
                                                              ProductOrderID, SteelGrade, Status, LadleType, LadleNo, TreatmentPosition,
                                                              ExtreatmentEnd, LadleTareWeight, SteelMass, SlagMass, Commit, m_lastError); 
    }
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDLadleTablesOnDeparture(sHeatInfo &HeatInfo, long &LadleNo, std::string &LadleType, long LadleLocation, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDLadleTablesOnDeparture",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_LADLE       PD_LADLE(m_pDM_DBManagerTask->getStdConnection());

    // sets known weights from pretreatment data and pretretment counter
    RetValue = RetValue && PD_LADLE.doDeparture(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, LadleNo, LadleType, LadleLocation, Commit, m_lastError);

		//SANKAR - ladle life data will come from JSW L3
    //RetValue = RetValue && handleLadleLifeData(LadleNo, LadleType, DEF_GC_ACTION_DEF::TappingEnd, false); 
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDLadleTablesOnTappingEnd(sHeatInfo &HeatInfo, long &LadleNo, std::string &LadleType, long LadleLocation, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDLadleTablesOnTappingEnd",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_LADLE       PD_LADLE(m_pDM_DBManagerTask->getStdConnection());

    // sets known weights from pretreatment data and LAST_FILL_TIME
    RetValue = RetValue && PD_LADLE.doTappingEnd(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, LadleNo, LadleType, LadleLocation, Commit, m_lastError);

  }

  checkLastError();

  return RetValue;
}


bool CDM_DBManager::handlePDPretreatTablesOnAnnounce(sHeatInfo &HeatInfo, const std::string &Order, const std::string &SteelGrade, const std::string &UserCode, sPDData &PDData, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDPretreatTablesOnAnnounce",3);
  
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_SAMPLE_REF          PD_SAMPLE_REF         (m_pDM_DBManagerTask->getStdConnection());
    CPD_PRETREATDATA        PD_PRETREATDATA       (m_pDM_DBManagerTask->getStdConnection());
    CPD_LADLE               PD_LADLE              (m_pDM_DBManagerTask->getStdConnection());
    CGC_Ladle_Def_Container GC_Ladle_Def_Container(m_pDM_DBManagerTask->getStdConnection());

    bool storePretreatDataOnAnnounce = true;
    bool resetPretreatDataOnAnnounce = false;

    cCBS_StdInitBase::getInstance()->replaceWithEntry("PROCESS", "StorePretreatDataOnAnnounce", storePretreatDataOnAnnounce);
    cCBS_StdInitBase::getInstance()->replaceWithEntry("PROCESS", "ResetPretreatDataOnAnnounce", resetPretreatDataOnAnnounce);

    if ( resetPretreatDataOnAnnounce )
    {
      // Incoming ladle
      if ( PDData.PreLadleNo != DEF::Inv_Long && PDData.PreLadleType != DEF::Inv_String )
      {
        if( PD_LADLE.select(PDData.PreLadleNo, PDData.PreLadleType) )
        {
          PD_LADLE.setPRETREAT_CNT_ACT  (CSMC_DBData::unspecLong);
          PD_LADLE.setPRETREAT_CNT_PREV (CSMC_DBData::unspecLong);

          RetValue = RetValue && PD_LADLE.update();

          if( RetValue )
          {
            if( Commit )
            {
              PD_LADLE.commit();
            }
          }
          else
          {
            setLastError(PD_LADLE.getLastError(), 1);
          }
        } // if( PD_LADLE.select(PDData.PreLadleNo, PDData.PreLadleType) )
      }
    } // if ( resetPretreatDataOnAnnounce )

    if ( RetValue && storePretreatDataOnAnnounce )
    {
      if ( PD_PRETREATDATA.selectValidDataByProdOrderId(Order) )
      {
        long SampleRef = PD_PRETREATDATA.getSAMPLE_REF(1);

        PD_PRETREATDATA.setHEATID(HeatInfo.HeatId);
        PD_PRETREATDATA.setTREATID(HeatInfo.TreatId);
        PD_PRETREATDATA.setPLANT(HeatInfo.Plant);
        PD_PRETREATDATA.setPLANTNO(HeatInfo.PlantNo);

        if ( SampleRef == CSMC_DBData::unspecLong || !PD_SAMPLE_REF.select(SampleRef))
        {
          SampleRef = PD_SAMPLE_REF.insertNewSAMPLE_REF(Commit,m_lastError);
          PD_PRETREATDATA.setSAMPLE_REF(SampleRef);
        }
        if ( SteelGrade != DEF::Inv_String )
        {
          PD_PRETREATDATA.setSTEELGRADECODE(SteelGrade);
        }
        if( PDData.SteelMass != DEF::Inv_Double && PDData.SteelMass > 0. )
        {
          PD_PRETREATDATA.setSTEELWEIGHT(PDData.SteelMass);
        }
        if( PDData.SlagMass != DEF::Inv_Double && PDData.SlagMass > 0. )
        {
          PD_PRETREATDATA.setSLAGWEIGHT(PDData.SlagMass);
        }

        // Incoming ladle
        if ( GC_Ladle_Def_Container.isValidLadle(PDData.PreLadleNo, PDData.PreLadleType) )
        {
          PD_PRETREATDATA.setLADLENO  (PDData.PreLadleNo);
          PD_PRETREATDATA.setLADLETYPE(PDData.PreLadleType);
        }

        PD_PRETREATDATA.setREVTIME(CDateTime());

        RetValue = RetValue && PD_PRETREATDATA.update();

        if( RetValue )
        {
          if( Commit )
          {
            PD_PRETREATDATA.commit();
          }
        }
        else
        {
          setLastError(PD_PRETREATDATA.getLastError(), 1);
        }

        PDData.SampleRef            = SampleRef;
        PDData.OverWriteSampleTime  = true;

        RetValue = RetValue && addSampleAnalysisRef(HeatInfo, UserCode, PDData, SampleRef, Commit);
      }
      else
      {
        long PredCounter = -1;

        PDData.OverWriteSampleTime  = true;

        RetValue = RetValue && addSampleAnalysisRef(HeatInfo, UserCode, PDData, PDData.SampleRef, Commit);

        //get next sequence value
        RetValue = RetValue && PD_PRETREATDATA.getNextPRETREAT_COUNTER(PredCounter, m_lastError);

        if ( RetValue )
        {
          PD_PRETREATDATA.setPRETREAT_COUNTER(PredCounter);

          PD_PRETREATDATA.setHEATID(HeatInfo.HeatId);
          PD_PRETREATDATA.setTREATID(HeatInfo.TreatId);
          PD_PRETREATDATA.setPLANT(HeatInfo.Plant);
          PD_PRETREATDATA.setPLANTNO(HeatInfo.PlantNo);

          PD_PRETREATDATA.setSTEELGRADECODE(SteelGrade);

          // Incoming ladle
          if ( GC_Ladle_Def_Container.isValidLadle(PDData.PreLadleNo, PDData.PreLadleType) )
          {
            PD_PRETREATDATA.setLADLENO  (PDData.PreLadleNo);
            PD_PRETREATDATA.setLADLETYPE(PDData.PreLadleType);
          }

          if( PDData.SteelMass != DEF::Inv_Double && PDData.SteelMass > 0. )
            PD_PRETREATDATA.setSTEELWEIGHT(PDData.SteelMass);
            
          if( PDData.SlagMass != DEF::Inv_Double && PDData.SlagMass > 0. )
            PD_PRETREATDATA.setSLAGWEIGHT(PDData.SlagMass);

          PD_PRETREATDATA.setPRODORDERID(Order);

          PD_PRETREATDATA.setSAMPLE_REF(PDData.SampleRef);

          PD_PRETREATDATA.setREVTIME(CDateTime());
    
          RetValue = RetValue && PD_PRETREATDATA.insert();    

          if( RetValue )
          {
            if( Commit )
            {
              PD_PRETREATDATA.commit();
            }
          }
          else
          {
            setLastError(PD_PRETREATDATA.getLastError(), 1);
          }
        } // if ( RetValue )
        else
        {
          setLastError(PD_PRETREATDATA.getLastError(), 1);
        }
      } 
    } // if ( storePretreatDataOnAnnounce )
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDTablesOnAnalysisReceived(sHeatInfo &HeatInfo, seqAnalysis &SeqAnalysis, long LadleNo, const std::string& LadleType, CDateTime SampleTime, long SampleType, long SampleNo, long SampleMode, long SampleOrigin, const std::string& SampleLocation, long &SampleCounter, const std::string& SampleId, const std::string& OrderId, const std::string& User, long TreatmentPosition, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDTablesOnAnalysisReceived",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_SAMPLE_REF       PD_SAMPLE_REF      (m_pDM_DBManagerTask->getStdConnection());
    CPD_SAMPLE           PD_SAMPLE          (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA        PD_HEAT_DATA       (m_pDM_DBManagerTask->getStdConnection());
    CPD_PLANTSTATUS      PD_PLANTSTATUS     (m_pDM_DBManagerTask->getStdConnection());
    CPD_PRETREATDATA     PD_PRETREATDATA    (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA_LIQADD PD_HEAT_DATA_LIQADD(m_pDM_DBManagerTask->getStdConnection());


    //Read data from PD_SAMPLE_REF using SAMPLE_REF from PD_HEAT_DATA
    if (PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
    {
      long SAMPLE_REF = PD_HEAT_DATA.getSAMPLE_REF(1);

      if ( SAMPLE_REF != CSMC_DBData::unspecLong )
      {
        // insert data into PD_SAMPLE and return new SAMPLE_REF
        RetValue = RetValue && addSampleAnalysis(HeatInfo, SeqAnalysis, LadleNo, LadleType, SampleTime, SampleType, SampleNo, SampleMode, SampleOrigin, SampleLocation, SAMPLE_REF, SampleCounter, SampleId, OrderId, false, User,  Commit);
      }
      else
      {  
        RetValue = RetValue && addSampleAnalysis(HeatInfo, SeqAnalysis, LadleNo, LadleType, SampleTime, SampleType, SampleNo, SampleMode, SampleOrigin, SampleLocation, SAMPLE_REF, SampleCounter, SampleId, OrderId, false, User, Commit);

        RetValue = RetValue && PD_HEAT_DATA.doSampleRefUpdate(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, SAMPLE_REF, false, m_lastError);
      }
    } // if (PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant)
    else if (PD_PRETREATDATA.selectValidDataByHeat(HeatInfo.HeatId, HeatInfo.TreatId))
    {
      long SAMPLE_REF = PD_PRETREATDATA.getSAMPLE_REF(1);

      if ( SAMPLE_REF != CSMC_DBData::unspecLong )
      {
        // insert data into PD_SAMPLE and return new SAMPLE_REF
        RetValue = RetValue && addSampleAnalysis(HeatInfo, SeqAnalysis, LadleNo, LadleType, SampleTime, SampleType, SampleNo, SampleMode, SampleOrigin, SampleLocation, SAMPLE_REF, SampleCounter, SampleId, OrderId, false, User, Commit);
      }
      else
      {  
        RetValue = RetValue && addSampleAnalysis(HeatInfo, SeqAnalysis, LadleNo, LadleType, SampleTime, SampleType, SampleNo, SampleMode, SampleOrigin, SampleLocation, SAMPLE_REF, SampleCounter, SampleId, OrderId, false, User, Commit);

        // heat is not yet announced, may be sample of pretreatmant
        RetValue = RetValue && PD_PRETREATDATA.updateSampleRefForHeatData(HeatInfo.HeatId, HeatInfo.TreatId, SAMPLE_REF);
      }
    }

    // updating liquid addition data
    if ( RetValue && PD_HEAT_DATA_LIQADD.selectHeatByLadle(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, LadleType, LadleNo, CSMC_DBData::unspecString ) )
    {
      long SAMPLE_REF = PD_HEAT_DATA_LIQADD.getSAMPLE_REF(1);

      if ( SAMPLE_REF != CSMC_DBData::unspecLong )
      {
        // insert data into PD_SAMPLE and return new SAMPLE_REF
        RetValue = RetValue && addSampleAnalysis(HeatInfo, SeqAnalysis, LadleNo, LadleType, SampleTime, SampleType, SampleNo, SampleMode, SampleOrigin, SampleLocation, SAMPLE_REF, SampleCounter, SampleId, OrderId, false, User, Commit);
      }
      else
      {  
        RetValue = RetValue && addSampleAnalysis(HeatInfo, SeqAnalysis, LadleNo, LadleType, SampleTime, SampleType, SampleNo, SampleMode, SampleOrigin, SampleLocation, SAMPLE_REF, SampleCounter, SampleId, OrderId, false, User, Commit);

        RetValue = RetValue &&  PD_HEAT_DATA_LIQADD.updateSampleRefForHeatId(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, LadleType , LadleNo, SAMPLE_REF);
      }
    }

    // update Plant Status
    if ( RetValue )
    {
      PD_PLANTSTATUS.updateSampleCounter(HeatInfo.Plant, HeatInfo.PlantNo, HeatInfo.HeatId, HeatInfo.TreatId, SampleCounter, TreatmentPosition, true, m_lastError);
    }
  }

  checkLastError();

  return RetValue;
}

//data are inserted diractly into PD_HEAT_DATA... tables
bool CDM_DBManager::handlePDTablesOnAnnounce(sHeatInfo &HeatInfo, const std::string &Order, const std::string &SteelGrade, const std::string &UserCode, sPDData &PDData, long &SampleRef, long TreatmentPosition, bool Commit )
{
  log("++++++ CDM_DBManager::handlePDTablesOnAnnounce",3);
  
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPP_HEAT                PP_HEAT               (m_pDM_DBManagerTask->getStdConnection());
    CPP_HEAT_PLANT          PP_HEAT_PLANT         (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA           PD_HEAT_DATA          (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA_PRODPRAC  PD_HEAT_DATA_PRODPRAC (m_pDM_DBManagerTask->getStdConnection());
    CPD_LADLE               PD_LADLE              (m_pDM_DBManagerTask->getStdConnection());
    CPD_PRETREATDATA        PD_PRETREATDATA       (m_pDM_DBManagerTask->getStdConnection());

    //-> copy data from PD_PREDTREATDATA into PD_HEAT_DATA...
    if ( PD_PRETREATDATA.selectValidDataByProdOrderId(Order) )
    {
      if ( PDData.SampleRef == DEF::Inv_Long )
      {
        PDData.SampleRef       = PD_PRETREATDATA.getSAMPLE_REF(1);
      }
      if ( PDData.SteelMass == DEF::Inv_Double )
      {
        PDData.SteelMass       = PD_PRETREATDATA.getSTEELWEIGHT(1);
      }
      if ( PDData.SlagMass == DEF::Inv_Double)
      {
        PDData.SlagMass        = PD_PRETREATDATA.getSLAGWEIGHT(1);
      }

      // Incoming ladle
      if ( PDData.PreLadleNo == DEF::Inv_Long || PDData.PreLadleType == DEF::Inv_String )
      {
        PDData.PreLadleNo         = PD_PRETREATDATA.getLADLENO(1);
        PDData.PreLadleType       = PD_PRETREATDATA.getLADLETYPE(1);
      }
      if ( PDData.PretreatCounter == DEF::Inv_Long || PDData.PretreatCounter <= 0 )
      {
        PDData.PretreatCounter = PD_PRETREATDATA.getPRETREAT_COUNTER(1);
      }
    }
    else
    {
      PDData.SteelMass       = 0.0;
      PDData.SlagMass        = 0.0;
    }

    if ( PDData.PreLadleState == DEF::Inv_String || PDData.PreLadleState.empty() )
    {
      PDData.PreLadleState = DEF_GC_THERM_STAT::M;
      log("DM_DBManager::handlePDTablesOnAnnounce: no therm stat defined using " + DEF_GC_THERM_STAT::M, 1);
    }

    // Incoming ladle
    if( PDData.PreLadleNo != DEF::Inv_Long && PDData.PreLadleNo > 0 )
    {
      log("++++++ CDM_DBManager::handlePDTablesOnAnnounce: PD_LADLE.doAnnouncement", 4);
      RetValue = RetValue && PD_LADLE.doAnnouncement(PDData.PreLadleNo, PDData.PreLadleType, PDData.PreLadleState, PDData.SteelMass, PDData.SlagMass, PDData.PretreatCounter, Commit, m_lastError);
    }// if( PDData.PreLadleNo != DEF::Inv_Long )
    
    //get SAMPLE_REF if exists
    if (PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
    {
      // announcement again
      SampleRef = PD_HEAT_DATA.getSAMPLE_REF(1);
    }

    //store analysis
    PDData.OverWriteSampleTime  = true;
    RetValue = RetValue && addSampleAnalysisRef(HeatInfo, UserCode, PDData, SampleRef, Commit);

    //insert into PD_HEAT_DATA... tables
    // received ladle is used ladle for announcement not for tapping (LF, RH)
    // therefore the tapping ladle has to be set in specialized classes
    if (RetValue)
    {
      log("++++++ CDM_DBManager::handlePDTablesOnAnnounce: PD_PRETREATDATA.doAnnouncemen", 4);
      RetValue = RetValue && PD_PRETREATDATA.doAnnouncement(HeatInfo.HeatId, HeatInfo.Plant, HeatInfo.TreatId, Commit, m_lastError);
      log("++++++ CDM_DBManager::handlePDTablesOnAnnounce: PD_HEAT_DATA.doAnnouncement", 4);

      CDateTime LastTreatmentEndTime = getLastTreatmentEndTime(HeatInfo, TreatmentPosition);

      // Outgoing ladle
      RetValue = RetValue && PD_HEAT_DATA.doAnnouncement(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, SteelGrade, 
        PDData.SteelMass, PDData.SlagMass, SampleRef, PDData.LadleNo, PDData.LadleType, LastTreatmentEndTime, UserCode, Commit, m_lastError);
    }

    if (RetValue)
    {
      log("++++++ CDM_DBManager::handlePDTablesOnAnnounce: PD_HEAT_DATA_PRODPRAC.doAnnouncement", 4);
      RetValue = RetValue && PD_HEAT_DATA_PRODPRAC.doAnnouncement(HeatInfo.Plant, HeatInfo.PlantNo, HeatInfo.HeatId, 
                                                              HeatInfo.TreatId, Commit, m_lastError);
    }
  }

  checkLastError();

  return RetValue;
}

CDateTime CDM_DBManager::getLastTreatmentEndTime(sHeatInfo &HeatInfo, long TreatmentPosition)
{
  CDateTime LastTreatmentEndTime;

  CPD_HEAT_DATA           PD_HEAT_DATA          (m_pDM_DBManagerTask->getStdConnection());

  LastTreatmentEndTime = PD_HEAT_DATA.getLastFinishedTimeByPlant(HeatInfo.Plant, HeatInfo.PlantNo);

  return LastTreatmentEndTime;
}


bool CDM_DBManager::handlePDTablesOnChangeAimData(sHeatInfo &HeatInfo, const std::string &SteelGrade, const std::string &Order, double AimWeight, double Temp, CDateTime &TreatStart, CDateTime &TreatEnd, long TreatmentPosition, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDTablesOnChangeAimData",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPP_ORDER               PP_ORDER              (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA           PD_HEAT_DATA          (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA_PRODPRAC  PD_HEAT_DATA_PRODPRAC (m_pDM_DBManagerTask->getStdConnection());
    CPD_PLANTSTATUS         PD_PLANTSTATUS        (m_pDM_DBManagerTask->getStdConnection());

    //first,need update pp_order's steel grade
    RetValue = RetValue && PP_ORDER.doSteelGradeChange(Order, SteelGrade, UserCode, Commit, m_lastError);
    RetValue = RetValue && PD_HEAT_DATA.doChange(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, SteelGrade, Order, AimWeight, Temp, TreatStart, TreatEnd, Commit, m_lastError);
    RetValue = RetValue && PD_HEAT_DATA_PRODPRAC.doChangeAimData(HeatInfo.Plant, HeatInfo.PlantNo, HeatInfo.HeatId, HeatInfo.TreatId, Commit, m_lastError);
    RetValue = RetValue && PD_PLANTSTATUS.changeAimData(HeatInfo.Plant, HeatInfo.PlantNo, HeatInfo.HeatId, HeatInfo.TreatId, SteelGrade,TreatmentPosition, TreatEnd, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

//handle data in PD_ tables when ChangeLiquidAddition occures
bool CDM_DBManager::handlePDTablesOnChangeLiquidAddition(sHeatInfo &HeatInfo, long LiqAddNo, std::string &UserCode, sPDData &PDData, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDTablesOnChangeLiquidAddition",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_HEAT_DATA_LIQADD  PD_HEAT_DATA_LIQADD(m_pDM_DBManagerTask->getStdConnection());  
    CPD_LADLE             PD_LADLE(m_pDM_DBManagerTask->getStdConnection());
    CPD_SAMPLE_REF        PD_SAMPLE_REF(m_pDM_DBManagerTask->getStdConnection());

    long SAMPLE_REF = DEF::Inv_Long;

    /*********************************************
    JOGE received ladle has to be store in PD_HEAT_DATA_LIQADD if any ladle received
    and if ladle is available and thermal status is available than change the thermal status 
    of received ladle
    //Check if LadleState change
    if (PDData.LadleState != DEF::Inv_String &&
        !PDData.LadleState.empty())
    {
      //if LadleNo is not set try to get it
      if (PDData.LadleNo == DEF::Inv_Long)
        RetValue = RetValue && getLadleFromLiqAdd(HeatInfo, LiqAddNo, PDData.LadleNo, PDData.LadleType);
      RetValue = RetValue && PD_LADLE.updateTermalStatus(PDData.LadleNo, PDData.LadleType, PDData.LadleState, Commit, m_lastError);
    }

    //if LadleNo is not set try to get it
    if (PDData.LadleNo == DEF::Inv_Long)
      RetValue = RetValue && getLadleFromLiqAdd(HeatInfo, LiqAddNo, PDData.LadleNo, PDData.LadleType);
    else
    {
      //LadleNo is set -> update the PD_HEAT_DATA table
      CPD_HEAT_DATA PD_HEAT_DATA(m_pDM_DBManagerTask->getStdConnection());
      RetValue = RetValue && PD_HEAT_DATA.doLadleDataChanged(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, PDData.LadleNo, PDData.LadleType, false, m_lastError);
    }
    **************************/

    if ( PDData.PreLadleNo   == CSMC_DBData::unspecLong && 
         PDData.PreLadleType == CSMC_DBData::unspecString )
    {
      if ( PD_HEAT_DATA_LIQADD.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, LiqAddNo) )
      {
        PDData.PreLadleNo    = PD_HEAT_DATA_LIQADD.getLADLENO(1);
        PDData.PreLadleType  = PD_HEAT_DATA_LIQADD.getLADLETYPE(1); 
      }
    }

    // Incoming ladle
    if (PDData.PreLadleNo    != DEF::Inv_Long && 
        PDData.PreLadleType  != DEF::Inv_String && 
        PDData.PreLadleState != DEF::Inv_String &&
        !PDData.PreLadleState.empty())
    {
      RetValue = RetValue && PD_LADLE.updateTermalStatus(PDData.PreLadleNo, PDData.PreLadleType, PDData.PreLadleState, Commit, m_lastError);
    }

    //get SAMPLE_REF if exists
    if (PD_HEAT_DATA_LIQADD.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, LiqAddNo))
    {
      PDData.SampleRef = PD_HEAT_DATA_LIQADD.getSAMPLE_REF(1);
    }

    //Add the sample analysis
    PDData.OverWriteSampleTime  = true;
    RetValue = RetValue && addSampleAnalysisRef(HeatInfo, UserCode, PDData,SAMPLE_REF, Commit);

    // Incoming ladle
    //update the PD_HEAT_DATA_LIQADD
    RetValue = RetValue && PD_HEAT_DATA_LIQADD.doChangeLiquidAdditionData(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, LiqAddNo, 
                                                                          PDData.SteelMass, PDData.SlagMass, PDData.PreLadleNo, PDData.PreLadleType, 
                                                                          PDData.PreLadleState, SAMPLE_REF, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDTablesOnChangeProdPrac(sHeatInfo &HeatInfo, const std::string &Description, long ProdPrac, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDTablesOnChangeProdPrac",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_HEAT_DATA_PRODPRAC  PD_HEAT_DATA_PRODPRAC(m_pDM_DBManagerTask->getStdConnection());

    RetValue = RetValue && PD_HEAT_DATA_PRODPRAC.doChangeProdPrac(HeatInfo.Plant, HeatInfo.PlantNo, HeatInfo.HeatId, HeatInfo.TreatId, Description, ProdPrac, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDTablesOnDelayStatus(sHeatInfo &HeatInfo, CDateTime &StartTime, CDateTime &EndTime, const std::string &Code, const std::string &UserCode, const std::string &Comment, long Status, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDTablesOnDelayStatus",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_DELAYS PD_DELAYS(m_pDM_DBManagerTask->getStdConnection());

    if ( Status == DEF_GEN_STATES::Delete )
    {
      //check if Delay exists -> set exipiration date
      RetValue = RetValue && PD_DELAYS.expireDelay(HeatInfo.Plant, HeatInfo.PlantNo, Code, StartTime, UserCode, Commit, m_lastError);
    }
    else
    {
      //check if Delay exists -> update existing, otherwise insert
      RetValue = RetValue && PD_DELAYS.updateOrInsert(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, Code, StartTime, EndTime, UserCode, Comment, Commit, m_lastError);      
    }
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDTablesOnDeparture(sHeatInfo &HeatInfo, const std::string &OrderId, const std::string &UserCode, long TreatmentPosition, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDTablesOnDeparture",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_HEAT_DATA       PD_HEAT_DATA      (m_pDM_DBManagerTask->getStdConnection());
    CPD_TAPCH_DATA      PD_TAPCH_DATA     (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_PLANT_REF  PD_HEAT_PLANT_REF (m_pDM_DBManagerTask->getStdConnection());
    
    CPD_SCRAP_CONTAINER_ORDER   PD_SCRAP_CONTAINER_ORDER(m_pDM_DBManagerTask->getStdConnection());

    CDM_ProductManagementInterface_Impl *dataProvider = m_pDM_DBManagerTask->getpProductManagementInterface();

    double ElecEgy   = dataProvider->getDouble(HeatInfo.ProductId, DATA::ElecCons);

    RetValue = RetValue && PD_HEAT_DATA.doDeparture(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
 
    // Setting tap end time
    RetValue = RetValue && PD_TAPCH_DATA.doDeparture(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, ElecEgy, Commit, m_lastError);

    RetValue = RetValue && handlePDHeatStatus(HeatInfo, m_HeatStatus.Departure, UserCode, TreatmentPosition, Commit);

    //Prepare PD tables
    RetValue = RetValue && handlePDPretreatDataOnDeparture(HeatInfo, OrderId, UserCode, Commit);

    RetValue = RetValue && PD_SCRAP_CONTAINER_ORDER.deletePlannedDataOnDeparture(HeatInfo.Plant, OrderId, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDTablesOnLadleDataChanged(sHeatInfo &HeatInfo, const std::string &UserCode, const std::string &pLadleStatus, long LadleNo, const std::string &LadleType, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDTablesOnLadleDataChanged",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_HEAT_DATA   PD_HEAT_DATA  (m_pDM_DBManagerTask->getStdConnection());
    CPD_LADLE       PD_LADLE      (m_pDM_DBManagerTask->getStdConnection());
    CPD_PLANTSTATUS PD_PLANTSTATUS(m_pDM_DBManagerTask->getStdConnection());

    //update PD_HEAT_DATA
    RetValue = RetValue && PD_HEAT_DATA.doLadleDataChanged(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, LadleNo, LadleType/*, pLadleStatus*/, Commit, m_lastError);
    RetValue = RetValue && PD_LADLE.updateTermalStatus(LadleNo, LadleType, pLadleStatus, Commit, m_lastError);
    // update plant status independent of treatment position but for the heat on any position
    RetValue = RetValue && PD_PLANTSTATUS.changeLadleData(HeatInfo.Plant, HeatInfo.PlantNo, CSMC_DBData::unspecLong, HeatInfo.HeatId, HeatInfo.TreatId, LadleNo, LadleType, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDTablesOnProdOrdChanged(sHeatInfo &HeatInfo, const std::string &SteelGrade, const std::string &Order, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDTablesOnProdOrdChanged",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPP_HEAT                PP_HEAT               (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA           PD_HEAT_DATA          (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA_PRODPRAC  PD_HEAT_DATA_PRODPRAC (m_pDM_DBManagerTask->getStdConnection());

    double AimWeight  = CSMC_DBData::unspecDouble;
    double AimTemp    = CSMC_DBData::unspecDouble;
    long AimWeightDB  = -1;
    long AimTempDB    = -1;
    // time are not set because they are not order dependent
    CDateTime TreatStart = CDateTime::InvalidDateTime();
    CDateTime TreatEnd   = CDateTime::InvalidDateTime();

    if ((RetValue = RetValue && getAimWeight(HeatInfo.Plant, Order, AimWeightDB)) == true)
    {
      AimWeight = AimWeightDB;
    }
    if ((RetValue = RetValue && getAimTemperature(HeatInfo.Plant, Order, AimTempDB)) == true)
    {
      AimTemp = AimTempDB;
    }

    //update the Order in PP_HEAT first
    RetValue = RetValue && PP_HEAT.updateInsertPP(HeatInfo.HeatId, Order, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, UserCode, Commit, m_lastError);
    RetValue = RetValue && PD_HEAT_DATA.doChange(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, SteelGrade, Order, AimWeight, AimTemp, TreatStart, TreatEnd, Commit, m_lastError);
    RetValue = RetValue && PD_HEAT_DATA_PRODPRAC.doProdOrderChange(HeatInfo.Plant, HeatInfo.PlantNo, HeatInfo.HeatId, HeatInfo.TreatId, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDTablesOnRemoveLiquidAddition(sHeatInfo &HeatInfo, long LiqAddNo, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDTablesOnRemoveLiquidAddition",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_HEAT_DATA_LIQADD PD_HEAT_DATA_LIQADD(m_pDM_DBManagerTask->getStdConnection());

    RetValue = RetValue && PD_HEAT_DATA_LIQADD.doRemoveLiquidAdditionData(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, LiqAddNo, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDTablesOnSetupOfHeat(bool IsHeatPlanned, sHeatInfo &HeatInfo, sPDData &PDData, long Status, const std::string &OrderId, const CDateTime &HeatStart, const CDateTime &HeatEnd, const std::string &SteelgradeCode, const std::string &UserCode, long &SampleRef, long TreatmentPosition, bool Commit )
{
  log("++++++ CDM_DBManager::handlePDTablesOnSetupOfHeat",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    double AimWeight    = CSMC_DBData::unspecDouble;
    double AimTemp      = CSMC_DBData::unspecDouble;
    long TreatmentMode  = CSMC_DBData::unspecLong;

    std::string mHeatCust  = CSMC_DBData::unspecString;
    std::string mTreatCust = CSMC_DBData::unspecString;

    long SAMPLE_REF = CSMC_DBData::unspecLong;

    if (IsHeatPlanned)
    {
      log("++++++ CDM_DBManager::IsHeatPlanned",3);
      if ( Status >= m_HeatStatus.Announced )
      {
        getTreatmentMode(HeatInfo, OrderId, TreatmentMode);
        //heat is planned
        CPD_HEAT_REF        PD_HEAT_REF       (m_pDM_DBManagerTask->getStdConnection());
        CPD_HEAT_PLANT_REF  PD_HEAT_PLANT_REF (m_pDM_DBManagerTask->getStdConnection()); 
        CPD_HEAT_DATA       PD_HEAT_DATA      (m_pDM_DBManagerTask->getStdConnection());

        RetValue = RetValue && CDM_DBManager::handlePPTabelsOnAnnounce(HeatInfo, PDData, mHeatCust, mTreatCust, OrderId, SteelgradeCode, HeatEnd, false, UserCode, AimWeight, AimTemp, TreatmentMode, Commit);

        //insert into PD_.._REF tables and set PLANNED = 0 in PP_HEAT_PLANT
        RetValue = RetValue && PD_HEAT_REF.doSetupHeat(HeatInfo.HeatId, HeatInfo.Plant, Status, UserCode, Commit, m_lastError);
        RetValue = RetValue && PD_HEAT_PLANT_REF.write(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Status, Commit, m_lastError);

        RetValue = RetValue && handlePDTablesOnAnnounce(HeatInfo, OrderId, SteelgradeCode, UserCode, PDData, SAMPLE_REF, TreatmentPosition, Commit);

        if (Status < m_HeatStatus.Departure)
        {
          // Outgoing ladle
          RetValue = RetValue && PD_HEAT_DATA.doSetupHeatTreatmentStart(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, SteelgradeCode, PDData.LadleNo, PDData.LadleType,
            HeatStart, HeatEnd, PDData.SteelMass, PDData.Temp, SAMPLE_REF, UserCode, Commit, m_lastError);
        }
        else if (Status == m_HeatStatus.Departure)
        {
          // Incoming ladle
          RetValue = RetValue && PD_HEAT_DATA.doSetupHeat(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, SteelgradeCode, PDData.PreLadleNo, PDData.PreLadleType,
            HeatStart, HeatEnd, PDData.SteelMass, PDData.Temp, SAMPLE_REF, UserCode, Commit, m_lastError);
        }
        else
        {
          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_ErrorHeatStatusChange(sMessage, HeatInfo.HeatId.c_str(), HeatInfo.TreatId.c_str(), HeatInfo.Plant.c_str(), CDataConversion::LongToString(Status).c_str());

          setLastError(std::string("WRONG_PLANT_UNIT_USE_") + HeatInfo.Plant + "_STATUS", 0, "", 1);
          RetValue = false;
        }
      }
      else if ( Status == m_HeatStatus.Planned )
      {
        //Heat is in production or departed    
        CPD_HEAT_DATA      PD_HEAT_DATA  (m_pDM_DBManagerTask->getStdConnection());
        CPP_HEAT           PP_HEAT       (m_pDM_DBManagerTask->getStdConnection());
        CPP_ORDER          PP_ORDER      (m_pDM_DBManagerTask->getStdConnection());
        CPP_HEAT_PLANT     PP_HEAT_PLANT (m_pDM_DBManagerTask->getStdConnection());
        CPD_HEAT_PLANT_REF PD_HEAT_PLANT_REF (m_pDM_DBManagerTask->getStdConnection());  
        CPD_HEAT_REF       PD_HEAT_REF   (m_pDM_DBManagerTask->getStdConnection());

        //update or insert Steelgrade and Order in PP_ tables // order change is not regarded
        RetValue = RetValue && PP_ORDER.updateInsertPP(OrderId, SteelgradeCode, UserCode, Commit, m_lastError);
        RetValue = RetValue && PP_HEAT.updateInsertPP(HeatInfo.HeatId, OrderId, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, UserCode, CSMC_DBData::unspecLong,  CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, Commit, m_lastError);

        // Incoming ladle
        RetValue = RetValue && handlePDTablesOnLadleDataChanged(HeatInfo, UserCode, CSMC_DBData::unspecString, PDData.PreLadleNo, PDData.PreLadleType, Commit); 

        if ( PD_HEAT_REF.hasState(HeatInfo.HeatId,m_HeatStatus.Departure) )
        {
          RetValue = RetValue && PD_HEAT_REF.doSetupHeat(HeatInfo.HeatId, HeatInfo.Plant, Status, UserCode, Commit, m_lastError);

          RetValue = RetValue && PD_HEAT_DATA.doSetupHeatAnnouncement(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, SteelgradeCode, PDData.LadleNo, PDData.LadleType,
                                                          HeatStart, HeatEnd, PDData.SteelMass, PDData.Temp, SampleRef, UserCode, Commit, m_lastError);

          RetValue = RetValue && PD_HEAT_PLANT_REF.doCancelHeat(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);

          RetValue = RetValue && PP_HEAT_PLANT.doCancelHeat(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
          RetValue = RetValue && PP_HEAT.setPlanned(HeatInfo.HeatId, 1, Commit, m_lastError);
        }
      }
      else
      {   
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorHeatStatusChange(sMessage, HeatInfo.HeatId.c_str(), HeatInfo.TreatId.c_str(), HeatInfo.Plant.c_str(), CDataConversion::LongToString(Status).c_str());

        setLastError(std::string("WRONG_PLANT_UNIT_USE_") + HeatInfo.Plant + "_STATUS", 0, "", 1);
        RetValue = false;
      }
    }
    else
    {
      log("++++++ CDM_DBManager::IsHeatNotPlanned",3);
      //Heat is in production or departed    
      CPD_HEAT_DATA      PD_HEAT_DATA  (m_pDM_DBManagerTask->getStdConnection());
      CPP_HEAT           PP_HEAT       (m_pDM_DBManagerTask->getStdConnection());
      CPP_ORDER          PP_ORDER      (m_pDM_DBManagerTask->getStdConnection());
      CPP_HEAT_PLANT     PP_HEAT_PLANT (m_pDM_DBManagerTask->getStdConnection());
      CPD_HEAT_PLANT_REF PD_HEAT_PLANT_REF (m_pDM_DBManagerTask->getStdConnection());  
      CPD_HEAT_REF       PD_HEAT_REF   (m_pDM_DBManagerTask->getStdConnection());

      //update or insert Steelgrade and Order in PP_ tables // order change is not regarded
      RetValue = RetValue && PP_ORDER.updateInsertPP(OrderId, SteelgradeCode, UserCode, Commit, m_lastError);
      RetValue = RetValue && PP_HEAT.updateInsertPP(HeatInfo.HeatId, OrderId, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, UserCode, Commit, m_lastError);

      // Incoming ladle
      RetValue = RetValue && handlePDTablesOnLadleDataChanged(HeatInfo, UserCode, CSMC_DBData::unspecString, PDData.PreLadleNo, PDData.PreLadleType, Commit); 

      //RetValue = RetValue && addSampleAnalysisRef(HeatInfo, UserCode, PDData, SampleRef, Commit);
     
      if ( Status == m_HeatStatus.Planned )
      {
        if ( PD_HEAT_REF.hasState(HeatInfo.HeatId,m_HeatStatus.Departure) )
        {
          RetValue = RetValue && PD_HEAT_REF.doSetupHeat(HeatInfo.HeatId, HeatInfo.Plant, Status, UserCode, Commit, m_lastError);

          // Outgoing Ladle
          RetValue = RetValue && PD_HEAT_DATA.doSetupHeatAnnouncement(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, SteelgradeCode, PDData.LadleNo, PDData.LadleType,
                                                          HeatStart, HeatEnd, PDData.SteelMass, PDData.Temp, SampleRef, UserCode, Commit, m_lastError);

          // doCancelHeat is used because maghreb HMI is not selecting the correct Heat
          RetValue = RetValue && PD_HEAT_PLANT_REF.doCancelHeat(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);               
          
          RetValue = RetValue && PP_HEAT_PLANT.doCancelHeat(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
          RetValue = RetValue && PP_HEAT.setPlanned(HeatInfo.HeatId, 1, Commit, m_lastError);
        }
        else
        {
          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_ErrorHeatStatusChange(sMessage, HeatInfo.HeatId.c_str(), HeatInfo.TreatId.c_str(), HeatInfo.Plant.c_str(), CDataConversion::LongToString(Status).c_str());

          setLastError(std::string("ONLY_DEPARTED_HEATS_CAN_BE_RESETED"), 0, "", 1);
          RetValue = false;
        }
      }// if ( Status == m_HeatStatus.Planned )
      else
      {
        if (Status < m_HeatStatus.Departure)
        {
          // Incoming Ladle
          RetValue = RetValue && PD_HEAT_DATA.doSetupHeatTreatmentStart(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, SteelgradeCode, PDData.PreLadleNo, PDData.PreLadleType,
            HeatStart, HeatEnd, PDData.SteelMass, PDData.Temp, SampleRef, UserCode, Commit, m_lastError);
        }
        else if (Status == m_HeatStatus.Departure)
        {
          RetValue = RetValue && PD_HEAT_DATA.doSetupHeat(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, SteelgradeCode, PDData.LadleNo, PDData.LadleType,
            HeatStart, HeatEnd, PDData.SteelMass, PDData.Temp, SampleRef, UserCode, Commit, m_lastError);
        }
        else
        {
          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_ErrorHeatStatusChange(sMessage, HeatInfo.HeatId.c_str(), HeatInfo.TreatId.c_str(), HeatInfo.Plant.c_str(), CDataConversion::LongToString(Status).c_str());

          setLastError(std::string("WRONG_PLANT_UNIT_USE_") + HeatInfo.Plant + "_STATUS", 0, "", 1);
          RetValue = false;
        }

        RetValue = RetValue && handlePDHeatStatus(HeatInfo, Status, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, Commit); 
      }   
    }// if (!IsHeatPlanned)

    if ( Status == m_HeatStatus.Tapping || Status == m_HeatStatus.Departure )
    {
      RetValue = RetValue && CDM_DBManager::handlePDTablesOnDeparture(HeatInfo, OrderId, UserCode, TreatmentPosition, Commit);   
    }
  }// if (RetValue)

  return RetValue;
}

bool CDM_DBManager::handlePDTablesOnSteelGradeChanged(sHeatInfo &HeatInfo, const std::string &SteelGrade, const std::string &Order, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDTablesOnSteelGradeChanged",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_HEAT_DATA           PD_HEAT_DATA          (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA_PRODPRAC  PD_HEAT_DATA_PRODPRAC (m_pDM_DBManagerTask->getStdConnection());
    CPP_ORDER               PP_ORDER              (m_pDM_DBManagerTask->getStdConnection());
		CPD_PLANTSTATUS PD_PLANTSTATUS(m_pDM_DBManagerTask->getStdConnection()); //SARS

    RetValue = RetValue && PD_HEAT_DATA.doSteelGradeChange(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, SteelGrade, Commit, m_lastError);
    if (!RetValue)
    {
      setLastError(PD_HEAT_DATA.getLastError(), 1 );
    }

    RetValue = RetValue && PD_HEAT_DATA_PRODPRAC.doSteelGradeChange(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, SteelGrade, Commit, m_lastError);
    if (!RetValue)
    {
      setLastError(PD_HEAT_DATA_PRODPRAC.getLastError(), 1 );
    }

    RetValue = RetValue && PP_ORDER.doSteelGradeChange(Order, SteelGrade, UserCode, Commit, m_lastError);
    if (!RetValue)
    {
      setLastError(PP_ORDER.getLastError(), 1 );
    }
    
		//SARS
    RetValue = RetValue && PD_PLANTSTATUS.changeAimData(HeatInfo.Plant, HeatInfo.PlantNo, HeatInfo.HeatId, HeatInfo.TreatId, SteelGrade,CSMC_DBData::unspecLong,CSMC_DBData::unspecDate,Commit, m_lastError);
    if (!RetValue)
    {
      setLastError(PD_PLANTSTATUS.getLastError(), 1 );
    }

  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDTablesOnTappingStart(sHeatInfo &HeatInfo, const std::string& UserCode, const long& TreatmentPosition, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDTablesOnTappingStart",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    //Set status
    RetValue = RetValue && handlePDHeatStatus(HeatInfo, m_HeatStatus.Tapping, UserCode, TreatmentPosition, Commit);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDTablesOnTempMeasurement(sHeatInfo &pHeatInfo, sPDData &PDData, const std::string &pUser, long &pSampCounter, bool Commit)
{
  bool result = (m_pDM_DBManagerTask != NULL);

  if (result)
  {
    CPD_HEAT_DATA   PD_HEAT_DATA(m_pDM_DBManagerTask->getStdConnection());
    CPD_SAMPLE_REF  PD_SAMPLE_REF(m_pDM_DBManagerTask->getStdConnection());

    //get SAMPLE_REF of the heat
    result = result && PD_HEAT_DATA.select(pHeatInfo.HeatId, pHeatInfo.TreatId, pHeatInfo.Plant);

    if (result)
    {
      PDData.SampleRef            = PD_HEAT_DATA.getSAMPLE_REF(1);
      PDData.OverWriteSampleTime  = true;
      
      //if SAMPLE_REF in PD_HEAT_DATA is empty -> must by updated
      bool updatePDHeatData = (PDData.SampleRef == DEF::Inv_Long);

      long SAMPLE_REF = CSMC_DBData::unspecLong;
      //update Sample
      result = result && addSampleAnalysisRef(pHeatInfo, pUser, PDData, SAMPLE_REF, Commit); 

      //if the SAMPLE_REF in PD_HEAT_DATA is empty -> must by updated 
      if (updatePDHeatData)
        result = result && PD_HEAT_DATA.doSampleRefUpdate(pHeatInfo.HeatId, pHeatInfo.TreatId, pHeatInfo.Plant, SAMPLE_REF, Commit, m_lastError);
      
      //set the output variable
      pSampCounter = PD_SAMPLE_REF.getSampleCounter(SAMPLE_REF, DEF_GC_MEASUREMENT_TYPE::Temp);
    }
    else
    {
      //heat does not exists in PD_HEAT_DATA
      setLastError("Heat " + pHeatInfo.HeatId + " not exists in PD_HEAT_DATA", 0, 
        "select count(*) from PD_HEAT_DATA " + PD_HEAT_DATA.getWhereStatement());
    }
  }

  checkLastError();

  return result;
}


bool CDM_DBManager::handlePPTabelsOnAnnounce(sHeatInfo &HeatInfo, sPDData &PDData, const std::string &HeatIdCust, std::string &TreatIdCust, const std::string &Order, const std::string &SteelGrade, const CDateTime &TreatEnd, const bool &OnRequest, const std::string &UserCode, double &AimWeight, double &AimTemp, long TreatmentMode, bool Commit)
{
  log("++++++ CDM_DBManager::handlePPTabelsOnAnnounce",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    // to get all data base errors
    CPP_ORDER_SINGLE_AIMS PP_ORDER_SINGLE_AIMS  (m_pDM_DBManagerTask->getStdConnection());
    CGT_GRADE_SINGLE_AIMS GT_GRADE_SINGLE_AIMS  (m_pDM_DBManagerTask->getStdConnection());

    CGT_PARAM             GT_PARAM              (m_pDM_DBManagerTask->getStdConnection());

    CPP_ORDER             PP_ORDER              (m_pDM_DBManagerTask->getStdConnection());
    CPP_HEAT              PP_HEAT               (m_pDM_DBManagerTask->getStdConnection());
    CPP_HEAT_PLANT        PP_HEAT_PLANT         (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA         PD_HEAT_DATA          (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_PLANT_REF    PD_HEAT_PLANT_REF     (m_pDM_DBManagerTask->getStdConnection());

    if ( AimTemp == CSMC_DBData::unspecDouble || AimTemp <= 1000. )
    {
      if ( GT_GRADE_SINGLE_AIMS.select(HeatInfo.Plant, SteelGrade) )
      {
        AimTemp = GT_GRADE_SINGLE_AIMS.getAIMTEMP(1);

        std::string Message = "USING AIMTEMP " + CDataConversion::DoubleToString(AimTemp);

        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_DBReadInfo(sMessage, DEF_GC_PP_ORDER_SINGLE_AIMS::AIMTEMP.c_str(), "GT_GRADE_SINGLE_AIMS", Message.c_str());
      }
      else
      {
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_DBReadError(sMessage,"AIMTEMP","GT_GRADE_SINGLE_AIMS","AIMTEMP MISSING");
      }
    }

    if ( AimWeight == CSMC_DBData::unspecDouble || AimWeight <= 0. )
    {
      if ( GT_PARAM.selectByPlant(HeatInfo.Plant,HeatInfo.PlantNo,"DefltAimSteelMass",0,DEF_GC_PARAM_TYPE::DParam) )
      {
        AimWeight = CDataConversion::StringToDouble(GT_PARAM.getVALUE(1),AimWeight);

        std::string Message = "USING AIMSTEEL " + CDataConversion::DoubleToString(AimWeight);

        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_DBReadInfo(sMessage, DEF_GC_PP_ORDER_SINGLE_AIMS::AIMSTEEL.c_str(), "GT_PARAM", Message.c_str());
      }  
      else
      {
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_DBReadError(sMessage,"DefltAimSteelMass","GT_PARAM","PARAM MISSING");
      }
    }     

    
    RetValue = RetValue && PP_ORDER.updateInsertPP(Order, SteelGrade, UserCode, Commit, m_lastError);     
    RetValue = RetValue && PP_ORDER_SINGLE_AIMS.updateInsertPP(Order, HeatInfo.Plant, std::string(DEF_GC_PP_ORDER_SINGLE_AIMS::AIMSTEEL),      CDataConversion::DoubleToString(AimWeight),   Commit, m_lastError);
    RetValue = RetValue && PP_ORDER_SINGLE_AIMS.updateInsertPP(Order, HeatInfo.Plant, std::string(DEF_GC_PP_ORDER_SINGLE_AIMS::AIMTEMP),       CDataConversion::DoubleToString(AimTemp),     Commit, m_lastError);
    
    // if TreatmentMode is not avialable (TreatmentMode == DEF::Inv_Long) it will not be stored
    if ( TreatmentMode != DEF::Inv_Long )
    { // special for EAF
      RetValue = RetValue && PP_ORDER_SINGLE_AIMS.updateInsertPP(Order, HeatInfo.Plant, std::string(DEF_GC_PP_ORDER_SINGLE_AIMS::TREATMENTMODE), CDataConversion::LongToString(TreatmentMode), Commit, m_lastError);
//      RetValue = RetValue && PP_ORDER_SINGLE_AIMS.updateInsertPP(Order, HeatInfo.Plant, std::string(DEF_GC_PP_ORDER_SINGLE_AIMS::AIMHOTHEEL), DEF::Inv_String, Commit, m_lastError);
    }
    //check for Heat Id is empty -> get sequence ID
    if (HeatInfo.HeatId.empty())
    {
      RetValue = RetValue && PP_HEAT.getNextHeatId(HeatInfo.HeatId, m_lastError);
    }
    if (HeatInfo.TreatId.empty())
    {
      CTreatID TreatID;
      HeatInfo.TreatId = TreatID.generateNextTreatID("0"); 
    }

    if ( PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant) )
    {
      //PD_HEAT_PLANT_REF.doCancelHeat(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
      PD_HEAT_DATA.doCancelHeat(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
      // manage TreatID by using format !
      CTreatID TreatID;

      HeatInfo.TreatId = TreatID.generateNextTreatID(HeatInfo.TreatId); 

      // should not be in heat announcement use case
      CDateTime TreatEndAct = PD_HEAT_DATA.getTREATEND_ACT(1);

      if ( TreatEndAct != CSMC_DBData::unspecDate )
      {
        TreatID.setFormat(std::string("CC"));
        TreatIdCust = TreatID.generateNextTreatID(TreatIdCust);
      }
    }

    CDateTime TreatStart;

    // changing from planning to production
    long Planned = 0 ;

    RetValue = RetValue && PP_HEAT.updateInsertPP(HeatInfo.HeatId, Order,  CSMC_DBData::unspecString, CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, UserCode,  CSMC_DBData::unspecLong, Planned, CSMC_DBData::unspecLong,CSMC_DBData::unspecString, CSMC_DBData::unspecLong, Commit, m_lastError);
    RetValue = RetValue && PP_HEAT_PLANT.updateInsertPP(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, HeatIdCust, TreatIdCust, TreatStart, TreatEnd, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::heatScheduleOnAnnouncement(sHeatInfo &HeatInfo, const std::string &UserCode,const long &TreatmentPosition, bool Commit)
{
  log("++++++ CDM_DBManager::heatScheduleOnAnnouncement",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_HEAT_REF        PD_HEAT_REF       (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_PLANT_REF  PD_HEAT_PLANT_REF (m_pDM_DBManagerTask->getStdConnection());

    // JAST
    // Heat Announcment is not a status for PD_HEAT_REF but for PD_HEAT_PLANT_REF only
    // PD_HEAT_REF gives the over-all state of a heat 
    // we shall not influence a heat at plant A when this is announced at plant B for reasons of pre-calculation
    RetValue = RetValue && PD_HEAT_REF.doAnnouncement(HeatInfo.HeatId, HeatInfo.Plant, UserCode, Commit, m_lastError);  // internal logic was changed
    RetValue = RetValue && PD_HEAT_PLANT_REF.write(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, DEF_GC_STATUS::HeatAnnounced, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::heatScheduleOnCancelHeat(sHeatInfo &HeatInfo, std::string &HeatCustId, const long &TreatmentPosition, bool Commit)
{
  log("++++++ CDM_DBManager::heatScheduleOnCancelHeat",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  if (RetValue)
  {  
    CPP_HEAT           PP_HEAT            (m_pDM_DBManagerTask->getStdConnection());
    CPP_HEAT_PLANT     PP_HEAT_PLANT      (m_pDM_DBManagerTask->getStdConnection());
    CPP_ORDER          PP_ORDER           (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_PLANT_REF PD_HEAT_PLANT_REF  (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_REF       PD_HEAT_REF        (m_pDM_DBManagerTask->getStdConnection());
    CPD_PLANTSTATUS    PD_PLANTSTATUS     (m_pDM_DBManagerTask->getStdConnection());

    CPD_HEAT_DATA      PD_HEAT_DATA       (m_pDM_DBManagerTask->getStdConnection());

    // ***********************************************************************************************************
    // handle PP tables first
    // ***********************************************************************************************************
    // under special circumstances planning data may be removed when heat is in production !
    // ***********************************************************************************************************

    if ( PP_HEAT.select(HeatInfo.HeatId) && PP_HEAT_PLANT.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant) )
    {    
      std::string OrderId = PP_HEAT.getPRODORDERID(1);

      if ( OrderId == CSMC_DBData::unspecString )
      {
        setLastError("NO_HEAT_DATA_FOUND", 0, PP_HEAT.getActStatement());
      }

      // check if the heat was planned by schedule or on operator request during announcment of a unkwon heat -> PP_ORDER.ON_REQUEST == 1
      if (OrderId != CSMC_DBData::unspecString && PP_ORDER.select(OrderId) && PP_ORDER.getON_REQUEST(1) == 0)
      {
        RetValue = RetValue && PP_HEAT_PLANT.doCancelHeat(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
      }
      else
      {
        //delete the Planned heat from PP_HEAT_PLANT
        RetValue = RetValue && PP_HEAT_PLANT.deleteRow(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);

        //Test if the row with the current HeatId can be deleted from the PP_HEAT
        if (RetValue && !PP_HEAT_PLANT.exists(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))        
        {
          //No rows left in the PP_HEAT_PLANT, row can be deleted from PP_HEAT          
          RetValue = RetValue && PP_HEAT.deleteRow(HeatInfo.HeatId, Commit, m_lastError);
        }
        //delete order on operator request from PP_ORDER    
        if (RetValue && OrderId != CSMC_DBData::unspecString && PP_ORDER.select(OrderId) && PP_ORDER.getON_REQUEST(1) == 1)
        {
          // PP_ORDER_SINGLE_AIMS will be cleared because of ON DELETE CASCADE CONSTRAINT
          RetValue = RetValue && PP_ORDER.deletePP(OrderId, Commit, m_lastError);
        }
      }
    }
    else
    {
      setLastError("NO_HEAT_DATA_FOUND", 0, PP_HEAT_PLANT.getActStatement());
    }

    // ***********************************************************************************************************
    // proceed with PD tables even if PP tables have no respective data !
    // ***********************************************************************************************************
    if (RetValue)
    {  
      RetValue = RetValue && PD_HEAT_DATA.doCancelHeat(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
      //Update the REFerence tables
      RetValue = RetValue && PD_HEAT_PLANT_REF.doCancelHeat(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
      RetValue = RetValue && PD_HEAT_REF.doCancelHeat(HeatInfo.HeatId, Commit, m_lastError);

      //remove the heat info from table
      RetValue = RetValue && PD_PLANTSTATUS.resetPlantStatus(HeatInfo.Plant, HeatInfo.PlantNo, TreatmentPosition, Commit, m_lastError);
    }
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::heatScheduleOnDeparture(sHeatInfo &HeatInfo, const std::string &UserCode, const long &TreatmentPosition, bool Commit)
{
  log("++++++ CDM_DBManager::heatScheduleOnDeparture",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_HEAT_REF    PD_HEAT_REF(m_pDM_DBManagerTask->getStdConnection());
    
    RetValue = RetValue && handlePDHeatStatus(HeatInfo, m_HeatStatus.Departure, UserCode, TreatmentPosition, Commit);

     //Set status
    RetValue = RetValue && PD_HEAT_REF.doDeparture(HeatInfo.HeatId, HeatInfo.Plant, UserCode, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDPretreatDataOnDeparture(sHeatInfo &HeatInfo, const std::string &OrderId, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDPretreatDataOnDeparture",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if(RetValue)
  { 
    CPD_PRETREATDATA   PD_PRETREATDATA    (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA      PD_HEAT_DATA       (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_PLANT_REF PD_HEAT_PLANT_REF  (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_REF       PD_HEAT_REF        (m_pDM_DBManagerTask->getStdConnection());
    CPD_SAMPLE_REF     PD_SAMPLE_REF      (m_pDM_DBManagerTask->getStdConnection());
    CPD_SAMPLE         PD_SAMPLE          (m_pDM_DBManagerTask->getStdConnection());

    CDateTime Now;
    sPDData PDData;

    CDM_ProductManagementInterface_Impl *dataProvider = m_pDM_DBManagerTask->getpProductManagementInterface();
    double DurSinceHeatAnnounce = dataProvider->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatAnnounce);
    double DurSinceHeatStart    = dataProvider->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatStart);

    long HeatStatusNo         = CSMC_DBData::unspecLong;
    std::string SteelGrade    = CSMC_DBData::unspecString;
    std::string OrderId       = CSMC_DBData::unspecString;
    std::string HEATID_CUST   = CSMC_DBData::unspecString;
    std::string TREATID_CUST  = CSMC_DBData::unspecString;
    long SAMPLE_REF           = CSMC_DBData::unspecLong;

    //1. Fill PD_PRETREAT_DATA.HEAT_STATUSNO from PD_HEAT_REF.HEAT_STATUSNO
    if (PD_HEAT_REF.select(HeatInfo.HeatId))
    {
      HeatStatusNo = PD_HEAT_REF.getHEATSTATUSNO(1);
    }

    if( PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant) )
    {
      SteelGrade = PD_HEAT_DATA.getSTEELGRADECODE_ACT(1);

      if(SteelGrade == CSMC_DBData::unspecString)
        SteelGrade = PD_HEAT_DATA.getSTEELGRADECODE_PLAN(1);

      // calculated steel mass
      PDData.SteelMass    = PD_HEAT_DATA.getSTEELMASS(1);
      PDData.SlagMass     = PD_HEAT_DATA.getSLAGMASS(1);
      SAMPLE_REF          = PD_HEAT_DATA.getSAMPLE_REF(1);

      // Outgoing Ladle
      PDData.LadleNo      = PD_HEAT_DATA.getLADLENO(1);
      PDData.LadleType    = PD_HEAT_DATA.getLADLETYPE(1);
     
      OrderId             = PD_HEAT_DATA.getPRODORDERID_ACT(1);
    }

    if( SAMPLE_REF != CSMC_DBData::unspecLong && PD_SAMPLE_REF.select(SAMPLE_REF) )
    {
      long SC_SLAG_CLAC  = PD_SAMPLE_REF.getSLAG_CALC(1);
      long SC_STEEL_CALC = PD_SAMPLE_REF.getSTEEL_CALC(1);
      long SC_TEMP_CALC  = PD_SAMPLE_REF.getTEMP_CALC(1);

      PDData.OverWriteSampleTime = true;

      // for next treatment use only calculated values
      if ( SC_TEMP_CALC  != CSMC_DBData::unspecLong || 
           SC_SLAG_CLAC  != CSMC_DBData::unspecLong || 
           SC_STEEL_CALC != CSMC_DBData::unspecLong )
      {
        PD_SAMPLE_REF.setREVTIME(Now);

        if ( SC_SLAG_CLAC != CSMC_DBData::unspecLong )
        {
          if ( PD_SAMPLE_REF.getSLAG(1) != CSMC_DBData::unspecLong )
          {
            PD_SAMPLE.updateSampleDetails(SC_SLAG_CLAC, OrderId, CSMC_DBData::unspecLong, CSMC_DBData::unspecString, DEF_GC_SAMPLEUSABLE::usablewithoutsampletaken, "Model", CSMC_DBData::unspecString, CSMC_DBData::unspecLong);
            // set actual sample time of calculated sample
            PD_SAMPLE.updateSampleTimes(SC_SLAG_CLAC, Now, Now, Now, DurSinceHeatAnnounce, DurSinceHeatStart, PDData.OverWriteSampleTime);
            // if a slag sample exists use the calculated sample
            PD_SAMPLE_REF.setSLAG(SC_SLAG_CLAC);
          }

          PD_SAMPLE_REF.setSLAG_CALC(CSMC_DBData::unspecLong);
        }

        if ( SC_STEEL_CALC != CSMC_DBData::unspecLong )
        {
          PD_SAMPLE.updateSampleDetails(SC_STEEL_CALC, OrderId, CSMC_DBData::unspecLong, CSMC_DBData::unspecString,  DEF_GC_SAMPLEUSABLE::usablewithoutsampletaken, "Model", CSMC_DBData::unspecString, CSMC_DBData::unspecLong);
          // set actual sample time of calculated sample
          PD_SAMPLE.updateSampleTimes(SC_SLAG_CLAC, Now, Now, Now, DurSinceHeatAnnounce, DurSinceHeatStart, PDData.OverWriteSampleTime);
          PD_SAMPLE_REF.setSTEEL(SC_STEEL_CALC);
          PD_SAMPLE_REF.setSTEEL_CALC(CSMC_DBData::unspecLong);
        }

        if ( SC_TEMP_CALC             != CSMC_DBData::unspecLong && 
             PD_SAMPLE_REF.getTEMP(1) == CSMC_DBData::unspecLong )
        {
          PD_SAMPLE.updateSampleDetails(SC_TEMP_CALC, OrderId, DEF_GC_SAMPLEMODE::automatic,CSMC_DBData::unspecString,  DEF_GC_SAMPLEUSABLE::usablewithoutsampletaken, "Model", CSMC_DBData::unspecString, CSMC_DBData::unspecLong);
          // set actual sample time of calculated sample
          PD_SAMPLE.updateSampleTimes(SC_TEMP_CALC, Now, Now, Now, DurSinceHeatAnnounce, DurSinceHeatStart, PDData.OverWriteSampleTime);
          // if no temp measurement exists use the calculated sample
          PD_SAMPLE_REF.setTEMP(SC_TEMP_CALC);
          PD_SAMPLE_REF.setTEMP_CALC(CSMC_DBData::unspecLong);
        }

        RetValue = RetValue && PD_SAMPLE_REF.update();

      }// for next treatment use only calculated values
    }// if( SAMPLE_REF != CSMC_DBData::unspecLong && PD_SAMPLE_REF.select(SAMPLE_REF) )

    if ( PD_HEAT_PLANT_REF.selectDataByExpirationDate(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, false) )
    {
      HEATID_CUST =  PD_HEAT_PLANT_REF.getHEATID_CUST(1);
      TREATID_CUST = PD_HEAT_PLANT_REF.getTREATID_CUST(1);
    }

    // Outgoing Ladle
    RetValue = RetValue && PD_PRETREATDATA.updateInsert(HeatInfo.HeatId, HeatInfo.TreatId, OrderId, HeatInfo.Plant, 
                          HeatInfo.PlantNo, SteelGrade, HEATID_CUST, TREATID_CUST, PDData.SteelMass, PDData.SlagMass, SAMPLE_REF, 
                          PDData.LadleType, PDData.LadleNo, UserCode, HeatStatusNo, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;

}

bool CDM_DBManager::insertOrder(sHeatInfo &HeatInfo, const std::string &Order, const std::string &SteelGrade, const double AimWeight, const std::string &UserCode, bool Commit)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    // to get all data base errors
    CPP_ORDER PP_ORDER(m_pDM_DBManagerTask->getStdConnection());
    CPP_ORDER_SINGLE_AIMS PP_ORDER_SINGLE_AIMS(m_pDM_DBManagerTask->getStdConnection());
    CPP_HEAT PP_HEAT(m_pDM_DBManagerTask->getStdConnection());

    //check for Heat Id is empty -> get sequence ID
    if (HeatInfo.HeatId.empty())
    {
      RetValue = RetValue && PP_HEAT.getNextHeatId(HeatInfo.HeatId, m_lastError);
    }
    if (HeatInfo.TreatId.empty())
    {
      CTreatID NewTreatID;
      HeatInfo.TreatId = NewTreatID.getTreatID("",1);
    }
    //insert order
    RetValue = RetValue && PP_ORDER.updateInsertPP(Order, SteelGrade, UserCode, Commit, m_lastError);
    RetValue = RetValue && PP_ORDER_SINGLE_AIMS.updateInsertPP(Order, HeatInfo.Plant, std::string(DEF_GC_PP_ORDER_SINGLE_AIMS::AIMSTEEL), CDataConversion::DoubleToString(AimWeight), Commit, m_lastError);
    //insert PP_heat
    RetValue = RetValue && PP_HEAT.updateInsertPP(HeatInfo.HeatId, Order, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, UserCode, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::insertPlannedHeat(sHeatInfo &HeatInfo, const std::string &HeatIdCust, const std::string &TreatIdCust, const std::string &Order, const std::string &UserCode, CDateTime &TreatEnd, bool Commit)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPP_HEAT       PP_HEAT(m_pDM_DBManagerTask->getStdConnection());
    CPP_HEAT_PLANT PP_HEAT_PLANT(m_pDM_DBManagerTask->getStdConnection());  

    //check for Heat Id is empty -> get sequence ID
    if (HeatInfo.HeatId.empty())
    {
      RetValue = RetValue && PP_HEAT.getNextHeatId(HeatInfo.HeatId, m_lastError);
    }
    if (HeatInfo.TreatId.empty())
    {
      CTreatID NewTreatID;
      HeatInfo.TreatId = NewTreatID.getTreatID("",1);
    }

    bool isOnRequest = false;
    CDateTime TreatStart;

    RetValue = RetValue && PP_HEAT.updateInsertPP(HeatInfo.HeatId, Order, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, UserCode, Commit, m_lastError);
    RetValue = RetValue && PP_HEAT_PLANT.updateInsertPP(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, HeatIdCust, TreatIdCust, TreatStart, TreatEnd, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::isOnRequest(std::string &pPlan, std::string &UserCode)
{
  log("++++++ CDM_DBManager::isOnRequest",3);

  log("Is OnRequest: Plan: '" + pPlan + "' User: '" + UserCode + "'", 3);

  //The both parameters can not be empty
  bool RetValue = !(pPlan.empty() && UserCode.empty());
  if (RetValue)
  {
    //if the parameters are equal then no OnRequest
    RetValue = (pPlan.compare(UserCode) != 0);// !=0 => strings are not equal than true

    if (RetValue)
    {
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);

      pEventLog->EL_LogMessage(sMessage, "OnRequest(): Value is modified by HMI user" );
    }
    else
    {
      log("OnRequest(): Value was not modified", 3);
    }
      
  }
  else
    log("OnRequest(): Compared values are empty!!", 1);

  return RetValue;

}

void CDM_DBManager::log(cCBS_ODBC_DBError& CBS_ODBC_DBError, long _level)
{
  std::stringstream Message;
  Message << m_lastError.m_MessageText 
          << " - " 
          << m_lastError.m_NativeErrorCode 
          << " - " 
          << m_lastError.m_SQLState;

  log(Message.str(), _level);
}

void CDM_DBManager::log(const std::string& _message, long _level)
{
  if (m_pDM_DBManagerTask)
  {
    m_pDM_DBManagerTask->log(_message, _level);
  }
}

bool CDM_DBManager::isHeatPlanned(sHeatInfo &HeatInfo)
{
  log("++++++ CDM_DBManager::isHeatPlanned",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPP_HEAT PP_HEAT(m_pDM_DBManagerTask->getStdConnection());
    CPP_HEAT_PLANT PP_HEAT_PLANT(m_pDM_DBManagerTask->getStdConnection());

    RetValue = RetValue && PP_HEAT.exists(HeatInfo.HeatId);
    RetValue = RetValue && PP_HEAT_PLANT.exists(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant);
  }
  return RetValue;
}

bool CDM_DBManager::isOrdered(const std::string &Order)
{
  log("++++++ CDM_DBManager::isOrdered",3);

  bool result = (m_pDM_DBManagerTask != NULL);
  if (result)
  {
    CPP_ORDER PP_ORDER(m_pDM_DBManagerTask->getStdConnection());

    result = PP_ORDER.exists(Order);
  }
  return result;
}


//reset Last Error structure
void CDM_DBManager::resetLastError()
{
  log("++++++ CDM_DBManager::resetLastError",3);

  m_lastError.m_MessageText     = "";
  m_lastError.m_NativeErrorCode = -1;
  m_lastError.m_SQLState        = "";

  m_lastErrorOpAcknowledge      = 0;
}

void CDM_DBManager::sendEventLog(sEventLogMessage &Event, std::string &pException, std::string &pFunction, std::string &pAction)
{
  log("++++++ CDM_DBManager::sendEventLog",3);

  size_t pos = 0;

  while((pos = pException.find('\n')) != std::string::npos) 
  {
    pException.replace(pos,1,"");
  }

  pos = 0;
  while((pos = pFunction.find('\n')) != std::string::npos) 
  {
    pFunction.replace(pos,1,"");
  }

  pos = 0;
  while((pos = pAction.find('\n')) != std::string::npos) 
  {
    pAction.replace(pos,1,"");
  }

  //write event log
  if ( Event.opAckn == 1 )
  {
    std::string HMIMessage = pException + " " + pFunction;
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    pEventLog->EL_HandleHMIOperatorAcknowledge(Event, HMIMessage.c_str() );
  }
  else
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    pEventLog->EL_ExceptionCaught(Event, pException.c_str(), pFunction.c_str(), pAction.c_str());
  }
}

bool CDM_DBManager::setEquipmentAgeByHeat(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::setEquipmentAgeByHeat",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CEquipmentData EquipmentData(m_pDM_DBManagerTask->getStdConnection());

    //increase life by 1 for all equipment with HEATS type
    //RetValue = RetValue && EquipmentData.increaseEquipmentAge(HeatInfo.Plant, HeatInfo.PlantNo, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, DEF_GC_COUNTER_TYPE::HEATS, 1., Commit);
		//SANKAR
    RetValue = RetValue && EquipmentData.increaseEquipmentAge(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant, HeatInfo.PlantNo, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, DEF_GC_COUNTER_TYPE::HEATS, 1., Commit);

    if (!RetValue)
    {
      m_lastError = EquipmentData.getLastError();

      log(m_lastError,3);
    }
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::setEquipmentAgeByWeight(sHeatInfo &HeatInfo, double Weight, bool Commit)
{
  log("++++++ CDM_DBManager::setEquipmentAgeByWeight",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CEquipmentData EquipmentData(m_pDM_DBManagerTask->getStdConnection());

    //increase life for all equipment with TONS type
    if(Weight > 0.)
    {
      double WeightInTons = Weight / 1000.;
			//SANKAR
      //RetValue = RetValue && EquipmentData.increaseEquipmentAge(HeatInfo.Plant, HeatInfo.PlantNo, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, DEF_GC_COUNTER_TYPE::TONS, WeightInTons,  Commit);
        RetValue = RetValue && EquipmentData.increaseEquipmentAge(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant, HeatInfo.PlantNo, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, DEF_GC_COUNTER_TYPE::TONS, WeightInTons, Commit);
    }

    if (!RetValue)
    {
      m_lastError = EquipmentData.getLastError();

      log(m_lastError,3);
    }
  }

  checkLastError();

  return RetValue;
}

void CDM_DBManager::checkLastError()
{
  if ( isError(m_lastError) )
  {
    setLastError(m_lastError, m_lastErrorOpAcknowledge);
  }
}



bool CDM_DBManager::isError(cCBS_ODBC_DBError& Error)
{
  bool RetValue = true;
  
  if ( Error.m_MessageText.empty() )
  {
    RetValue = false;
  }

  return RetValue;
}

void CDM_DBManager::setLastError(cCBS_ODBC_DBError& LastError, long OpAcknowledge )
{
  log("++++++ CDM_DBManager::setLastError",3);

  m_SMC_ErrorHandler.setError(LastError, OpAcknowledge);

  std::stringstream Message;
  Message << LastError;

  log(Message.str(), 1);

  resetLastError();
}

void CDM_DBManager::setLastError(const std::string &ErrorMessage, long ErrCode, const std::string &SQL, long OpAcknowledge )
{
  log("++++++ CDM_DBManager::setLastError",3);

  m_SMC_ErrorHandler.setError(ErrorMessage, ErrCode, SQL, OpAcknowledge );

  std::stringstream Message;
  Message << ErrorMessage 
    << " - " 
    << ErrCode 
    << " - " 
    << SQL;

  log(Message.str(), 1);

  resetLastError();
}

void CDM_DBManager::splitPlantPlantNo(std::string &PlantID, std::string &Plant, long &PlantNo)
{
  log("++++++ CDM_DBManager::splitPlantPlantNo",3);


  std::string ActPlantID = PlantID;

  if ( m_pGC_Plant_Container )
  {
    Plant    = m_pGC_Plant_Container->getPlant(ActPlantID);
    PlantNo  = m_pGC_Plant_Container->getPlantNo(ActPlantID);
  }
  else
  {
    Plant    = "";
    PlantNo  = 0;
  }

  if ( Plant.empty()|| PlantNo == 0 )
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DBReadError(sMessage, "PLANT or PLANTO" , "GC_PLANT" , PlantID.c_str() );
  }
}

void CDM_DBManager::setHeatInfo(CEventMessage &Event, sHeatInfo &HeatInfo)
{
  log("++++++ CDM_DBManager::setHeatInfo",3);

  HeatInfo.HeatId             = Event.getHeatID();
  HeatInfo.TreatId            = Event.getTreatID();
  HeatInfo.Plant              = Event.getPlantID();
  HeatInfo.ProductId          = Event.getProductID();

  splitPlantPlantNo(HeatInfo.Plant, HeatInfo.Plant, HeatInfo.PlantNo);
}


bool  CDM_DBManager::updateMaterialAmount( std::string Plant,long PlantNo,seqMaterials &sqMat,bool IsContainAllMat,bool Commit)
{
  log("++++++ CDM_DBManager::updateMaterialAmount",3);

  bool RetValue = m_pDM_DBManagerTask != NULL;
  bool Transaction = true;
  if (RetValue)
  {    
    CPD_MAT_AVAIL mPD_Mat_Avail(m_pDM_DBManagerTask->getStdConnection());

    //Avoid keeping material which is not sent by L1 Material PLC.
    if(IsContainAllMat == true)
    {
      mPD_Mat_Avail.deleteRow(Plant,PlantNo,DEF_GC_RECIPE_SOURCE::Bin,CSMC_DBData::unspecLong,CSMC_DBData::unspecString);   
    }

    sMaterial SMaterial;
    long MatLength = CIntfData::getLength(sqMat);

    for (long idx=0; idx<MatLength; idx++)
    {
      CIntfData::getAt(SMaterial,sqMat,idx);
      std::string MaterialCode = SMaterial.MatCode;
      std::string MaterialPurpose = SMaterial.Purpose;
      if(MaterialCode.empty())
        continue;
      long  MatSource = SMaterial.Source;
      long SourceNo = SMaterial.SourceNo;
      std::string Source;
      if(MatSource == 1)
        Source = DEF_GC_RECIPE_SOURCE::Bin;
      else if(MatSource == 2)
        Source = DEF_GC_RECIPE_SOURCE::Hand;
      else if(MatSource == 3)
        Source = DEF_GC_RECIPE_SOURCE::Wire;
      Transaction = mPD_Mat_Avail.updateOrInsertRow(Plant,PlantNo,Source,SourceNo,MaterialCode,SMaterial.MatWeight);
      if(!Transaction)
        break;
    }

    if (Transaction)
    {
      if(Commit)
      {
        mPD_Mat_Avail.commit();
        RetValue = true;
      }
    }
    else
    {
      mPD_Mat_Avail.rollback();
      RetValue = false;
    }
  }
  return RetValue;
}

bool  CDM_DBManager::updateMaterialPurpose(std::string Plant,long PlantNo,seqMaterials &sqMat,bool IsContainAllMat,bool Commit)
{
  log("++++++ CDM_DBManager::updateMaterialPurpose",3);

  bool RetValue = m_pDM_DBManagerTask != NULL;
  bool Transaction = true;
  if (RetValue)
  {    
    CGT_MAT_PURP m_GtMatPurp(m_pDM_DBManagerTask->getStdConnection());

    sMaterial SMaterial;
    std::string strPurposeCodeLast = "";
    long MatLength = CIntfData::getLength(sqMat);
    long UnitGroupNo = m_pGC_Plantgroup_Container->getUnitGroupNo(Plant, PlantNo);       
  
    for (long idx=0; idx<MatLength; idx++)
    {
      CIntfData::getAt(SMaterial,sqMat,idx);
      std::string MaterialCode = SMaterial.MatCode;
      std::string MaterialPurpose = SMaterial.Purpose; 

      if(MaterialCode.empty() || MaterialPurpose.empty())
        continue;

      if(IsContainAllMat && strPurposeCodeLast != MaterialPurpose) //remove all old matcode
      {
        m_GtMatPurp.deleteRow(UnitGroupNo,CSMC_DBData::unspecString,MaterialPurpose);
      }

      if (m_GtMatPurp.select( UnitGroupNo, MaterialCode, MaterialPurpose))
      {
        if (SMaterial.MatWeight <= 0)
          Transaction = Transaction && m_GtMatPurp.deleteRow(UnitGroupNo,MaterialCode, MaterialPurpose);
      }
      else // no relation -> insert 
        Transaction = Transaction && m_GtMatPurp.insertRow(UnitGroupNo,MaterialCode, MaterialPurpose);

      if(!Transaction)
        break;
      strPurposeCodeLast = MaterialPurpose;
    }

    if (Transaction)
    {
      if(Commit)
      {
         m_GtMatPurp.commit();
         RetValue = true;
      }
    }
    else
    {
      m_GtMatPurp.rollback();
      RetValue = false;
    }
  }
  return RetValue;
}

bool CDM_DBManager::updateOrder(const std::string &Order, const std::string &Plant, const std::string &SteelGrade, const double AimWeight, const std::string &UserCode, bool Commit)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    // to get all data base errors
    CPP_ORDER PP_ORDER(m_pDM_DBManagerTask->getStdConnection());
    CPP_ORDER_SINGLE_AIMS PP_ORDER_SINGLE_AIMS(m_pDM_DBManagerTask->getStdConnection());

    RetValue = RetValue && PP_ORDER.updateInsertPP(Order, SteelGrade, UserCode, Commit, m_lastError);  
    RetValue = RetValue && PP_ORDER_SINGLE_AIMS.updateInsertPP(Order, Plant, std::string(DEF_GC_PP_ORDER_SINGLE_AIMS::AIMSTEEL), CDataConversion::DoubleToString(AimWeight), Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::updatePlannedHeat(sHeatInfo &HeatInfo, const std::string &HeatIdCust, const std::string &TreatIdCust, const std::string &Order, const std::string &UserCode, CDateTime &TreatEnd, bool Commit)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPP_HEAT PP_HEAT(m_pDM_DBManagerTask->getStdConnection());
    CPP_HEAT_PLANT PP_HEAT_PLANT(m_pDM_DBManagerTask->getStdConnection());

    bool isOnRequest = false;
    CDateTime TreatStart;

    RetValue = RetValue && PP_HEAT.updateInsertPP(HeatInfo.HeatId, Order, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, UserCode, Commit, m_lastError);
    RetValue = RetValue && PP_HEAT_PLANT.updateInsertPP(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, HeatIdCust, TreatIdCust, TreatStart, TreatEnd, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

// method will assign most actual analysis (calculated or measured) to existing SAMPLE_REF of PD_HOTHEEL 
bool CDM_DBManager::writeHotHeelAnalysisOnTappingStart(sHeatInfo &HeatInfo, long Sample_Ref_HotHeel, bool Commit)
{
  log("++++++ CDM_DBManager::writeHotHeelAnalysisOnTappingStart",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_HEAT_DATA         PD_HEAT_DATA        (m_pDM_DBManagerTask->getStdConnection());
    CPD_SAMPLE_REF        PD_SAMPLE_REF       (m_pDM_DBManagerTask->getStdConnection());
    CPD_SAMPLE            PD_SAMPLE           (m_pDM_DBManagerTask->getStdConnection());

    long SAMPLE_COUNTER_HOTHEEL = PD_SAMPLE.getNextSAMPLE_COUNTER(); 
    long SampleUsable           = DEF_GC_SAMPLEUSABLE::usablewithsampletaken; // 1

    // read sample of certain types in descending chronological order
    // create a copy of respective entries and change MEASTYPENO to "HotHeel"-value
    if ( PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant) )
    {
      long Sample_Ref = PD_HEAT_DATA.getSAMPLE_REF(1);

      long Sample_Counter = PD_SAMPLE_REF.getCounterSTEEL_CALC(Sample_Ref); /*"Steel_Calc"*/
      Sample_Counter = CDataConversion::SetInvalidToDefault(Sample_Counter,PD_SAMPLE_REF.getSampleCounter(Sample_Ref,DEF_GC_MEASUREMENT_TYPE::Steel));

      if ( Sample_Counter != CSMC_DBData::unspecLong )
      {
        RetValue = RetValue && PD_SAMPLE.copyToSampleCounter(Sample_Counter, SAMPLE_COUNTER_HOTHEEL, DEF_GC_MEASUREMENT_TYPE::HotHeel, Commit, m_lastError);
      }

      Sample_Counter = PD_SAMPLE_REF.getCounterSLAG_CALC(Sample_Ref); /*"Slag_Calc"*/
      Sample_Counter = CDataConversion::SetInvalidToDefault(Sample_Counter,PD_SAMPLE_REF.getSampleCounter(Sample_Ref,DEF_GC_MEASUREMENT_TYPE::Slag));

      if ( Sample_Counter != CSMC_DBData::unspecLong )
      {
        RetValue = RetValue && PD_SAMPLE.copyToSampleCounter(Sample_Counter, SAMPLE_COUNTER_HOTHEEL, DEF_GC_MEASUREMENT_TYPE::HotHeel, Commit, m_lastError);
      }

      Sample_Counter = PD_SAMPLE_REF.getCounterTEMP_CALC(Sample_Ref); /*"Temp_Calc"*/
      Sample_Counter = CDataConversion::SetInvalidToDefault(Sample_Counter,PD_SAMPLE_REF.getSampleCounter(Sample_Ref,DEF_GC_MEASUREMENT_TYPE::Temp));

      if ( Sample_Counter != CSMC_DBData::unspecLong )
      {
        RetValue = RetValue && PD_SAMPLE.copyToSampleCounter(Sample_Counter, SAMPLE_COUNTER_HOTHEEL, DEF_GC_MEASUREMENT_TYPE::HotHeel, Commit, m_lastError);
      }
    }

    // create or update SAMPLE_REF at PD_HOTHEEL 
    if ( RetValue )
    {
      if ( PD_SAMPLE.updateSampleDetails(SAMPLE_COUNTER_HOTHEEL, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, CSMC_DBData::unspecString, SampleUsable, CSMC_DBData::unspecString, CSMC_DBData::unspecString, CSMC_DBData::unspecLong) )
      {
        PD_SAMPLE.updateSampleDetails(SAMPLE_COUNTER_HOTHEEL, CSMC_DBData::unspecLong);

        // assign SAMPLE_COUNTER_HOTHEEL to "Steel", "Slag" and "Temp" of SAMPLE_REF
        RetValue = RetValue && PD_SAMPLE_REF.writeSAMPLE_REF(Sample_Ref_HotHeel, SAMPLE_COUNTER_HOTHEEL ,DEF_GC_MEASUREMENT_TYPE::HotHeel);
      }
    }
    else
    {
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_DBWriteError(sMessage, "" , "PD_SAMPLE", "copy failure");
    
    }
  }

  checkLastError();

  return RetValue;
}


bool CDM_DBManager::AutomaticlyFillRelativeDelays(const std::string Plant,long PlantNo,const std::string HeatID,const std::string TreatID,bool& bAutoEnd,const std::string &User,bool Commit )
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_DELAYS PD_DELAYS (m_pDM_DBManagerTask->getStdConnection());

    PD_DELAYS.fillAutoEndTimeByEvents(Plant, PlantNo, HeatID, TreatID, User, bAutoEnd, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::changeHeatCustSeqParam(long PlantNo, long Value, bool Commit)
{
  log("++++++ CDM_DBManager::changeHeatCustSeqParam",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CGT_PARAM GT_PARAM(m_pDM_DBManagerTask->getStdConnection());
    RetValue = RetValue && GT_PARAM.setHeatCustSeqParam(PlantNo, Value, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

// Function to check if new Aim Data are different to existing
// stored in data base (PD_HEAT_DATA)
bool CDM_DBManager::isAimDataChanged(CEventMessage& Event, const std::string &SteelGrade, double AimWeight, double AimTemp, CDateTime &TreatStart, CDateTime &TreatEnd)
{
  log("++++++ CDM_DBManager::isAimDataChanged",3);

  bool RetValue = false; // error
  std::string HeatID    = Event.getHeatID();
  std::string TreatID   = Event.getTreatID();
  std::string PlantID   = Event.getPlantID();
  std::string Plant;
  long PlantNo = 0;

  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  // check valid values if change is forced e.g. by L1
  if ( m_pDM_DBManagerTask != NULL )
  {
    CPD_HEAT_DATA  PD_HEAT_DATA   (m_pDM_DBManagerTask->getStdConnection());

    if ( !HeatID .empty() && !TreatID.empty() )
    {
      if ( PD_HEAT_DATA.select(HeatID, TreatID, Plant) )
      {
        if ( PD_HEAT_DATA.getSTEELGRADECODE_ACT(1) != SteelGrade && SteelGrade != DEF::Inv_String )
        {
          RetValue = true; 
        }
        if ( PD_HEAT_DATA.getAIMSTEELWGT_MOD(1) != AimWeight && AimWeight != DEF::Inv_Double )
        {
          RetValue = true; 
        }
        if ( PD_HEAT_DATA.getAIMTEMP_MOD(1) != AimTemp && AimTemp != DEF::Inv_Double )
        {
          RetValue = true; 
        }
        if ( PD_HEAT_DATA.getTREATSTART_MOD(1) != TreatStart && TreatStart != CDateTime::InvalidDateTime() )
        {
          RetValue = true; 
        }
        if ( PD_HEAT_DATA.getTREATEND_MOD(1) != TreatEnd && TreatEnd != CDateTime::InvalidDateTime() )
        {
          RetValue = true; 
        }

      }
    }// if ( !HeatID .empty() && !TreatID.empty() )
  }// if ( m_pDM_DBManagerTask != NULL )

  return RetValue;
}


bool CDM_DBManager::isProductionPracticeChanged(CEventMessage& Event, const std::string &Desc_PP, long& ProdPracNo)
{
  log("++++++ CDM_DBManager::isProductionPracticeChanged",3);

  bool RetValue = false; // error
  std::string HeatID    = Event.getHeatID();
  std::string TreatID   = Event.getTreatID();
  std::string PlantID   = Event.getPlantID();
  std::string Plant;
  long PlantNo = 0;

  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  // ProdPracNo contains valid values if change is forced e.g. by L1
  if ( ProdPracNo != CSMC_DBData::unspecLong && 
       ProdPracNo != DEF::Inv_Long )
  {
    if ( m_pDM_DBManagerTask != NULL )
    {
      CPD_HEAT_DATA_PRODPRAC  PD_HEAT_DATA_PRODPRAC   (m_pDM_DBManagerTask->getStdConnection());

      if ( !HeatID .empty() && !TreatID.empty() )
      {
        if ( PD_HEAT_DATA_PRODPRAC.select(HeatID, TreatID, Plant, Desc_PP) )
        {
          if ( PD_HEAT_DATA_PRODPRAC.getPRODPRACID_MOD(1) != ProdPracNo )
          {
            RetValue = true; // practice pointer is changed
          }
        }
        else
        {
          setLastError("NO_PROD_PRAC_POINTER_DEFINED", 0, PD_HEAT_DATA_PRODPRAC.getActStatement());
        }
      }// if ( !HeatID .empty() && !TreatID.empty() )
    }// if ( m_pDM_DBManagerTask != NULL )
  }

  return RetValue;
}

bool CDM_DBManager::handlePDTablesOnSampleTaken(sHeatInfo &HeatInfo, long MeasurementType, CDateTime &SampleTime, long LadleNo, const std::string &LadleType, const std::string &UserCode, long &SampleCounter, long SampleOrigin, long SampleNo, bool Commit)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);

  if (RetValue)
  {
    CPD_SAMPLE_REF  PD_SAMPLE_REF (m_pDM_DBManagerTask->getStdConnection());
    CPD_SAMPLE      PD_SAMPLE     (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA   PD_HEAT_DATA  (m_pDM_DBManagerTask->getStdConnection());

    seqSample SeqSample;

    long SampleRef      = CSMC_DBData::unspecLong;
    long SampleCounter  = PD_SAMPLE.insertSample(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo,
                                                SampleOrigin, MeasurementType, SampleNo, SeqSample, Commit, m_lastError);
    //Sample REF exists
    if (PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
    {
      SampleRef = PD_HEAT_DATA.getSAMPLE_REF(1);

      PD_SAMPLE_REF.updateSAMPLE_REF(SampleRef,SampleCounter,MeasurementType,Commit,m_lastError);

    }
    //No sample REF exists in PD_HEAT_DATA, create it
    else
    {  
      //get next sample ref and insert into SampleRef
      SampleRef = PD_SAMPLE_REF.insertNewSAMPLE_REF(Commit, m_lastError);

      //update PD_HEAT_DATA table
      RetValue = RetValue && PD_HEAT_DATA.doSampleRefUpdate(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, SampleRef, false, m_lastError);
    }
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::resetCustHeatId(const std::string & Plant, long PlantNo, std::vector<std::string> &PlantList, long ReturnHeatNo, bool Commit)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CGT_PARAM GT_PARAM(m_pDM_DBManagerTask->getStdConnection());

    RetValue = GT_PARAM.selectByPlant(Plant,PlantNo,"CustHeatIDSequence", 0, DEF_GC_PARAM_TYPE::LParam); //select Sequence parameters
    
    if (RetValue)
    {
      try
      {
        //fill parameters into vector
        std::vector<long> m_SeqParam;
        for (long i = 1; i <= GT_PARAM.getLastRow(); i++)
        {
          m_SeqParam.push_back( CDataConversion::StringToLong( GT_PARAM.getVALUE(i).c_str()) );      
        }

        RetValue = GT_PARAM.selectByPlant(Plant,PlantNo, "CustHeatIDYear", 0, DEF_GC_PARAM_TYPE::LParam); //select year for param

        if (RetValue)
        {
          // JAST to be completed as implemented at EAF/MAGHREB

          //reset the cust heatID
          //std::string sYear = GT_PARAM.getVALUE(1);        
          //
          //CPP_HEAT_PLANT PP_HEAT_PLANT(m_pDM_DBManagerTask->getStdConnection());
          //RetValue = PP_HEAT_PLANT.resetCustHeatId(m_SeqParam, sYear, PlantList, ReturnHeatNo, Commit, m_lastError);        
        }      
      }
      catch(...)
      {
        log("Reset CustHeatId Error",3);
        RetValue = false;
      }
    }
    else
      setLastError(string("CustHeatIDSequence not found in GT_PARAM"),
      0, "select * from GT_PARAM where " + GT_PARAM.getWhereStatement());
  }

  return RetValue;
}

bool CDM_DBManager::setScrapContainerData(CEventMessage& Event, const std::string ContainerType, long ContainerInSeq, long ContainerNo, long ContainerLocation, long RecipeStatus, seqBatch& RecipeContent, bool commit)
{
  log("++++++ CDM_DBManager::setScrapContainerData",3);

  bool RetValue = false;

  std::string ProductID = Event.getProductID();
  std::string OrderId   = Event.getOrderID();
  std::string PlantID   = Event.getPlantID(); 
  std::string DataKey   = Event.getDataKey();
  std::string Plant;
  long PlantNo          = 1;
  CDateTime Now;


  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_DBManager::setScrapContainerData");

    return false;
  }

  if ( ContainerInSeq == DEF::Inv_Long )
  {
    setLastError("INVALID_CONTAINER_DATA",0,"");
    return false;
  }

  // if L1 prepares data for a container without relation to a order, we have to accept data also
  if ( OrderId == DEF::Inv_String || OrderId.empty() )
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_LogMessage(sMessage, "empty orderid received");
  }

  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  if ( m_pDM_DBManagerTask->getpDataInterface() )
  {
    // ****************************************
    // proceed only for valid order information
    // ****************************************
    if ( OrderId != DEF::Inv_String && !OrderId.empty() )
    {
      //============  read interface data ========================================

      CPD_SCRAP_CONTAINER_ORDER PD_SCRAP_CONTAINER_ORDER(m_pDM_DBManagerTask->getStdConnection());

      if ( RecipeStatus == DEF_GC_RECIPE_STATUS::Enabled )
      {
        if ( PD_SCRAP_CONTAINER_ORDER.select(Plant, OrderId, ContainerInSeq) )
        {
          PD_SCRAP_CONTAINER_ORDER.setORDERTIME(Now);
          PD_SCRAP_CONTAINER_ORDER.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::Ordered);

          // L1 has a ContainerNo before enable
          if ( ContainerNo > 0 && ContainerType != DEF::Inv_String )
          {
            PD_SCRAP_CONTAINER_ORDER.setCONTAINERNO(ContainerNo);
            PD_SCRAP_CONTAINER_ORDER.setCONTAINERTYPE(ContainerType);
          }

          RetValue = PD_SCRAP_CONTAINER_ORDER.update();   

          if (!RetValue)
          {
            m_lastError = PD_SCRAP_CONTAINER_ORDER.getLastError();
          }
        }
        else
        {
          setLastError("NO_SCRAP_ORDER_AVAILABLE", 0, PD_SCRAP_CONTAINER_ORDER.getActStatement());
        }
      }
      else
      {
        if ( PD_SCRAP_CONTAINER_ORDER.select(Plant, OrderId, ContainerInSeq) )
        {
          long ContainerLast = PD_SCRAP_CONTAINER_ORDER.getCONTAINERLAST(1);

          if ( RecipeStatus == DEF_GC_RECIPE_STATUS::ProcessingStart )
          {
            PD_SCRAP_CONTAINER_ORDER.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::LoadingStarted);
          }
          else if ( RecipeStatus == DEF_GC_RECIPE_STATUS::WeighingComplete )
          {
            PD_SCRAP_CONTAINER_ORDER.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::LoadingEnded);
          }
          else if ( RecipeStatus == DEF_GC_RECIPE_STATUS::Discharged )
          {
            PD_SCRAP_CONTAINER_ORDER.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::Discharged);
          }

          if ( RecipeStatus == DEF_GC_RECIPE_STATUS::Disabled )
          {
            PD_SCRAP_CONTAINER_ORDER.setCONTAINERNO(CSMC_DBData::unspecLong);
            PD_SCRAP_CONTAINER_ORDER.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::Planned);
            PD_SCRAP_CONTAINER_ORDER.setORDERTIME(CSMC_DBData::unspecDate);
          }
          else
          {
            PD_SCRAP_CONTAINER_ORDER.setCONTAINERNO(ContainerNo);
            PD_SCRAP_CONTAINER_ORDER.setCONTAINERTYPE(ContainerType);
          }

          RetValue = PD_SCRAP_CONTAINER_ORDER.update();   

          if (!RetValue)
          {
            m_lastError = PD_SCRAP_CONTAINER_ORDER.getLastError();
          }

          // ***********************************
          // check planned data to be completed
          // ***********************************
          CPD_SCRAP_CONTAINER_ORDER_ENTRY PD_SCRAP_CONTAINER_ORDER_ENTRY(m_pDM_DBManagerTask->getStdConnection());
          CPD_SCRAP_CONTAINER_ENTRY       PD_SCRAP_CONTAINER_ENTRY      (m_pDM_DBManagerTask->getStdConnection());

          std::string RecipeName = ContainerType+CDataConversion::LongToString(ContainerInSeq);

          if ( CIntfData::getLength(RecipeContent) == 0 && RecipeStatus != DEF_GC_RECIPE_STATUS::Disabled     && 
                                                           RecipeStatus != DEF_GC_RECIPE_STATUS::Discharged   )
          {
            CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
            sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
            pEventLog->EL_LogMessage(sMessage, "No material received for saving");
          }
          else if ( CIntfData::getLength(RecipeContent) == 0 && RecipeStatus == DEF_GC_RECIPE_STATUS::Discharged )
          {
            if ( PD_SCRAP_CONTAINER_ENTRY.select(ContainerNo, ContainerType, CSMC_DBData::unspecLong) ) 
            {
              seqBatch SeqBatch;

              for (long r = 1; r <= PD_SCRAP_CONTAINER_ENTRY.getLastRow(); ++r)
              {
                sBatch    Batch;

                Batch.MatCode               = PD_SCRAP_CONTAINER_ENTRY.getMAT_CODE(r).c_str();
                Batch.Mass                  = PD_SCRAP_CONTAINER_ENTRY.getMATWEIGHT(r);
                Batch.MatLoadingSequence    = PD_SCRAP_CONTAINER_ENTRY.getMATCHARGESEQ(r);
                Batch.MatFeedSpeed          = CSMC_DBData::unspecDouble;
                Batch.FeedingRateRel2Energy = CSMC_DBData::unspecDouble;
                Batch.Source                = CSMC_DBData::unspecLong;


                // Ignore those materials that have a weight of near zero .
                if (Batch.Mass > 0.001)
                {
                  CIntfData::insert(SeqBatch, Batch);
                }
              } // for (long r = 1; r <= PD_SCRAP_CONTAINER_ORDER_ENTRY.getLastRow(); ++r)

              if ( CIntfData::getLength(SeqBatch) != 0 )
              {
                RecipeContent = SeqBatch;
              }
            }// if ( PD_SCRAP_CONTAINER_ENTRY.select(ContainerNo, ContainerType, CSMC_DBData::unspecLong) ) 
          }

          bool hasContainerOrderEntry = PD_SCRAP_CONTAINER_ORDER_ENTRY.select(Plant,OrderId,ContainerInSeq,CSMC_DBData::unspecLong);

          if ( !hasContainerOrderEntry && CIntfData::getLength(RecipeContent) != 0 )
          {   
            for (long i = 0 ; i < CIntfData::getLength(RecipeContent) ; ++i)
            {
              sBatch Batch;
              if (CIntfData::getAt(Batch,RecipeContent,i))
              {
                PD_SCRAP_CONTAINER_ORDER_ENTRY.setPLANT(Plant);
                PD_SCRAP_CONTAINER_ORDER_ENTRY.setPRODORDERID(OrderId);
                PD_SCRAP_CONTAINER_ORDER_ENTRY.setCONTAINERINSEQ(ContainerInSeq);
                PD_SCRAP_CONTAINER_ORDER_ENTRY.setRECIPENAME(RecipeName);
                PD_SCRAP_CONTAINER_ORDER_ENTRY.setMAT_CODE(std::string(Batch.MatCode));
                PD_SCRAP_CONTAINER_ORDER_ENTRY.setMATCHARGESEQ(Batch.MatLoadingSequence);

                RetValue = RetValue && PD_SCRAP_CONTAINER_ORDER_ENTRY.insert();
              }
            }

            if (!RetValue)
            {
              log("Saving of new Container data in PD_SCRAP_CONTAINER_ORDER_ENTRY", 1);
              m_lastError = PD_SCRAP_CONTAINER_ORDER_ENTRY.getLastError();
            }
          } // if ( !PD_SCRAP_CONTAINER_ORDER_ENTRY.select(Plant,OrderId,ContainerInSeq,ContainerType+CDataConversion::LongToString(ContainerInSeq),CSMC_DBData::unspecString) )
          else if ( hasContainerOrderEntry && CIntfData::getLength(RecipeContent) ==  0 )
          {
            seqBatch SeqBatch;

            for (long r = 1; r <= PD_SCRAP_CONTAINER_ORDER_ENTRY.getLastRow(); ++r)
            {
              sBatch    Batch;

              Batch.MatCode               = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMAT_CODE(r).c_str();
              Batch.Mass                  = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMATWEIGHT(r);
              Batch.MatLoadingSequence    = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMATCHARGESEQ(r);
              Batch.MatFeedSpeed          = CSMC_DBData::unspecDouble;
              Batch.FeedingRateRel2Energy = CSMC_DBData::unspecDouble;
              Batch.Source                = CSMC_DBData::unspecLong;

              // Ignore those materials that have a weight of near zero .
              if (Batch.Mass > 0.001)
              {
                CIntfData::insert(SeqBatch, Batch);
              }
            } // for (long r = 1; r <= PD_SCRAP_CONTAINER_ORDER_ENTRY.getLastRow(); ++r)

            if ( CIntfData::getLength(SeqBatch) != 0 )
            {
              setLastError("Using Practice data to set the container data", 0, "", 1);
              RecipeContent = SeqBatch;
            }
          }
          CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

          pDataInterface->setLong(Event.getDataKey(), DATA::LastBasket, ContainerLast);
        } // if ( PD_SCRAP_CONTAINER_ORDER.select(Plant, OrderId, ContainerInSeq) )
        else
        {
          PD_SCRAP_CONTAINER_ORDER.setPLANT(Plant);
          PD_SCRAP_CONTAINER_ORDER.setPRODORDERID(OrderId);
          PD_SCRAP_CONTAINER_ORDER.setCONTAINERINSEQ(ContainerInSeq);
          PD_SCRAP_CONTAINER_ORDER.setREVTIME(Now);
        
          if ( RecipeStatus == DEF_GC_RECIPE_STATUS::ProcessingStart )
          {
            PD_SCRAP_CONTAINER_ORDER.setORDERTIME(Now);
            PD_SCRAP_CONTAINER_ORDER.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::LoadingStarted);
          }
          else if ( RecipeStatus == DEF_GC_RECIPE_STATUS::WeighingComplete )
          {
            PD_SCRAP_CONTAINER_ORDER.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::LoadingEnded);
          }

          if ( RecipeStatus == DEF_GC_RECIPE_STATUS::Disabled )
          {
            PD_SCRAP_CONTAINER_ORDER.setCONTAINERNO(CSMC_DBData::unspecLong);
            PD_SCRAP_CONTAINER_ORDER.setCONTAINERTYPE(CSMC_DBData::unspecString);
            PD_SCRAP_CONTAINER_ORDER.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::Planned);
            PD_SCRAP_CONTAINER_ORDER.setORDERTIME(CSMC_DBData::unspecDate);
          }
          else
          {
            PD_SCRAP_CONTAINER_ORDER.setCONTAINERNO(ContainerNo);
            PD_SCRAP_CONTAINER_ORDER.setCONTAINERTYPE(ContainerType);
          }

          RetValue = PD_SCRAP_CONTAINER_ORDER.insert();

          if (!RetValue)
          {
            m_lastError = PD_SCRAP_CONTAINER_ORDER.getLastError();
          }

          // ***********************************
          // check planned data to be completed
          // ***********************************
          if ( CIntfData::getLength(RecipeContent) == 0 && RecipeStatus != DEF_GC_RECIPE_STATUS::Disabled )
          {
            CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
            sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
            pEventLog->EL_LogMessage(sMessage, "No material received for saving");
          }

          CPD_SCRAP_CONTAINER_ORDER_ENTRY PD_SCRAP_CONTAINER_ORDER_ENTRY(m_pDM_DBManagerTask->getStdConnection());

          std::string RecipeName = ContainerType+CDataConversion::LongToString(ContainerInSeq);
        
          for (long i = 0 ; i < CIntfData::getLength(RecipeContent) ; ++i)
          {
            sBatch Batch;
            if (CIntfData::getAt(Batch,RecipeContent,i))
            {
              PD_SCRAP_CONTAINER_ORDER_ENTRY.setPLANT(Plant);
              PD_SCRAP_CONTAINER_ORDER_ENTRY.setPRODORDERID(OrderId);
              PD_SCRAP_CONTAINER_ORDER_ENTRY.setCONTAINERINSEQ(ContainerInSeq);
              PD_SCRAP_CONTAINER_ORDER_ENTRY.setRECIPENAME(RecipeName);
              PD_SCRAP_CONTAINER_ORDER_ENTRY.setMAT_CODE(std::string(Batch.MatCode));
              PD_SCRAP_CONTAINER_ORDER_ENTRY.setMATCHARGESEQ(Batch.MatLoadingSequence);

              RetValue = RetValue && PD_SCRAP_CONTAINER_ORDER_ENTRY.insert();
            }
          }

          if (!RetValue)
          {
            log("Saving of new Container data in PD_SCRAP_CONTAINER_ORDER_ENTRY", 1);
            m_lastError = PD_SCRAP_CONTAINER_ORDER_ENTRY.getLastError();
          }

        } // if ( PD_SCRAP_CONTAINER_ORDER.select(Plant, OrderId, ContainerInSeq) )
      } // if ( RecipeStatus == DEF_GC_RECIPE_STATUS::Enabled )
    } // if ( OrderId != DEF::Inv_String && !OrderId.empty() )
    else
    {
      // to handle data from L1 for unknown orderid when enable from scrap is sent
      if ( RecipeStatus == DEF_GC_RECIPE_STATUS::Enabled )
      {
        RetValue = true;
      }
    }

    //============  set new Container data in  =================================

    if (  RecipeStatus == DEF_GC_RECIPE_STATUS::ProcessingStart   || 
          RecipeStatus == DEF_GC_RECIPE_STATUS::WeighingComplete  ||
          RecipeStatus == DEF_GC_RECIPE_STATUS::Discharged        ||
          RecipeStatus == DEF_GC_RECIPE_STATUS::Disabled            )
    {
      if ( ContainerLocation != DEF::Inv_Long )
      {
        CPD_SCRAP_CONTAINER PD_SCRAP_CONTAINER(m_pDM_DBManagerTask->getStdConnection());

        if ( RecipeStatus == DEF_GC_RECIPE_STATUS::Disabled )
        {
          RetValue = PD_SCRAP_CONTAINER.deleteRow(ContainerNo,ContainerType);
        }

        if ( RecipeStatus == DEF_GC_RECIPE_STATUS::ProcessingStart )
        {
          PD_SCRAP_CONTAINER.deleteRow(ContainerNo,ContainerType);
          PD_SCRAP_CONTAINER.setLOADINGSTARTTIME(Now); 
        }

        if ( RecipeStatus == DEF_GC_RECIPE_STATUS::WeighingComplete )
        {
          PD_SCRAP_CONTAINER.setLOADINGENDTIME(Now); 
        }

        if ( RecipeStatus != DEF_GC_RECIPE_STATUS::Disabled )
        {
          PD_SCRAP_CONTAINER.setLOCATIONNO(ContainerLocation);
          PD_SCRAP_CONTAINER.setSTATUSNO(DEF_GC_SCRAP_CONTAINER_STATUS::Available);

          if ( PD_SCRAP_CONTAINER.select(ContainerNo,ContainerType) )
          {     
            RetValue = PD_SCRAP_CONTAINER.update();
          }
          else
          {
            PD_SCRAP_CONTAINER.setCONTAINERNO(ContainerNo);
            PD_SCRAP_CONTAINER.setCONTAINERTYPE(ContainerType);
            RetValue = PD_SCRAP_CONTAINER.insert();
          }

          //============  store received weight  =========================

          if ( CIntfData::getLength(RecipeContent) == 0 && RecipeStatus != DEF_GC_RECIPE_STATUS::Disabled )
          {
            CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
            sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
            pEventLog->EL_LogMessage(sMessage, "No material received for saving");
          }

          CPD_SCRAP_CONTAINER_ENTRY PD_SCRAP_CONTAINER_ENTRY(m_pDM_DBManagerTask->getStdConnection());

          PD_SCRAP_CONTAINER_ENTRY.deleteRow(ContainerNo,ContainerType,CSMC_DBData::unspecLong);


					//SARS
					double totalWeight = 0.;
          for (long i = 0 ; i < CIntfData::getLength(RecipeContent) ; ++i)
					{
						sBatch Batch;
						if (CIntfData::getAt(Batch,RecipeContent,i))
						{
							totalWeight =  totalWeight + Batch.Mass;
						}
          }

					for (long i = 0 ; i < CIntfData::getLength(RecipeContent) ; ++i)
					{
						sBatch Batch;
						if (CIntfData::getAt(Batch,RecipeContent,i))
						{
							PD_SCRAP_CONTAINER_ENTRY.setCONTAINERNO(ContainerNo);
							PD_SCRAP_CONTAINER_ENTRY.setCONTAINERTYPE(ContainerType);
							PD_SCRAP_CONTAINER_ENTRY.setMAT_CODE(std::string(Batch.MatCode));
							PD_SCRAP_CONTAINER_ENTRY.setMATWEIGHT(Batch.Mass);

							//SARS 
							CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();
              double bskWgt = pDataInterface->getDouble(Event.getDataKey(), DATA::BasketWeight);
              if ( (bskWgt ==  CSMC_DBData::unspecDouble) || (bskWgt ==  0.0))
              {
                  PD_SCRAP_CONTAINER_ENTRY.setMATWEIGHT(Batch.Mass);
              }
              else
              {
									if (totalWeight > 0) 
										PD_SCRAP_CONTAINER_ENTRY.setMATWEIGHT( (Batch.Mass/totalWeight) * bskWgt);
									else
										PD_SCRAP_CONTAINER_ENTRY.setMATWEIGHT(bskWgt);
              }//SARS : end

							PD_SCRAP_CONTAINER_ENTRY.setMATCHARGESEQ(Batch.MatLoadingSequence);

							RetValue = RetValue && PD_SCRAP_CONTAINER_ENTRY.insert();
						}
					}


          if (!RetValue)
          {
            log("Saving of new Container data in PD_SCRAP_CONTAINER_ENTRY", 1);
            m_lastError = PD_SCRAP_CONTAINER_ENTRY.getLastError();
          }
        }// if ( RecipeStatus != DEF_GC_RECIPE_STATUS::Disabled )
        else  if ( ( OrderId == DEF::Inv_String || OrderId.empty() ) && ( (ContainerType != DEF::Inv_String && !ContainerType.empty()) && (ContainerNo != DEF::Inv_Long && ContainerNo > 0) ) )
        {
          CPD_SCRAP_CONTAINER_ORDER PD_SCRAP_CONTAINER_ORDER(m_pDM_DBManagerTask->getStdConnection());

          if ( PD_SCRAP_CONTAINER_ORDER.selectOrderedButNotCharged(Plant, CSMC_DBData::unspecString, ContainerNo, ContainerType) )
          {
            PD_SCRAP_CONTAINER_ORDER.setCONTAINERNO(CSMC_DBData::unspecLong);
            PD_SCRAP_CONTAINER_ORDER.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::Planned);
            PD_SCRAP_CONTAINER_ORDER.setORDERTIME(CSMC_DBData::unspecDate);
            RetValue = PD_SCRAP_CONTAINER_ORDER.update();
          }
        }

        if (!RetValue)
        {
          m_lastError = PD_SCRAP_CONTAINER.getLastError();
          log("update of PD_SCRAP_CONTAINER->LOCATIONNO failed", 1);
        }
      }// if (ContainerLocation != DEF::Inv_Long)
      else
      {
        RetValue = false;
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_InconsistentDataReceived(sMessage, "ContainerLocation", Event.getMessage().c_str());
      }
    }// if ( RecipeStatus == DEF_GC_RECIPE_STATUS::ProcessingStart || RecipeStatus == DEF_GC_RECIPE_STATUS::WeighingComplete  )

    if ( commit )
    {
      if (RetValue)
      {
        m_pDM_DBManagerTask->getStdConnection()->commit();
      }
      else
      {
        m_pDM_DBManagerTask->getStdConnection()->rollback();
      }
    }
  }// if ( m_pDM_DBManagerTask->getpDataInterface() )

  checkLastError();

  return RetValue;
}

// look for order with respective Container data
// check if Container has already the given StatusNo
// increase value if sequence has reached the end
long CDM_DBManager::getNextContainerInSeqWithStatus(CEventMessage& Event, const std::string& ContainerType, long StatusNo)
{
  std::string ProductID = Event.getProductID();
  std::string HeatID    = Event.getHeatID();
  std::string OrderId   = Event.getOrderID();
  std::string PlantID   = Event.getPlantID();
  std::string Plant;
  long MaxContainerInSeq  = 0;
  long NextContInSeq      = 1; // assume to start always with 1
  long PlantNo            = 1;

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_DBManager::getNextContainerInSeqWithStatus");

    return CSMC_DBData::unspecLong;
  }

  if (OrderId.empty() || OrderId == DEF::Inv_String)
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_InconsistentDataReceived(sMessage, "OrderId", Event.getMessage().c_str());

    return false;
  }
  
  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  //============  read Container from PD_SCRAP_CONTAINER_ORDER =================================
  // read Container id from this table
  CPD_SCRAP_CONTAINER_ORDER PD_SCRAP_CONTAINER_ORDER (m_pDM_DBManagerTask->getStdConnection());

  // select all Container for the given order and ContainerType ordered by CONTAINERINSEQ
  if (PD_SCRAP_CONTAINER_ORDER.selectByContainerTypeAndState(Plant, OrderId, ContainerType, StatusNo) )
  {
    for ( long i = 1; i <= PD_SCRAP_CONTAINER_ORDER.getLastRow(); ++i )
    {
      if ( PD_SCRAP_CONTAINER_ORDER.getCONTAINERNO(i) == CSMC_DBData::unspecLong )
      {
        // take the first ContainerInSeq without Container assigned
        NextContInSeq = PD_SCRAP_CONTAINER_ORDER.getCONTAINERINSEQ(i);
        break;
      }
      else
      {
        // or take the next expected ContainerInSeq when all have Container assigned
        MaxContainerInSeq = max( MaxContainerInSeq , PD_SCRAP_CONTAINER_ORDER.getCONTAINERINSEQ(i) );

        NextContInSeq     = MaxContainerInSeq + 1;
      }
    }
  }

  return NextContInSeq;
}

bool CDM_DBManager::checkContainerAssignment(CEventMessage& Event, const std::string& ContainerType, long ContainerInSeq, long ContainerNo)
{
  bool RetValue = false; 

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::string ProductID = Event.getProductID();
  std::string OrderId   = Event.getOrderID();
  std::string PlantID   = Event.getPlantID();
  std::string DataKey   = Event.getDataKey();
  std::string Plant;
  long PlantNo          = 1;

  std::string HMIClientId = pDataInterface->getString(DataKey, DATA::HMIClientId);

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_BBManager::checkContainerAssignment");

    return false;
  }

  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  if (m_pDM_DBManagerTask->getpDataInterface())
  {
    //============  read Container from PD_SCRAP_CONTAINER_ORDER =================================

    // return false if no OrderId
    if (OrderId.empty() || 
        OrderId == DEF::Inv_String)
    {
      setLastError("INVALID_PRODUCTION_ORDER", 0, "");
      handleError(Event, HMIClientId);

      return false;
    }

    CPD_SCRAP_CONTAINER_ORDER PD_SCRAP_CONTAINER_ORDER(m_pDM_DBManagerTask->getStdConnection());

    if (PD_SCRAP_CONTAINER_ORDER.selectByContainerNoAndType(Plant, OrderId, ContainerInSeq, ContainerNo, ContainerType ))
    {
      RetValue = true;
    }
    else
    {
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorSearchingData(sMessage,"","PD_SCRAP_CONTAINER_ORDER");
    }
  }
  return RetValue;
}

// remove assignment for ContainerNo for all oders af plant for respective Plant and ContainerType
bool CDM_DBManager::deassignScrapContainer(const std::string& Plant, const std::string& OrderId, const std::string& ContainerType, long ContainerInSeq, long ContainerNo, bool commit)
{
  log("++++++ CDM_DBManager::deassignScrapContainer",3);

  bool RetValue = false;

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_DBManager::deassignScrapContainer");

    return false;
  }

  if (m_pDM_DBManagerTask->getpDataInterface())
  {
    //============  reset Container in PD_SCRAP_CONTAINER_ORDER =================================
    // delete CONTAINERNO and CONTAINERTYPE from this table
    //
    CPD_SCRAP_CONTAINER_ORDER PD_SCRAP_CONTAINER_ORDER(m_pDM_DBManagerTask->getStdConnection());

    if (PD_SCRAP_CONTAINER_ORDER.selectByContainerNoAndType(Plant, OrderId, CSMC_DBData::unspecLong, ContainerNo, ContainerType))
    {
      PD_SCRAP_CONTAINER_ORDER.setCONTAINERNO(CSMC_DBData::unspecLong);
      PD_SCRAP_CONTAINER_ORDER.setCONTAINERTYPE(CSMC_DBData::unspecString);
      PD_SCRAP_CONTAINER_ORDER.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::Planned);

      if (PD_SCRAP_CONTAINER_ORDER.update())
      {
        RetValue = true;
      }
      else
      {
        m_lastError = PD_SCRAP_CONTAINER_ORDER.getLastError();
      }
    }
    else
    {
      setLastError("NO_SCRAP_ORDER_AVAILABLE", 1200, PD_SCRAP_CONTAINER_ORDER.getActStatement() );
    }
  }

  if (commit)
  {
    if (RetValue)
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
    }
    else
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback();
    }
  }

  return RetValue;
}

bool CDM_DBManager::assignScrapContainer(CEventMessage& Event, const std::string& ContainerType, long ContainerInSeq, long ContainerNo, long LastBasket, bool commit)
{
  log("++++++ CDM_DBManager::assignScrapContainer",3);

  bool RetValue = true;
  CDateTime Now;

  std::string ProductID = Event.getProductID();
  std::string OrderId   = Event.getOrderID();
  std::string PlantID   = Event.getPlantID();

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();
  
  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_DBManager::assignScrapContainer");

    return false;
  }


  if ( ContainerNo != DEF::Inv_Long && ContainerInSeq != DEF::Inv_Long)
  {
    //============  set new Container in PD_SCRAP_CONTAINER_ORDER =================================

    CPD_SCRAP_CONTAINER_ORDER PD_SCRAP_CONTAINER_ORDER(m_pDM_DBManagerTask->getStdConnection());

    if (PD_SCRAP_CONTAINER_ORDER.select(HeatInfo.Plant, OrderId, ContainerInSeq))
    {
      PD_SCRAP_CONTAINER_ORDER.setCONTAINERNO(ContainerNo);
      PD_SCRAP_CONTAINER_ORDER.setCONTAINERTYPE(ContainerType);
      PD_SCRAP_CONTAINER_ORDER.setCONTAINERLAST(LastBasket);

      if (PD_SCRAP_CONTAINER_ORDER.update())
        RetValue = true;
      else
        m_lastError = PD_SCRAP_CONTAINER_ORDER.getLastError();
    }
    else
    {
      // reset existing container with CONTAINERLAST == 1 if LastBasket is 1
      if ( LastBasket == 1 )
      {
        if ( PD_SCRAP_CONTAINER_ORDER.select(HeatInfo.Plant, OrderId, CSMC_DBData::unspecLong) )
        {
          PD_SCRAP_CONTAINER_ORDER.setCONTAINERLAST(CSMC_DBData::unspecLong);

          if (PD_SCRAP_CONTAINER_ORDER.update())
            RetValue = true;
          else
            m_lastError = PD_SCRAP_CONTAINER_ORDER.getLastError();
        }
      }

      PD_SCRAP_CONTAINER_ORDER.setPRODORDERID(OrderId);
      PD_SCRAP_CONTAINER_ORDER.setPLANT(HeatInfo.Plant);
      PD_SCRAP_CONTAINER_ORDER.setCONTAINERINSEQ(ContainerInSeq);
      PD_SCRAP_CONTAINER_ORDER.setCONTAINERNO(ContainerNo);
      PD_SCRAP_CONTAINER_ORDER.setCONTAINERTYPE(ContainerType);
      PD_SCRAP_CONTAINER_ORDER.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::Ordered);
      PD_SCRAP_CONTAINER_ORDER.setREVTIME(Now);

      PD_SCRAP_CONTAINER_ORDER.setCONTAINERLAST(LastBasket);

      if (PD_SCRAP_CONTAINER_ORDER.insert())
        RetValue = true;
      else
        m_lastError = PD_SCRAP_CONTAINER_ORDER.getLastError();
    }
  }
  else
  {
    setLastError("ERROR_CONTAINER_ASSIGNMENT", 0, "");
  }

  if (commit)
  {
    if (RetValue)
      m_pDM_DBManagerTask->getStdConnection()->commit();
    else
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback();
    }
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDRecipeDataOnScrapContainerAssignment(sHeatInfo &HeatInfo, const std::string &OrderId, const std::string &ContainerType, long ContainerInSeq, long ContainerNo, long RecipeStatus, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDRecipeDataOnScrapContainerAssignment",3);

  bool RetValue = true;

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_DBManager::handlePDRecipeDataOnScrapContainerAssignment");

    RetValue = false;
  }

  std::string RecipeName = CSMC_DBData::unspecString;

  double DurSinceHeatAnnounce = 0.;
  double DurSinceHeatStart    = 0.;
  double ElecCons             = 0.;

  seqGasData      TotalMetAmount;

  if (m_pDM_DBManagerTask->getpProductManagementInterface())
  {
    DurSinceHeatAnnounce  = m_pDM_DBManagerTask->getpProductManagementInterface()->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatAnnounce);
    DurSinceHeatStart     = m_pDM_DBManagerTask->getpProductManagementInterface()->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatStart);
    ElecCons              = m_pDM_DBManagerTask->getpProductManagementInterface()->getDouble(HeatInfo.ProductId, DATA::ElecCons);

    // necessary to write actual gas consumption to PD_RECIPE and PD_ACTION
    TotalMetAmount        = CIntfData::ToCORBAType(m_pDM_DBManagerTask->getpProductManagementInterface()->getGasData(HeatInfo.ProductId.c_str(), DATA::TotalMetAmount));
  }

  sMetTimeStamp MetTimeStamp;
  MetTimeStamp.O2_Moment                = DEF::Inv_Double;
  MetTimeStamp.Ar_Moment                = DEF::Inv_Double;
  MetTimeStamp.N2_Moment                = DEF::Inv_Double;
  MetTimeStamp.Elec_Moment              = CDataConversion::SetInvalidToDefault(ElecCons,0.);
  MetTimeStamp.DurSinceHeatAnnouncement = CDataConversion::SetInvalidToDefault(DurSinceHeatAnnounce,0);
  MetTimeStamp.DurSinceStartOfHeat      = CDataConversion::SetInvalidToDefault(DurSinceHeatStart,0);

  if ( CIntfData::getLength(TotalMetAmount) > 0 )
  {
    CGasDataHandler GasDataHandler(TotalMetAmount);
    MetTimeStamp.O2_Moment = GasDataHandler.getGasData(DEF_GAS::O2);
    MetTimeStamp.Ar_Moment = GasDataHandler.getGasData(DEF_GAS::Ar);
    MetTimeStamp.N2_Moment = GasDataHandler.getGasData(DEF_GAS::N2);
  }

  if ( RetValue )
  {
    CPD_HEAT_DATA                   PD_HEAT_DATA                  (m_pDM_DBManagerTask->getStdConnection());

    if ( !HeatInfo.HeatId.empty() && HeatInfo.HeatId != CSMC_DBData::unspecString && PD_HEAT_DATA.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant) )
    {
      CPD_SCRAP_CONTAINER_ORDER       PD_SCRAP_CONTAINER_ORDER      (m_pDM_DBManagerTask->getStdConnection());
      CPD_SCRAP_CONTAINER_ORDER_ENTRY PD_SCRAP_CONTAINER_ORDER_ENTRY(m_pDM_DBManagerTask->getStdConnection());
      CPD_SCRAP_CONTAINER_ENTRY       PD_SCRAP_CONTAINER_ENTRY      (m_pDM_DBManagerTask->getStdConnection());

      CPD_RECIPE                      PD_RECIPE                     (m_pDM_DBManagerTask->getStdConnection());

      // we will copy data from PD_SCRAP_CONTEINER_XXX table to PD_RECIPE
      // CPD_SCRAP_CONTAINER_ORDER_ENTRY  -> status "enabled"
      // CPD_SCRAP_CONTAINER_ENTRY        -> status "WeighingComplete"

      ContainerInSeq = CDataConversion::SetInvalidToDefault(ContainerInSeq, CSMC_DBData::unspecLong, DEF::Inv_Long);

      if ( ContainerInSeq != CSMC_DBData::unspecLong )
      {
        RecipeName = ContainerType + CDataConversion::LongToString(ContainerInSeq);
      }

      // JAST will be managed by PD_RECIPE itself
      // first delete all entries at PC_RECIPE for Source = "Yard" and given recipe determined by ContainerInSeq
      // PD_RECIPE.deleteRow(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,RecipeName,CSMC_DBData::unspecLong,DEF_GC_RECIPE_SOURCE::Yard,CSMC_DBData::unspecLong, Commit, m_lastError);

      // iterate over all existing container for respective OrderId
      if ( PD_SCRAP_CONTAINER_ORDER.selectByContainerNoAndType(HeatInfo.Plant, OrderId, ContainerInSeq, CSMC_DBData::unspecLong, ContainerType) )
      {
        for ( long i = 1; i <= PD_SCRAP_CONTAINER_ORDER.getLastRow(); ++i )
        {
          long CONTAINERNO        = PD_SCRAP_CONTAINER_ORDER.getCONTAINERNO(i);
          long CONTAINERINSEQ     = PD_SCRAP_CONTAINER_ORDER.getCONTAINERINSEQ(i);
          long STATUSNO           = PD_SCRAP_CONTAINER_ORDER.getSTATUSNO(i);

          if ( CONTAINERINSEQ != CSMC_DBData::unspecLong )
          {
            std::string RecipeName  = ContainerType + CDataConversion::LongToString(CONTAINERINSEQ);

            // *********************************************************************
            // setpoints as "calculated" from PD_SCRAP_CONTAINER_ORDER_ENTRY
            // *********************************************************************
            if (PD_SCRAP_CONTAINER_ORDER_ENTRY.select(HeatInfo.Plant, OrderId, CONTAINERINSEQ, CSMC_DBData::unspecLong))
            {
              seqBatch SeqBatch;

              for (long r = 1; r <= PD_SCRAP_CONTAINER_ORDER_ENTRY.getLastRow(); ++r)
              {
                sBatch    Batch;

                Batch.MatCode               = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMAT_CODE(r).c_str();
                Batch.Mass                  = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMATWEIGHT(r);
                Batch.MatLoadingSequence    = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMATCHARGESEQ(r);
                Batch.MatFeedSpeed          = CSMC_DBData::unspecDouble;
                Batch.FeedingRateRel2Energy = CSMC_DBData::unspecDouble;
                Batch.Source                = CSMC_DBData::unspecLong;


                // Ignore those materials that have a weight of near zero .
                if (Batch.Mass > 0.001)
                {
                  CIntfData::insert(SeqBatch, Batch);
                }
              } // for (long r = 1; r <= PD_SCRAP_CONTAINER_ORDER_ENTRY.getLastRow(); ++r)

              sRecipeInfo RecipeInfoOrder;
              RecipeInfoOrder.RecipeStatus         = DEF_GC_RECIPE_STATUS::Calculated;
              RecipeInfoOrder.DurSinceHeatAnnounce = DurSinceHeatAnnounce;
              RecipeInfoOrder.DurSinceHeatStart    = DurSinceHeatStart;
              RecipeInfoOrder.RecipeName           = RecipeName;
              RecipeInfoOrder.RecipeNo             = 1; 
              RecipeInfoOrder.RecipeSource         = DEF_GC_RECIPE_SOURCE::Yard;
              RecipeInfoOrder.RecipeTarget         = DEF_GC_CHARGE_DEST::Furnace;


              if ( CIntfData::getLength(SeqBatch) > 0 )
              {
                // scrap container data could contain identical materials several times
                // this is not covered by writeBatch if use case is handled several times
                // we have to remove data first

                //the data for pd_recipe_entry also inserted in this function
                RetValue = PD_RECIPE.replaceBatch(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, RecipeInfoOrder, MetTimeStamp, SeqBatch, Commit, m_lastError);
              }
            }
            else
            {
              std::string SearchKey = HeatInfo.Plant + "; OrderId = " + OrderId + "; ContainerInSeg = "+ CDataConversion::LongToString(CONTAINERINSEQ);
              CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
              sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
              pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.c_str(),"PD_SCRAP_CONTAINER_ORDER_ENTRY");
            }

            // *********************************************************************
            // Planned materials on L1 as "Enable" from PD_SCRAP_CONTAINER_ORDER_ENTRY
            // *********************************************************************
            if ( RecipeStatus == DEF_GC_RECIPE_STATUS::Enabled )
            {
              if (PD_SCRAP_CONTAINER_ORDER_ENTRY.select(HeatInfo.Plant, OrderId, CONTAINERINSEQ, CSMC_DBData::unspecLong))
              {
                seqBatch SeqBatch;

                for (long r = 1; r <= PD_SCRAP_CONTAINER_ORDER_ENTRY.getLastRow(); ++r)
                {
                  sBatch    Batch;

                  Batch.MatCode               = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMAT_CODE(r).c_str();
                  Batch.Mass                  = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMATWEIGHT(r);
                  Batch.MatLoadingSequence    = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMATCHARGESEQ(r);
                  Batch.MatFeedSpeed          = CSMC_DBData::unspecDouble;
                  Batch.FeedingRateRel2Energy = CSMC_DBData::unspecDouble;
                  Batch.Source                = CSMC_DBData::unspecLong;

                  // Ignore those materials that have a weight of near zero .
                  if (Batch.Mass > 0.001)
                  {
                    CIntfData::insert(SeqBatch, Batch);
                  }
                } // for (long r = 1; r <= PD_SCRAP_CONTAINER_ORDER_ENTRY.getLastRow(); ++r)

                sRecipeInfo RecipeInfoOrder;
                RecipeInfoOrder.RecipeStatus         = RecipeStatus;
                RecipeInfoOrder.DurSinceHeatAnnounce = MetTimeStamp.DurSinceHeatAnnouncement;
                RecipeInfoOrder.DurSinceHeatStart    = MetTimeStamp.DurSinceStartOfHeat;
                RecipeInfoOrder.RecipeName           = RecipeName;
                RecipeInfoOrder.RecipeNo             = 1; 
                RecipeInfoOrder.RecipeSource         = DEF_GC_RECIPE_SOURCE::Yard;
                RecipeInfoOrder.RecipeTarget         = DEF_GC_CHARGE_DEST::Furnace;

                if ( CIntfData::getLength(SeqBatch) > 0 )
                {
                  // scrap container data could contain identical materials several times
                  // this is not covered by writeBatch if use case is handled several times
                  // we have to remove data first

                  //the data for pd_recipe_entry also inserted in this function
                  RetValue = PD_RECIPE.replaceBatch(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, RecipeInfoOrder, MetTimeStamp, SeqBatch, Commit, m_lastError);
                }
              }
              else
              {
                std::string SearchKey = HeatInfo.Plant + "; OrderId = " + OrderId + "; ContainerInSeg = "+ CDataConversion::LongToString(CONTAINERINSEQ);
                CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
                sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
                pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.c_str(),"PD_SCRAP_CONTAINER_ORDER_ENTRY");
              }
            } // if ( RecipeStatus == DEF_GC_RECIPE_STATUS::ProcessingStart ||

            // *********************************************************************
            // loaded materials as "WeighingComplete" from PD_SCRAP_CONTAINER_ENTRY
            // *********************************************************************
            if ( RecipeStatus == DEF_GC_RECIPE_STATUS::ProcessingStart || 
                 RecipeStatus == DEF_GC_RECIPE_STATUS::WeighingComplete)
            {
              if (PD_SCRAP_CONTAINER_ENTRY.select(CONTAINERNO,  ContainerType, CSMC_DBData::unspecLong))
              {
                seqBatch SeqBatch;

                for (long r = 1; r <= PD_SCRAP_CONTAINER_ENTRY.getLastRow(); ++r)
                {
                  sBatch    Batch;

                  Batch.MatCode               = PD_SCRAP_CONTAINER_ENTRY.getMAT_CODE(r).c_str();
                  Batch.Mass                  = PD_SCRAP_CONTAINER_ENTRY.getMATWEIGHT(r);
                  Batch.MatLoadingSequence    = PD_SCRAP_CONTAINER_ENTRY.getMATCHARGESEQ(r);
                  Batch.MatFeedSpeed          = CSMC_DBData::unspecDouble;
                  Batch.FeedingRateRel2Energy = CSMC_DBData::unspecDouble;
                  Batch.Source                = CSMC_DBData::unspecLong;

                  // Ignore those materials that have a weight of near zero .
                  if (Batch.Mass > 0.001)
                  {
                    CIntfData::insert(SeqBatch, Batch);
                  }
                } // for (long r = 1; r <= PD_SCRAP_CONTAINER_ENTRY.getLastRow(); ++r)

                sRecipeInfo RecipeInfoOrder;
                RecipeInfoOrder.RecipeStatus         = RecipeStatus;
                RecipeInfoOrder.DurSinceHeatAnnounce = MetTimeStamp.DurSinceHeatAnnouncement;
                RecipeInfoOrder.DurSinceHeatStart    = MetTimeStamp.DurSinceStartOfHeat;
                RecipeInfoOrder.RecipeName           = RecipeName;
                RecipeInfoOrder.RecipeNo             = 1; 
                RecipeInfoOrder.RecipeSource         = DEF_GC_RECIPE_SOURCE::Yard;
                RecipeInfoOrder.RecipeTarget         = DEF_GC_CHARGE_DEST::Furnace;

                if ( CIntfData::getLength(SeqBatch) > 0 )
                {
                  // scrap container data could contain identical materials several times
                  // this is not covered by writeBatch if use case is handled several times
                  // we have to remove data first

                  //the data for pd_recipe_entry also inserted in this function
                  RetValue = PD_RECIPE.replaceBatch(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, RecipeInfoOrder, MetTimeStamp, SeqBatch, Commit, m_lastError);
                }
              }// if (PD_SCRAP_CONTAINER_ENTRY.select(CONTAINERNO,  ContainerType, CSMC_DBData::unspecString))
            } // if ( RecipeStatus == DEF_GC_RECIPE_STATUS::WeighingComplete )
          } // if ( CONTAINERINSEQ != CSMC_DBData::unspecLong && 
        }// for ( long i = 1; i <= PD_SCRAP_CONTAINER_ORDER.getLastRow(); ++i )
      }//  if ( PD_SCRAP_CONTAINER_ORDER.selectByContainerNoAndType(HeatInfo.Plant,OrderId, ContainerInSeq, CSMC_DBData::unspecLong, ContainerType) )
    }
  }// if ( RetValue )

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDRecipeDataOnScrapContainerDeAssignment(sHeatInfo &HeatInfo, const std::string &OrderId, const std::string &ContainerType, long ContainerInSeq, long ContainerNo, long RecipeStatus, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDRecipeDataOnScrapContainerDeAssignment",3);

  bool RetValue = true;

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_DBManager::handlePDRecipeDataOnScrapContainerDeAssignment");

    RetValue = false;
  }

  double DurSinceHeatAnnounce = 0.;
  double DurSinceHeatStart    = 0.;
  double ElecCons             = 0.;

  seqGasData      TotalMetAmount;

  sMetTimeStamp MetTimeStamp;
  MetTimeStamp.O2_Moment   = 0.;
  MetTimeStamp.Ar_Moment   = 0.;
  MetTimeStamp.N2_Moment   = 0.;
  MetTimeStamp.Elec_Moment = 0.;
  MetTimeStamp.DurSinceHeatAnnouncement = 0.;
  MetTimeStamp.DurSinceStartOfHeat      = 0.;

  if ( RetValue )
  {
    if (m_pDM_DBManagerTask->getpProductManagementInterface())
    {
      //DurSinceHeatAnnounce  = m_pDM_DBManagerTask->getpProductManagementInterface()->getDouble(ProductID, DATA::DurSinceHeatAnnounce);
      //DurSinceHeatStart     = m_pDM_DBManagerTask->getpProductManagementInterface()->getDouble(ProductID, DATA::DurSinceHeatStart);
      //ElecCons              = m_pDM_DBManagerTask->getpProductManagementInterface()->getDouble(ProductID, DATA::ElecCons);

      //// necessary to write actual gas consumption to PD_RECIPE and PD_ACTION
      //TotalMetAmount        = CIntfData::ToCORBAType(m_pDM_DBManagerTask->getpProductManagementInterface()->getGasData(ProductID.c_str(), DATA::TotalMetAmount));
    }

    CPD_SCRAP_CONTAINER_ORDER       PD_SCRAP_CONTAINER_ORDER      (m_pDM_DBManagerTask->getStdConnection());
    CPD_SCRAP_CONTAINER_ORDER_ENTRY PD_SCRAP_CONTAINER_ORDER_ENTRY(m_pDM_DBManagerTask->getStdConnection());
    CPD_RECIPE                      PD_RECIPE                     (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA                   PD_HEAT_DATA                  (m_pDM_DBManagerTask->getStdConnection());

    if ( PD_SCRAP_CONTAINER_ORDER.select(HeatInfo.Plant, OrderId, ContainerInSeq) )
    {
      for ( long i = 1; i <= PD_SCRAP_CONTAINER_ORDER.getLastRow(); ++i )
      {
        long CONTAINERNO        = PD_SCRAP_CONTAINER_ORDER.getCONTAINERNO(i);
        long CONTAINERINSEQ     = PD_SCRAP_CONTAINER_ORDER.getCONTAINERINSEQ(i);
        long STATUSNO           = PD_SCRAP_CONTAINER_ORDER.getSTATUSNO(i);

        // this container has been removed from OrderId that has no CONTAINERNO anny more
        if ( CONTAINERNO == CSMC_DBData::unspecLong )
        {
          std::string RecipeName = ContainerType + CDataConversion::LongToString(CONTAINERINSEQ);

          // *********************************************************************
          // setpoints as "calculated" from PD_SCRAP_CONTAINER_ORDER_ENTRY
          // *********************************************************************
          if (PD_SCRAP_CONTAINER_ORDER_ENTRY.select(HeatInfo.Plant, OrderId, CONTAINERINSEQ, CSMC_DBData::unspecLong))
          {
            seqBatch SeqBatch;

            for (long r = 1; r <= PD_SCRAP_CONTAINER_ORDER_ENTRY.getLastRow(); ++r)
            {
              sBatch    Batch;

              Batch.MatCode               = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMAT_CODE(r).c_str();
              Batch.Mass                  = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMATWEIGHT(r);
              Batch.MatLoadingSequence    = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMATCHARGESEQ(r);
              Batch.MatFeedSpeed          = CSMC_DBData::unspecDouble;
              Batch.FeedingRateRel2Energy = CSMC_DBData::unspecDouble;
              Batch.Source                = CSMC_DBData::unspecLong;


              // Ignore those materials that have a weight of near zero .
              if (Batch.Mass > 0.001)
              {
                CIntfData::insert(SeqBatch, Batch);
              }
            } // for (long r = 1; r <= PD_SCRAP_CONTAINER_ORDER_ENTRY.getLastRow(); ++r)

            sRecipeInfo RecipeInfoOrder;
            RecipeInfoOrder.RecipeStatus         = DEF_GC_RECIPE_STATUS::Calculated;
            RecipeInfoOrder.DurSinceHeatAnnounce = DurSinceHeatAnnounce;
            RecipeInfoOrder.DurSinceHeatStart    = DurSinceHeatStart;
            RecipeInfoOrder.RecipeName           = RecipeName;
            RecipeInfoOrder.RecipeNo             = 1; 
            RecipeInfoOrder.RecipeSource         = DEF_GC_RECIPE_SOURCE::Yard;
            RecipeInfoOrder.RecipeTarget         = DEF_GC_CHARGE_DEST::Furnace;


            if ( CIntfData::getLength(SeqBatch) > 0 )
            {
              // scrap container data could contain identical materials several times
              // this is not covered by writeBatch if use case is handled several times
              // we have to remove data first

              //the data for pd_recipe_entry also inserted in this function
              if ( PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant) )
              {
                RetValue = PD_RECIPE.removeRecipeData(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, RecipeInfoOrder.RecipeName, RecipeInfoOrder.RecipeNo, RecipeInfoOrder.RecipeSource, CSMC_DBData::unspecLong, Commit, m_lastError);
                RetValue = RetValue && PD_RECIPE.writeBatch(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, RecipeInfoOrder, MetTimeStamp, SeqBatch, Commit, m_lastError);
              }
            }
          }
          else
          {
            std::string SearchKey = HeatInfo.Plant + "; OrderId = " + OrderId + "; ContainerInSeg = "+ CDataConversion::LongToString(CONTAINERINSEQ);
            CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
            sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
            pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.c_str(),"PD_SCRAP_CONTAINER_ORDER_ENTRY");
          }
        }
        else
        {
          std::string SearchKey = HeatInfo.Plant + "; OrderId = " + OrderId + "; ContainerInSeg = "+ CDataConversion::LongToString(CONTAINERINSEQ) + " CONTAINERNO is in use!!";
          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.c_str(),"PD_SCRAP_CONTAINER_ORDER");
        }

        // we will not remove scrap container if if is trached by scrap yard
        // PD_RECIPE.updateRecipeData(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, RecipeName,CSMC_DBData::unspecLong,DEF_GC_RECIPE_SOURCE::Yard,CSMC_DBData::unspecLong, Commit, m_lastError);
      }

    }
    else
    {
      std::string SearchKey = HeatInfo.Plant + "; OrderId = " + OrderId ;
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.c_str(),"PD_SCRAP_CONTAINER_ORDER");
    }
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDRecipeDataOnScrapContainerDischarged(sHeatInfo &HeatInfo, const std::string &OrderId, const std::string &ContainerType, long ContainerInSeq, long ContainerNo, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDRecipeDataOnScrapContainerDischarged",3);

  bool RetValue = true;

  std::string ProductID   = HeatInfo.ProductId;
  std::string HeatID      = HeatInfo.HeatId;
  std::string TreatID     = HeatInfo.TreatId;
  std::string Plant       = HeatInfo.Plant;
  long PlantNo            = HeatInfo.PlantNo;
  std::string RecipeName  = CSMC_DBData::unspecString;

  CDateTime Now;
  double DurSinceHeatAnnounce = 0.;
  double DurSinceHeatStart    = 0.;
  double ScrapWeight          = 0.;
  double ElecCons             = 0.;

  seqGasData      TotalMetAmount;
  seqBatch        SeqMatDataContainer;

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_DBManager::handlePDRecipeDataOnScrapContainerDischarged");

    RetValue = false;
  }

  if ( RetValue )
  {
    CPD_SCRAP_CONTAINER_ORDER       PD_SCRAP_CONTAINER_ORDER      (m_pDM_DBManagerTask->getStdConnection());
    CPD_SCRAP_CONTAINER_ORDER_ENTRY PD_SCRAP_CONTAINER_ORDER_ENTRY(m_pDM_DBManagerTask->getStdConnection());
    CPD_SCRAP_CONTAINER_ENTRY       PD_SCRAP_CONTAINER_ENTRY      (m_pDM_DBManagerTask->getStdConnection());
    CGC_RECIPE_L1                   GC_RECIPE_L1                  (m_pDM_DBManagerTask->getStdConnection());

    CPD_ACTION                      PD_ACTION                     (m_pDM_DBManagerTask->getStdConnection());

    CPD_RECIPE                      PD_RECIPE                     (m_pDM_DBManagerTask->getStdConnection());

    if (m_pDM_DBManagerTask->getpProductManagementInterface())
    {
      DurSinceHeatAnnounce  = m_pDM_DBManagerTask->getpProductManagementInterface()->getDouble(ProductID, DATA::DurSinceHeatAnnounce);
      DurSinceHeatStart     = m_pDM_DBManagerTask->getpProductManagementInterface()->getDouble(ProductID, DATA::DurSinceHeatStart);
      ElecCons              = m_pDM_DBManagerTask->getpProductManagementInterface()->getDouble(ProductID, DATA::ElecCons);

      // necessary to write actual gas consumption to PD_RECIPE and PD_ACTION
      TotalMetAmount        = CIntfData::ToCORBAType(m_pDM_DBManagerTask->getpProductManagementInterface()->getGasData(ProductID.c_str(), DATA::TotalMetAmount));
    }

    sMetTimeStamp MetTimeStamp;
    MetTimeStamp.O2_Moment   = DEF::Inv_Double;
    MetTimeStamp.Ar_Moment   = DEF::Inv_Double;
    MetTimeStamp.N2_Moment   = DEF::Inv_Double;
    MetTimeStamp.Elec_Moment              = CDataConversion::SetInvalidToDefault(ElecCons,0.);
    MetTimeStamp.DurSinceHeatAnnouncement = CDataConversion::SetInvalidToDefault(DurSinceHeatAnnounce,0);
    MetTimeStamp.DurSinceStartOfHeat      = CDataConversion::SetInvalidToDefault(DurSinceHeatStart,0);

    //set corresponding gas moment. valid gas types O2,Ar,N2
    if ( CIntfData::getLength(TotalMetAmount) > 0 )
    {
      CGasDataHandler GasDataHandler(TotalMetAmount);
      MetTimeStamp.O2_Moment = GasDataHandler.getGasData(DEF_GAS::O2);
      MetTimeStamp.Ar_Moment = GasDataHandler.getGasData(DEF_GAS::Ar);
      MetTimeStamp.N2_Moment = GasDataHandler.getGasData(DEF_GAS::N2);
    }

    if (PD_SCRAP_CONTAINER_ORDER.selectByContainerNoAndType(Plant, OrderId, CSMC_DBData::unspecLong, ContainerNo, ContainerType) )
    {
      // get discharged ContainerType data
      ContainerNo     = PD_SCRAP_CONTAINER_ORDER.getCONTAINERNO(1);
      ContainerInSeq  = PD_SCRAP_CONTAINER_ORDER.getCONTAINERINSEQ(1);

      if (PD_SCRAP_CONTAINER_ORDER_ENTRY.select(Plant, OrderId, ContainerInSeq, CSMC_DBData::unspecLong))
      {
        RecipeName = PD_SCRAP_CONTAINER_ORDER_ENTRY.getRECIPENAME(1);
      }
      else
      {
        std::string SearchKey = Plant + "; OrderId = " + OrderId + "; ContainerInSeg = "+ CDataConversion::LongToString(ContainerInSeq);
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.c_str(),"PD_SCRAP_CONTAINER_ORDER_ENTRY");
      }

      //============  write material to PD_RECIPE =================================

      // read materials from the ContainerType using assigned ContainerType id
      if (ContainerNo != CSMC_DBData::unspecLong && 
          PD_SCRAP_CONTAINER_ENTRY.select(ContainerNo, ContainerType, CSMC_DBData::unspecLong))
      {
        for (long r = 1; r <= PD_SCRAP_CONTAINER_ENTRY.getLastRow(); r++)
        {
          sBatch    Batch;

          Batch.MatCode               = PD_SCRAP_CONTAINER_ENTRY.getMAT_CODE(r).c_str();
          Batch.Mass                  = PD_SCRAP_CONTAINER_ENTRY.getMATWEIGHT_CHARGED(r);
          Batch.MatLoadingSequence    = PD_SCRAP_CONTAINER_ENTRY.getMATCHARGESEQ(r);
          Batch.MatFeedSpeed          = CSMC_DBData::unspecDouble;
          Batch.FeedingRateRel2Energy = CSMC_DBData::unspecDouble;
          Batch.Source                = CSMC_DBData::unspecLong;

          // Ignore those materials that have a weight of near zero .
          if (Batch.Mass > 0.001)
          {
            CIntfData::insert(SeqMatDataContainer, Batch);

            ScrapWeight += Batch.Mass;
          }
        }// end for loop
      }
      else
      {
        std::stringstream SearchKey;
        SearchKey << ContainerNo << " " << ContainerType;
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PD_SCRAP_CONTAINER_ENTRY");
      }

      // proceed if SeqMatDataContainer > 0 but return also true not!
      // because model needs to be informed for "discharge" event if no matrials are transferred here!
      // setLastError is still written due to inform the operator for missing data from L1
      if (CIntfData::getLength(SeqMatDataContainer) > 0)
      {
        if ( RecipeName == CSMC_DBData::unspecString )
        {
          RecipeName = ContainerType + CDataConversion::LongToString(ContainerInSeq);

          if (!GC_RECIPE_L1.select(Plant, RecipeName, 0))
          {
            std::stringstream SearchKey;
            SearchKey << Plant << ", " << RecipeName << ", 0";
            CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
            sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
            pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"GC_RECIPE_L1");

            RecipeName = CSMC_DBData::unspecString;
          }
        }

        if (RecipeName != CSMC_DBData::unspecString )
        {
          sRecipeInfo RecipeInfoContainer;
          RecipeInfoContainer.RecipeStatus         = DEF_GC_RECIPE_STATUS::Discharged;
          RecipeInfoContainer.DurSinceHeatAnnounce = DurSinceHeatAnnounce;
          RecipeInfoContainer.DurSinceHeatStart    = DurSinceHeatStart;
          RecipeInfoContainer.RecipeName           = RecipeName;
          RecipeInfoContainer.RecipeNo             = 1; 
          RecipeInfoContainer.RecipeSource         = DEF_GC_RECIPE_SOURCE::Yard;
          RecipeInfoContainer.RecipeTarget         = DEF_GC_CHARGE_DEST::Furnace;


          // scrap container data could contain identical materials several times
          // this is not covered by writeBatch if use case is handled several times
          // we have to remove data first

          //the data for pd_recipe_entry also inserted in this function
          RetValue = RetValue && PD_RECIPE.replaceBatch(HeatID, TreatID, Plant, RecipeInfoContainer, MetTimeStamp, SeqMatDataContainer, Commit, m_lastError);

          if (!RetValue)
          {
            CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
            sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
            pEventLog->EL_DBWriteError(sMessage,"","PD_RECIPE","writeBatch failed!");
          }
        }
      }
      else
      {
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ScrapContainerDischargedError(sMessage, ContainerInSeq  , ContainerNo);

        setLastError("EMPTY_CONTAINER_DISCHARGED", 1200, std::string(""));

        // not explicitely set
        // RetValue = true;
      }

      //============  write action =================================
      RetValue = RetValue && PD_ACTION.UpdateOrInsertAction(HeatID, TreatID, Plant, DEF_GC_ACTION_DEF::ScrapAddition, "kg", CDataConversion::DoubleToString(ScrapWeight), 0, MetTimeStamp, false, false, m_lastError);

      if ( !RetValue )
      {
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_DBWriteError(sMessage,"","PD_ACTION","write failed!");
      }
    }// if (PD_SCRAP_CONTAINER_ORDER.selectByContainerNoAndType(Plant, OrderId, CSMC_DBData::unspecLong, ContainerNo, ContainerType) )
    else
    {
      std::string SearchKey = Plant + "; OrderId = " + OrderId + "; ContainerInSeg = "+ CDataConversion::LongToString(ContainerInSeq);
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.c_str(),"PD_SCRAP_CONTAINER_ORDER");
    }
  }// if ( RetValue )

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handlePDRecipeDataOnScrapContainerOnAnnounce(sHeatInfo &HeatInfo, const std::string &OrderId, const std::string &ContainerType, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDRecipeDataOnScrapContainerOnAnnounce",3);

  bool RetValue = true;

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_DBManager::handlePDRecipeDataOnScrapContainerOnAnnounce");

    RetValue = false;
  }

  sMetTimeStamp MetTimeStamp;
  MetTimeStamp.O2_Moment   = 0.;
  MetTimeStamp.Ar_Moment   = 0.;
  MetTimeStamp.N2_Moment   = 0.;
  MetTimeStamp.Elec_Moment = 0.;
  MetTimeStamp.DurSinceHeatAnnouncement = 0.;
  MetTimeStamp.DurSinceStartOfHeat      = 0.;

  if ( RetValue )
  {
    CPD_SCRAP_CONTAINER_ORDER       PD_SCRAP_CONTAINER_ORDER        (m_pDM_DBManagerTask->getStdConnection());
    CPD_SCRAP_CONTAINER_ORDER       PD_SCRAP_CONTAINER_ORDER_Update (m_pDM_DBManagerTask->getStdConnection());
    CPD_SCRAP_CONTAINER_ORDER_ENTRY PD_SCRAP_CONTAINER_ORDER_ENTRY  (m_pDM_DBManagerTask->getStdConnection());
    CPD_SCRAP_CONTAINER_ENTRY       PD_SCRAP_CONTAINER_ENTRY        (m_pDM_DBManagerTask->getStdConnection());

    CPD_RECIPE                      PD_RECIPE                     (m_pDM_DBManagerTask->getStdConnection());

    // we will copy data from PD_SCRAP_CONTEINER_XXX table to PD_RECIPE
    // CPD_SCRAP_CONTAINER_ORDER_ENTRY  -> status "enabled"
    // CPD_SCRAP_CONTAINER_ENTRY        -> status "WeighingComplete"

    // JAST will be managed by PD_RECIPE itself
    // first delete all entries at PC_RECIPE for Source = "Yard" 
    //PD_RECIPE.deleteRow(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,CSMC_DBData::unspecString,CSMC_DBData::unspecLong,DEF_GC_RECIPE_SOURCE::Yard,CSMC_DBData::unspecLong, Commit, m_lastError);

    //CONTAINERTYPE should not be emtpy!!! 
    // iterate over all existing container for respective OrderId
    if ( PD_SCRAP_CONTAINER_ORDER.selectByContainerNoAndType(HeatInfo.Plant, OrderId, CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, CSMC_DBData::unspecString) )
    {
      for ( long i = 1; i <= PD_SCRAP_CONTAINER_ORDER.getLastRow(); ++i )
      {
        long CONTAINERNO        = PD_SCRAP_CONTAINER_ORDER.getCONTAINERNO(i);
        long CONTAINERINSEQ     = PD_SCRAP_CONTAINER_ORDER.getCONTAINERINSEQ(i);
        long STATUSNO           = PD_SCRAP_CONTAINER_ORDER.getSTATUSNO(i);

        if ( CONTAINERINSEQ != CSMC_DBData::unspecLong )
        {
          std::string RecipeName  = ContainerType + CDataConversion::LongToString(CONTAINERINSEQ);

          log("++++++ CDM_DBManager::handlePDRecipeDataOnScrapContainerOnAnnounce::Planned",3);
          // *********************************************************************
          // setpoints as "calculated"
          // *********************************************************************
          if (PD_SCRAP_CONTAINER_ORDER_ENTRY.select(HeatInfo.Plant, OrderId, CONTAINERINSEQ, CSMC_DBData::unspecLong))
          {
            seqBatch SeqBatch;

            for (long r = 1; r <= PD_SCRAP_CONTAINER_ORDER_ENTRY.getLastRow(); ++r)
            {
              sBatch    Batch;

              Batch.MatCode               = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMAT_CODE(r).c_str();
              Batch.Mass                  = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMATWEIGHT(r);
              Batch.MatLoadingSequence    = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMATCHARGESEQ(r);
              Batch.MatFeedSpeed          = CSMC_DBData::unspecDouble;
              Batch.FeedingRateRel2Energy = CSMC_DBData::unspecDouble;
              Batch.Source                = CSMC_DBData::unspecLong;

              // Ignore those materials that have a weight of near zero .
              if (Batch.Mass > 0.001)
              {
                CIntfData::insert(SeqBatch, Batch);
              }
            } // for (long r = 1; r <= PD_SCRAP_CONTAINER_ORDER_ENTRY.getLastRow(); ++r)

            sRecipeInfo RecipeInfoOrder;
            RecipeInfoOrder.RecipeStatus         = DEF_GC_RECIPE_STATUS::Calculated;
            RecipeInfoOrder.DurSinceHeatAnnounce = MetTimeStamp.DurSinceHeatAnnouncement;
            RecipeInfoOrder.DurSinceHeatStart    = MetTimeStamp.DurSinceStartOfHeat;
            RecipeInfoOrder.RecipeName           = RecipeName;
            RecipeInfoOrder.RecipeNo             = 1; 
            RecipeInfoOrder.RecipeSource         = DEF_GC_RECIPE_SOURCE::Yard;
            RecipeInfoOrder.RecipeTarget         = DEF_GC_CHARGE_DEST::Furnace;


            if ( CIntfData::getLength(SeqBatch) > 0 )
            {
              // scrap container data could contain identical materials several times
              // this is not covered by writeBatch if use case is handled several times
              // we have to remove data first

              //the data for pd_recipe_entry also inserted in this function
              RetValue = PD_RECIPE.replaceBatch(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, RecipeInfoOrder, MetTimeStamp, SeqBatch, Commit, m_lastError);
            }
          }
          else
          {
            std::string SearchKey = HeatInfo.Plant + "; OrderId = " + OrderId + "; ContainerInSeg = "+ CDataConversion::LongToString(CONTAINERINSEQ);
            CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
            sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
            pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.c_str(),"PD_SCRAP_CONTAINER_ORDER_ENTRY");
          }


          // *********************************************************************
          // Planned materials as "Enable"
          // *********************************************************************
          if ( STATUSNO >= DEF_GC_SCRAP_CONT_ORDER_STATUS::LoadingStarted)
          {
            log("++++++ CDM_DBManager::handlePDRecipeDataOnScrapContainerOnAnnounce::LoadingStarted",3);

            if (PD_SCRAP_CONTAINER_ORDER_ENTRY.select(HeatInfo.Plant, OrderId, CONTAINERINSEQ, CSMC_DBData::unspecLong))
            {
              seqBatch SeqBatch;

              for (long r = 1; r <= PD_SCRAP_CONTAINER_ORDER_ENTRY.getLastRow(); ++r)
              {
                sBatch    Batch;

                Batch.MatCode               = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMAT_CODE(r).c_str();
                Batch.Mass                  = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMATWEIGHT(r);
                Batch.MatLoadingSequence    = PD_SCRAP_CONTAINER_ORDER_ENTRY.getMATCHARGESEQ(r);
                Batch.MatFeedSpeed          = CSMC_DBData::unspecDouble;
                Batch.FeedingRateRel2Energy = CSMC_DBData::unspecDouble;
                Batch.Source                = CSMC_DBData::unspecLong;

                // Ignore those materials that have a weight of near zero .
                if (Batch.Mass > 0.001)
                {
                  CIntfData::insert(SeqBatch, Batch);
                }
              } // for (long r = 1; r <= PD_SCRAP_CONTAINER_ORDER_ENTRY.getLastRow(); ++r)

              sRecipeInfo RecipeInfoOrder;
              RecipeInfoOrder.RecipeStatus         = DEF_GC_RECIPE_STATUS::Enabled;
              RecipeInfoOrder.DurSinceHeatAnnounce = MetTimeStamp.DurSinceHeatAnnouncement;
              RecipeInfoOrder.DurSinceHeatStart    = MetTimeStamp.DurSinceStartOfHeat;
              RecipeInfoOrder.RecipeName           = RecipeName;
              RecipeInfoOrder.RecipeNo             = 1; 
              RecipeInfoOrder.RecipeSource         = DEF_GC_RECIPE_SOURCE::Yard;
              RecipeInfoOrder.RecipeTarget         = DEF_GC_CHARGE_DEST::Furnace;


              if ( CIntfData::getLength(SeqBatch) > 0 )
              {
                // scrap container data could contain identical materials several times
                // this is not covered by writeBatch if use case is handled several times
                // we have to remove data first

                //the data for pd_recipe_entry also inserted in this function
                RetValue = PD_RECIPE.replaceBatch(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, RecipeInfoOrder, MetTimeStamp, SeqBatch, Commit, m_lastError);
              }
            }
            else
            {
              std::string SearchKey = HeatInfo.Plant + "; OrderId = " + OrderId + "; ContainerInSeg = "+ CDataConversion::LongToString(CONTAINERINSEQ);
              CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
              sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
              pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.c_str(),"PD_SCRAP_CONTAINER_ORDER_ENTRY");
            }
          }
          // *********************************************************************
          // loaded materials as "WeighingComplete"
          // *********************************************************************
          if ( STATUSNO >= DEF_GC_SCRAP_CONT_ORDER_STATUS::LoadingEnded )
          {
            log("++++++ CDM_DBManager::handlePDRecipeDataOnScrapContainerOnAnnounce::LoadingEnded",3);

            if (PD_SCRAP_CONTAINER_ENTRY.select(CONTAINERNO,  ContainerType, CSMC_DBData::unspecLong))
            {
              seqBatch SeqBatch;

              for (long r = 1; r <= PD_SCRAP_CONTAINER_ENTRY.getLastRow(); ++r)
              {
                sBatch    Batch;

                Batch.MatCode               = PD_SCRAP_CONTAINER_ENTRY.getMAT_CODE(r).c_str();
                
                if ( STATUSNO >= DEF_GC_SCRAP_CONT_ORDER_STATUS::Discharged )
                {
                  Batch.Mass                  = PD_SCRAP_CONTAINER_ENTRY.getMATWEIGHT_CHARGED(r);
                }
                else
                {
                  Batch.Mass                  = PD_SCRAP_CONTAINER_ENTRY.getMATWEIGHT(r);
                }

                Batch.MatLoadingSequence    = PD_SCRAP_CONTAINER_ENTRY.getMATCHARGESEQ(r);
                Batch.MatFeedSpeed          = CSMC_DBData::unspecDouble;
                Batch.FeedingRateRel2Energy = CSMC_DBData::unspecDouble;
                Batch.Source                = CSMC_DBData::unspecLong;

                // Ignore those materials that have a weight of near zero .
                if (Batch.Mass > 0.001)
                {
                  CIntfData::insert(SeqBatch, Batch);
                }
              } // for (long r = 1; r <= PD_SCRAP_CONTAINER_ENTRY.getLastRow(); ++r)

              sRecipeInfo RecipeInfoOrder;
              RecipeInfoOrder.RecipeStatus         = DEF_GC_RECIPE_STATUS::WeighingComplete;
              RecipeInfoOrder.DurSinceHeatAnnounce = MetTimeStamp.DurSinceHeatAnnouncement;
              RecipeInfoOrder.DurSinceHeatStart    = MetTimeStamp.DurSinceStartOfHeat;
              RecipeInfoOrder.RecipeName           = RecipeName;
              RecipeInfoOrder.RecipeNo             = 1; 
              RecipeInfoOrder.RecipeSource         = DEF_GC_RECIPE_SOURCE::Yard;
              RecipeInfoOrder.RecipeTarget         = DEF_GC_CHARGE_DEST::Furnace;


              if ( CIntfData::getLength(SeqBatch) > 0 )
              {
                // scrap container data could contain identical materials several times
                // this is not covered by writeBatch if use case is handled several times
                // we have to remove data first

                //the data for pd_recipe_entry also inserted in this function
                RetValue = PD_RECIPE.replaceBatch(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, RecipeInfoOrder, MetTimeStamp, SeqBatch, Commit, m_lastError);
              }
            }
            else
            {
              std::string SearchKey = HeatInfo.Plant + "; OrderId = " + OrderId + "; ContainerInSeg = "+ CDataConversion::LongToString(CONTAINERINSEQ);
              CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
              sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
              pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.c_str(),"PD_SCRAP_CONTAINER_ENTRY");
            }
          }

          if ( STATUSNO >= DEF_GC_SCRAP_CONT_ORDER_STATUS::Discharged )
          {
            log("++++++ CDM_DBManager::handlePDRecipeDataOnScrapContainerOnAnnounce::Discharged",3);
            // at heat announce we should not have discharged Baskets
            //RetValue = handlePDRecipeDataOnScrapContainerDischarged(HeatInfo, OrderId, ContainerType, CONTAINERINSEQ, CONTAINERNO, UserCode, false);

            CPD_SCRAP_CONTAINER         PD_SCRAP_CONTAINER               (m_pDM_DBManagerTask->getStdConnection());
            CPD_SCRAP_CONTAINER_ENTRY   PD_SCRAP_CONTAINER_ENTRY_Update  (m_pDM_DBManagerTask->getStdConnection());

            if ( PD_SCRAP_CONTAINER_ORDER_Update.select(HeatInfo.Plant, OrderId, CONTAINERINSEQ) && PD_SCRAP_CONTAINER.select(CONTAINERNO,  ContainerType) )
            {
              if ( PD_SCRAP_CONTAINER_ORDER_Update.getCONTAINERNO(1) != CSMC_DBData::unspecLong )
              {
                if (PD_SCRAP_CONTAINER_ENTRY.select(CONTAINERNO,  ContainerType, CSMC_DBData::unspecLong))
                {
                  // reset to not charged!

                  PD_SCRAP_CONTAINER_ORDER_Update.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::LoadingEnded);
                  PD_SCRAP_CONTAINER_ORDER_Update.setDISCHARGETIME(CSMC_DBData::unspecDate);
                  RetValue = RetValue && PD_SCRAP_CONTAINER_ORDER_Update.update();

                  PD_SCRAP_CONTAINER.setCHARGINGTIME(CSMC_DBData::unspecDate);
                  RetValue = RetValue && PD_SCRAP_CONTAINER.update();                    

                  for (long i=1; i<= PD_SCRAP_CONTAINER_ENTRY.getLastRow(); i++)
                  {             
                    if ( PD_SCRAP_CONTAINER_ENTRY_Update.select(PD_SCRAP_CONTAINER_ENTRY.getCONTAINERNO(i), PD_SCRAP_CONTAINER_ENTRY.getCONTAINERTYPE(i), PD_SCRAP_CONTAINER_ENTRY.getMATCHARGESEQ(i)) ) 
                    {
                      if ( PD_SCRAP_CONTAINER_ENTRY.getMATWEIGHT_CHARGED(i) > 0. )
                      {
                        PD_SCRAP_CONTAINER_ENTRY_Update.setMATWEIGHT(PD_SCRAP_CONTAINER_ENTRY.getMATWEIGHT_CHARGED(i));
                        PD_SCRAP_CONTAINER_ENTRY_Update.setMATWEIGHT_CHARGED(0.0);

                        RetValue = RetValue &&PD_SCRAP_CONTAINER_ENTRY_Update.update();
                      }
                    }

                    if(Commit)
                    {
                      if ( RetValue ) 
                      {
                        PD_SCRAP_CONTAINER_ENTRY.commit();
                      }
                      else
                      {
                        PD_SCRAP_CONTAINER_ENTRY.rollback();
                      }
                    }
                  }// if ( PD_SCRAP_CONTAINER_ENTRY.getMATWEIGHT_CHARGED(1) > 0. )
                }// if (PD_SCRAP_CONTAINER_ENTRY.select(CONTAINERNO,  ContainerType, CSMC_DBData::unspecLong))
              }
              else
              {
                PD_SCRAP_CONTAINER_ORDER_Update.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::Ordered);
                PD_SCRAP_CONTAINER_ORDER_Update.update();
              }
            }// if ( PD_SCRAP_CONTAINER.select(CONTAINERNO,  ContainerType) )
          }// if ( STATUSNO >= DEF_GC_SCRAP_CONT_ORDER_STATUS::Discharged )
        } // if ( CONTAINERINSEQ != CSMC_DBData::unspecLong &&
        else
        {
          log("++++++ CDM_DBManager::handlePDRecipeDataOnScrapContainerOnAnnounce::NoBasket",3);
        }
      }// for ( long i = 1; i <= PD_SCRAP_CONTAINER_ORDER.getLastRow(); ++i )

      PD_SCRAP_CONTAINER_ORDER.setCONTAINERTYPE(ContainerType);
      RetValue = RetValue && PD_SCRAP_CONTAINER_ORDER.update();
    }// if ( PD_SCRAP_CONTAINER_ORDER.selectByContainerNoAndType(HeatInfo.Plant,OrderId,CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, ContainerType) )
  }// if ( RetValue )

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::dischargeScrapContainer(CEventMessage& Event, const std::string& ContainerType, long ContainerInSeq, long ContainerNo, long ContainerLocation, bool commit)
{
  log("++++++ CDM_DBManager::dischargeScrapContainer",3);

  bool RetValue = true;

  std::string ProductID   = Event.getProductID();
  std::string OrderId     = Event.getOrderID();
  std::string HeatID      = Event.getHeatID();
  std::string TreatID     = Event.getTreatID();
  std::string PlantID     = Event.getPlantID();
  std::string Plant       = CSMC_DBData::unspecString;
  long PlantNo            = 1;

  CDateTime Now;

  seqBatch        SeqMatDataContainer;

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_DBManager::dischargeScrapContainer");

    return false;
  }

  if (ContainerNo == DEF::Inv_Long          || 
      ContainerNo == CSMC_DBData::unspecLong)
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ErrorHandlingScrapContainerData(sMessage,ContainerType.c_str(),ContainerNo,"CDM_DBManager::dischargeScrapContainer()");

    return false;
  }

  if (OrderId.empty() || OrderId == DEF::Inv_String)
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_InconsistentDataReceived(sMessage, "OrderId", Event.getMessage().c_str());

    return false;
  }

  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  CPD_SCRAP_CONTAINER_ORDER       PD_SCRAP_CONTAINER_ORDER      (m_pDM_DBManagerTask->getStdConnection());
  CPD_SCRAP_CONTAINER             PD_SCRAP_CONTAINER            (m_pDM_DBManagerTask->getStdConnection());
  CPD_SCRAP_CONTAINER_ENTRY       PD_SCRAP_CONTAINER_ENTRY      (m_pDM_DBManagerTask->getStdConnection());

  //============  update PD_SCRAP_CONTAINER_ORDER =================================
  // read Container id from this table
  // we are looking for the respective BaskeID, not for the ContainerInSeq !
  // we do exepect a Container to be used only once for a heat !
  if (PD_SCRAP_CONTAINER_ORDER.selectByContainerNoAndType(Plant, OrderId, CSMC_DBData::unspecLong, ContainerNo, ContainerType) )
  {
    // get discharged Container data
    ContainerNo     = PD_SCRAP_CONTAINER_ORDER.getCONTAINERNO(1);
    ContainerInSeq  = PD_SCRAP_CONTAINER_ORDER.getCONTAINERINSEQ(1);

    PD_SCRAP_CONTAINER_ORDER.setDISCHARGETIME(Now);  // set charge time
    PD_SCRAP_CONTAINER_ORDER.setREVTIME(Now);        // update  revision time
    PD_SCRAP_CONTAINER_ORDER.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::Discharged);

    RetValue = PD_SCRAP_CONTAINER_ORDER.update();

    if (!RetValue)
    {
      PD_SCRAP_CONTAINER_ORDER.rollback();

      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_DBWriteError(sMessage,"","PD_SCRAP_CONTAINER_ORDER","update failed!");
    }
  }
  else
  {
    std::string SearchKey = Plant + "; OrderId = " + OrderId + "; ContainerInSeg = "+ CDataConversion::LongToString(ContainerInSeq);
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.c_str(),"PD_SCRAP_CONTAINER_ORDER");
  }

  //============  free Container and set charge time =========================

  if (RetValue)
  {
    if ( PD_SCRAP_CONTAINER.select(ContainerNo,ContainerType) )
    {
      PD_SCRAP_CONTAINER.setCHARGINGTIME(Now);
      PD_SCRAP_CONTAINER.setSTATUSNO(DEF_GC_SCRAP_CONTAINER_STATUS::Available);
      PD_SCRAP_CONTAINER.setLOCATIONNO(ContainerLocation);

      RetValue = PD_SCRAP_CONTAINER.update();

      if (!RetValue)
      {
        PD_SCRAP_CONTAINER.rollback();

        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_DBWriteError(sMessage,"","PD_SCRAP_CONTAINER","update failed!");
      }
    }
    else
    {
      std::stringstream SearchKey;
      SearchKey << ContainerNo << " " << ContainerType;
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PD_SCRAP_CONTAINER");
    }
  }

  if (RetValue)
  {
    // read materials from the Container using assigned Container id
    if ( PD_SCRAP_CONTAINER_ENTRY.select(ContainerNo, ContainerType, CSMC_DBData::unspecLong) )
    {
      for (long r = 1; r <= PD_SCRAP_CONTAINER_ENTRY.getLastRow(); r++)
      {
        sBatch    Batch;

        Batch.MatCode               = PD_SCRAP_CONTAINER_ENTRY.getMAT_CODE(r).c_str();
        Batch.Mass                  = PD_SCRAP_CONTAINER_ENTRY.getMATWEIGHT(r);
        Batch.MatLoadingSequence    = PD_SCRAP_CONTAINER_ENTRY.getMATCHARGESEQ(r);
        Batch.MatFeedSpeed          = CSMC_DBData::unspecDouble;
        Batch.FeedingRateRel2Energy = CSMC_DBData::unspecDouble;
        Batch.Source                = CSMC_DBData::unspecLong;

        // Ignore those materials that have a weight of near zero .
        if (Batch.Mass > 0.001)
        {
          CIntfData::insert(SeqMatDataContainer, Batch);
        }
      }// end for loop
    }
    else
    {
      std::stringstream SearchKey;
      SearchKey << ContainerNo << " " << ContainerType;
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PD_SCRAP_CONTAINER_ENTRY");
    }
  }

  if (CIntfData::getLength(SeqMatDataContainer) == 0)
  {
    setLastError("EMPTY_CONTAINER_DISCHARGED", 1400, std::string(""));

    RetValue = false;
  }

  if (RetValue)
  {
    //============  move charged weight  =========================
    for (long i = 0 ; i < CIntfData::getLength(SeqMatDataContainer) ; ++i)
    {
      sBatch    Batch;
      CIntfData::getAt(Batch,SeqMatDataContainer,i);

      if ( PD_SCRAP_CONTAINER_ENTRY.select(ContainerNo,ContainerType,Batch.MatLoadingSequence) )
      {
        PD_SCRAP_CONTAINER_ENTRY.setMATWEIGHT_CHARGED(Batch.Mass);
        PD_SCRAP_CONTAINER_ENTRY.setMATWEIGHT(CSMC_DBData::unspecDouble);

        RetValue = RetValue && PD_SCRAP_CONTAINER_ENTRY.update();

        if (!RetValue)
        {
          PD_SCRAP_CONTAINER_ENTRY.rollback();

          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_DBWriteError(sMessage,"","PD_SCRAP_CONTAINER_ENTRY","update failed!");

          break;
        }
      }
    }
  }

  if (RetValue)
  {
    if ( commit )
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
    }
  }

  return RetValue;
}

bool CDM_DBManager::insertPDPretreatData(sHeatInfo &HeatInfo, std::string &OrderId, std::string &User, bool Commit)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CDM_ProductManagementInterface_Impl *dataProvider = m_pDM_DBManagerTask->getpProductManagementInterface();
    CPD_HEAT_REF      PD_HEAT_REF     (m_pDM_DBManagerTask->getStdConnection());
    CPD_PRETREATDATA  PD_PRETREATDATA (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA     PD_HEAT_DATA    (m_pDM_DBManagerTask->getStdConnection());

    long SampleCountRef        = DEF::Inv_Long;
    std::string SteelGrade     = dataProvider->getString(HeatInfo.ProductId, DATA::SteelGradeCode);
    std::string HeatId_Cust;
    std::string TreatId_Cust;

    sPDData PDData;
    PDData.SteelMass   = dataProvider->getDouble(HeatInfo.ProductId, DATA::SteelMassAct);
    
    // Outgoing Ladle
    PDData.LadleNo     = dataProvider->getLong(HeatInfo.ProductId, DATA::LadleNo);
    PDData.LadleType   = dataProvider->getString(HeatInfo.ProductId, DATA::LadleType);

    PDData.Temp        = dataProvider->getDouble(HeatInfo.ProductId, DATA::TempAim);
    PDData.TempTime    = CDateTime().assDate();

    long Status         = dataProvider->getLong(HeatInfo.ProductId, DATA::Status);

    if ( Status == DEF::Inv_Long )
    {
      //1. Fill PD_PRETREAT_DATA.HEAT_STATUSNO from PD_HEAT_REF.HEAT_STATUSNO
      if ( PD_HEAT_REF.select( HeatInfo.HeatId ) )
      {
        Status  = PD_HEAT_REF.getHEATSTATUSNO(1);
      }
    }

    double SlagMass = dataProvider->getDouble(HeatInfo.ProductId, DATA::SlagMass);
    if ( SlagMass == DEF::Inv_Double )
    {
      //3. Fill PD_PRETREAT_DATA.SLAGWEIGHT from PD_HEAT_DATA.SLAGMASS
      if (PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      {
        SlagMass = PD_HEAT_DATA.getSLAGMASS(1);
      }
    }

    if (SteelGrade == DEF::Inv_String)
    {
      if (PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      {
        SteelGrade = PD_HEAT_DATA.getSTEELGRADECODE_ACT(1);
      }
      if (SteelGrade == DEF::Inv_String)
      {
        SteelGrade = PD_HEAT_DATA.getSTEELGRADECODE_PLAN(1);
      }
    }

    if (OrderId == DEF::Inv_String || OrderId.empty())
    {
      if (PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      {
        OrderId = PD_HEAT_DATA.getPRODORDERID_ACT(1);
      }
      if (SteelGrade == DEF::Inv_String)
      {
        OrderId = PD_HEAT_DATA.getPRODORDERID_PLAN(1);
      }
    }

    if (PDData.SteelMass == DEF::Inv_Double)
    {
      //2. Fill PD_PRETREAT_DATA.STEELWEIGHT from PD_HEAT_DATA.STEELMASS
      if (PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      {
        PDData.SteelMass = PD_HEAT_DATA.getSTEELMASS(1);
      }
    }

    if (SampleCountRef == DEF::Inv_Long)
    {
      if (PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      {
        SampleCountRef = PD_HEAT_DATA.getSAMPLE_REF(1);
      }    
    }

    // Outgoing Ladle
    if (PDData.LadleType == DEF::Inv_String || PDData.LadleNo == DEF::Inv_Long)
    {
      if (PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      {
        PDData.LadleType  = PD_HEAT_DATA.getLADLETYPE(1);
        PDData.LadleNo    = PD_HEAT_DATA.getLADLENO(1);
      }  
    }

    if ( User == DEF::Inv_String || User.empty())
    {
      if (PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      {
        User = PD_HEAT_DATA.getUSERCODE(1);
      }  
    }
    if ( User == DEF::Inv_String || User.empty())
    {
      User = "HMI";
    }


    if (!PD_PRETREATDATA.selectValidDataByProdOrderIdAndPlant(OrderId, HeatInfo.Plant))
    {
      // Outgoing Ladle
      RetValue = RetValue && PD_PRETREATDATA.updateInsert(HeatInfo.HeatId, HeatInfo.TreatId, OrderId, HeatInfo.Plant, 
        HeatInfo.PlantNo, SteelGrade, HeatId_Cust, TreatId_Cust, PDData.SteelMass, SlagMass, SampleCountRef, PDData.LadleType, PDData.LadleNo, User, Status, Commit, m_lastError);
    }
  }

  checkLastError();

  return RetValue;

}

bool CDM_DBManager::isHeatPlanned(const std::string &HeatId)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);

  if (RetValue)
  {
    CPP_HEAT PP_HEAT(m_pDM_DBManagerTask->getStdConnection());

    RetValue = PP_HEAT.isPlanned(HeatId);
  }

  return RetValue;
}

bool CDM_DBManager::isCustHeatPlanned(const std::string &CustHeatId, const std::string &CustTreatId )
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);

  if (RetValue)
  {
    CPP_HEAT_PLANT PP_HEAT_PLANT(m_pDM_DBManagerTask->getStdConnection());

    RetValue = PP_HEAT_PLANT.isCustHeatPlanned(CustHeatId, CustTreatId);
  }

  return RetValue;
}


//get Ladle information from PD_HEAT_DATA table
bool CDM_DBManager::getLadleFromHeatData(sHeatInfo &HeatInfo, long &LadleNo, std::string &LadleType)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_HEAT_DATA           PD_HEAT_DATA(m_pDM_DBManagerTask->getStdConnection());
    CGC_Ladle_Def_Container GC_Ladle_Def_Container(m_pDM_DBManagerTask->getStdConnection());

    RetValue = PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant);

    if (RetValue)
    {
      LadleNo = PD_HEAT_DATA.getLADLENO(1);
      LadleType = PD_HEAT_DATA.getLADLETYPE(1);
    }

    if ( !GC_Ladle_Def_Container.isValidLadle(LadleNo, LadleType) )
    {
      RetValue = false;
    }
  }

  return RetValue;
}

bool CDM_DBManager::evChangeHotHeelData(CEventMessage &Event)
{
  log("++++++ CDM_DBManager::evChangeHotHeelData",3);

  bool RetValue = true;
  
  long Sample_Counter   = CSMC_DBData::unspecLong;
  long Sample_Ref       = CSMC_DBData::unspecLong;

  CDateTime now;

  CDM_DataInterface_Impl *dataProvider = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  HeatInfo.HeatId   = Event.getHeatID();
  HeatInfo.TreatId  = Event.getTreatID();
  HeatInfo.Plant    = Event.getPlantID();

  CDateTime SampleTime          = dataProvider->getDate(Event.getDataKey().c_str(), DATA::SteelSampleTime);

  std::string SampleLocation    = dataProvider->getString(Event.getDataKey(), DATA::SampleLocation);
  
  seqAnalysis SeqAnalysisSteel  = CIntfData::ToCORBAType(dataProvider->getAnalysis(Event.getDataKey().c_str(), DATA::SteelMeasAnalysis));
  seqAnalysis SeqAnalysisSlag   = CIntfData::ToCORBAType(dataProvider->getAnalysis(Event.getDataKey().c_str(), DATA::SlagMeasAnalysis));
  double SteelMass              = dataProvider->getDouble(Event.getDataKey(),DATA::SteelMassAct);
  double SlagMass               = dataProvider->getDouble(Event.getDataKey(),DATA::SlagMassAct);
  double TemperatureMeas        = dataProvider->getDouble(Event.getDataKey(),DATA::MeasTemp);

  std::string UserCode          = dataProvider->getString(Event.getDataKey(),DATA::UserCode);
  std::string HMIClientId       = dataProvider->getString(Event.getDataKey(), DATA::HMIClientId);
 
  long LadleNo                  = CSMC_DBData::unspecLong;
  std::string LadleType         = CSMC_DBData::unspecString;
  CDM_DBManager::splitPlantPlantNo(HeatInfo.Plant, HeatInfo.Plant, HeatInfo.PlantNo);

  CPD_SAMPLE_REF         PD_SAMPLE_REF       (m_pDM_DBManagerTask->getStdConnection());

  //Step 1: copy all sample counters into new Sampleref for HotHeel from PD_Sample_Ref regarding PD_HEAT_DATA
  RetValue = RetValue && changeHotHeelData(HeatInfo, Sample_Ref, SteelMass, SlagMass, true);  

  //Step 2: if there is Temperature measurement,save it into PD_Sample and PD_Sample_Entry,
  //update sample counter for TempMeas of HotHeel.   

  seqAnalysis SeqAnalysisHotHeel;

  if( CIntfData::getLength(SeqAnalysisSlag) > 0)
  {
    Sample_Counter = PD_SAMPLE_REF.getSampleCounter(Sample_Ref,DEF_GC_MEASUREMENT_TYPE::Slag);
    CSMC_DataProvider_Impl::insertSeqAnalysis(SeqAnalysisHotHeel, SeqAnalysisSlag);
  }

  if( CIntfData::getLength(SeqAnalysisSteel) > 0)
  {
    if ( Sample_Counter  == CSMC_DBData::unspecLong )
    {
      Sample_Counter = PD_SAMPLE_REF.getSampleCounter(Sample_Ref,DEF_GC_MEASUREMENT_TYPE::Steel);
    }
    CSMC_DataProvider_Impl::insertSeqAnalysis(SeqAnalysisHotHeel, SeqAnalysisSteel);
  }

  if(TemperatureMeas > 0.0)
  { 
    if ( Sample_Counter  == CSMC_DBData::unspecLong )
    {
      Sample_Counter = PD_SAMPLE_REF.getSampleCounter(Sample_Ref,DEF_GC_MEASUREMENT_TYPE::Temp);
    }
    CSMC_DataProvider_Impl::insertAnalysisValue(SeqAnalysisHotHeel, DEF_GC_MEASUREMENT_NAME::Temp, TemperatureMeas);
  }

  if ( CIntfData::getLength(SeqAnalysisHotHeel) > 0 )
  {
    RetValue = RetValue && addSampleAnalysis(HeatInfo, SeqAnalysisHotHeel, LadleNo, LadleType, SampleTime, DEF_GC_MEASUREMENT_TYPE::HotHeel, CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, SampleLocation, Sample_Ref, Sample_Counter, CSMC_DBData::unspecString, CSMC_DBData::unspecString, true, UserCode, false);
  }

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId, true);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }

  return RetValue;
}

bool CDM_DBManager::evHeatEnd(CEventMessage &Event)
{
  log("++++++ CDM_DBManager::evHeatEnd",3);

  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

	//SARS
	std::string UserCode    = pDataInterface->getString(Event.getDataKey(), DATA::UserCode);
  long TreatmentPosition  = getActTreatmentPosition(Event);
	RetValue = RetValue && CDM_DBManager::handlePDHeatStatus(HeatInfo, m_HeatStatus.TreatmentEnd, UserCode, TreatmentPosition, false);



  //Add Action, make commit
  RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo, DEF_GC_ACTION_DEF::HeatEnd, "", "", false, false, false);

  RetValue = RetValue && CDM_DBManager::copyHDAction(HeatInfo, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }

  //======================= update the heat stack  ==============================
  setHeatStack();
  //======================= update the heat stack  ==============================

  return RetValue;
}

bool CDM_DBManager::evHeatStart(CEventMessage &Event)
{
  log("++++++ CDM_DBManager::evHeatStart",3);

  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string OrderId     = Event.getOrderID();
  std::string DataKey     = Event.getDataKey();
  std::string UserCode    = pDataInterface->getString(DataKey, DATA::UserCode);
  std::string HMIClientId = pDataInterface->getString(DataKey, DATA::HMIClientId);

  long TreatmentPosition  = getActTreatmentPosition(Event);

  RetValue = RetValue && CDM_DBManager::handlePDTableOnHeatStart(HeatInfo, UserCode, TreatmentPosition, false);

  //Add Action
  RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo, DEF_GC_ACTION_DEF::HeatStart, "", "", false, false, false);

  RetValue = RetValue && CDM_DBManager::copyHDAction(HeatInfo, false); 

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_DBManager::evHandleUpdatePurpose(CEventMessage &Event)
 {
  log("++++++ CDM_DBManager::evHandleUpdatePurpose",3);

  bool RetValue = true;

  sHeatInfo HeatInfo;
  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  HeatInfo.Plant        = Event.getPlantID();
  seqMaterials sqMat    = CIntfData::ToCORBAType(pDataInterface->getMaterials(Event.getDataKey().c_str(),DATA::MinBinWeight));
  bool IsContainAllMat  = pDataInterface->getBoolean(Event.getDataKey().c_str(),DATA::AllMaterials);

  RetValue = handleMatAvailibiltyChange( HeatInfo.Plant,HeatInfo.PlantNo,sqMat,IsContainAllMat,true);

  return true;
}

bool CDM_DBManager::evChangeAimData(CEventMessage &Event)
{
  log("++++++ CDM_DBManager::evChangeAimData",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string OrderId		  = Event.getOrderID();
  std::string SteelGrade	= pDataInterface->getString(Event.getDataKey(), DATA::SteelGradeCode);
  std::string UserCode	  = pDataInterface->getString(Event.getDataKey(), DATA::UserCode);
  double AimWeight	      = pDataInterface->getDouble(Event.getDataKey(), DATA::AimWeight);
  double AimTemp		      = pDataInterface->getDouble(Event.getDataKey(), DATA::TempAim);
  CDateTime  TreatStart   = CSMC_DBData::unspecDate;
  CDateTime  TreatEnd	    = pDataInterface->getDate(Event.getDataKey().c_str(), DATA::TreatEndAim);
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  long TreatmentPosition  = getActTreatmentPosition(Event);

  // perform changes only if AimData are changed
  bool RetValue = isAimDataChanged(Event, SteelGrade, AimWeight, AimTemp, TreatStart, TreatEnd);

  RetValue = RetValue && CDM_DBManager::handlePDTablesOnChangeAimData(HeatInfo, SteelGrade, OrderId, AimWeight, AimTemp, TreatStart, TreatEnd, TreatmentPosition, UserCode, false);

  RetValue = RetValue && CDM_DBManager::copyHDHeatData(HeatInfo, false);
  
  //Get Actual SteelGrade in case it is invalid
  if (SteelGrade == DEF::Inv_String || SteelGrade.empty())
  {
    RetValue = RetValue && CDM_DBManager::getActSteelGrade(HeatInfo, SteelGrade);
  }

  RetValue = RetValue && CDM_DBManager::copyHDGrades(HeatInfo, SteelGrade, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }

  return RetValue;
}

bool CDM_DBManager::evCancelHeat(CEventMessage &Event)
{
  log("++++++ CDM_DBManager::evCancelHeat",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
  std::string HeatCustId  = pDataInterface->getString(Event.getDataKey(), DATA::CustHeatID);

  long TreatmentPosition  = getActTreatmentPosition(Event);

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  //Schedule Heat
  bool RetValue = CDM_DBManager::heatScheduleOnCancelHeat(HeatInfo, HeatCustId, TreatmentPosition, false);

  //Add Action, make commit
  RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo, DEF_GC_ACTION_DEF::Cancel, "", "", false, false, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }

  //======================= update the heat stack  ==============================
  setHeatStack();
  //======================= update the heat stack  ==============================

  return RetValue;
}

bool CDM_DBManager::evChangeLiquidAdditionData(CEventMessage &Event)
{
  log("++++++ CDM_DBManager::evChangeLiquidAdditionData",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string UserCode	  = pDataInterface->getString(Event.getDataKey(), DATA::UserCode);
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
  long LiqAddNo		        = pDataInterface->getLong  (Event.getDataKey(), DATA::LiqAddNo);

  sPDData PDData;
  PDData.SteelMass	     = pDataInterface->getDouble(Event.getDataKey(), DATA::SteelMassAct);
  PDData.SlagMass	       = pDataInterface->getDouble(Event.getDataKey(), DATA::SlagMassAct);
  
  // Incoming ladle
  PDData.PreLadleNo		   = pDataInterface->getLong(Event.getDataKey(), DATA::LadleNo);
  PDData.PreLadleType	   = pDataInterface->getString(Event.getDataKey(), DATA::LadleType);
  PDData.PreLadleState	 = pDataInterface->getString(Event.getDataKey(), DATA::LadleStatus);

  PDData.SteelSampleTime = pDataInterface->getDate(Event.getDataKey().c_str(), DATA::SteelSampleTime);
  PDData.Temp		         = pDataInterface->getDouble(Event.getDataKey(), DATA::TempAim);
  // HMI is filling DATA::MeasTemp, not  DATA::TempAim
  if (PDData.Temp ==  DEF::Inv_Double ) PDData.Temp	= pDataInterface->getDouble(Event.getDataKey(), DATA::MeasTemp);
  PDData.TempTime	       = pDataInterface->getDate(Event.getDataKey().c_str(), DATA::TempMeasTime);
  PDData.SteelAnalysis   = CIntfData::ToCORBAType(pDataInterface->getAnalysis(Event.getDataKey().c_str(), DATA::SteelMeasAnalysis));
  PDData.SlagAnalysis    = CIntfData::ToCORBAType(pDataInterface->getAnalysis(Event.getDataKey().c_str(), DATA::SlagMeasAnalysis));

  //if the LiqAddNo is not defined, set it to 1
  if (LiqAddNo == DEF::Inv_Long)
  {
    LiqAddNo = 1;
  }

  bool RetValue = CDM_DBManager::handlePDTablesOnChangeLiquidAddition(HeatInfo, LiqAddNo, UserCode, PDData, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

//process evChangeProdPracPointerParameter event
bool CDM_DBManager::evChangeProdPracPointerParameter(CEventMessage &Event)
{
  log("++++++ CDM_DBManager::evChangeProdPracPointerParameter",3);

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  long ProdPrac               = pDataInterface->getLong(Event.getDataKey(), DATA::ProdPracPointer);
  std::string SteelGradeCode  = pDataInterface->getString(Event.getDataKey(), DATA::SteelGradeCode);
  std::string HMIClientId     = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
  std::string CustHeatID      = pDataInterface->getString(Event.getDataKey(), DATA::CustHeatID);
  std::string CustTreatID     = pDataInterface->getString(Event.getDataKey(), DATA::CustTreatID);

  // perform changes only if ProdPrac is changed
  bool RetValue = isProductionPracticeChanged(Event, DEF_GC_PRODPRAC_DEF::Parameter, ProdPrac);
 
  //handle PD tables
  RetValue = RetValue && CDM_DBManager::handlePDTablesOnChangeProdPrac(HeatInfo, DEF_GC_PRODPRAC_DEF::Parameter, ProdPrac, false);

  RetValue = RetValue && CDM_DBManager::copyHDHeatData(HeatInfo, false);
  RetValue = RetValue && CDM_DBManager::copyHDParams(HeatInfo, false);
  // copy new set production practice pointer
  RetValue = RetValue && CDM_DBManager::copyHDGrades(HeatInfo, "", false);
    
  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);

    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__, "", HeatInfo.ProductId, CustHeatID);
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    pEventLog->EL_ProdPracChanged(sMessage, SteelGradeCode.c_str(), DEF_GC_PRODPRAC_DEF::Parameter.c_str(),
                                  ProdPrac, CustHeatID.c_str(), CustTreatID.c_str(), HeatInfo.Plant.c_str());

  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }

  return RetValue;
}

bool CDM_DBManager::handleNewTreatmentPosition(const std::string& Plant, long PlantNo, long OriginPosition, long AimPosition, bool commit)
{
  log("++++++ CDM_DBManager::handleNewTreatmentPosition",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  if (RetValue)
  {
    CPD_PLANTSTATUS PD_PLANTSTATUS(m_pDM_DBManagerTask->getStdConnection());

    RetValue = PD_PLANTSTATUS.switchTreatmentPosition(Plant, PlantNo, OriginPosition, AimPosition, false, m_lastError);
  }

  checkLastError();

  return RetValue;
}

// return actual tratment position of ProductManagementInterface
// function to be overwritten by respctive plant unts
long CDM_DBManager::getActTreatmentPosition(CEventMessage &Event)
{
  long TreatmentPosition = DEF::Inv_Long; 

  log("++++++ CDM_DBManager::getActTreatmentPosition",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  TreatmentPosition = m_pDM_DBManagerTask->getpProductManagementInterface()->getLong  (HeatInfo.ProductId, DATA::TreatmentPosition);

  if ( TreatmentPosition == DEF::Inv_Long )
  {
    TreatmentPosition = DEF_GC_TRETMENTPOSITION::Furnace ; // "furnace" as default
  }

  return TreatmentPosition;

}

bool CDM_DBManager::evChangeProdPracPointerRestriction(CEventMessage &Event)
{
  log("++++++ CDM_DBManager::evChangeProdPracPointerRestriction",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string OrderId     = Event.getOrderID();
  long  ProdPracPointer   = pDataInterface->getLong(Event.getDataKey()  ,DATA::ProdPracPointer);
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(),DATA::HMIClientId);
  long TreatmentMode      = 0;

  // perform changes only if ProdPrac is changed
  bool RetValue = isProductionPracticeChanged(Event, DEF_GC_PRODPRAC_DEF::Restriction, ProdPracPointer);

  if (RetValue)
  {
    //handle PD tables
    RetValue = RetValue && CDM_DBManager::handlePDTablesOnChangeProdPrac(HeatInfo, DEF_GC_PRODPRAC_DEF::Restriction, ProdPracPointer, false);

    RetValue = RetValue && getTreatmentMode(HeatInfo, OrderId, TreatmentMode);

    RetValue = RetValue && CDM_DBManager::copyHDHeatData(HeatInfo, false);
    RetValue = RetValue && CDM_DBManager::copyHDRestris(HeatInfo, TreatmentMode, false);

    // copy new set production practice pointer
    RetValue = RetValue && CDM_DBManager::copyHDGrades(HeatInfo, "", false);

    if (RetValue)
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
      CDM_DBManager::handleInformation(Event, HMIClientId);  
    }
    else
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback();
      CDM_DBManager::handleError(Event, HMIClientId);
    }
  }
  else
  {
    CDM_DBManager::handleInformation(Event, HMIClientId); 
  }

  return RetValue;
}

bool CDM_DBManager::evChangeTapLadleData(CEventMessage &Event)
{
  log("++++++ CDM_DBManager::evChangeTapLadleData",3);

  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string UserCode	  = pDataInterface->getString(Event.getDataKey(), DATA::UserCode);
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
  std::string LadleStatus = pDataInterface->getString(Event.getDataKey(), DATA::LadleStatus);
  long	 LadleNo	        = pDataInterface->getLong  (Event.getDataKey(), DATA::LadleNo);	
  std::string LadleType	  = pDataInterface->getString(Event.getDataKey(), DATA::LadleType);

  // *******************************************************
  // check Ladle Data against ladle catalogue
  // *******************************************************
  checkLadleData(LadleNo, LadleType, HMIClientId, "UNKNOWN_TAPPING_LADLE");

  RetValue = RetValue && CDM_DBManager::handlePDTablesOnLadleDataChanged(HeatInfo, UserCode, LadleStatus, LadleNo, LadleType, false); 

  RetValue = RetValue && CDM_DBManager::copyHDHeatData(HeatInfo, false);

  std::string SteelGradeCode = (pDataInterface->getString(Event.getDataKey(),DATA::SteelGradeCode));

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);  
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }

  return RetValue;
}

//process evDelayStatus event
bool CDM_DBManager::evDelayStatus(CEventMessage &Event)
{
  log("++++++ CDM_DBManager::evDelayStatus",3);

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
  std::string UserCode    = pDataInterface->getString(Event.getDataKey(),DATA::UserCode);  
  CDateTime StartTime     = pDataInterface->getDate(Event.getDataKey().c_str(), DATA::DelayStartDate);
  CDateTime EndTime       = pDataInterface->getDate(Event.getDataKey().c_str(), DATA::DelayEndDate);
  std::string DelayCode   = pDataInterface->getString(Event.getDataKey(), DATA::DelayCode);
  std::string Comment     = pDataInterface->getString(Event.getDataKey(), DATA::Comment);
  long Status             = pDataInterface->getLong(Event.getDataKey(), DATA::Status);

  Status = CDataConversion::SetInvalidToDefault(Status,DEF_GEN_STATES::Insert,DEF::Inv_Long);
  
  bool RetValue = CDM_DBManager::handlePDTablesOnDelayStatus(HeatInfo, StartTime, EndTime, DelayCode, UserCode, Comment, Status, false);

  RetValue = RetValue && CDM_DBManager::copyHDDelays(HeatInfo, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);  
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }

  return RetValue;
}

bool CDM_DBManager::evHeatAnnouncement(CEventMessage &Event, bool commit)
{
  bool RetValue = true; 

  log("++++++ CDM_DBManager::evHeatAnnouncement",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string EvOrderId        = Event.getOrderID();

  std::string OrderId          = pDataInterface->getString(Event.getDataKey(), DATA::OrderId);
  std::string OrderIdUser      = pDataInterface->getString(Event.getDataKey(), DATA::OrderIdUser);
  std::string CustHeatId       = pDataInterface->getString(Event.getDataKey(), DATA::CustHeatID);
  std::string CustTreatId      = pDataInterface->getString(Event.getDataKey(), DATA::CustTreatID);
  std::string CustHeatIdUser   = pDataInterface->getString(Event.getDataKey(), DATA::CustHeatIdUser);
  std::string CustTreatIdUser  = pDataInterface->getString(Event.getDataKey(), DATA::CustTreatIdUser);
  std::string SteelGradeCode   = pDataInterface->getString(Event.getDataKey(), DATA::SteelGradeCode);
  std::string UserCode         = pDataInterface->getString(Event.getDataKey(), DATA::UserCode);
  std::string HMIClientId      = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
  
  CDateTime  mPlanEndTime(pDataInterface->getDate(Event.getDataKey().c_str(), DATA::PlanEndTime));

  double AimWeight        = pDataInterface->getDouble(Event.getDataKey(), DATA::AimWeight);
  double AimWeightUser    = pDataInterface->getDouble(Event.getDataKey(), DATA::AimWeightUser);
  double AimTemp          = pDataInterface->getDouble(Event.getDataKey(), DATA::TempAim);

  // TreatmentMode is not available for all palnt units. 
  // if TreatmentMode is not avialable (TreatmentMode == DEF::Inv_Long) it will not be stored in functiond below
  long   TreatmentMode     = pDataInterface->getLong(Event.getDataKey(), DATA::TreatmentMode);
  long   TreatmentPosition = getActTreatmentPosition(Event);

  sPDData PDData;
  PDData.SteelMass        = pDataInterface->getDouble(Event.getDataKey().c_str(), DATA::SteelMassAct);
  PDData.SlagMass         = pDataInterface->getDouble(Event.getDataKey().c_str(), DATA::SlagMassAct);

  // Incoming ladle
  PDData.PreLadleNo       = pDataInterface->getLong(Event.getDataKey().c_str(),   DATA::LadleNo);
  PDData.PreLadleType     = pDataInterface->getString(Event.getDataKey().c_str(), DATA::LadleType);
  PDData.PreLadleState    = pDataInterface->getString(Event.getDataKey().c_str(), DATA::LadleStatus);

  PDData.SampleNo         = pDataInterface->getLong(Event.getDataKey().c_str(),   DATA::SampleNo);
  PDData.SteelSampleTime  = pDataInterface->getDate(Event.getDataKey().c_str(),   DATA::SteelSampleTime);
  PDData.Temp             = pDataInterface->getDouble(Event.getDataKey().c_str(), DATA::MeasTemp);
  PDData.TempTime         = pDataInterface->getDate(Event.getDataKey().c_str(),   DATA::TempMeasTime);
  PDData.SampleMode       = pDataInterface->getLong(Event.getDataKey().c_str(),   DATA::SampleMode);
  PDData.SampleOrigin     = pDataInterface->getLong(Event.getDataKey().c_str(),   DATA::SampleOrigin);
  PDData.SteelAnalysis    = CIntfData::ToCORBAType(pDataInterface->getAnalysis(Event.getDataKey().c_str(), DATA::SteelMeasAnalysis));
  PDData.PretreatCounter  = pDataInterface->getLong(Event.getDataKey().c_str(),   DATA::Counter);

  std::string mOrd        = OrderId;
  std::string mHeatCust   = CustHeatId;
  std::string mTreatCust  = CustTreatId;

  // *******************************************************
  // OrderId
  // *******************************************************
  if ( (OrderId.empty() || OrderId == DEF::Inv_String) )
  {
    mOrd = EvOrderId;
  }
  if ( !OrderIdUser.empty() && OrderIdUser != DEF::Inv_String )
  {
    mOrd = OrderIdUser;
  }
  if ( (mOrd.empty() || mOrd == DEF::Inv_String) )
  {
    setLastError("INVALID_PRODUCTION_ORDER", 0, "", 1);
    RetValue = false;
  }


  // *******************************************************
  // HeatId
  // *******************************************************
  if ( !CustHeatIdUser.empty() && CustHeatIdUser != DEF::Inv_String )
  {
    mHeatCust = CustHeatIdUser;
  }
  if ( (mHeatCust.empty() || mHeatCust == DEF::Inv_String) )
  {
    setLastError("INVALID_HEATID", 0, "", 1);
    RetValue = false;
  }

  // *******************************************************
  // TreatId
  // *******************************************************
  if ( !CustTreatIdUser.empty() && CustTreatIdUser != DEF::Inv_String )
  {
    mTreatCust = CustTreatIdUser;
  }
  if ( (mTreatCust.empty() || mTreatCust == DEF::Inv_String) )
  {
    setLastError("INVALID_TREATID", 0, "", 1);
    RetValue = false;
  }

  // *******************************************************
  // SteelGradeCode
  // *******************************************************
  if ( (SteelGradeCode.empty() || SteelGradeCode == DEF::Inv_String) )
  {
    setLastError("INVALID_STEEL_GRADE", 0, "", 1);
    RetValue = false;
  }

  // *******************************************************
  // AimWeight
  // *******************************************************
  if ( AimWeightUser != DEF::Inv_Double )
  {
    AimWeight = AimWeightUser;
  }

  // *******************************************************
  // check Ladle Data against ladle catalogue
  // *******************************************************
  // we have plant units without sending ladle information at heat announcement
  // we check only "valid" data against catalogue
  // Incoming ladle
  checkLadleData(PDData.PreLadleNo, PDData.PreLadleType, HMIClientId, "UNKNOWN_TAP_OR_TEEMING_LADLE");

  // *******************************************************
  // check TreatmentPosition
  // *******************************************************
  if ( TreatmentPosition == DEF::Inv_Long )
  {
    TreatmentPosition = DEF_GC_TRETMENTPOSITION::Furnace; // furnace
  }

  // *******************************************************
  // Pretreat Data
  // *******************************************************
  RetValue = RetValue && handlePDPretreatTablesOnAnnounce(HeatInfo, mOrd, SteelGradeCode, UserCode, PDData, true);

  if (RetValue)
  {
    //Check if Heat is onRequest or doesn't exest
    if ( CDM_DBManager::isOnRequest(CustHeatId, CustHeatIdUser) || CDM_DBManager::isOnRequest(OrderId, OrderIdUser) || !CDM_DBManager::isHeatPlanned(HeatInfo) )
    {
      // we will not call 
      // CDM_DBManager::checkSeqOfCustHeatId(HeatInfo, mHeatCust, mTreatCust, commit);
      // in case that operator set values himself

      // if TreatmentMode is not avialable (TreatmentMode == DEF::Inv_Long) it will not be stored in functiond below
      RetValue = RetValue && CDM_DBManager::handlePPTabelsOnAnnounce(HeatInfo, PDData, mHeatCust, mTreatCust, mOrd, SteelGradeCode, mPlanEndTime, true, UserCode, AimWeight, AimTemp, TreatmentMode, commit);
    }
    else
    {
      bool UseNaturalHeatSequence = false;

      cCBS_StdInitBase::getInstance()->replaceWithEntry("PROCESS","UseNaturalHeatSequence",UseNaturalHeatSequence);

      if ( UseNaturalHeatSequence )
      {
        // check if heat is planned and planned heat is in sequence
        // method may overwrite mHeatCust with scheduled value
        // we will proceed even if return value is false !
        CDM_DBManager::checkSeqOfCustHeatId(HeatInfo, mHeatCust, mTreatCust, commit);
      }

      // if TreatmentMode is not avialable (TreatmentMode == DEF::Inv_Long) it will not be stored in functiond below
      RetValue = RetValue && CDM_DBManager::handlePPTabelsOnAnnounce(HeatInfo, PDData, mHeatCust, mTreatCust, mOrd, SteelGradeCode, mPlanEndTime, false, UserCode, AimWeight, AimTemp, TreatmentMode, commit);
    }

    //Schedule Heat
    RetValue = RetValue && CDM_DBManager::heatScheduleOnAnnouncement(HeatInfo, UserCode, TreatmentPosition, commit);

    //Prepare PD tables
    long SAMPLE_REF = CSMC_DBData::unspecLong;
    RetValue = RetValue && handlePDTablesOnAnnounce(HeatInfo, mOrd, SteelGradeCode, UserCode, PDData, SAMPLE_REF, TreatmentPosition, commit);
  }

  //Add Action
  RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo, DEF_GC_ACTION_DEF::HeatAnnounce, "", "", false, false, commit);

  //Add Action
  RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo, DEF_GC_ACTION_DEF::PreparationStart, "", "", false, false, commit);

  //Copy data into HD tables
  RetValue = RetValue && CDM_DBManager::copyHDHeatData(HeatInfo, false);
  RetValue = RetValue && CDM_DBManager::copyHDGrades(HeatInfo, SteelGradeCode, false);
  RetValue = RetValue && CDM_DBManager::copyHDParams(HeatInfo, false);
  
  if ( TreatmentMode == DEF::Inv_Long )
  {
    RetValue = RetValue && getTreatmentMode(HeatInfo, OrderId, TreatmentMode);
  }

  RetValue = RetValue && CDM_DBManager::copyHDTreatmode (HeatInfo, OrderId, TreatmentMode, false);
  RetValue = RetValue && CDM_DBManager::copyHDRestris   (HeatInfo, TreatmentMode, false);

  if (commit)
  {
    if ( RetValue )
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
    }
    else 
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback(); 
    }
  }

  if (RetValue)
  {
    log("Set event heat, treat, order data",3);
    Event.setHeatID(HeatInfo.HeatId);
    Event.setTreatID(HeatInfo.TreatId);
    Event.setOrderID(mOrd);

    log("Set received CustHeatID and CustTreatID",3);
    m_pDM_DBManagerTask->getpDataInterface()->setString(Event.getDataKey(), DATA::CustHeatID, mHeatCust);
    m_pDM_DBManagerTask->getpDataInterface()->setString(Event.getDataKey(), DATA::CustTreatID, mTreatCust);

    CDM_DBManager::handleInformation(Event, HMIClientId, true);
  }
  else
  {
    CDM_DBManager::handleError(Event, HMIClientId);
  }

  //======================= update the heat stack  ==============================
  setHeatStack();
  //======================= update the heat stack  ==============================

  return RetValue;
}

// method checks if CustHeatId is really planned (relevant for melting units) and if it is the first heat in sequence for the
// respective plant unit. Otherwise the CustHeatId will be set to the first heat in plannning sequence !
bool CDM_DBManager::checkSeqOfCustHeatId(sHeatInfo &HeatInfo, std::string& CustHeatId, std::string& CustTreatId, bool commit)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  
  if (RetValue)
  {
    CPP_HEAT_PLANT PP_HEAT_PLANT         (m_pDM_DBManagerTask->getStdConnection());

    bool IsHeatPlanned = isCustHeatPlanned(CustHeatId, CustTreatId);

    // if heat is planned, check if CustHeatId is teh first in planned heat sequence
    if  ( IsHeatPlanned )
    {
      if ( PP_HEAT_PLANT.selectByPlanningState(HeatInfo.Plant, HeatInfo.PlantNo, true) )
      {
        // the announced heat is not the first in planned sequence !!!!!!
        if ( CustHeatId != PP_HEAT_PLANT.getHEATID_CUST_PLAN(1) )
        {
          // take the heat from planning sequence
          CustHeatId = PP_HEAT_PLANT.getHEATID_CUST_PLAN(1);

          std::string TreatId = CSMC_DBData::unspecString;

          // write the new value to pp_heat_plant
          RetValue = RetValue && PP_HEAT_PLANT.updateInsertPP(HeatInfo.HeatId, TreatId, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, CustHeatId, CSMC_DBData::unspecString, CSMC_DBData::unspecDate, CSMC_DBData::unspecDate, commit, m_lastError);
          
          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_DBWriteInfo(sMessage,"HEATID_CUST_PLAN","PP_HEAT_PLANT","heat is adapted to correct planning sequence");

          RetValue = false;
        } // if ( CustHeatId != PP_HEAT_PLANT.getHEATID_CUST_PLAN(1) )
      } // if ( PP_HEAT_PLANT.selectByPlanningState(HeatInfo.Plant, HeatInfo.PlantNo, true)
    } // IsHeatPlanned
  }

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::evProductionOrderChanged(CEventMessage &Event)
{
  log("++++++ CDM_DBManager::evProductionOrderChanged",3);

  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string OrderId     = Event.getOrderID();

  std::string OrderIdNew  = pDataInterface->getString(Event.getDataKey(), DATA::ProdOrderSchedule);
  std::string UserCode    = pDataInterface->getString(Event.getDataKey(), DATA::UserCode);
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
  std::string SteelGradeCode;

  //Get SteelGradeCode if empty
  if (RetValue &&  ( SteelGradeCode.empty() || SteelGradeCode == DEF::Inv_String ) )
  {
    RetValue = RetValue && CDM_DBManager::getActSteelGrade(HeatInfo, SteelGradeCode);
  }

  RetValue = RetValue && CDM_DBManager::handlePDTablesOnProdOrdChanged(HeatInfo, SteelGradeCode, OrderIdNew, UserCode, false);

  long TreatmentMode = 0;
  RetValue = RetValue && getTreatmentMode(HeatInfo, OrderId, TreatmentMode);

  RetValue = RetValue && CDM_DBManager::copyHDHeatData  (HeatInfo, false);
  RetValue = RetValue && CDM_DBManager::copyHDGrades    (HeatInfo, "", false);
  RetValue = RetValue && CDM_DBManager::copyHDParams    (HeatInfo, false);
  RetValue = RetValue && CDM_DBManager::copyHDRestris   (HeatInfo, TreatmentMode, false);
  RetValue = RetValue && CDM_DBManager::copyHDMatFeed   (HeatInfo, "", TreatmentMode,  false);
  
  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);  
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();      
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_DBManager::handlePDTableOnHeatStart(sHeatInfo &HeatInfo, const std::string& UserCode, long TreatmentPosition, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDTableOnHeatStart",3);

  bool RetValue = true;
  CDateTime Now;

  CPD_HEAT_DATA       PD_HEAT_DATA      (m_pDM_DBManagerTask->getStdConnection());
  CPD_HEAT_REF        PD_HEAT_REF       (m_pDM_DBManagerTask->getStdConnection());
  CPD_PLANTSTATUS     PD_PLANTSTATUS    (m_pDM_DBManagerTask->getStdConnection());
  CPD_HEAT_PLANT_REF  PD_HEAT_PLANT_REF (m_pDM_DBManagerTask->getStdConnection());

  if ( PD_HEAT_DATA.isHeatDeparted(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant) )
  {
    setLastError("HEAT_START_FOR_DEPARTED_HEAT", 0, "" , 1);
    RetValue = false;
  }

  RetValue = RetValue && PD_HEAT_REF.doHeatStart(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, UserCode,Commit, m_lastError);//sankar add plant

  RetValue = RetValue && PD_HEAT_DATA.doHeatStart(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);

  RetValue = RetValue && CDM_DBManager::handlePDHeatStatus(HeatInfo, m_HeatStatus.TreatmentStart, UserCode, TreatmentPosition, Commit);

  RetValue = RetValue && PD_PLANTSTATUS.doHeatStart(HeatInfo.Plant, HeatInfo.PlantNo, TreatmentPosition, HeatInfo.HeatId, HeatInfo.TreatId, Commit, m_lastError);

  checkLastError();
  
  return RetValue;
}

bool CDM_DBManager::handlePDTableOnHeatEnd(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_DBManager::handlePDTableOnHeatEnd",3);

  bool RetValue = true;
  CDateTime Now;

  CPD_HEAT_DATA       PD_HEAT_DATA      (m_pDM_DBManagerTask->getStdConnection());
  CPD_HEAT_PLANT_REF  PD_HEAT_PLANT_REF (m_pDM_DBManagerTask->getStdConnection());

  RetValue = PD_HEAT_DATA.doHeatEnd(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);

  RetValue = RetValue && PD_HEAT_PLANT_REF.setStatus(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, DEF_GC_STATUS::TreatmentEnd, true, Commit, m_lastError);

  checkLastError();

  return RetValue;
}

bool CDM_DBManager::handleOperatorComment(sHeatInfo &HeatInfo, const std::string &OperatorComment, bool Commit)
{
  log("++++++ CDM_DBManager::handleOperatorComment",3);

  bool result = (m_pDM_DBManagerTask != NULL);
  if (result)
  {
    CPD_HEAT_DATA   PD_HEAT_DATA  (m_pDM_DBManagerTask->getStdConnection());

    if ( PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant) )
    {
      PD_HEAT_DATA.setCOMMENTS(OperatorComment);
      result = PD_HEAT_DATA.update();
    }
  }

  return result;
}

bool CDM_DBManager::evHeatDeparture(CEventMessage &Event)
{
  log("++++++ CDM_DBManager::evHeatDeparture",3);

  bool RetValue = true;

  //======================= update the heat stack  ==============================
  setHeatStack();  
  //======================= update the heat stack  ==============================

  return RetValue;
}

std::set<std::string> CDM_DBManager::getHeatsPresettedAndPlanned(const std::string& Plant)
{
  std::set<std::string> Heats;

  CPP_HEAT_PLANT          PP_HEAT_PLANT         (m_pDM_DBManagerTask->getStdConnection());

  // find PresettedHeats 
  // select heats with PLANNED = 1 and PRESET_HEATID = 1
  if ( PP_HEAT_PLANT.selectByPlanningStateAndPreset( Plant, CSMC_DBData::unspecLong, 1, 1, false) )
  {
    for (long row = 1; row <= PP_HEAT_PLANT.getLastRow(); row++)
    {
      if ( !PP_HEAT_PLANT.isNull(CPP_HEAT_PLANT::HEATID_CUST_PLAN, row ) )
      {
        Heats.insert(PP_HEAT_PLANT.getHEATID_CUST_PLAN(row));
      }
    }
  }

  return Heats;
}

std::set<std::string> CDM_DBManager::getUsedHeatsFromSchedule(const std::string& Plant)
{
  std::set<std::string> Heats;

  CPP_HEAT_PLANT          PP_HEAT_PLANT         (m_pDM_DBManagerTask->getStdConnection());

  // find UsedHeats
  // select heats with PLANNED = 0
  if ( PP_HEAT_PLANT.selectByPlanningState( Plant, CSMC_DBData::unspecLong, 0) )
  {
    for (long row = 1; row <= PP_HEAT_PLANT.getLastRow(); row++)
    {
      if ( !PP_HEAT_PLANT.isNull(CPP_HEAT_PLANT::HEATID_CUST_PLAN, row ) )
      {
        Heats.insert(PP_HEAT_PLANT.getHEATID_CUST_PLAN(row));
      }
    }
  }

  return Heats;
}

std::string CDM_DBManager::getNextAvailableHeatIdCust(const std::string& Plant, const std::set<std::string> &HeatsPresettedAndPlanned, const std::set<std::string>& HeatsInProduction, const std::string& HeatIDPrefix, long& HeatIDCounter, const std::string& TreatID)
{
  CPP_HEAT_PLANT          PP_HEAT_PLANT         (m_pDM_DBManagerTask->getStdConnection());

  CHeatIDCust HeatIDCust;

  std::string NextHeatIDCust = HeatIDCust.getHeatIDCust(HeatIDPrefix, HeatIDCounter);

  // prevent generting HeatIDCust that are already defined by planning system (presetted)
  // prevent generting already used HeatIDCust
  while ( HeatsPresettedAndPlanned.find(NextHeatIDCust) != HeatsPresettedAndPlanned.end() || 
          HeatsInProduction.find(NextHeatIDCust)        != HeatsInProduction.end()        ||
          PP_HEAT_PLANT.isCustHeatInProduction(NextHeatIDCust, TreatID, Plant )           )
  {
    HeatIDCounter++;
    NextHeatIDCust = HeatIDCust.getHeatIDCust(HeatIDPrefix, HeatIDCounter);
  }

  return NextHeatIDCust;
}

std::string CDM_DBManager::getNextAvailableHeatIdCust(const std::string& Plant, const std::string& HeatIDPrefix, long& HeatIDCounter, const std::string& TreatID)
{
  std::set<std::string> HeatsPresettedAndPlanned  = getHeatsPresettedAndPlanned(Plant);
  std::set<std::string> HeatsInProduction         = getUsedHeatsFromSchedule(Plant);

  return getNextAvailableHeatIdCust(Plant, HeatsPresettedAndPlanned, HeatsInProduction, HeatIDPrefix, HeatIDCounter, TreatID);
}

std::string CDM_DBManager::getNextHeatIdCust(const std::string& Plant)
{
  CHeatIDCust HeatIDCust;

  std::string NextHeatIdCust;
  std::string HeatIDPrefix  ;
  long HeatIDCounter        = 0;


  CPD_HEAT_PLANT_REF    PD_HEAT_PLANT_REF   (m_pDM_DBManagerTask->getStdConnection());
  CGT_PARAM             GT_PARAM            (m_pDM_DBManagerTask->getStdConnection());

  // **************************************************************************
  // try to find highest used HEATID_CUST that is in production at Plant
  // **************************************************************************
  if ( PD_HEAT_PLANT_REF.selectValidCustData(CSMC_DBData::unspecString, CSMC_DBData::unspecString, Plant, false) )
  {
    std::string HEATID_CUST = PD_HEAT_PLANT_REF.getHEATID_CUST(1);

    HeatIDPrefix  = HeatIDCust.getPrefix(HEATID_CUST);
    HeatIDCounter = HeatIDCust.getCounter(HEATID_CUST);

  }
  // **************************************************************************
  // read data from parameter table to find possible start point for generation
  // **************************************************************************
  else
  {
    if ( GT_PARAM.selectByPlant(Plant, CSMC_DBData::unspecLong, "SeqStartHeatIDCust" ,0 ,DEF_GC_PARAM_TYPE::LParam) )
    {
      HeatIDCounter     = CDataConversion::StringToLong(GT_PARAM.getVALUE(1),1);
    }
  }

  NextHeatIdCust = HeatIDCust.generateNextHeatIDCust(HeatIDPrefix, HeatIDCounter);
 
  return NextHeatIdCust;
}

bool CDM_DBManager::handlePDTablesOnMaterialHandlingReport(const sHeatInfo& HeatInfo, const sRecipeInfo& RecipeInfo, const seqBatch& Batch, const seqGasData& GasData, double ElecEnergy, bool Commit )
{
  log("++++++ CDM_DBManager::handlePDTablesOnMaterialHandlingReport",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  if (RetValue)
  {
    sRecipeInfo RecipeInfo(RecipeInfo);
    seqGasData GasData(GasData);
    seqBatch Batch(Batch);

    CPD_RECIPE  PD_RECIPE(m_pDM_DBManagerTask->getStdConnection());

    long BatchLength = CIntfData::getLength(Batch);

    std::stringstream tmpStr;
    tmpStr << "Heatid : "     << HeatInfo.HeatId
      << ", Treatid : "       << HeatInfo.TreatId
      << ", RecipeName : "    << RecipeInfo.RecipeName
      << ", RecipeSource : "  << RecipeInfo.RecipeSource
      << ", RecipeStatus : "  << RecipeInfo.RecipeStatus
      << ", RecipeNo : "      << RecipeInfo.RecipeNo
      << ", RecipeTarget : "  << RecipeInfo.RecipeTarget
      << ", Batch size : "    << BatchLength;

    if ( 0 != CIntfData::getLength(Batch) )
    {
      PD_RECIPE.checkBatchStateChange(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, RecipeInfo);

      // in case of materials beeing enabled that are not included in a calcualtion result, write warning to operator
      if ( RecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::Enabled &&  
           !PD_RECIPE.checkBatchForCalculatedMaterials(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, RecipeInfo, Batch) )
      {
        std::string HMIMessage = "WARNING_NOT_CALCULATED_MATERIAL_ENABLED " + RecipeInfo.RecipeName;
        setLastError(HMIMessage, 0, "" , 1);
      }

      sMetTimeStamp TimeStamp;
      TimeStamp.O2_Moment   = DEF::Inv_Double;
      TimeStamp.Ar_Moment   = DEF::Inv_Double;
      TimeStamp.N2_Moment   = DEF::Inv_Double;
      TimeStamp.Elec_Moment = CDataConversion::SetInvalidToDefault(ElecEnergy, DEF::Inv_Double);

      if ( CIntfData::getLength(GasData) > 0 )
      {
        CGasDataHandler GasDataHandler(GasData);
        TimeStamp.O2_Moment = GasDataHandler.getGasData(DEF_GAS::O2);
        TimeStamp.N2_Moment = GasDataHandler.getGasData(DEF_GAS::N2);
        TimeStamp.Ar_Moment = GasDataHandler.getGasData(DEF_GAS::Ar);
      }

      RetValue = PD_RECIPE.writeBatch(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, RecipeInfo, TimeStamp, Batch, false, m_lastError);

      if ( Commit )
      {
        if ( RetValue )
        {
          PD_RECIPE.commit();
        }
        else
        {
          PD_RECIPE.rollback();
        }
      }
    } 
    else
    {
      if (RecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::Enabled ||
          RecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::Weighed ||
          RecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::WeighingCompleteUpdate)
      {
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_RecipeWithoutMaterials(sMessage, RecipeInfo.RecipeName.c_str(), RecipeInfo.RecipeNo, RecipeInfo.RecipeStatus);
      }
    }
  }

  return RetValue;
}

