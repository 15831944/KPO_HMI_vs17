//## Copyright (C) 2009 SMS Siemag AG, Germany 
//## Version generated by (DB)ClassCodeUtility BETA 0.6.0 


#include "iSMC_DataDefinitions_s.hh"
#include "iEventMessages_s.hh"

#include "cCBS_StdInitBase.h"
#include "CSMC_DataProvider_Impl.h"
#include "CSMC_EventLogFrameController.h"
#include "CDM_DataInterface_Impl.h"
#include "CDataConversion.h"
#include "CHeatIDCust.h"
#include "CHeatStatusContainer.h"

//GC_tables
#include "CGC_PLANT.h"
#include "CGC_Plant_Container.h"

//GT_tables
#include "CGT_PARAM.h"

//PD tables
#include "CPD_HEAT_PLANT_REF.h"
#include "CPD_HEAT_DATA.h"
#include "CPD_PRETREATDATA.h"
#include "CPD_HOT_METAL.h"
#include "CPD_HEAT_REF.h"
#include "CPD_SCRAP_CONTAINER_ORDER.h"
#include "CPD_HOT_METAL_ORDER.h"
#include "CPD_LADLE.h"


//PP tables
#include "CPP_HEAT.h"
#include "CPP_ORDER.h"
#include "CPP_HEAT_PLANT.h"
#include "CPP_ORDER_SINGLE_AIMS.h"
#include "CPD_PLANTSTATUS.h"
#include "CPD_PLANTSTATUS_PLANT.h"
#include "CGC_HEAT_STATUS.h"

//Definition classes
#include "DEF_GC_HEAT_STATUS.h"
#include "DEF_GC_PLANT_DEF.h"
#include "DEF_GC_PARAM_TYPE.h"
#include "DEF_GC_MEASUREMENT_ORIGIN.h"
#include "DEF_GC_SCRAP_CONT_ORDER_STATUS.h"
#include "DEF_GC_LADLE_TYPE.h"
#include "DEF_GC_MEASUREMENT_NAME.h"
#include "DEF_GC_PLANTGROUP_DESC.h"


#include "CDM_GENTask.h"
#include "CDM_GENDBManager.h"



CDM_GENDBManager::CDM_GENDBManager(CDM_DBManagerTask* _task)
: CDM_DBManager(_task)
{
}

CDM_GENDBManager::~CDM_GENDBManager()
{
}

void CDM_GENDBManager::init()
{
  CDM_DBManager::init();
}

bool CDM_GENDBManager::evCCSHeatStatus(CEventMessage &Event)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);

  if ( RetValue )
  {

    //std::string PlantId         = m_pDM_DBManagerTask->getpDataInterface()->getString (Event.getDataKey(), DATA::PlantID);
    //long        CasterNo        = m_pDM_DBManagerTask->getpDataInterface()->getLong   (Event.getDataKey(), DATA::CasterNo);
    std::string CustHeatID      = m_pDM_DBManagerTask->getpDataInterface()->getString (Event.getDataKey(), DATA::CustHeatID);
	  std::string CustTreatID      = m_pDM_DBManagerTask->getpDataInterface()->getString (Event.getDataKey(), DATA::CustTreatID);
    long        RemSteelWeight  = m_pDM_DBManagerTask->getpDataInterface()->getLong   (Event.getDataKey(), DATA::RemSteelWeightLadle);
    long        HeatStatus      = m_pDM_DBManagerTask->getpDataInterface()->getLong   (Event.getDataKey(), DATA::HeatStatus);
	  std::string HeatID          = m_pDM_DBManagerTask->getpDataInterface()->getString (Event.getDataKey(), DATA::HeatID);
	  std::string TreatID         = m_pDM_DBManagerTask->getpDataInterface()->getString (Event.getDataKey(), DATA::TreatID);
    long        CCSId           = m_pDM_DBManagerTask->getpDataInterface()->getLong   (Event.getDataKey(), DATA::CasterNo);
	  std::string OrderID         = m_pDM_DBManagerTask->getpDataInterface()->getString (Event.getDataKey(), DATA::OrderId);
	  std::string SteelGrade      = m_pDM_DBManagerTask->getpDataInterface()->getString (Event.getDataKey(), DATA::SteelGradeCode);
	  long        LadleNo         = m_pDM_DBManagerTask->getpDataInterface()->getLong   (Event.getDataKey(), DATA::LadleNo);
	  long        RemSteelWeightTundish         = m_pDM_DBManagerTask->getpDataInterface()->getLong   (Event.getDataKey(), DATA::RemSteelWeightTundish);
	
	  CDateTime SetInTurretTime;
	  SetInTurretTime     <<  m_pDM_DBManagerTask->getpDataInterface()->getDate (Event.getDataKey().c_str(), DATA::ReqSetInTurretTime);
	
	  long        TundishSuperHeat         = m_pDM_DBManagerTask->getpDataInterface()->getLong   (Event.getDataKey(), DATA::TundishSuperHeat);
	

    CPD_PRETREATDATA      PD_PRETREATDATA       (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_PLANT_REF    PD_HEAT_PLANT_REF    (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA         PD_HEAT_DATA         (m_pDM_DBManagerTask->getStdConnection());
    CGC_PLANT             GC_PLANT             (m_pDM_DBManagerTask->getStdConnection());
    CGC_Plant_Container   GC_Plant_Container   (m_pDM_DBManagerTask->getStdConnection(), DEF_GC_PLANT_DEF::CCS);
	  CPD_PLANTSTATUS       PD_PLANTSTATUS         (m_pDM_DBManagerTask->getStdConnection());
	  CPD_LADLE             PD_LADLE         (m_pDM_DBManagerTask->getStdConnection());
	  CPD_PLANTSTATUS_PLANT PD_PLANTSTATUS_PLANT (m_pDM_DBManagerTask->getStdConnection());
	  CGC_HEAT_STATUS             GC_HEAT_STATUS         (m_pDM_DBManagerTask->getStdConnection());
		CGT_PARAM           GT_PARAM              (m_pDM_DBManagerTask->getStdConnection());

    CHeatStatusContainer  HeatStatusContainer   (m_pDM_DBManagerTask->getStdConnection());

    //long CutComplete    = HeatStatusContainer.getHeatStatus(DEF_GC_PLANT_DEF::CCS, DEF_GC_HEAT_STATUS::CutComplete );
    long LadleSentToCCM    = HeatStatusContainer.getHeatStatus(DEF_GC_PLANT_DEF::CCS, DEF_GC_HEAT_STATUS::LadleSentToCCM );
	  long LadleDeparture = HeatStatusContainer.getHeatStatus(DEF_GC_PLANT_DEF::CCS, DEF_GC_HEAT_STATUS::LadleDeparture );
	  long LdlPouringStart = HeatStatusContainer.getHeatStatus(DEF_GC_PLANT_DEF::CCS, DEF_GC_HEAT_STATUS::LdlPouringStart );
	  long LdlPouringStop = HeatStatusContainer.getHeatStatus(DEF_GC_PLANT_DEF::CCS, DEF_GC_HEAT_STATUS::LdlPouringStop );
		
    long DefltReturnSteelWgt = 40000; // default value in kg
		if(GT_PARAM.select(DEF_GC_PLANTGROUP_DESC::All_Units,"CCSReturnSteelForRetreatment", 0, CSMC_DBData::unspecLong))
    {
      DefltReturnSteelWgt = CDataConversion::StringToLong(GT_PARAM.getVALUE(1)) ; 
    }


    //long LadleAtCaster  = HeatStatusContainer.getHeatStatus(DEF_GC_PLANT_DEF::CCS, DEF_GC_HEAT_STATUS::LdlInCastPos );

	//sankar table has no such GROSSWEIGHT column
	  //update ladle gross weight , TATA has this facility
      /*if (LadleNo != DEF::Inv_Long  && RemSteelWeight != DEF::Inv_Long)
      {
          bool hasRecord = PD_LADLE.select(LadleNo, "T") ;
          if(hasRecord)
          {
            double tareWgt = PD_LADLE.getTAREWEIGHT(1);
            PD_LADLE.setGROSSWEIGHT(tareWgt + RemSteelWeight);   
            PD_LADLE.update();
            PD_LADLE.commit();
          }
      }*/
	  long TreatmentPosition = 1;
	  cCBS_ODBC_DBError pError;
    CDateTime Now;

	  //as per XLS file: 0=undefined, 1= ladle arrived,2=ladle opened, 3=ladle closed ,4=ladle departed, 5= tailout started ,6=tailout ended ,7=casting aborted
	  HeatStatus = GC_HEAT_STATUS.getHeatStatusNo(DEF_GC_PLANT_DEF::CCS, CSMC_DBData::unspecLong,HeatStatus);

		//SARS: because during LadleDeparture wrong steel weight is coming from CCS as per commissioning data or sometimes LadleDeparture signal is not coming
		if(LadleDeparture  == HeatStatus) 
		{
			return true;
		}

	  if( (LadleSentToCCM == HeatStatus) || (LdlPouringStop  == HeatStatus) ||  (LadleDeparture  == HeatStatus) )
	  {
		  TreatmentPosition = 2;
	  }

	  if (LdlPouringStart == HeatStatus)
	  {		  
		  if(PD_PLANTSTATUS.select(DEF_GC_PLANT_DEF::CCS, CCSId,2))
		  {
			  if(HeatID ==  PD_PLANTSTATUS.getHEATID(1))
			  {
				  PD_PLANTSTATUS.setHEATID(CSMC_DBData::unspecString);
				  PD_PLANTSTATUS.setTREATID(CSMC_DBData::unspecString);
				  PD_PLANTSTATUS.setLADLENO(CSMC_DBData::unspecLong);
				  PD_PLANTSTATUS.setHEATSTATUSNO(CSMC_DBData::unspecLong);
				  PD_PLANTSTATUS.update();
				  PD_PLANTSTATUS.commit();
			  }
		  }
	  }

	  if ( (LdlPouringStop == HeatStatus) || (LadleDeparture == HeatStatus) )
	  {		  
		  if(PD_PLANTSTATUS.select(DEF_GC_PLANT_DEF::CCS, CCSId,1))
		  {
			  if(HeatID ==  PD_PLANTSTATUS.getHEATID(1))
			  {
				  PD_PLANTSTATUS.setHEATID(CSMC_DBData::unspecString);
				  PD_PLANTSTATUS.setTREATID(CSMC_DBData::unspecString);
				  PD_PLANTSTATUS.setLADLENO(CSMC_DBData::unspecLong);
				  PD_PLANTSTATUS.setHEATSTATUSNO(CSMC_DBData::unspecLong);
				  PD_PLANTSTATUS.update();
				  PD_PLANTSTATUS.commit();
			  }
		  }
	  }


      bool hasRecord = PD_PLANTSTATUS.select(DEF_GC_PLANT_DEF::CCS, CCSId,TreatmentPosition) ;
      PD_PLANTSTATUS.setPLANT(DEF_GC_PLANT_DEF::CCS);
      PD_PLANTSTATUS.setPLANTNO(CCSId);
      PD_PLANTSTATUS.setTREATMENTPOSITION(TreatmentPosition);
      PD_PLANTSTATUS.setREVTIME(Now);

      PD_PLANTSTATUS.setHEATID(HeatID);
      PD_PLANTSTATUS.setTREATID(TreatID);
      PD_PLANTSTATUS.setPRODORDERID(OrderID);
      PD_PLANTSTATUS.setSTEELGRADECODE(SteelGrade);
      PD_PLANTSTATUS.setHEATSTATUSNO(HeatStatus);

      PD_PLANTSTATUS.setLADLETYPE(DEF_GC_LADLE_TYPE::TeemingLadle);
      PD_PLANTSTATUS.setLADLENO(LadleNo);
      PD_PLANTSTATUS.setHEATID_EXT_CUST(CustHeatID);
      PD_PLANTSTATUS.setTREATID_EXT_CUST(CustTreatID);
      PD_PLANTSTATUS.setEXPTREATMENTEND(SetInTurretTime); //as per LF requirement
      PD_PLANTSTATUS.setTEMP(TundishSuperHeat); //as per LF requirement

      if(hasRecord) 
        PD_PLANTSTATUS.update();
      else 
        PD_PLANTSTATUS.insert();

      PD_PLANTSTATUS.commit();


      PD_PLANTSTATUS_PLANT.updateStatus(DEF_GC_PLANT_DEF::CCS, CCSId,1,3,"REQUIREDSETINTURRETU",SetInTurretTime.toDBString(),true,pError);
      PD_PLANTSTATUS_PLANT.updateStatus(DEF_GC_PLANT_DEF::CCS, CCSId,1,1,"REMAININGLADLESTEELW",CDataConversion::LongToString(RemSteelWeight),true,pError);
      PD_PLANTSTATUS_PLANT.updateStatus(DEF_GC_PLANT_DEF::CCS, CCSId,1,1,"REMAININGTUNDISHSTEE",CDataConversion::LongToString(RemSteelWeightTundish),true,pError);
	    PD_PLANTSTATUS_PLANT.updateStatus(DEF_GC_PLANT_DEF::CCS, CCSId,1,1,"SUPERHEAT",CDataConversion::LongToString(TundishSuperHeat),true,pError);

    // check if ladle has been completely casted
		if( (LdlPouringStop == HeatStatus) || (LadleDeparture  == HeatStatus) )
    {
      if ( PD_PRETREATDATA.selectByHeatDataExtCust(CustHeatID, CustTreatID ) )
      {
        PD_PRETREATDATA.setSTEELWEIGHT(RemSteelWeight);
	      if ( RemSteelWeight < DefltReturnSteelWgt ) //SARS: heat will not display in HMI for re-treatment at LF as per MOM on 23.04.2013 
				{
	        PD_PRETREATDATA.setEXPIRATIONDATE(CDateTime());
				}

        RetValue = PD_PRETREATDATA.update();

        if ( RetValue )
        {
          PD_PRETREATDATA.commit();
        }
        else
        {
          PD_PRETREATDATA.rollback();

          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_DBWriteError(sMessage,"","PD_PRETREATDATA","update fails!");
        }
      }
    }
	//SANKAR
    //else   if   (HeatStatus == LadleAtCaster)
    //{

    //  // We only get customer Heat Id from Caster. Find the internal Heat Id with the highest internal treat Id,
    //  // for that heat append "C1" to Act_Route_Code.
    //  //

    //  log (std::string("Heat ") + CustHeatID + ": Ladle arrival at Caster", 3);

    //  std::string noTreatIdCust = CSMC_DBData::unspecString;
    //  std::string noPlant       = CSMC_DBData::unspecString;
    //  bool Ascending = true;              //we want the highest Treatment Id
    //  if   (PD_HEAT_PLANT_REF.selectByCustHeatData (CustHeatID, noTreatIdCust, noPlant,  ! Ascending))
    //  {
    //    long rows=PD_HEAT_PLANT_REF.getLastRow();
    //    std::string  highestTreatId;

    //    // Assuming the internal Heat Id is always the same for one Customer Heat Id
    //    std::string HeatId;
    //    for (long ich=1; ich<=rows; ich++)   // loop received Heats
    //    {
    //      HeatId    = PD_HEAT_PLANT_REF.getHEATID(ich);
    //      std::string TreatId = PD_HEAT_PLANT_REF.getTREATID(ich);
    //      if   (highestTreatId.empty() || TreatId.compare (highestTreatId) > 0)    // current TreatId > highest
    //      {
    //        highestTreatId = TreatId; 
    //      }
    //    }
    //    log ("Estimated Internal Heat/Treat Id: Heat " + HeatId + ", Treat " + highestTreatId, 3);
    //    if   (PD_HEAT_DATA.select (HeatId, highestTreatId, noPlant))
    //    {
    //      std::string ActRouteCode = PD_HEAT_DATA.getROUTECODE_ACT(1);
    //      
    //      std::string CasterRouteCode;
    //      std::string Plant   = GC_Plant_Container.getPlant(PlantId);
    //      long PlantNo = GC_Plant_Container.getPlantNo(PlantId); 

    //      if   ( GC_PLANT.select(Plant, PlantNo) )
    //      {
    //        CasterRouteCode = GC_PLANT.getROUTECODEID(1);
    //       }
    //      else
    //        CasterRouteCode = "C1";

    //      if   (ActRouteCode.substr(max(0, ActRouteCode.size()-2), 2) != CasterRouteCode)  // Only if not already appended before 
    //      {
    //        log ("Appending <" + CasterRouteCode + "> to exisisting Route Code <" + ActRouteCode + ">", 3);
    //        ActRouteCode = ActRouteCode + CasterRouteCode;
    //        PD_HEAT_DATA.setROUTECODE_ACT (ActRouteCode);
    //        RetValue = PD_HEAT_DATA.update();
    //        if   (RetValue)
    //        {
    //          log ("...Success, commit.", 5);
    //          PD_HEAT_DATA.commit();
    //        }
    //        else
    //        {
    //          log ("...Fail.", 5);
    //          PD_HEAT_DATA.rollback ();

    //          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    //          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    //          pEventLog->EL_DBWriteError(sMessage,"","PD_HEAT_DATA","update Route Code fails!");
    //        }
    //      }  // else C1 has already been set before, useless to append it another time. NOTHING TO DO
    //      else
    //      {
    //        log ("Not Appending <" + CasterRouteCode + "> to exisisting Route Code <" + ActRouteCode + ">", 3);
    //      }
    //    }   // Heat Data could be read, otherwise we also cannot write
    //    else
    //    {
    //      // Heat Data could NOT be read, so we cannot write
    //      log ("evCCSHeatStatus: Cannot Read PD_HEAT_DATA for update Route Code:", 2);
    //    }
    //  }
    //  else
    //  {
    //    log ("Heat Id " + CustHeatID + " seems to be unknown here, no route code modification.", 3);
    //  }
    //}
  }

  return RetValue;
}

bool CDM_GENDBManager::evHeatScheduleUpdate(CEventMessage &Event)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);

  std::string Function = "CDM_GENDBManager::evHeatScheduleUpdate";

  std::string ParamName     = "SeqStartHeatIDCust";
  std::string ParamValue    = "0";
  std::string MeltingPlant  = DEF_GC_PLANT_DEF::EAF;
  std::string HMIClientId;

  cCBS_StdInitBase::getInstance()->replaceWithEntry("PROCESS","MeltingPlant",MeltingPlant);

  try
  {
    // read data from DH in case of event send by HMI only
    if ( Event.getMessage() == HMI_EvMsg::evHMIHeatScheduleUpdate )
    {
      CDM_DataInterface_Impl *m_pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

      if ( m_pDataInterface ) 
      {
        ParamName     = CDataConversion::SetInvalidToDefault(m_pDataInterface->getString(Event.getDataKey(),DATA::ParamName).c_str() ,ParamName);
        ParamValue    = CDataConversion::SetInvalidToDefault(m_pDataInterface->getString(Event.getDataKey(),DATA::ParamValue).c_str(),ParamValue);
        HMIClientId   = m_pDataInterface->getString(Event.getDataKey(),DATA::HMIClientId);
      }// if ( m_pDataInterface ) 
    }

    if ( RetValue )
    {
      CGT_PARAM           GT_PARAM              (m_pDM_DBManagerTask->getStdConnection());
      CPP_HEAT            PP_HEAT               (m_pDM_DBManagerTask->getStdConnection());
      CPP_HEAT_PLANT      PP_HEAT_PLANT_UPDATE  (m_pDM_DBManagerTask->getStdConnection());
      CPP_HEAT_PLANT      PP_HEAT_PLANT         (m_pDM_DBManagerTask->getStdConnection());
      CPD_HEAT_PLANT_REF  PD_HEAT_PLANT_REF     (m_pDM_DBManagerTask->getStdConnection());
      CPD_HEAT_REF        PD_HEAT_REF           (m_pDM_DBManagerTask->getStdConnection());

      CHeatIDCust HeatIDCust;

      long HMINoStart                     = CDataConversion::StringToLong(ParamValue,0);

      long HeatIDCustNoMax                = HeatIDCust.getMaxCounter();
      long HeatIDCustNoMin                = 1;
        
      // new start point
      long HeatIDCustNoStart              = -1;

      // possible start points
      long HeatIDNoPlanned                = -1;
      long HeatIDNoParam                  = -1;
      long HeatIDNoHMI                    = -1;

      if ( HMINoStart > 0 )
      {
        HeatIDNoHMI = HMINoStart;
      }
        
      std::string HeatIDCustNoStartPrefix     = ""; 
      std::string HeatIDNoPlannedPrefix       = ""; 
      std::string HeatIDNoParamPrefix         = ""; 
      std::string HeatIDNoHMIPrefix           = ""; 

      // **************************************************************************
      // read data from parameter table to find possible start point for generation
      // **************************************************************************
      if ( GT_PARAM.selectByPlant(MeltingPlant, CSMC_DBData::unspecLong, ParamName ,0 ,DEF_GC_PARAM_TYPE::LParam) )
      {
        RetValue = true;

        HeatIDNoParam     = CDataConversion::StringToLong(GT_PARAM.getVALUE(1),1);
        double MIN_VALUE  = GT_PARAM.getMIN_VALUE(1); 
        double MAX_VALUE  = GT_PARAM.getMAX_VALUE(1); 

        if ( MAX_VALUE != CSMC_DBData::unspecDouble )
        {
          HeatIDCustNoMax   = (long)MAX_VALUE;
        }
        else
        {
          GT_PARAM.setMAX_VALUE(HeatIDCustNoMax);

          RetValue = GT_PARAM.update();

          if ( RetValue )
          {
            GT_PARAM.commit();
          }
        }

        if ( MIN_VALUE == CSMC_DBData::unspecDouble )
        {
          HeatIDCustNoMin   = (long)MIN_VALUE;
        }
        else
        {
          GT_PARAM.setMIN_VALUE(HeatIDCustNoMin);

          RetValue = GT_PARAM.update();

          if ( RetValue )
          {
            GT_PARAM.commit();
          }
        }

        // reset HeatIDNoParam
        if ( HeatIDNoParam >= HeatIDCustNoMax )
        {
          HeatIDNoParam = (long)GT_PARAM.getMIN_VALUE(1);  

          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_DBWriteInfo(sMessage,ParamName.c_str(),"GT_PARAM","IS RESETTED");
        }
      }  
      else
      {
        RetValue = false;

        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_DBReadError(sMessage,ParamName.c_str(),"GT_PARAM","PARAM MISSING");
      }

      // ****************************************************************************
      // read data from planning tables to find possible start point for generation
      // look for first HEATID_CUST that is planned and usable
      // ****************************************************************************
      if ( RetValue )
      {
        // seach for "lowest" HEATID_CUST for MeltingPlant that is planned !
        if ( PP_HEAT_PLANT.selectByPlanningState(MeltingPlant, CSMC_DBData::unspecLong, 1, true) )
        {
          if ( !PP_HEAT_PLANT.isNull(CPP_HEAT_PLANT::HEATID_CUST_PLAN, 1) )
          {
            HeatIDNoPlanned        = HeatIDCust.getCounter(PP_HEAT_PLANT.getHEATID_CUST_PLAN(1));
            HeatIDNoPlannedPrefix  = HeatIDCust.getPrefix (PP_HEAT_PLANT.getHEATID_CUST_PLAN(1));
          }
        }
        else
        {
          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_DBReadWarning(sMessage,"HEATID_CUST","PD_HEAT_PLANT_REF",std::string("DETERMINE THE START POINT FAILED - USING PARAM: " + ParamName).c_str()); 
        }
      }

      // ****************************************************************************
      // read data from production tables to find possible start point for generation
      // look for last HEATID_CUST that was announced
      // ****************************************************************************
      if ( RetValue )
      {
        // seach for "highest" HEATID_CUST for MeltingPlant that is in production !
        if ( PD_HEAT_PLANT_REF.selectValidCustDataInProduction(CSMC_DBData::unspecString, CSMC_DBData::unspecString, MeltingPlant, CSMC_DBData::unspecLong, false) )
        {
          if ( !PD_HEAT_PLANT_REF.isNull(CPD_HEAT_PLANT_REF::HEATID_CUST, 1) )
          {
            HeatIDNoPlanned        = HeatIDCust.getCounter(PD_HEAT_PLANT_REF.getHEATID_CUST(1));
            HeatIDNoPlannedPrefix  = HeatIDCust.getPrefix (PD_HEAT_PLANT_REF.getHEATID_CUST(1));
          }
        }
        else
        {
          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_DBReadWarning(sMessage,"HEATID_CUST","PD_HEAT_PLANT_REF",std::string("DETERMINE THE START POINT FAILED - USING PARAM: " + ParamName).c_str()); 
        }
      }


      // *************************************************************************
      // read data from given argument to find possible start point for generation
      // *************************************************************************

      // ********************************************
      // check for highest start point for generation
      // ********************************************
      // priority HeatIDNoParam > HeatIDNoHMI > HeatIDNoPlanned 
      if ( RetValue )
      {
        // sort by maximal No to find start point

        // use planned HeatId as first attempt for generation
        HeatIDCustNoStart       = HeatIDNoPlanned;
        HeatIDCustNoStartPrefix = HeatIDNoPlannedPrefix;

        // HMI input overrules Planning data
        if ( HeatIDNoHMI > 0 )
        {
          HeatIDCustNoStart       = HeatIDNoHMI;
          HeatIDCustNoStartPrefix = HeatIDNoHMIPrefix;
        }
        // if no startpoint from HMI and no startpoint from planning data use parameter
        else if ( HeatIDCustNoStart < 0 )
        {
          HeatIDCustNoStart       = HeatIDNoParam;
          HeatIDCustNoStartPrefix = HeatIDNoParamPrefix;
        }
      }

      // ****************************************************************************************************
      // start generation for all planned heats except heats that are "preset" and have already a heatid_cust
      // ****************************************************************************************************
      if ( RetValue )
      {
        std::set<std::string> HeatsPresettedAndPlanned  = getHeatsPresettedAndPlanned(MeltingPlant);
        std::set<std::string> HeatsInUse                = getUsedHeatsFromSchedule(MeltingPlant);

        // iteration over all heats that are planned
        // skip heats that are and not presetted and not used
        if ( PP_HEAT_PLANT.selectByPlanningStateAndPreset(MeltingPlant, CSMC_DBData::unspecLong, 1, 0, false) )
        {
          std::string HeatIDGenerationPrefix  = HeatIDCustNoStartPrefix;
          long        HeatIDGeneration        = HeatIDCustNoStart;

          for (long row = 1; row <= PP_HEAT_PLANT.getLastRow(); row++)
          {  
            std::string ActHeatId           = PP_HEAT_PLANT.getHEATID(row);

            std::string ActTreatIdCustPlan  = PP_HEAT_PLANT.getTREATID_CUST_PLAN(row);

            // find available heat id cust
            // if it is in HeatsPresettedAndPlanned or HeatsInUse function will increase HeatIDGeneration
            std::string NextHeatIDCust = getNextAvailableHeatIdCust(MeltingPlant, HeatsPresettedAndPlanned, HeatsInUse, HeatIDGenerationPrefix, HeatIDGeneration, ActTreatIdCustPlan);

            std::string TreatId = CSMC_DBData::unspecString;

            RetValue = RetValue && PP_HEAT_PLANT_UPDATE.updateInsertPP(ActHeatId, 
                                                                        TreatId, 
                                                                        CSMC_DBData::unspecString, 
                                                                        CSMC_DBData::unspecLong, 
                                                                        NextHeatIDCust, 
                                                                        CSMC_DBData::unspecString,
                                                                        CSMC_DBData::unspecDate, 
                                                                        CSMC_DBData::unspecDate, 
                                                                        false, m_lastError);     


            std::string Msg =  "HEATID_CUST_PLAN = " + PP_HEAT_PLANT.getHEATID_CUST_PLAN(row) + " updated with " + NextHeatIDCust;

            CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
            sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
            pEventLog->EL_DBWriteInfo(sMessage,"HEATID_CUST_PLAN","PP_HEAT_PLANT", Msg.c_str());

            // increase start point for next update
            HeatIDGeneration++; 

            if ( !RetValue )
            {
              break;
            }
          }// for (long row = 1; row <= count; row++)

          if ( RetValue )
          {
            PP_HEAT_PLANT_UPDATE.commit();
          }
          else
          {
            PP_HEAT_PLANT_UPDATE.rollback();
          }
        }
        else
        {
          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_DBReadError(sMessage,"","PP_HEAT_PLANT","NO PLANNING DATA AVAILABLE");
        } 
      }
      else
      {
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_DBWriteError(sMessage,"HEATID_CUST_PLAN","PP_HEAT_PLANT","GENERATION OF CUSTOMER HEATID FAILED");
      }

      if ( RetValue )
      {
        // update parameter
        if ( GT_PARAM.updateValue(MeltingPlant, CSMC_DBData::unspecLong, ParamName, 0, DEF_GC_PARAM_TYPE::LParam, CDataConversion::LongToString(HeatIDCustNoStart) ) )
        {
          GT_PARAM.commit();

          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_DBWriteInfo(sMessage,ParamName.c_str(),"GT_PARAM","PARAM UPADTED");        
        }
        else
        {
          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_DBWriteError(sMessage,"","GT_PARAM","PARAM UPADTED");
        }
      }
    }// if ( RetValue )
  }
  catch (cCBS_DBExc &e)
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage, (e.getText()).c_str(), Function.c_str(), ParamName.c_str()); 
    RetValue = false;
  }
  catch(CORBA::SystemException& sExc) 
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,sExc._name(), Function.c_str(), ParamName.c_str());
    RetValue = false;
  }
  catch(CORBA::Exception& cExc) 
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,cExc._name(), Function.c_str(), ParamName.c_str());
    RetValue = false;
  }
  catch(...)
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage, "unknown exception", Function.c_str(), ParamName.c_str());
    RetValue = false;
  }

  if ( RetValue )
  {
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    CDM_DBManager::handleError(Event, HMIClientId);
  }


  return RetValue;
}

//find the next order for which scrap should be loaded
bool CDM_GENDBManager::evScrapChuteRequest(CEventMessage& Event)
{
  try
  {
    log("++++++ CDM_GENDBManager::evScrapChuteRequest",3);

    std::string DataKey   = Event.getDataKey();
    std::string PlantID   = "";//Event.getPlantID(); can not be used here, unit number is unknown
    std::string Plant     = "BOF";//m_pGC_Plant_Container->getPlant(PlantID); get it from the event datakey somehow
    long PlantNo          = -1;//m_pGC_Plant_Container->getPlantNo(PlantID);

    cCBS_StdConnection * Connection = m_pDM_DBManagerTask->getStdConnection();

    if (Connection)
    {
      CPD_SCRAP_CONTAINER_ORDER PD_SCRAP_CONTAINER_ORDER(Connection);
      CPD_HEAT_DATA PD_HEAT_DATA(Connection);
      CPP_HEAT PP_HEAT(Connection);
      CPP_HEAT_PLANT PP_HEAT_PLANT(Connection);
        
      std::string nextOrderID = CSMC_DBData::unspecString;
      long ContainerInSeq = 1000; //there should be no more than 1000 containers in a sequence, we start with big value so we can use < to get smallest
      
      //check if there is an order that should be loaded in PD_SCRAP_CONTAINER_ORDER
      //do not care if loading instructions are available
      //if more than one order is available decide which should be loaded next
      //set the order ID in the event data for the DH, if no order available set to invalid
      if (PD_SCRAP_CONTAINER_ORDER.selectByContainerState(Plant,CSMC_DBData::unspecString,DEF_GC_SCRAP_CONT_ORDER_STATUS::OrderAvailable,true))
      {
        CDateTime nextRequiredTimeByStarted = CSMC_DBData::unspecDate; //priority one already announced to L1
        CDateTime nextRequiredTimeByCalculated = CSMC_DBData::unspecDate; //priority two in the heat stack
        CDateTime nextRequiredTimeByHeatSchedule = CSMC_DBData::unspecDate; //priority three by heat schedule
        //priority four would be by PP_ORDER.ORDERSEQNO this attribute is not filled at the moment, so the order that would be implemented there is not clear

        std::string OrderID;
        CDateTime requiredTime;

        long lastRow = PD_SCRAP_CONTAINER_ORDER.getLastRow();

        for (long i = 1; i<=lastRow; i++)
        {
          OrderID = PD_SCRAP_CONTAINER_ORDER.getPRODORDERID(i);

          if (PD_HEAT_DATA.selectByPRODORDERID_ACT_ValidNotFinished(OrderID,Plant,CSMC_DBData::unspecLong))
          {
            requiredTime = PD_HEAT_DATA.getTREATSTART_ACT(1);

            if (requiredTime != CSMC_DBData::unspecDate) //already started
            {
              if ( nextRequiredTimeByStarted == CSMC_DBData::unspecDate
                || requiredTime < nextRequiredTimeByStarted )
              {
                nextRequiredTimeByStarted = requiredTime;
                nextOrderID = OrderID;
              }                
            }//if (requiredTime != CSMC_DBData::unspecDate) //already started
            else if (nextRequiredTimeByStarted == CSMC_DBData::unspecDate) // we should not continue if we already have a prio one case
            {
              requiredTime = PD_HEAT_DATA.getTREATSTART_MOD(1);

              if (requiredTime != CSMC_DBData::unspecDate)
              {
                if ( nextRequiredTimeByCalculated == CSMC_DBData::unspecDate
                  || requiredTime < nextRequiredTimeByCalculated )
                {
                  nextRequiredTimeByCalculated = requiredTime;
                  nextOrderID = OrderID;
                }                
              }//if (requiredTime != CSMC_DBData::unspecDate)
              else
              {
                log("Required start time not set!",2);
              }
            }//else if (nextRequiredTimeByStarted == CSMC_DBData::unspecDate)
          }
          else if ( nextRequiredTimeByStarted == CSMC_DBData::unspecDate
                 && nextRequiredTimeByCalculated == CSMC_DBData::unspecDate
                 && PP_HEAT.selectOrder(OrderID)
                 && PP_HEAT_PLANT.select(PP_HEAT.getHEATID(1), CSMC_DBData::unspecString, Plant)
                  ) 
          {
            requiredTime = PP_HEAT_PLANT.getTREATSTART_PLAN(1);

            if (requiredTime != CSMC_DBData::unspecDate)
            {
              if ( nextRequiredTimeByHeatSchedule == CSMC_DBData::unspecDate
                || requiredTime < nextRequiredTimeByHeatSchedule )
              {
                nextRequiredTimeByHeatSchedule = requiredTime;
                nextOrderID = OrderID;
              }                
            }//if (requiredTime != CSMC_DBData::unspecDate)
          }
        }//for (long i = 1; i<=lastRow; i++)

        if (nextOrderID == CSMC_DBData::unspecString)
        {
          nextOrderID = PD_SCRAP_CONTAINER_ORDER.getPRODORDERID(1);
        }

        //set the status to sent
        if (PD_SCRAP_CONTAINER_ORDER.select(Plant,nextOrderID,CSMC_DBData::unspecLong))
        {
          lastRow = PD_SCRAP_CONTAINER_ORDER.getLastRow();

          //find smallest available
          for (long i = 1; i<=lastRow; i++)
          {
            if ( PD_SCRAP_CONTAINER_ORDER.getSTATUSNO(i) == DEF_GC_SCRAP_CONT_ORDER_STATUS::OrderAvailable
              && PD_SCRAP_CONTAINER_ORDER.getCONTAINERINSEQ(i) < ContainerInSeq)
            {
              ContainerInSeq = PD_SCRAP_CONTAINER_ORDER.getCONTAINERINSEQ(i);
            }
          }
          
          if (PD_SCRAP_CONTAINER_ORDER.select(Plant,nextOrderID,ContainerInSeq))
          {
            PD_SCRAP_CONTAINER_ORDER.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::Ordered);
            PD_SCRAP_CONTAINER_ORDER.setREVTIME(CDateTime());

            if (PD_SCRAP_CONTAINER_ORDER.update())
            {
              CDM_DataInterface_Impl * pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

              if (pDataInterface)
              {
                pDataInterface->setString(DataKey,DATA::OrderId, OrderID);
                pDataInterface->setLong(DataKey,DATA::ScrapChuteInSeq, ContainerInSeq);
                PD_SCRAP_CONTAINER_ORDER.commit();
              }
              else
              {
                log("DataInterface not available!",1);
                PD_SCRAP_CONTAINER_ORDER.rollback();
              } 
            }
            else
            {
              log("Could not update status in PD_SCRAP_CONTAINER_ODER!",1);
              PD_SCRAP_CONTAINER_ORDER.rollback();
            }
          }

        }
      }//if (PD_SCRAP_CONTAINER_ORDER.selectByContainerState(Plant,CSMC_DBData::unspecString,DEF_GC_SCRAP_CONT_ORDER_STATUS::OrderAvailable,true))
      else
      {
        //no orders available
        log("No scrap orders available!",2);
      }
    }
    else
    {
      log("No connection to DB established!",1);
    }
  }
  catch(...)
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,"Unknown exception.","CDM_GENDBManager::evScrapChuteRequest()"," - ");
  }

  return true;
}//bool CDM_GENDBManager::evScrapChuteRequest(CEventMessage& Event)

bool CDM_GENDBManager::evHotMetalAnalysisReceived(CEventMessage &Event)
{
  log("++++++ CDM_GENDBManager::evHotMetalAnalysisReceived",3);

  bool result = (m_pDM_DBManagerTask != NULL);
  if (result)
  {
    //=====================================================================================
    // This function handles received hot metal analysis.
    // In first step the hot metal counter has to be determined.
    // If the counter is available the analysis will be assigned to it.
    // If the order id is valid and has more than one assigned hot metal the last hot metal counter
    // will be used to assign analysis.
    // If the hot metal counter cannot be determined analysis are stored without any reference
    // to hot metal. Maybe ladle data and/or order id will be store as additional information
    // together with the analysis, in this situation.
    //=====================================================================================
    CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

    sHeatInfo HeatInfo;
    sPDData PDData;

    std::string OrderId     = Event.getOrderID();
    HeatInfo.Plant          = CSMC_DBData::unspecString; // plant is not known

    bool AssignmentPossible = false;
    CSMC_EventLogFrame *pEventLogFrame = CSMC_EventLogFrameController::getInstance()->getpEventLog();

    long HotMetalCounter    = CSMC_DBData::unspecLong;
    PDData.SampleOrigin     = pDataInterface->getLong(Event.getDataKey(),   DATA::SampleOrigin);
    PDData.HMSampleTime     << pDataInterface->getDate(Event.getDataKey().c_str(), DATA::HMSampleTime);
    PDData.SampleLocation   = pDataInterface->getString(Event.getDataKey(), DATA::SampleLocation);
    std::string UserCode    = pDataInterface->getString(Event.getDataKey(), DATA::UserCode);
    PDData.LadleNo          = pDataInterface->getLong(Event.getDataKey(),   DATA::LadleNo);
    PDData.LadleType        = pDataInterface->getString(Event.getDataKey(), DATA::LadleType);
    PDData.HMAnalysis       = CIntfData::ToCORBAType(pDataInterface->getAnalysis(Event.getDataKey().c_str(), DATA::HMMeasAnalysis));
    std::string HotMetalId  = pDataInterface->getString(Event.getDataKey(), DATA::HotMetalId);
    std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

    //=====================================================================================
    // check and convert received data
    //=====================================================================================

    if ( UserCode == DEF::Inv_String )
    {
      UserCode.clear();
    }

    if ( PDData.HMAnalysis.length() == 0 )
    {
      setLastError("EMPTY_ANALYSIS_SEQ",0,"");
      CDM_DBManager::handleError(Event, HMIClientId);

      return false;
    }

    //=====================================================================================
    // validate HotMetalId
    //=====================================================================================
    CPD_HOT_METAL   PD_HOT_METAL  (m_pDM_DBManagerTask->getStdConnection());

    if ( !HotMetalId.empty() && HotMetalId != DEF::Inv_String )
    {
      // as long as we do not have an external not metal id 
      // the hot metal counter is the  same like HotMetalId
      HotMetalCounter = CDataConversion::StringToLong(HotMetalId);

      if ( PD_HOT_METAL.select(HotMetalCounter) &&
           PD_HOT_METAL.getLastRow() == 1 )
      {
        AssignmentPossible = true;
        std::stringstream Message;
        Message << "Hot metal counter received and exists in data base '" << HotMetalCounter << "'";
        log(Message.str(),3);
      }
    }


    //=====================================================================================
    // validate ladle number
    //=====================================================================================
    if ( !AssignmentPossible && PDData.LadleNo != DEF::Inv_Long )
    {
      CPD_LADLE   PD_LADLE  (m_pDM_DBManagerTask->getStdConnection());

      if ( PD_LADLE.select(PDData.LadleNo, PDData.LadleType) && 
           PD_LADLE.getLastRow() == 1 )
      {
        HotMetalCounter = PD_LADLE.getHOTMETAL_CNT_ACT(1);
        if ( HotMetalCounter != CSMC_DBData::unspecLong )
        {
          AssignmentPossible = true;
          std::stringstream Message;
          Message << "Take HOTMETAL_CNT_ACT '" << HotMetalCounter << "' from ladle " << PDData.LadleType << PDData.LadleNo;
          log(Message.str(),3);
        }
      }
      else
      {
        sEventLogMessage EventLogMessage = pEventLogFrame->initMessage(__FILE__, __LINE__);
        pEventLogFrame->EL_ErrorUnknownLadleReceived(EventLogMessage, PDData.LadleType.c_str(), CDataConversion::LongToString(PDData.LadleNo).c_str());
      }

    }
    else if ( PDData.LadleNo == DEF::Inv_Long )
    {
      sEventLogMessage EventLogMessage = pEventLogFrame->initMessage(__FILE__, __LINE__);
      pEventLogFrame->EL_InvalidLadle(EventLogMessage, PDData.LadleType.c_str(), PDData.LadleNo, Event.getMessage().c_str());
    }

    //=====================================================================================
    // get the hot metal counter of the last hot metal of received order id
    //=====================================================================================
    if ( !AssignmentPossible )
    {
      if ( !OrderId.empty() && OrderId != DEF::Inv_String )
      {
        CPD_HOT_METAL_ORDER   PD_HOT_METAL_ORDER  (m_pDM_DBManagerTask->getStdConnection());

        if ( PD_HOT_METAL_ORDER.selectOrderedBySeq(HeatInfo.Plant, OrderId) )
        {
          // go from last to first until a valid hot metal counter is reached
          long rows = PD_HOT_METAL_ORDER.getLastRow();
          for ( long i = rows; i > 0; i-- )
          {
            HotMetalCounter = PD_HOT_METAL_ORDER.getHOTMETAL_COUNTER(i);
            std::string HM_LADLE_IN_SEQ = CDataConversion::LongToString(PD_HOT_METAL_ORDER.getHM_LADLE_IN_SEQ(i));

            if ( HotMetalCounter != CSMC_DBData::unspecLong )
            {
              //last hot metal counter found
              //stop loop
              AssignmentPossible = true;
              log("Take HOTMETAL_COUNTER form PD_HOT_METAL_ORDER with HM_LADLE_IN_SEQ " + HM_LADLE_IN_SEQ,3);
              break;
            }
          }
        }
      }
      else
      {
        sEventLogMessage EventLogMessage = pEventLogFrame->initMessage(__FILE__, __LINE__);
        pEventLogFrame->EL_InvalidProductionOrder(EventLogMessage, OrderId.c_str(),  Event.getMessage().c_str());
      }
    }

    //=====================================================================================
    // write analysis into PD_SAMPLE and make assignment to hot metal if possible
    //=====================================================================================
    if ( AssignmentPossible )
    {
      if ( PD_HOT_METAL.select(HotMetalCounter) &&
           PD_HOT_METAL.getLastRow() == 1 )
      {
        PDData.SampleRef = PD_HOT_METAL.getSAMPLE_REF(1);

        if ( PDData.SampleRef != CSMC_DBData::unspecLong )
        {
          // update of existing sample reference
          std::stringstream Message;
          Message << "Update existing SAMPLE_REF '" << PDData.SampleRef << "' from HOTMETAL_COUNTER '" << HotMetalCounter << "' to store analysis";
          log(Message.str(),3);

          // write data to data base
          result = result && CDM_DBManager::addAnalysisHotMetal(HeatInfo, OrderId, PDData, HotMetalCounter, UserCode, false); 
        }
        else
        {
          // create new sample reference
          std::stringstream Message;
          Message << "Create new SAMPLE_REF for HOTMETAL_COUNTER '" << HotMetalCounter << "' to store analysis";
          log(Message.str(),3);

          // write data to data base
          result = result && CDM_DBManager::addAnalysisHotMetal(HeatInfo, OrderId, PDData, HotMetalCounter, UserCode, false); 

          PD_HOT_METAL.setSAMPLE_REF(PDData.SampleRef);
          result = result && PD_HOT_METAL.update();
        }
      }
    }
    else
    {
      std::stringstream Message;
      Message << "Create new SAMPLE_REF without HOTMETAL_COUNTER";
      log(Message.str(),3);

      // write data to data base
      result = result && CDM_DBManager::addAnalysisHotMetal(HeatInfo, OrderId, PDData, HotMetalCounter, UserCode, false); 

      sEventLogMessage EventLogMessage = pEventLogFrame->initMessage(__FILE__, __LINE__);
      pEventLogFrame->EL_HMAnalysisAssignmentError(EventLogMessage, (PDData.LadleType + CDataConversion::LongToString(PDData.LadleNo)).c_str(), PDData.SampleRef);
    }

    if (result)
    {
      long LengthMeasAnalysis = CIntfData::getLength(PDData.HMAnalysis);
      std::string Code1 = DEF_GC_MEASUREMENT_NAME::C;
      std::string Code2 = DEF_GC_MEASUREMENT_NAME::Si;
      std::string Code3 = DEF_GC_MEASUREMENT_NAME::Mn;
      std::string Code4 = DEF_GC_MEASUREMENT_NAME::P;
      std::string Code5 = DEF_GC_MEASUREMENT_NAME::S;
      std::string Code6 = DEF_GC_MEASUREMENT_NAME::Al;
      std::string Code7 = DEF_GC_MEASUREMENT_NAME::Fe;

      float  Val1  = 0.;
      float  Val2  = 0.;
      float  Val3  = 0.;
      float  Val4  = 0.;
      float  Val5  = 0.;
      float  Val6  = 0.;
      float  Val7  = 0.;

      for ( int x = 0; x<LengthMeasAnalysis; x++ ) 
      {
        sAnalysis strAnalysis;
        string Element;
        long GetAtValue = CIntfData::getAt(strAnalysis, PDData.HMAnalysis, x);
        Element = strAnalysis.Element;
        if      (Element == Code1) Val1 = (float)strAnalysis.Concentration;
        else if (Element == Code2) Val2 = (float)strAnalysis.Concentration;
        else if (Element == Code3) Val3 = (float)strAnalysis.Concentration;
        else if (Element == Code4) Val4 = (float)strAnalysis.Concentration;
        else if (Element == Code5) Val5 = (float)strAnalysis.Concentration;
        else if (Element == Code6) Val6 = (float)strAnalysis.Concentration;
        else if (Element == Code7) Val7 = (float)strAnalysis.Concentration;
      }

      // set hot metal counter to the interface 
      if ( HotMetalId == DEF::Inv_String )
      {
        log("Hot metal Id is invalid. Use HotMetalCounter for HotMetalId",2);

        HotMetalId = CDataConversion::LongToString(HotMetalCounter);
      }
      pDataInterface->setString(Event.getDataKey(), DATA::HotMetalId, HotMetalId);
      pDataInterface->setLong(Event.getDataKey(), DATA::HotMetalCounter, HotMetalCounter);

      sEventLogMessage EventLogMessage = pEventLogFrame->initMessage(__FILE__, __LINE__);
      pEventLogFrame->EL_HotMetalAnalysisReceived(EventLogMessage, HotMetalId.c_str(),
        Code1.c_str(),Val1, Code2.c_str(),Val2, Code3.c_str(),Val3, Code4.c_str(),Val4, Code5.c_str(),Val5, Code6.c_str(),Val6, Code7.c_str(),Val7);

      m_pDM_DBManagerTask->getStdConnection()->getpCBSConnection()->commit();
    }
    else
    {
      pDataInterface->setLong(Event.getDataKey(), DATA::HotMetalId, DEF::Inv_Long);

      m_pDM_DBManagerTask->getStdConnection()->getpCBSConnection()->rollback();
      CDM_DBManager::handleError(Event, HMIClientId);
    }

  }//(m_pDM_DBManagerTask != NULL)

  return result;
}

bool CDM_GENDBManager::evHotMetalTemperatureReceived(CEventMessage &Event)
{
  log("++++++ CDM_GENDBManager::evHotMetalTemperatureReceived",3);

  bool result = (m_pDM_DBManagerTask != NULL);
  if (result)
  {
    //=====================================================================================
    // This function handles received hot metal temperature.
    // In first step the hot metal counter has to be determined.
    // If the counter is available the temperature will be assigned to it.
    // If the order id is valid and has more than one assigned hot metal the last hot metal counter
    // will be used to assign temperature.
    // If the hot metal counter cannot be determined the temperature is stored without any reference
    // to hot metal. The ladle data and/or order id will be store as additional information
    // together with the measure temperature, in this situation.
    //=====================================================================================
    CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

    sHeatInfo HeatInfo;
    sPDData PDData;

    std::string OrderId     = Event.getOrderID();
    HeatInfo.Plant          = CSMC_DBData::unspecString; // plant is not known

    bool AssignmentPossible = false;
    CSMC_EventLogFrame *pEventLogFrame = CSMC_EventLogFrameController::getInstance()->getpEventLog();

    long HotMetalCounter    = CSMC_DBData::unspecLong;
    PDData.SampleOrigin     = pDataInterface->getLong  (Event.getDataKey(), DATA::SampleOrigin);
    PDData.TempTime        << pDataInterface->getDate  (Event.getDataKey().c_str(), DATA::DateTime);
    PDData.SampleLocation   = pDataInterface->getString(Event.getDataKey(), DATA::SampleLocation);
    std::string UserCode    = pDataInterface->getString(Event.getDataKey(), DATA::UserCode);
    PDData.LadleNo          = pDataInterface->getLong  (Event.getDataKey(), DATA::LadleNo);
    PDData.LadleType        = pDataInterface->getString(Event.getDataKey(), DATA::LadleType);
    PDData.Temp             = pDataInterface->getDouble(Event.getDataKey(), DATA::MeasTemp);
    std::string HotMetalId  = pDataInterface->getString(Event.getDataKey(), DATA::HotMetalId);
    std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

    //=====================================================================================
    // check and convert received data
    //=====================================================================================

    if ( UserCode == DEF::Inv_String )
    {
      UserCode.clear();
    }

    if ( PDData.Temp == DEF::Inv_Double )
    {
      setLastError("INVALID_HM_TEMERATURE",0,"");
      CDM_DBManager::handleError(Event, HMIClientId);

      return false;
    }

    //=====================================================================================
    // validate HotMetalId
    //=====================================================================================
    CPD_HOT_METAL   PD_HOT_METAL  (m_pDM_DBManagerTask->getStdConnection());

    if ( !HotMetalId.empty() && HotMetalId != DEF::Inv_String )
    {
      // as long as we do not have an external not metal id 
      // the hot metal counter is the  same like HotMetalId
      HotMetalCounter = CDataConversion::StringToLong(HotMetalId);

      if ( PD_HOT_METAL.select(HotMetalCounter) &&
           PD_HOT_METAL.getLastRow() == 1 )
      {
        AssignmentPossible = true;
        std::stringstream Message;
        Message << "Hot metal counter received and exists in data base '" << HotMetalCounter << "'";
        log(Message.str(),3);
      }
    }


    //=====================================================================================
    // validate ladle number
    //=====================================================================================
    if ( !AssignmentPossible && PDData.LadleNo != DEF::Inv_Long )
    {
      CPD_LADLE   PD_LADLE  (m_pDM_DBManagerTask->getStdConnection());

      if ( PD_LADLE.select(PDData.LadleNo, PDData.LadleType) && 
           PD_LADLE.getLastRow() == 1 )
      {
        HotMetalCounter = PD_LADLE.getHOTMETAL_CNT_ACT(1);
        if ( HotMetalCounter != CSMC_DBData::unspecLong )
        {
          AssignmentPossible = true;
          std::stringstream Message;
          Message << "Take HOTMETAL_CNT_ACT '" << HotMetalCounter << "' from ladle " << PDData.LadleType << PDData.LadleNo;
          log(Message.str(),3);
        }
      }
      else
      {
        sEventLogMessage EventLogMessage = pEventLogFrame->initMessage(__FILE__, __LINE__);
        pEventLogFrame->EL_ErrorUnknownLadleReceived(EventLogMessage, PDData.LadleType.c_str(), CDataConversion::LongToString(PDData.LadleNo).c_str());
      }

    }
    else if ( PDData.LadleNo == DEF::Inv_Long )
    {
      sEventLogMessage EventLogMessage = pEventLogFrame->initMessage(__FILE__, __LINE__);
      pEventLogFrame->EL_InvalidLadle(EventLogMessage, PDData.LadleType.c_str(), PDData.LadleNo, Event.getMessage().c_str());
    }

    //=====================================================================================
    // get the hot metal counter of the last hot metal of received order id
    //=====================================================================================
    if ( !AssignmentPossible )
    {
      if ( !OrderId.empty() && OrderId != DEF::Inv_String )
      {
        CPD_HOT_METAL_ORDER   PD_HOT_METAL_ORDER  (m_pDM_DBManagerTask->getStdConnection());

        if ( PD_HOT_METAL_ORDER.selectOrderedBySeq(HeatInfo.Plant, OrderId) )
        {
          // go from last to first until a valid hot metal counter is reached
          long rows = PD_HOT_METAL_ORDER.getLastRow();
          for ( long i = rows; i > 0; i-- )
          {
            HotMetalCounter = PD_HOT_METAL_ORDER.getHOTMETAL_COUNTER(i);
            std::string HM_LADLE_IN_SEQ = CDataConversion::LongToString(PD_HOT_METAL_ORDER.getHM_LADLE_IN_SEQ(i));

            if ( HotMetalCounter != CSMC_DBData::unspecLong )
            {
              //last hot metal counter found
              //stop loop
              AssignmentPossible = true;
              log("Take HOTMETAL_COUNTER form PD_HOT_METAL_ORDER with HM_LADLE_IN_SEQ " + HM_LADLE_IN_SEQ,3);
              break;
            }
          }
        }
      }
      else
      {
        sEventLogMessage EventLogMessage = pEventLogFrame->initMessage(__FILE__, __LINE__);
        pEventLogFrame->EL_InvalidProductionOrder(EventLogMessage, OrderId.c_str(),  Event.getMessage().c_str());
      }
    }

    //=====================================================================================
    // write temperature into PD_SAMPLE and make assignment to hot metal if possible
    //=====================================================================================
    if ( AssignmentPossible )
    {
      if ( PD_HOT_METAL.select(HotMetalCounter) &&
           PD_HOT_METAL.getLastRow() == 1 )
      {
        PDData.SampleRef = PD_HOT_METAL.getSAMPLE_REF(1);

        if ( PDData.SampleRef != CSMC_DBData::unspecLong )
        {
          // update of existing sample reference
          std::stringstream Message;
          Message << "Update existing SAMPLE_REF '" << PDData.SampleRef << "' from HOTMETAL_COUNTER '" << HotMetalCounter << "' to store hot metal temperature";
          log(Message.str(),3);

          // write data to data base
          result = result && CDM_DBManager::addTemperatureHotMetal(HeatInfo, OrderId, PDData, HotMetalCounter, UserCode, false); 
        }
        else
        {
          // create new sample reference
          std::stringstream Message;
          Message << "Create new SAMPLE_REF for HOTMETAL_COUNTER '" << HotMetalCounter << "' to store temperature";
          log(Message.str(),3);

          // write data to data base
          result = result && CDM_DBManager::addTemperatureHotMetal(HeatInfo, OrderId, PDData, HotMetalCounter, UserCode, false); 

          PD_HOT_METAL.setSAMPLE_REF(PDData.SampleRef);
          result = result && PD_HOT_METAL.update();
        }
      }
    }
    else
    {
      std::stringstream Message;
      Message << "Create new SAMPLE_REF without HOTMETAL_COUNTER";
      log(Message.str(),3);

      // write data to data base
      result = result && CDM_DBManager::addTemperatureHotMetal(HeatInfo, OrderId, PDData, HotMetalCounter, UserCode, false); 

      sEventLogMessage EventLogMessage = pEventLogFrame->initMessage(__FILE__, __LINE__);
      pEventLogFrame->EL_HMTemperatureAssignmentError(EventLogMessage, (PDData.LadleType + CDataConversion::LongToString(PDData.LadleNo)).c_str(), PDData.SampleRef);
    }

    if (result)
    {
      // set hot metal counter to the interface 
      if ( HotMetalId == DEF::Inv_String )
      {
        log("Hot metal Id is invalid. Use HotMetalCounter for HotMetalId",2);

        HotMetalId = CDataConversion::LongToString(HotMetalCounter);
      }
      pDataInterface->setString(Event.getDataKey(), DATA::HotMetalId, HotMetalId);
      pDataInterface->setLong(Event.getDataKey(), DATA::HotMetalCounter, HotMetalCounter);

      sEventLogMessage EventLogMessage = pEventLogFrame->initMessage(__FILE__, __LINE__);
      pEventLogFrame->EL_HotMetalTemperatureReceived(EventLogMessage, HotMetalId.c_str(), PDData.Temp);

      m_pDM_DBManagerTask->getStdConnection()->getpCBSConnection()->commit();
    }
    else
    {
      pDataInterface->setLong(Event.getDataKey(), DATA::HotMetalId, DEF::Inv_Long);

      m_pDM_DBManagerTask->getStdConnection()->getpCBSConnection()->rollback();
      CDM_DBManager::handleError(Event, HMIClientId);
    }

  }//(m_pDM_DBManagerTask != NULL)

  return result;
}
