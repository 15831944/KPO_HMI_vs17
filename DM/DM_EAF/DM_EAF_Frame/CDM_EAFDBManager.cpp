//## Copyright (C) 2009 SMS Siemag AG, Germany 
//## Version generated by (DB)ClassCodeUtility BETA 0.6.0 


#include "iSMC_DataDefinitions_s.hh"
#include "iEventMessages_s.hh"
#include "CSMC_DataProvider_Impl.h"
#include "CSMC_EventLogFrameController.h"
#include "CSMC_EventLogEAFController.h"
#include "CDM_DataInterface_Impl.h"
#include "CDataConversion.h"
#include "CDM_PlantManagementInterface_Impl.h"
#include "CDM_ProductManagementInterface_Impl.h"
#include "CDataConversion.h"
#include "CStirringDataHandler.h"
#include "CDM_DBManager.h"
#include "CEquipmentData.h"
#include "CPP_ORDER.h"
#include "CPP_HEAT.h"
#include "CPP_ORDER_SINGLE_AIMS.h"
#include "CPD_LADLE.h"
#include "CPD_ACTION.h"
#include "CPD_HEAT_DATA.h"
#include "CPD_HEAT_REF.h"
#include "CPD_HEAT_PLANT_REF.h"
#include "CPD_PRETREATDATA.h"
#include "CPD_HEAT_DATA_LIQADD.h"
#include "CPD_SAMPLE.h"
#include "CPD_SAMPLE_REF.h"
#include "CPD_RECIPE_ENTRY.h"
#include "CGC_RECIPE_L1.h"
#include "CPD_HEAT_DATA_PRODPRAC.h"
#include "CPD_PLANTSTATUS_PLANT.h"
#include "CPDE_HEAT_DATA.h"
#include "CPDE_HEAT_DATA_BURN.h"
#include "CPD_HEAT_DATA_STIRR.h"
#include "CHDE_HEAT_DATA.h"
#include "CHDE_HEAT_DATA_MELT.h"
#include "CHDE_CYCL_MEAS_DATA.h"
#include "CHDE_CYCL_MEAS_DATA_BURN.h"
#include "CPDE_CYCL_MEAS_DATA.h"
#include "CPDE_HEAT_DATA_INJ.h"
#include "CHDE_CYCL_MEAS_DATA_INJ.h"
#include "CHDE_PP_STIRR.h"         
#include "CHDE_PP_STIRR_SPEC.h"   
#include "CHDE_PP_SCRAP.h"         
#include "CHDE_PP_SCRAP_BASKET.h" 
#include "CHDE_PP_INJECTION.h"     
#include "CHDE_PP_FLAME_PROFILE.h"
#include "CHDE_PP_PROCESS_PARAM.h"     
#include "CHDE_PP_EL.h"           
#include "CHDE_PP_EL_STEP_ENTRY.h"
#include "CHDE_PP_BURNER.h"       
#include "CHDE_PP_BURNER_STEP_ENTRY.h"   
#include "CHDE_PP_INJECTION_STEP_ENTRY.h"
#include "CHDE_PP_PROCESS.h"
#include "CHDE_PP_PROCESS_STEP_ENTRY.h"
#include "CHDE_PHASE_BURNER_RES.h"
#include "CHDE_PHASE_INJECT_RES.h"
#include "CHDE_PHASE_PROCESS_RES.h"
#include "CHDE_PHASE_STIRRING_RES.h"
#include "CHDE_ACTUAL_RES.h"
#include "CHDE_ACTUAL_RES_ANL.h"



#include "CPD_PLANTSTATUS.h"
#include "CGT_TREATMODE_ENTRY.h"
#include "CGC_HEAT_STATUS.h"
#include "CGC_PRODPRAC_DEF.h"
#include "CHD_HEAT_DATA.h"
#include "CHD_TREATMODE.h"
#include "CPD_RECIPE.h"
#include "CPD_SCRAP_CONTAINER_ORDER.h"
#include "CPD_SCRAP_CONTAINER_ORDER_ENTRY.h"
#include "CPD_SCRAP_CONTAINER.h"
#include "CPD_SCRAP_CONTAINER_ENTRY.h"
#include "CPD_HOT_METAL_ORDER.h"
#include "CPD_HOT_METAL.h"
#include "CPD_TAPCH_DATA.h"
#include "CPP_HEAT_PLANT.h"
#include "CGTE_PP_SCRAP_BASKET.h"
#include "CGT_GRADE_PRODPRAC.h"
#include "CGTE_PP_INJECTION.h"
#include "CGTE_PP_BURNER.h"
#include "CGTE_PP_STIRR.h"
#include "CGTE_PP_PROCESS.h"
#include "CGC_Recipe_L1Container.h"
#include "CGC_Plant_Container.h"
#include "CGT_PARAM.h"
#include "CGT_MAT_PURP.h"
#include "CSMC_RecipeHandler.h"
#include "DEF_GC_SCRAP_CONTAINER_TYPE.h"
#include "DEF_GC_SCRAP_CONTAINER_STATUS.h"
#include "DEF_GC_SCRAP_CONTAINER_LOC.h"
#include "DEF_GC_RECIPE_SOURCE.h"
#include "DEF_GC_SCRAP_CONT_ORDER_STATUS.h"
#include "DEF_GC_MEASUREMENT_TYPE.h"
#include "DEF_GC_MEASUREMENT_NAME.h"
#include "DEF_GC_LIQADD_TYPE.h"
#include "DEF_GC_LADLE_STATUS.h"
#include "DEF_GC_LADLE_POS.h"
#include "DEF_GC_ACTION_DEF.h"
#include "DEF_GC_PP_ORDER_SINGLE_AIMS.h"
#include "DEF_GCE_BURNER.h"
#include "DEF_GC_STIRR_GAS_TYPE.h"
#include "DEF_GCE_BURNER_GASTYPE.h"
#include "DEF_GC_LADLE_PARTS.h"
#include "DEF_GC_RECIPE_STATUS.h"
#include "DEF_GC_PRODPRAC_DEF.h"
#include "DEF_GC_CHARGE_DEST.h"
#include "DEF_GC_THERM_STAT.h"
#include "DEF_GC_LADLE_TYPE.h"
#include "DEF_GC_PLANT_DEF.h"
#include "DEF_GT_PURP.h"
#include "DEF_GC_PARAM_TYPE.h"
#include "DEF_GC_RECIPE_SOURCE.h"
#include "DEF_GC_PLANTSTATUS.h"
#include "DEF_GC_COUNTER_TYPE.h"
#include "DEF_GD_EQUIP_TYPE.h"
#include "DEF_GCE_INJECTION.h"  
#include "DEF_GC_HEAT_STATUS.h"
#include "DEF_GC_PLANTGROUP_DESC.h"

#include "CProductID.h"
#include "CHeatIDCust.h"
#include "CGasDataHandler.h"

#include "CDM_EAFDBManager.h"

#include "CHD_HEAT_DATA_LIQADD.h"
#include "CHD_HEAT_DATA_STIRR.h"




CDM_EAFDBManager::CDM_EAFDBManager(CDM_DBManagerTask* _task)
: CDM_DBManager(_task)
{
}

CDM_EAFDBManager::~CDM_EAFDBManager()
{
}

void CDM_EAFDBManager::init()
{
  CDM_DBManager::init();
}

bool CDM_EAFDBManager::copyHDECyclMeasData(sHeatInfo &HeatInfo, bool Commit)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHDE_CYCL_MEAS_DATA HDECyclMeasData(m_pDM_DBManagerTask->getStdConnection());
    CHDE_CYCL_MEAS_DATA_BURN HDECyclMeasDataBurn(m_pDM_DBManagerTask->getStdConnection());
    CHDE_CYCL_MEAS_DATA_INJ HDECyclMeasDataInj(m_pDM_DBManagerTask->getStdConnection());

    RetValue = HDECyclMeasData.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
    RetValue = RetValue && HDECyclMeasDataBurn.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
    RetValue = RetValue && HDECyclMeasDataInj.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
    
  }

  checkLastError();

  return RetValue;
}

bool CDM_EAFDBManager::copyHDEHeatData(sHeatInfo &HeatInfo, bool Commit)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHDE_HEAT_DATA HDEHeatData(m_pDM_DBManagerTask->getStdConnection());

    RetValue = HDEHeatData.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_EAFDBManager::checkHDEHeatData(sHeatInfo &HeatInfo, bool Commit)
{
  log("++++++ CDM_EAFDBManager::checkHDEHeatData",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  if (RetValue)
  {
    CHDE_HEAT_DATA HDE_HEAT_DATA(m_pDM_DBManagerTask->getStdConnection());

    bool CheckNullValues = false;
    cCBS_StdInitBase *pStdInitBase = cCBS_StdInitBase::getInstance();
    pStdInitBase->replaceWithEntry("ProcessControl", "CheckNullValues", CheckNullValues);

    if ( CheckNullValues )
    {
      HDE_HEAT_DATA.checkNULLValues(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant);
    }
  }

  checkLastError();

  return RetValue;
}


bool CDM_EAFDBManager::copyHDEHeatDataMelt(sHeatInfo &HeatInfo, bool Commit)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHDE_HEAT_DATA_MELT HDEHeatDataMelt(m_pDM_DBManagerTask->getStdConnection());

    RetValue = HDEHeatDataMelt.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
  }

  checkLastError();

  return RetValue;
}

bool CDM_EAFDBManager::copyHDEHeatPhaseData(sHeatInfo &HeatInfo, bool Commit)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CHDE_PHASE_BURNER_RES   HDE_PHASE_BURNER_RES(m_pDM_DBManagerTask->getStdConnection());
    CHDE_PHASE_INJECT_RES   HDE_PHASE_INJECT_RES(m_pDM_DBManagerTask->getStdConnection());
    CHDE_PHASE_PROCESS_RES  HDE_PHASE_PROCESS_RES(m_pDM_DBManagerTask->getStdConnection());
    CHDE_PHASE_STIRRING_RES HDE_PHASE_STIRRING_RES(m_pDM_DBManagerTask->getStdConnection());

    CHDE_ACTUAL_RES         HDE_ACTUAL_RES        (m_pDM_DBManagerTask->getStdConnection());
    CHDE_ACTUAL_RES_ANL     HDE_ACTUAL_RES_ANL    (m_pDM_DBManagerTask->getStdConnection());

    RetValue = RetValue && HDE_PHASE_BURNER_RES.copy  (HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
    RetValue = RetValue && HDE_PHASE_INJECT_RES.copy  (HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
    RetValue = RetValue && HDE_PHASE_PROCESS_RES.copy (HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
    RetValue = RetValue && HDE_PHASE_STIRRING_RES.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);

    RetValue = RetValue && HDE_ACTUAL_RES.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);
    RetValue = RetValue && HDE_ACTUAL_RES_ANL.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);

  }

  checkLastError();

  return RetValue;
}

bool CDM_EAFDBManager::copyHDEPpBurners(sHeatInfo &HeatInfo, bool Commit)
{
  if(m_pDM_DBManagerTask == NULL)
    return false;
  
  cCBS_StdConnection *mDatabaseConn = m_pDM_DBManagerTask->getStdConnection();
    
  if(mDatabaseConn == NULL)
    return false;

  bool RetValue       =  true;
  long PracNo         = -1;
  long TreatmentMode  = 0;
  long LiqAddAmount   = 0;
  long Fraction       = 0;

  if (CDM_DBManager::getPracNo(HeatInfo, DEF_GC_PRODPRAC_DEF::Burner, PracNo))
  {
    CHDE_PP_BURNER            HDE_PP_BURNER             (mDatabaseConn);
    CHDE_PP_BURNER_STEP_ENTRY HDE_PP_BURNER_STEP_ENTRY  (mDatabaseConn);
    CHD_HEAT_DATA             HD_HEAT_DATA              (mDatabaseConn);

    if (HD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
    {
      std::string ProdOrderID = HD_HEAT_DATA.getPRODORDERID_ACT(1);

      RetValue = RetValue && getTreatmentMode(HeatInfo, ProdOrderID, TreatmentMode);
      RetValue = RetValue && CDM_DBManager::getLiqAddAmount(HeatInfo.Plant, ProdOrderID, LiqAddAmount, Fraction);
    }
    else
    {
      RetValue = false;

      std::string SearchKey = HeatInfo.HeatId + " " + HeatInfo.TreatId + " " + HeatInfo.Plant;
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorSearchingData(sMessage, SearchKey.c_str(), "HD_HEAT_DATA");
    }

    RetValue = RetValue && HDE_PP_BURNER.copy(HeatInfo.HeatId,
                                          HeatInfo.TreatId, 
                                          HeatInfo.Plant, 
                                          HeatInfo.PlantNo, 
                                          PracNo,
                                          TreatmentMode,
                                          Fraction,
                                          Commit, 
                                          m_lastError);

    RetValue = RetValue && HDE_PP_BURNER_STEP_ENTRY.copy( HeatInfo.HeatId, 
                                                      HeatInfo.TreatId, 
                                                      HeatInfo.Plant, 
                                                      HeatInfo.PlantNo, 
                                                      PracNo,
                                                      TreatmentMode,
                                                      Fraction,
                                                      Commit, 
                                                      m_lastError);
    //FlameProfile is burner related
    RetValue = RetValue && copyHDEPpFlameProfile(HeatInfo, Commit);

    if ( !RetValue)
    {
      setLastError("ERROR_ON_BURNER_PRACTICE_DEFINITION", 0, HDE_PP_BURNER.getActStatement() );
    }

  }
  else
  {
    log("Can not find PracNo for copy HDE_PP_BURNER, HDE_PP_BURNER_STEP_ENTRY data",2);
  }

  return RetValue;
}

bool CDM_EAFDBManager::copyHDEPpElec(sHeatInfo &HeatInfo, const std::string &SteelGradeCode, bool Commit)
{
  if(m_pDM_DBManagerTask == NULL)
    return false;
  cCBS_StdConnection *mDatabaseConn = m_pDM_DBManagerTask->getStdConnection();
  if(mDatabaseConn == NULL)
    return false;

  bool RetValue       = true;
  long PracNo         = -1;
  long TreatmentMode  = 0;
  long LiqAddAmount   = 0;
  long Fraction       = 0;

  if (CDM_DBManager::getPracNo(HeatInfo, DEF_GC_PRODPRAC_DEF::Electric, PracNo))
  {
    CHDE_PP_EL              HDE_PP_EL           (mDatabaseConn);
    CHDE_PP_EL_STEP_ENTRY   HDE_PP_EL_STEP_ENTRY(mDatabaseConn);
    CHD_HEAT_DATA           HD_HEAT_DATA        (mDatabaseConn);

    if (HD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
    {
      std::string strProdOrderID = HD_HEAT_DATA.getPRODORDERID_ACT(1);
      RetValue = RetValue && getTreatmentMode(HeatInfo, strProdOrderID, TreatmentMode);
      RetValue = RetValue && getLiqAddAmount(HeatInfo.Plant, strProdOrderID, LiqAddAmount, Fraction);

      RetValue = RetValue && HDE_PP_EL.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, PracNo, TreatmentMode, Fraction, Commit, m_lastError);
      RetValue = RetValue && HDE_PP_EL_STEP_ENTRY.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, PracNo, TreatmentMode, Fraction, Commit, m_lastError);

      if ( !RetValue)
      {
        setLastError("ERROR_ON_ELEC_PRACTICE_DEFINITION", 0, HDE_PP_EL.getActStatement() );
      }

    }
    else
    {
      RetValue = false;

      std::string SearchKey = HeatInfo.HeatId + " " + HeatInfo.TreatId + " " + HeatInfo.Plant;
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorSearchingData(sMessage, SearchKey.c_str(), "HD_HEAT_DATA");
    }
  }
  else
  {
    RetValue = false;
    log("Can not find PracNo for copy HDE_PP_EL, HDE_PP_EL_STEP_ENTRY data",1);
  }

  return RetValue;
}

bool CDM_EAFDBManager::copyHDEPpFlameProfile(sHeatInfo &HeatInfo,bool Commit)
{
  if(m_pDM_DBManagerTask == NULL)
    return false;
  cCBS_StdConnection *mDatabaseConn = m_pDM_DBManagerTask->getStdConnection();
  if(mDatabaseConn == NULL)
    return false;

  CHDE_PP_FLAME_PROFILE  HDE_PP_FLAME_PROFILE(mDatabaseConn);

  bool RetValue = HDE_PP_FLAME_PROFILE.copy(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, Commit, m_lastError);

  if ( !RetValue)
  {
    setLastError("ERROR_ON_FLAME_PRACTICE_DEFINITION", 0, HDE_PP_FLAME_PROFILE.getActStatement() );
  }


  return RetValue;
}

bool CDM_EAFDBManager::copyHDEPpInjection(sHeatInfo &HeatInfo, bool Commit)
{
  if(m_pDM_DBManagerTask == NULL)
    return false;
  cCBS_StdConnection *mDatabaseConn = m_pDM_DBManagerTask->getStdConnection();
  if(mDatabaseConn == NULL)
    return false;

  bool RetValue       =  true;
  long PracNo         = -1;
  long TreatmentMode  = 0;
  long LiqAddAmount   = 0;
  long Fraction       = 0;

  // check if for this plant injection is define and has to copied
  CGC_PRODPRAC_DEF GC_PRODPRAC_DEF(mDatabaseConn);
  if (GC_PRODPRAC_DEF.select(HeatInfo.Plant, DEF_GC_PRODPRAC_DEF::Injection))
  {
    RetValue = CDM_DBManager::getPracNo(HeatInfo, DEF_GC_PRODPRAC_DEF::Injection, PracNo);
    if (RetValue)
    {
      CHDE_PP_INJECTION             HDE_PP_INJECTION            (mDatabaseConn);
      CHDE_PP_INJECTION_STEP_ENTRY  HDE_PP_INJECTION_STEP_ENTRY (mDatabaseConn);
      CHD_HEAT_DATA                 HD_HEAT_DATA                (mDatabaseConn);

      if (HD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      {
        std::string ProdOrderID = HD_HEAT_DATA.getPRODORDERID_ACT(1);

        RetValue = RetValue && getTreatmentMode(HeatInfo, ProdOrderID, TreatmentMode);
        RetValue = RetValue && CDM_DBManager::getLiqAddAmount(HeatInfo.Plant, ProdOrderID, LiqAddAmount, Fraction);
      }
      else
      {
        RetValue = false;

        std::string SearchKey = HeatInfo.HeatId + " " + HeatInfo.TreatId + " " + HeatInfo.Plant;
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorSearchingData(sMessage, SearchKey.c_str(), "HD_HEAT_DATA");
      }

      RetValue = RetValue && HDE_PP_INJECTION.copy( HeatInfo.HeatId, 
                                                HeatInfo.TreatId, 
                                                HeatInfo.Plant, 
                                                HeatInfo.PlantNo, 
                                                PracNo,
                                                TreatmentMode,
                                                Fraction,
                                                Commit, 
                                                m_lastError);

      RetValue = RetValue && HDE_PP_INJECTION_STEP_ENTRY.copy(HeatInfo.HeatId, 
                                                          HeatInfo.TreatId, 
                                                          HeatInfo.Plant, 
                                                          HeatInfo.PlantNo, 
                                                          PracNo,
                                                          TreatmentMode,
                                                          Fraction,
                                                          Commit, 
                                                          m_lastError);

      if ( !RetValue)
      {
        setLastError("ERROR_ON_INJECTION_PRACTICE_DEFINITION", 0, HDE_PP_INJECTION.getActStatement() );
      }

    }
    else
    {
      RetValue = false;

      std::string SearchKey = HeatInfo.HeatId + " " + HeatInfo.TreatId + " " + HeatInfo.Plant;
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorSearchingData(sMessage, SearchKey.c_str(), "HD_HEAT_DATA");
    }
  }
  else
  {
    std::stringstream SearchKey;
    SearchKey << HeatInfo.Plant << " ," << HeatInfo.PlantNo << " ," << DEF_GC_PRODPRAC_DEF::Injection;
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"GC_PRODPRAC_DEF");
  }

  return RetValue;
}

bool CDM_EAFDBManager::copyHDEPpProcess(sHeatInfo &HeatInfo, bool Commit)
{
  if(m_pDM_DBManagerTask == NULL)
    return false;
  cCBS_StdConnection *mDatabaseConn = m_pDM_DBManagerTask->getStdConnection();
  if(mDatabaseConn == NULL)
    return false;

  bool RetValue =  true;

  long PracNo         = -1;
  long TreatmentMode  = 0;
  long LiqAddAmount   = 0;
  long Fraction       = 0;

  RetValue = CDM_DBManager::getPracNo(HeatInfo, DEF_GC_PRODPRAC_DEF::Process, PracNo);
  if (RetValue)
  {
    CHDE_PP_PROCESS             HDE_PP_PROCESS            (mDatabaseConn);
    CHDE_PP_PROCESS_PARAM       HDE_PP_PROCESS_PARAM      (mDatabaseConn);
    CHDE_PP_PROCESS_STEP_ENTRY  HDE_PP_PROCESS_STEP_ENTRY (mDatabaseConn);
    CHD_HEAT_DATA               HD_HEAT_DATA              (mDatabaseConn);

    if (HD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
    {
      std::string ProdOrderID = HD_HEAT_DATA.getPRODORDERID_ACT(1);

      RetValue = RetValue && getTreatmentMode(HeatInfo, ProdOrderID, TreatmentMode);
      RetValue = RetValue && CDM_DBManager::getLiqAddAmount(HeatInfo.Plant, ProdOrderID, LiqAddAmount, Fraction);
    }
    else
    {
      RetValue = false;

      std::string SearchKey = HeatInfo.HeatId + " " + HeatInfo.TreatId + " " + HeatInfo.Plant;
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorSearchingData(sMessage, SearchKey.c_str(), "HD_HEAT_DATA");
    }

    RetValue = RetValue && HDE_PP_PROCESS.copy( HeatInfo.HeatId, 
                                            HeatInfo.TreatId, 
                                            HeatInfo.Plant, 
                                            HeatInfo.PlantNo, 
                                            PracNo,
                                            TreatmentMode,
                                            Fraction,
                                            Commit, 
                                            m_lastError);

    RetValue = RetValue && HDE_PP_PROCESS_PARAM.copy( HeatInfo.HeatId, 
                                                  HeatInfo.TreatId, 
                                                  HeatInfo.Plant, 
                                                  HeatInfo.PlantNo, 
                                                  PracNo,
                                                  TreatmentMode,
                                                  Fraction,
                                                  Commit, 
                                                  m_lastError);

    RetValue = RetValue && HDE_PP_PROCESS_STEP_ENTRY.copy(HeatInfo.HeatId, 
                                                      HeatInfo.TreatId, 
                                                      HeatInfo.Plant, 
                                                      HeatInfo.PlantNo, 
                                                      PracNo,
                                                      TreatmentMode,
                                                      Fraction,
                                                      Commit,
                                                      m_lastError);

    if ( !RetValue)
    {
      setLastError("ERROR_ON_PROCESS_PRACTICE_DEFINITION", 0, HDE_PP_PROCESS.getActStatement() );
    }

  }
  else
  {
    log("Error: Can not find PracNo for copy HDE_PP_PROCESS, HDE_PP_PROCESS_STEP_ENTRY data",1);
  }

  return RetValue;
}

bool CDM_EAFDBManager::copyHDEPpScrap(sHeatInfo &HeatInfo, const std::string& Order, bool Commit)
{
  bool RetValue = m_pDM_DBManagerTask != NULL;
  RetValue = RetValue && (m_pDM_DBManagerTask->getStdConnection() != NULL);
  if (RetValue)
  {
    // will be filled if set in data base
    long PracNo         = -1;
    long TreatmentMode  = 0;
    long LiqAddAmount   = 0;
    long Fraction       = 0;

    RetValue = CDM_DBManager::getPracNo(HeatInfo, DEF_GC_PRODPRAC_DEF::Scrap, PracNo);
    if (RetValue)
    {
      CHDE_PP_SCRAP          HDE_PP_SCRAP(m_pDM_DBManagerTask->getStdConnection());
      CHDE_PP_SCRAP_BASKET   HDE_PP_SCRAP_BASKET(m_pDM_DBManagerTask->getStdConnection());

      RetValue = RetValue && getTreatmentMode(HeatInfo, Order, TreatmentMode);
      RetValue = RetValue && CDM_DBManager::getLiqAddAmount(HeatInfo.Plant, Order, LiqAddAmount, Fraction);

      RetValue = RetValue && HDE_PP_SCRAP.copy( HeatInfo.HeatId, 
                                            HeatInfo.TreatId, 
                                            HeatInfo.Plant, 
                                            HeatInfo.PlantNo, 
                                            PracNo,
                                            TreatmentMode,
                                            Fraction,
                                            Commit, 
                                            m_lastError);

      RetValue = RetValue && HDE_PP_SCRAP_BASKET.copy(HeatInfo.HeatId, 
                                                  HeatInfo.TreatId, 
                                                  HeatInfo.Plant, 
                                                  HeatInfo.PlantNo, 
                                                  PracNo,
                                                  TreatmentMode,
                                                  Fraction,
                                                  Commit, 
                                                  m_lastError);

      if ( !RetValue)
      {
        setLastError("ERROR_ON_SCRAP_PRACTICE_DEFINITION", 0, HDE_PP_SCRAP.getActStatement() );
      }

    }
  }

  return RetValue;
}

bool CDM_EAFDBManager::copyHDEPpStirr(sHeatInfo &HeatInfo, const std::string &SteelGradeCode, bool Commit)
{
  if (m_pDM_DBManagerTask == NULL)
    return false;
  cCBS_StdConnection *mDatabaseConn = m_pDM_DBManagerTask->getStdConnection();
  if (mDatabaseConn == NULL)
    return false;

  bool RetValue       =  true;
  long PracNo         = -1;
  long TreatmentMode  = 0;
  long LiqAddAmount   = 0;
  long Fraction       = 0;

  // check if for this plant Stirring pointer is define and has to copied
  CGC_PRODPRAC_DEF GC_PRODPRAC_DEF(mDatabaseConn);
  if (GC_PRODPRAC_DEF.select(HeatInfo.Plant, DEF_GC_PRODPRAC_DEF::Injection))
  {
    RetValue = CDM_DBManager::getPracNo(HeatInfo, DEF_GC_PRODPRAC_DEF::Stirring, PracNo);
    if (RetValue)
    {
      CHDE_PP_STIRR         HDE_PP_STIRR        (mDatabaseConn);
      CHDE_PP_STIRR_SPEC    HDE_PP_STIRR_SPEC   (mDatabaseConn);
      CHD_HEAT_DATA         HD_HEAT_DATA        (mDatabaseConn);

      if (HD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
      {
        std::string ProdOrderID = HD_HEAT_DATA.getPRODORDERID_ACT(1);

        RetValue = RetValue && getTreatmentMode(HeatInfo, ProdOrderID, TreatmentMode);
        RetValue = RetValue && CDM_DBManager::getLiqAddAmount(HeatInfo.Plant, ProdOrderID, LiqAddAmount, Fraction);
      }
      else
      {
        RetValue = false;

        std::string SearchKey = HeatInfo.HeatId + " " + HeatInfo.TreatId + " " + HeatInfo.Plant;
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorSearchingData(sMessage, SearchKey.c_str(), "HD_HEAT_DATA");
      }
  
      RetValue = RetValue && HDE_PP_STIRR.copy( HeatInfo.HeatId, 
                                            HeatInfo.TreatId, 
                                            HeatInfo.Plant, 
                                            HeatInfo.PlantNo, 
                                            PracNo,
                                            TreatmentMode,
                                            Fraction,
                                            Commit, 
                                            m_lastError);

      RetValue = RetValue && HDE_PP_STIRR_SPEC.copy(HeatInfo.HeatId, 
                                                HeatInfo.TreatId, 
                                                HeatInfo.Plant, 
                                                HeatInfo.PlantNo, 
                                                PracNo,
                                                TreatmentMode,
                                                Fraction,
                                                Commit, 
                                                m_lastError);

      if ( !RetValue)
      {
        setLastError("ERROR_ON_STIRRING_PRACTICE_DEFINITION", 0, HDE_PP_STIRR.getActStatement() );
      }

    }
  }
  else
  {
    std::stringstream SearchKey;
    SearchKey << HeatInfo.Plant << " ," << HeatInfo.PlantNo << " ," << DEF_GC_PRODPRAC_DEF::Stirring;
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"GC_PRODPRAC_DEF");
  }

  return RetValue;
}

bool CDM_EAFDBManager::copyHDEProdPracData(sHeatInfo &HeatInfo, const std::string &SteelGradeCode, const std::string &OrderID, bool Commit)
{
  if(m_pDM_DBManagerTask == NULL)
    return false;
  
  cCBS_StdConnection *mDatabaseConn = m_pDM_DBManagerTask->getStdConnection();

  if(mDatabaseConn == NULL)
    return false;

  bool RetValue =  true;

  CGC_PRODPRAC_DEF GC_PRODPRAC_DEF(mDatabaseConn);

  if ( GC_PRODPRAC_DEF.select(HeatInfo.Plant, CSMC_DBData::unspecString) )
  {
    // wrong place of implementation, forces multiple copy calls in some cases
    // necessarry function calls have been moved to repective calls of copyHDEProdPracData
    //RetValue = RetValue && CDM_DBManager::copyHDParams      (HeatInfo, Commit);
    //RetValue = RetValue && CDM_DBManager::copyHDTreatmode   (HeatInfo, OrderID, TreatmentMode, Commit);
    //RetValue = RetValue && CDM_DBManager::copyHDRestris     (HeatInfo, TreatmentMode, Commit);
    //RetValue = RetValue && CDM_DBManager::copyHDMatFeed     (HeatInfo, "", TreatmentMode,  false);

    RetValue = RetValue && copyHDEPpBurners  (HeatInfo, Commit);
    RetValue = RetValue && copyHDEPpInjection(HeatInfo, Commit);
    RetValue = RetValue && copyHDEPpProcess  (HeatInfo, Commit);
	  RetValue = RetValue && copyHDEPpStirr    (HeatInfo,SteelGradeCode,Commit);
    RetValue = RetValue && copyHDEPpScrap    (HeatInfo, OrderID, Commit);
    // managed by copyHDEPpProcess
    // RetValue = RetValue && copyHDEPpElec     (HeatInfo, SteelGradeCode, Commit);
   
  }
  else
  {

    RetValue = false;
  }
  return RetValue;
}

long CDM_EAFDBManager::assignHotMetalLadle(CEventMessage& Event, long ChargeSeq, long HMLadleNo, std::string& HMLadleType, bool commit)
{
  long RetValue = 0;

  std::string ProductID = Event.getProductID();
  std::string OrderID   = Event.getOrderID();
  std::string HeatID    = Event.getHeatID();
  std::string TreatID   = Event.getTreatID();
  std::string PlantID   = Event.getPlantID();
  std::string Plant;
  long PlantNo          = 1;
  bool done = true;
  bool MakeNewAssignment = false;

  std::stringstream Arg;
  Arg << "Argument list assignHotMetalLadle: " << ChargeSeq << " " << HMLadleNo << " " << HMLadleType;
  log(Arg.str(), 3);

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_EAFDBManager::assignHotMetalLadle");

    return false;
  }

  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  if (m_pDM_DBManagerTask->getpDataInterface())
  {
    std::string HMIClientId = m_pDM_DBManagerTask->getpDataInterface()->getString(Event.getDataKey(), DATA::HMIClientId);

    // return false if no OrderID
    if (OrderID.empty() || 
        OrderID == DEF::Inv_String)
    {
      log("Not valid OrderID!",1);
      return -1;
    }
    if ( ChargeSeq == DEF::Inv_Long)
    {
      log("Not valid charging sequence!",1);
      return -1;
    }

    if ( !checkLadleData(HMLadleNo, HMLadleType, HMIClientId, "UNKNOWN_HOT_METAL_LADLE") )
    {
      log("Not valid ladle!",1);
      return -1;
    }

    // =======================================================================================
    // 
    // Get hot metal counter from PD_HOT_METAL_ORDER and PD_LADLE
    // If hot metal counter in ladle exists this will be taken for hot metal order
    // If counter in ladle dosn't exist but in order than counter from order will be taken
    // If no counter exist a new one is created and set in order and ladle
    // 
    // =======================================================================================

    CPD_HOT_METAL_ORDER PD_HOT_METAL_ORDER(m_pDM_DBManagerTask->getStdConnection());
    CPD_HOT_METAL PD_HOT_METAL(m_pDM_DBManagerTask->getStdConnection());
    CPD_LADLE PD_LADLE(m_pDM_DBManagerTask->getStdConnection());
    
    //============  read counter from PD_LADLE =================================

    long HotMetalCounterLadle = CSMC_DBData::unspecLong;

    if (PD_LADLE.select(HMLadleNo, HMLadleType))
    {
      HotMetalCounterLadle = PD_LADLE.getHOTMETAL_CNT_ACT(1);
    }
    else
    {
      if ( checkLadleData(HMLadleNo, HMLadleType, HMIClientId, "UNKNOWN_HOT_METAL_LADLE") )
      {
        PD_LADLE.setLADLENO(HMLadleNo);
        PD_LADLE.setLADLETYPE(HMLadleType);
        PD_LADLE.setLADLEPOSID(DEF_GC_LADLE_POS::UNDEF);
        PD_LADLE.setSTATUSNO(DEF_GC_LADLE_STATUS::Available);   

        done = PD_LADLE.insert();
        if (!done)
        {
          std::stringstream SearchKey;
          SearchKey << HMLadleNo << " " << HMLadleType;
          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PD_LADLE");
          return -1;
        }
      }
    }

    long HotMetalCounterToUpdate = -1;

    //============  read counter from PD_HOT_METAL_ORDER =================================
    long HotMetalCounterOrder = CSMC_DBData::unspecLong;

    if (PD_HOT_METAL_ORDER.select(Plant, OrderID, ChargeSeq))
    {
      HotMetalCounterOrder = PD_HOT_METAL_ORDER.getHOTMETAL_COUNTER(1);

      // take hot metal counter from ladle
      if (HotMetalCounterLadle != CSMC_DBData::unspecLong)
      {
        log("Take hot metal counter from ladle for PD_HOT_METAL_ORDER",3);

        HotMetalCounterToUpdate = HotMetalCounterLadle;
        PD_HOT_METAL_ORDER.setHOTMETAL_COUNTER(HotMetalCounterLadle);

        done = done && PD_HOT_METAL_ORDER.update();
      }
      else
      {
        log("Create new hot metal counter",3);

        PD_HOT_METAL.getNextHOTMETAL_COUNTER(HotMetalCounterToUpdate, m_lastError);
        PD_HOT_METAL.setHOTMETAL_COUNTER(HotMetalCounterToUpdate);

        done = done && PD_HOT_METAL.insert();
      }

      if (done && PD_HOT_METAL.select(HotMetalCounterToUpdate))
      {
        log("Update ladle data in PD_HOT_METAL",3);

        if ( checkLadleData(HMLadleNo, HMLadleType, HMIClientId, "UNKNOWN_HOT_METAL_LADLE") )
        {
          PD_HOT_METAL.setLADLENO(HMLadleNo);
          PD_HOT_METAL.setLADLETYPE(HMLadleType);

          done = done && PD_HOT_METAL.update();

          // indicate assignment
          RetValue = HMLadleNo;
        }
      }

      if (done && PD_LADLE.select(HMLadleNo, HMLadleType))
      {
        log("update hot metal counter in ladle",3);

        PD_LADLE.setHOTMETAL_CNT_ACT(HotMetalCounterToUpdate);
        done = done && PD_LADLE.update();
      }
    }// if (PD_HOT_METAL_ORDER.select(...
    else
    {
      log("Create new hot metal order",3);

      PD_HOT_METAL_ORDER.setPLANT(Plant);
      PD_HOT_METAL_ORDER.setPRODORDERID(OrderID);
      PD_HOT_METAL_ORDER.setHM_LADLE_IN_SEQ(ChargeSeq);

      if (HotMetalCounterLadle != CSMC_DBData::unspecLong)
      {
        log("Take hot metal counter from ladle for PD_HOT_METAL_ORDER",3);

        PD_HOT_METAL_ORDER.setHOTMETAL_COUNTER(HotMetalCounterLadle);
      }
      else
      {
        log("Create next hot metal counter for PD_HOT_METAL_ORDER and Ladle",3);

        if ( checkLadleData(HMLadleNo, HMLadleType, HMIClientId, "UNKNOWN_HOT_METAL_LADLE") )
        {
          PD_HOT_METAL.getNextHOTMETAL_COUNTER(HotMetalCounterOrder, m_lastError);

          PD_HOT_METAL.setHOTMETAL_COUNTER(HotMetalCounterOrder);
          PD_HOT_METAL.setLADLENO(HMLadleNo);
          PD_HOT_METAL.setLADLETYPE(HMLadleType);
          done = PD_HOT_METAL.insert();

          PD_HOT_METAL_ORDER.setHOTMETAL_COUNTER(HotMetalCounterLadle);
        }
      }
      done = done && PD_HOT_METAL_ORDER.insert();

      // indicate assignment
      RetValue = HMLadleNo;

    }

	//SRKO: PD_HEAT_DATA_LIQADD table value can be inserted/updated only after heat announcement.
	//			It has a foreign key reference to PD_HEAT_DATA table.

    ////======================== create liquid addition for model in PD_HEAT_DATA_LIQADD ================================
    //// create or update liquid addition for model
    //// only if ladle has content and heat is known
    //if (done /*&& HotMetalCounterToUpdate > 0*/ && !HeatID.empty() && !TreatID.empty())
    //{
    //  long LiqAddNo = 1;

    //  CPD_HEAT_DATA_LIQADD PD_HEAT_DATA_LIQADD(m_pDM_DBManagerTask->getStdConnection());
    //  CPD_SAMPLE_REF PD_SAMPLE_REF(m_pDM_DBManagerTask->getStdConnection());

    //  if (PD_HEAT_DATA_LIQADD.selectHeatByLadle(HeatID, TreatID, Plant, HMLadleType, HMLadleNo, CSMC_DBData::unspecString))
    //  {
    //    LiqAddNo = PD_HEAT_DATA_LIQADD.getLIQADDNO(1);

    //    if (PD_HOT_METAL.select(HotMetalCounterToUpdate))
    //    {
    //      PD_HEAT_DATA_LIQADD.setSTEELWEIGHT(PD_HOT_METAL.getWEIGHT(1));
    //      PD_HEAT_DATA_LIQADD.setSLAGWEIGHT(PD_HOT_METAL.getWEIGHT_SLAG(1));
    //      // check sample ref.
    //      // if sample ref does not exist create new
    //      // if sample ref exist make update
    //      long SampleRef = PD_HEAT_DATA_LIQADD.getSAMPLE_REF(1);
    //      
    //      if (SampleRef == CSMC_DBData::unspecLong)
    //      {
    //        SampleRef = PD_SAMPLE_REF.copyToNextSAMPLE_REF(PD_HOT_METAL.getSAMPLE_REF(1), false);

    //        if (SampleRef != CSMC_DBData::unspecLong)
    //        {
    //          PD_HEAT_DATA_LIQADD.setSAMPLE_REF(SampleRef);
    //        }
    //      }
    //      else
    //      {
    //        PD_SAMPLE_REF.copySampleRef(PD_HOT_METAL.getSAMPLE_REF(1),SampleRef,false, m_lastError);
    //      }

    //    }
    //    else
    //    {
    //      std::stringstream SearchKey;
    //      SearchKey << HotMetalCounterToUpdate;
    //      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    //      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    //      pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PD_HOT_METAL");

    //      //done = false;
    //    }

    //    done = done && PD_HEAT_DATA_LIQADD.update();
    //  }
    //  else if (PD_HEAT_DATA_LIQADD.getNextLiqAddNo(HeatID, TreatID, Plant, LiqAddNo, m_lastError))
    //  {
    //    PD_HEAT_DATA_LIQADD.setHEATID(HeatID);
    //    PD_HEAT_DATA_LIQADD.setTREATID(TreatID);
    //    PD_HEAT_DATA_LIQADD.setPLANT(Plant);
    //    PD_HEAT_DATA_LIQADD.setLIQADDNO(LiqAddNo);

    //    if ( checkLadleData(HMLadleNo, HMLadleType, HMIClientId, "UNKNOWN_HOT_METAL_LADLE") )
    //    {
    //      PD_HEAT_DATA_LIQADD.setLADLENO(HMLadleNo);
    //      PD_HEAT_DATA_LIQADD.setLADLETYPE(HMLadleType);
    //    }

    //    if (HMLadleType == DEF_GC_LADLE_TYPE::FeCrLadle)
    //    {
    //      PD_HEAT_DATA_LIQADD.setLIQADDTYPE(DEF_GC_LIQADD_TYPE::FeCr);
    //    }
    //    else
    //    {
    //      PD_HEAT_DATA_LIQADD.setLIQADDTYPE(DEF_GC_LIQADD_TYPE::HotMetal);
    //    }

    //    long NewSampleRef = CSMC_DBData::unspecLong;

    //    if (HotMetalCounterToUpdate != CSMC_DBData::unspecLong && PD_HOT_METAL.select(HotMetalCounterToUpdate))
    //    {
    //      PD_HEAT_DATA_LIQADD.setSTEELWEIGHT(PD_HOT_METAL.getWEIGHT(1));
    //      PD_HEAT_DATA_LIQADD.setSLAGWEIGHT(PD_HOT_METAL.getWEIGHT_SLAG(1));

    //      // copy sample ref content to new
    //      NewSampleRef = PD_SAMPLE_REF.copyToNextSAMPLE_REF(PD_HOT_METAL.getSAMPLE_REF(1), false);
    //    }
    //    else
    //    {
    //      std::stringstream SearchKey;
    //      SearchKey << HotMetalCounterToUpdate ;
    //      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    //      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    //      pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PD_HOT_METAL");

    //      //done = false;
    //      //RetValue = -1;
    //    }

    //    // in case of not existing sample ref
    //    PD_HEAT_DATA_LIQADD.setSAMPLE_REF(NewSampleRef);

    //    done = done && PD_HEAT_DATA_LIQADD.insert();
    //  }
    //}
    //else
    //{
    //  log("condition not tru 'if (done && !HotMetalCounterToUpdate != DEF::Inv_Long && !HeatID.empty() && !TreatID.empty())' to create liquid addition for for model in PD_HEAT_DATA_LIQADD", 1);
    //}


    // to be sure that in case of db error return value is not the ladle number
    if (!done && RetValue != -1)
      RetValue = 0;


    if (commit)
    {
      if (done)
      {
        m_pDM_DBManagerTask->getStdConnection()->commit();
        CDM_DBManager::handleInformation(Event, HMIClientId);
      }
      else
      {
        m_pDM_DBManagerTask->getStdConnection()->rollback();
        CDM_DBManager::handleError(Event, HMIClientId);
      }
    }
  }
  return RetValue;
}

bool CDM_EAFDBManager::assignScrapBasket(CEventMessage& Event, long BasketInSeq, long BasketId, long LastBasket, bool commit)
{
  return assignScrapContainer(Event, DEF_GC_SCRAP_CONTAINER_TYPE::Basket, BasketInSeq, BasketId, LastBasket, commit);
}

bool CDM_EAFDBManager::checkTreatMode(CEventMessage& Event)
{
  log("++++++ CDM_EAFDBManager::checkTreatMode",3);

  bool RetValue = true;

  std::string HeatID    = Event.getHeatID();
  std::string OrderID   = Event.getOrderID();
  std::string PlantID   = Event.getPlantID();
  std::string ProductID = Event.getProductID();

  std::stringstream ExceptionMsg;
  ExceptionMsg << "Handling event: " << Event.getSender()
    << ", " << Event.getHeatID()
    << ", " << Event.getTreatID() << ", " << Event.getDataKey();

  std::string Plant;
  long PlantNo          = 1;

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  try
  {
    CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

    if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
    {
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_EAFDBManager::checkTreatMode");
    }
    else if (OrderID.empty() || OrderID == DEF::Inv_String)
    {
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_InconsistentDataReceived(sMessage, "OrderID", Event.getMessage().c_str());
    }
    else
    {
      CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

      if (pDataInterface)
      {
        long BaskestDischargeCount = 1;
        long LastBasket            = pDataInterface->getLong   (Event.getDataKey(), DATA::LastBasket);
        std::string HMIClientId    = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

        //============  read Basket from PD_SCRAP_CONTAINER_ORDER =================================
        // read Basket id from this table
        CPD_SCRAP_CONTAINER_ORDER PD_SCRAP_CONTAINER_ORDER (m_pDM_DBManagerTask->getStdConnection());

        long TreatMentMode = 0;
        RetValue = getTreatmentMode(HeatInfo, OrderID, TreatMentMode);

        if ( PD_SCRAP_CONTAINER_ORDER.select(Plant, OrderID, CSMC_DBData::unspecLong) )
        {
          long RowCount = PD_SCRAP_CONTAINER_ORDER.getLastRow();
 
          for (long i=1; i<= RowCount; i++)
          {
            if ( PD_SCRAP_CONTAINER_ORDER.getDISCHARGETIME(i) != CSMC_DBData::unspecDate )
            {
              BaskestDischargeCount++;
            }
          }// for (long i=1; i= RowCount; i++)

          if ( (LastBasket == 1 && BaskestDischargeCount < TreatMentMode) || BaskestDischargeCount > TreatMentMode)
          {
            RetValue = false;
          }
        }// if ( PD_SCRAP_CONTAINER_ORDER.select(Plant, OrderID, CSMC_DBData::unspecLong) )

        if (!RetValue)
        {
          pDataInterface->setLong(Event.getDataKey(), DATA::TreatmentMode, BaskestDischargeCount);

          if (evChangeTreatmentMode(Event) )
          {
            setLastError("TREATMENTMODE_CHANGED_TO_" + CDataConversion::LongToString(BaskestDischargeCount), 1200, "", 1);
            CDM_DBManager::handleInformation(Event, HMIClientId);
          }
          else
          {
            setLastError("ERROR_ON_TREATMENTMODECHANGED_TO_" + CDataConversion::LongToString(BaskestDischargeCount), 1200, "", 1);
            CDM_DBManager::handleError(Event, HMIClientId);
          }
        }
      }// if (pDataInterface)
    }
  }
  catch(CORBA::SystemException& sExc) 
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,sExc._name(),
      "CDM_EAFDBManager::checkTreatMode()",
      ExceptionMsg.str().c_str());
  }
  catch(CORBA::Exception& cExc) 
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,cExc._name(),
      "CDM_EAFDBManager::checkTreatMode()",
      ExceptionMsg.str().c_str());
  }
  catch(...) 
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,"Unknown",
      "CDM_EAFDBManager::checkTreatMode()",
      ExceptionMsg.str().c_str());
  }

  return RetValue;
}


bool CDM_EAFDBManager::checkBasketAssignment(CEventMessage& Event)
{
  log("++++++ CDM_EAFDBManager::checkBasketAssignment",3);

  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::stringstream ExceptionMsg;
  ExceptionMsg << "Handling event: " << Event.getSender()
    << ", " << Event.getHeatID()
    << ", " << Event.getTreatID() << ", " << Event.getDataKey();

  try
  {
    long BasketId         = DEF::Inv_Long;
    long BasketInSeq      = DEF::Inv_Long;
    std::string HMIClientId;

    if (pDataInterface)
    {
      BasketInSeq    = pDataInterface->getLong  (Event.getDataKey(), DATA::BasketInSeq);
      BasketId       = pDataInterface->getLong  (Event.getDataKey(), DATA::BasketId);
      HMIClientId    = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
    }

    RetValue = RetValue && checkBasketData(BasketId, HMIClientId);

    RetValue = checkBasketAssignment(Event, BasketInSeq, BasketId );

  }
  catch(CORBA::SystemException& sExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,sExc._name(),
                                         "CDM_EAFDBManager::checkBasketAssignment()",
                                         ExceptionMsg.str().c_str());
  }
  catch(CORBA::Exception& cExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,cExc._name(),
                                         "CDM_EAFDBManager::checkBasketAssignment()",
                                         ExceptionMsg.str().c_str());
  }
  catch(...) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,"Unknown",
                                         "CDM_EAFDBManager::checkBasketAssignment()",
                                         ExceptionMsg.str().c_str());
  }

  return RetValue;

}

bool CDM_EAFDBManager::checkBasketAssignment(CEventMessage& Event, long BasketInSeq, long BasketId)
{
  return checkContainerAssignment(Event, DEF_GC_SCRAP_CONTAINER_TYPE::Basket, BasketInSeq, BasketId);
}

bool CDM_EAFDBManager::checkBasketData(long BasketInSeq, long BasketId, const std::string& HMIClientId)
{
  bool RetValue = true;

  if ( BasketInSeq == DEF::Inv_Long )
  {
    setLastError("UNKNOWN_BASKET_IN_SEQUENCE", 5001, "", 1);
    RetValue = false;
  }
  else
  {
    RetValue = checkContainerData( BasketId, DEF_GC_SCRAP_CONTAINER_TYPE::Basket, HMIClientId, "UNKNOWN_BASKET");
  }

  return RetValue;
}

bool CDM_EAFDBManager::checkBasketData(long BasketId, const std::string& HMIClientId)
{
  return checkContainerData( BasketId, DEF_GC_SCRAP_CONTAINER_TYPE::Basket, HMIClientId, "UNKNOWN_BASKET");
}

bool CDM_EAFDBManager::checkBasketData(long BasketInSeq)
{
  bool RetValue = true;

  if ( BasketInSeq == DEF::Inv_Long )
  {
    setLastError("UNKNOWN_BASKET_IN_SEQUENCE", 5001, "", 1);
    RetValue = false;
  }

  return RetValue;
}


long CDM_EAFDBManager::checkHMAssignment(CEventMessage& Event, long ChargeSeq, long HMLadleNo, std::string& HMLadleType)
{
  long RetValue = 0; // 0 - not assigned

  std::string ProductID = Event.getProductID();
  std::string OrderID   = Event.getOrderID();
  std::string PlantID   = Event.getPlantID();
  std::string Plant;
  long PlantNo          = 1;

  std::stringstream Arg;
  Arg << "Argument list checkHMAssignment: " << ChargeSeq << " " << HMLadleNo << " " << HMLadleType;
  log(Arg.str(), 3);

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_EAFDBManager::checkHMAssignment");

    return false;
  }

  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  if (m_pDM_DBManagerTask->getpDataInterface())
  {
    //============  read ladle from PD_HOT_METAL =================================

    // return false if no OrderID
    if (OrderID.empty() || 
        OrderID == DEF::Inv_String)
    {
      log("Not valid OrderID!",1);
      return -1;
    }

    if ( ChargeSeq == DEF::Inv_Long)
    {
      log("Not valid charging sequence!",1);
      return RetValue;
    }

    // get hot metal counter from PD_HOT_METAL_ORDER
    // and read ladle from PD_HOT_METAL by hot metal counter
    CPD_HOT_METAL_ORDER PD_HOT_METAL_ORDER(m_pDM_DBManagerTask->getStdConnection());
    CPD_HOT_METAL PD_HOT_METAL(m_pDM_DBManagerTask->getStdConnection());
		
    //if (PD_HOT_METAL_ORDER.select(Plant, OrderID, CSMC_DBData::unspecLong))
    if (PD_HOT_METAL_ORDER.select(Plant, OrderID, ChargeSeq)) //SARS
    {
      for (long i=1; i<=PD_HOT_METAL_ORDER.getLastRow(); i++)
      {
        long HOTMETAL_COUNTER = PD_HOT_METAL_ORDER.getHOTMETAL_COUNTER(i);
        long HM_LADLE_IN_SEQ  = PD_HOT_METAL_ORDER.getHM_LADLE_IN_SEQ(i);

        if (HOTMETAL_COUNTER != CSMC_DBData::unspecLong && 
            PD_HOT_METAL.select(HOTMETAL_COUNTER))
        {
          if (!PD_HOT_METAL.isNull(CPD_HOT_METAL::LADLENO, 1) && 
              !PD_HOT_METAL.isNull(CPD_HOT_METAL::LADLETYPE, 1) )
          {
            // get existing ladle
            long LaldeNo = PD_HOT_METAL.getLADLENO(1);
            std::string LadleType = PD_HOT_METAL.getLADLETYPE(1);

            if (LaldeNo == HMLadleNo &&
                LadleType == HMLadleType)
            {
              if (ChargeSeq != HM_LADLE_IN_SEQ)
              {
                log("Equal ladles by different charging sequence",3);
                RetValue = LaldeNo;// return used ladle number for this sequence
              }
            }

            //// if charge orders are equal, 
            //// ladles must be equal too
            //if (ChargeSeq == HM_LADLE_IN_SEQ)
            //{
            //  RetValue = HMLadleNo;

            //  // if ladles are not equal 
            //  // than return ladle assigned ladle
            //  if (LaldeNo != HMLadleNo &&
            //      LadleType != HMLadleType)
            //  {
            //    RetValue = LaldeNo;
            //    log("Ladles are equal",3);
            //    break;
            //  }
            //}// if (ChargeSeq == HM_LADLE_IN_SEQ)
          }// !PD_HOT_METAL.isNull(....
        }// PD_HOT_METAL.select(HOTMETAL_COUNTER)
      }// for (long i=1; i<=PD_HOT_METAL_ORDER.getLastRow(); i++)
    }// if (PD_HOT_METAL_ORDER.select(...
    else
    {
      std::string SearchKey = Plant + "; OrderID = " + OrderID + "; ChargeSeg = "+ CDataConversion::LongToString(ChargeSeq);
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.c_str(),"PD_HOT_METAL_ORDER");
    }
  }
  return RetValue;
}

long CDM_EAFDBManager::deassignHotMetalLadle(CEventMessage& Event, long ChargeSeq, const long HMLadleNo, const std::string& HMLadleType, bool commit)
{
  long RetValue = 0;
  std::string ProductID = Event.getProductID();
  std::string HeatID    = Event.getHeatID();
  std::string TreatID   = Event.getTreatID();
  std::string OrderID   = Event.getOrderID();
  std::string PlantID   = Event.getPlantID();
  std::string Plant;
  long PlantNo          = 1;

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_EAFDBManager::deassignHotMetalLadle");

    return -1;
  }

  if (ChargeSeq == DEF::Inv_Long)
  {
    log("ChargeSeq == DEF::Inv_Long", 0);
    return -1;
  }

  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  if (!m_pDM_DBManagerTask->getpDataInterface())
  {
    log("Not valid m_pDM_DBManagerTask->getpDataInterface()", 0);
    return -1;
  }

  //============  reset ladle status to available =================================

  CPD_LADLE PD_LADLE(m_pDM_DBManagerTask->getStdConnection());

  if (PD_LADLE.select(HMLadleNo, HMLadleType))
  {
    PD_LADLE.setSTATUSNO(DEF_GC_LADLE_STATUS::Available);
    if (PD_LADLE.update())
      RetValue = 1;
    else
      m_lastError = PD_LADLE.getLastError();
  }

  //============  reset ladle in PD_HOT_METAL_ORDER =================================
  // de-assigned ladle means reset hot metal counter
  // in HOT_METAL_ORDER
  //
  CPD_HOT_METAL_ORDER PD_HOT_METAL_ORDER(m_pDM_DBManagerTask->getStdConnection());

  if (PD_HOT_METAL_ORDER.select(Plant, OrderID, ChargeSeq))
  {
    log("reset hot metal counter in PD_HOT_METAL_ORDER", 3);

    PD_HOT_METAL_ORDER.setHOTMETAL_COUNTER(CSMC_DBData::unspecLong);
    if (PD_HOT_METAL_ORDER.update())
      RetValue = 1;
    else
      m_lastError = PD_HOT_METAL_ORDER.getLastError();
  }
  else
  {
    std::stringstream SearchKey;
    SearchKey << Plant << " " << OrderID << " " << ChargeSeq;
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ErrorSearchingData(sMessage, SearchKey.str().c_str(), "PD_HOT_METAL_ORDER");

    setLastError("NO_HM_ORDER_AVAILABLE", 1200, PD_HOT_METAL_ORDER.getActStatement());
  }

  if (RetValue > 0 && !HeatID.empty() && !TreatID.empty())
  {
    long LiqAddNo = 1;
    std::string LiqAddType;

    CPD_HEAT_DATA_LIQADD PD_HEAT_DATA_LIQADD(m_pDM_DBManagerTask->getStdConnection());

    if (PD_HEAT_DATA_LIQADD.selectHeatByLadle(HeatID, TreatID, Plant, HMLadleType, HMLadleNo, CSMC_DBData::unspecString))
    {
      // set number and type for model
      LiqAddNo = PD_HEAT_DATA_LIQADD.getLIQADDNO(1);
      LiqAddType = PD_HEAT_DATA_LIQADD.getLIQADDTYPE(1);

      m_pDM_DBManagerTask->getpDataInterface()->setLong(Event.getDataKey(), DATA::LiqAddNo, LiqAddNo);
      m_pDM_DBManagerTask->getpDataInterface()->setString(Event.getDataKey(), DATA::LiqAddType, LiqAddType);

      PD_HEAT_DATA_LIQADD.cleanWhereStatement();
      PD_HEAT_DATA_LIQADD.addWhereClause(CPD_HEAT_DATA_LIQADD::HEATID, HeatID);
      PD_HEAT_DATA_LIQADD.addWhereClause(CPD_HEAT_DATA_LIQADD::TREATID, TreatID);
      PD_HEAT_DATA_LIQADD.addWhereClause(CPD_HEAT_DATA_LIQADD::PLANT, Plant);
      PD_HEAT_DATA_LIQADD.addWhereClause(CPD_HEAT_DATA_LIQADD::LIQADDNO,LiqAddNo);
      if (!PD_HEAT_DATA_LIQADD.deleteRows())
      {
        m_lastError = PD_HEAT_DATA_LIQADD.getLastError();
        RetValue = 0;
      }
    }
    else
    {
      std::stringstream SearchKey;
      SearchKey << HeatID << " " << TreatID << " " << Plant << " " << HMLadleType << " " << HMLadleNo ;
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PD_HEAT_DATA_LIQADD");
    }
  }// if (!HeatID.empty() && !TreatID.empty())

  if (commit)
  {
    if (RetValue > 0)
      m_pDM_DBManagerTask->getStdConnection()->commit();
    else
      m_pDM_DBManagerTask->getStdConnection()->rollback();
  }

  return RetValue;
}

// remove assignment for Basket for all oders af plant for respective Plant
bool CDM_EAFDBManager::deassignScrapBasket(const std::string& Plant, const std::string& OrderID, long ContainerInSeq, long ContainerNo, bool commit)
{
  log("++++++ CDM_EAFDBManager::deassignScrapBasket",3);

  return deassignScrapContainer(Plant, OrderID, DEF_GC_SCRAP_CONTAINER_TYPE::Basket, ContainerInSeq, ContainerNo, commit);
}

long CDM_EAFDBManager::dischargeHotMetalLadle(CEventMessage& Event, long ChargeSeq, long HMLadleNo, std::string& HMLadleType, double& Weight, bool commit)
{
  long RetValue = 0;

  std::string ProductID = Event.getProductID();
  std::string OrderID   = Event.getOrderID();
  std::string HeatID    = Event.getHeatID();
  std::string TreatID   = Event.getTreatID();
  std::string PlantID   = Event.getPlantID();
  std::string Plant;
  long PlantNo          = 1;
  bool done = true;
  bool MakeNewAssignment = false;
  CDateTime Now; // to set discharge time

  std::stringstream Arg;
  Arg << "Argument list dischargeHotMetalLadle: " << ChargeSeq << " " << HMLadleNo << " " << HMLadleType;
  log(Arg.str(), 3);

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_EAFDBManager::dischargeHotMetalLadle");

    return false;
  }

  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  if (m_pDM_DBManagerTask->getpDataInterface())
  {
    std::string HMIClientId = m_pDM_DBManagerTask->getpDataInterface()->getString(Event.getDataKey(), DATA::HMIClientId);

    // return false if no OrderID
    if (OrderID.empty() || 
        OrderID == DEF::Inv_String)
    {
      return -1;
    }
    if ( ChargeSeq == DEF::Inv_Long)
      return -1; // return 0 -> not assigned

    if ( !checkLadleData(HMLadleNo, HMLadleType, HMIClientId, "UNKNOWN_HOT_METAL_LADLE") )
    {
      return -1;
    }

    // get hot metal counter from PD_HOT_METAL_ORDER
    // and read ladle from PD_HOT_METAL by hot metal counter
    CPD_HOT_METAL_ORDER PD_HOT_METAL_ORDER(m_pDM_DBManagerTask->getStdConnection());
    CPD_HOT_METAL PD_HOT_METAL(m_pDM_DBManagerTask->getStdConnection());
    CPD_LADLE PD_LADLE(m_pDM_DBManagerTask->getStdConnection());

    //======================== update in PD_LADLE ================================
    // update 'last time empty'
    // set ladle to available
    // 
    long HotMetalCounterLadle = CSMC_DBData::unspecLong;
    if (PD_LADLE.select(HMLadleNo, HMLadleType))
    {
      HotMetalCounterLadle = PD_LADLE.getHOTMETAL_CNT_ACT(1);
      if (HotMetalCounterLadle == CSMC_DBData::unspecLong)
      {
        std::stringstream SearchKey;
        SearchKey << "HOTMETAL_COUNTER_ACT for ladle " << HMLadleNo << HMLadleType;
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PD_LADLE");

        setLastError("EMPTY_LADLE", 0, PD_LADLE.getActStatement() );
      }

      PD_LADLE.setLAST_EMPTY_TIME(Now);
      PD_LADLE.setSTATUSNO(DEF_GC_LADLE_STATUS::Available);

      done = done && PD_LADLE.update();
    }
    else
    {
      std::stringstream SearchKey;
      SearchKey << HMLadleNo << " " << HMLadleType;
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PD_LADLE");

      return -1;
    }

    //======================== copy charged weight in PD_HOT_METAL ================================

    double WeightCharged = 0;
    if (done && HotMetalCounterLadle != CSMC_DBData::unspecLong && PD_HOT_METAL.select(HotMetalCounterLadle))
    {
      WeightCharged = PD_HOT_METAL.getWEIGHT(1);
      Weight = WeightCharged;

			//SARS: if same HM ladle is charged more than one time
      double Wgt = PD_HOT_METAL.getWEIGHT_CHARGED(1);
			int sameHMCountUsed = 0;
			if(PD_HOT_METAL_ORDER.select(Plant, OrderID, CSMC_DBData::unspecLong))
			{
				for( long i = 1 ; i <= PD_HOT_METAL_ORDER.getLastRow(); ++i )
				{
					if(PD_HOT_METAL_ORDER.getHOTMETAL_COUNTER(i) == HotMetalCounterLadle) 
						sameHMCountUsed = sameHMCountUsed + 1;
				}
				
			}
			if (Wgt != CSMC_DBData::unspecDouble && sameHMCountUsed != 1)
			{
				WeightCharged = WeightCharged + Wgt;
			}


			PD_HOT_METAL.setWEIGHT_CHARGED(WeightCharged); // copy act weight
      PD_HOT_METAL.setWEIGHT(CSMC_DBData::unspecDouble); // delete weight

      done = done && PD_HOT_METAL.update();

      // now discharge is done. return ladle number
      RetValue = HMLadleNo;
    }

    //======================== set discharge time PD_HOT_METAL_ORDER ================================

    if (done && PD_HOT_METAL_ORDER.select(Plant, OrderID, ChargeSeq))
    {
      PD_HOT_METAL_ORDER.setDISCHARGETIME(Now);

      done = done && PD_HOT_METAL_ORDER.update();
    }

    //======================== update PD_HEAT_DATA_LIQADD ================================
    // get liquid addition number for model and set it in DataInterface
    //
    long LiqAddNo = DEF::Inv_Long;
    std::string LiqAddType = DEF::Inv_String;

    if (!HeatID.empty() && !TreatID.empty())
    {
      CPD_HEAT_DATA_LIQADD PD_HEAT_DATA_LIQADD(m_pDM_DBManagerTask->getStdConnection());

      if (PD_HEAT_DATA_LIQADD.select(HeatID, TreatID, Plant, ChargeSeq)) //SARS
      //if (PD_HEAT_DATA_LIQADD.selectHeatByLadle(HeatID, TreatID, Plant, HMLadleType, HMLadleNo, CSMC_DBData::unspecString))
      {
				PD_HEAT_DATA_LIQADD.setDISCHARGETIME(Now);
				done = done && PD_HEAT_DATA_LIQADD.update();

        LiqAddNo    = PD_HEAT_DATA_LIQADD.getLIQADDNO(1);
        LiqAddType  = PD_HEAT_DATA_LIQADD.getLIQADDTYPE(1);

        m_pDM_DBManagerTask->getpDataInterface()->setLong(Event.getDataKey(), DATA::LiqAddNo, LiqAddNo);
        m_pDM_DBManagerTask->getpDataInterface()->setString(Event.getDataKey(), DATA::LiqAddType, LiqAddType);
      }
      else
      {
        std::stringstream SearchKey;
        SearchKey << HeatID << " " << TreatID << " " << Plant << " " << HMLadleType << " " << HMLadleNo ;
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PD_HEAT_DATA_LIQADD");

        setLastError("NO_LADLE_IN_LIQUID_ADDITION", 0, PD_HEAT_DATA_LIQADD.getActStatement());

        RetValue = 0;
        //done = false;
      }
    }
    else
    {
      log("No heat and treat to get LiqAddNo from PD_HEAT_DATA_LIQADD for model", 1);
    }

    // to be sure that in case of db error return value is not the ladle number
    if (!done && RetValue != -1)
      RetValue = 0;

    if (commit)
    {
      if (done)
      {
        m_pDM_DBManagerTask->getStdConnection()->commit();
        CDM_DBManager::handleInformation(Event, HMIClientId);
      }
      else
      {
        m_pDM_DBManagerTask->getStdConnection()->rollback();
        CDM_DBManager::handleError(Event, HMIClientId);
      }
    }
  }
  return RetValue;
}

bool CDM_EAFDBManager::dischargeScrapBasket(CEventMessage& Event, long BasketInSeq, long BasketId, bool commit)
{
  log("++++++ CDM_EAFDBManager::dischargeScrapBasket",3);

  return dischargeScrapContainer(Event, DEF_GC_SCRAP_CONTAINER_TYPE::Basket, BasketInSeq, BasketId, DEF_GC_SCRAP_CONTAINER_LOC::EAF, commit);
}

bool CDM_EAFDBManager::evAutoHeatAnnouncement(CEventMessage& Event)
{
  bool RetValue = false;

  std::stringstream ExceptionMsg;
  ExceptionMsg << "CDM_EAFDBManager::handleAutoHeatAnnouncement";

  try
  {
    if (m_pDM_DBManagerTask != NULL)
    {
      CGT_PARAM             GT_PARAM              (m_pDM_DBManagerTask->getStdConnection());

      if ( GT_PARAM.selectByPlant(DEF_GC_PLANT_DEF::EAF, CSMC_DBData::unspecLong, "AutoHeatAnnouncement", 0, DEF_GC_PARAM_TYPE::SParam) )
      {
        CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

        if ( GT_PARAM.getVALUE(1) == "Y" || GT_PARAM.getVALUE(1) == "1")
        {
          CPP_ORDER             PP_ORDER              (m_pDM_DBManagerTask->getStdConnection());
          CPP_HEAT              PP_HEAT               (m_pDM_DBManagerTask->getStdConnection());
          CPP_HEAT_PLANT        PP_HEAT_PLANT         (m_pDM_DBManagerTask->getStdConnection());
          CPP_ORDER_SINGLE_AIMS PP_ORDER_SINGLE_AIMS  (m_pDM_DBManagerTask->getStdConnection());

          CPD_PRETREATDATA      PD_PRETREATDATA       (m_pDM_DBManagerTask->getStdConnection());
          CPD_SAMPLE            PD_SAMPLE             (m_pDM_DBManagerTask->getStdConnection());
          CPD_SAMPLE_REF        PD_SAMPLE_REF         (m_pDM_DBManagerTask->getStdConnection());
          CPD_LADLE             PD_LADLE              (m_pDM_DBManagerTask->getStdConnection());

          CGC_Plant_Container   GC_Plant_Container    (m_pDM_DBManagerTask->getStdConnection());

          sHeatInfo HeatInfo;
          setHeatInfo(Event, HeatInfo);

          std::string UserCode = "AUTO";       

          if ( PP_HEAT_PLANT.selectByPlanningState( DEF_GC_PLANT_DEF::EAF, CSMC_DBData::unspecLong, 1) )
          {
            HeatInfo.HeatId         = PP_HEAT_PLANT.getHEATID(1);
            HeatInfo.TreatId        = PP_HEAT_PLANT.getTREATID(1);
            HeatInfo.Plant          = PP_HEAT_PLANT.getPLANT(1);
            std::string PlantId     = GC_Plant_Container.getL2PlantID(PP_HEAT_PLANT.getPLANT(1),PP_HEAT_PLANT.getPLANTNO(1));

            CProductID ProductID;
            HeatInfo.ProductId      = ProductID.getProductID(HeatInfo.HeatId,HeatInfo.TreatId);

            std::string CustHeatId  = PP_HEAT_PLANT.getHEATID_CUST_PLAN(1);
            std::string CustTreatId = PP_HEAT_PLANT.getTREATID_CUST_PLAN(1);

            CDateTime PlanEndTime    = PP_HEAT_PLANT.getTREATEND_PLAN(1);

            if ( PP_HEAT.select(HeatInfo.HeatId) )
            {
              std::string OrderID         = PP_HEAT.getPRODORDERID(1);
              std::string SteelGradeCode  = DEF::Inv_String;

							//SARS
							long LadleNo                  = PP_HEAT.getLADLENO(1);
							std::string LadleType         = PP_HEAT.getLADLETYPE(1);

              if ( OrderID != CSMC_DBData::unspecString && PP_ORDER.select(OrderID) )
              {
                SteelGradeCode = PP_ORDER.getSTEELGRADECODE(1);
              }

              long AimWeight = DEF::Inv_Long;
              if( OrderID != CSMC_DBData::unspecString && PP_ORDER_SINGLE_AIMS.select(OrderID, HeatInfo.Plant, 1, DEF_GC_PP_ORDER_SINGLE_AIMS::AIMSTEEL) )
              {
                AimWeight = CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1));
              }

              long AimTemp = DEF::Inv_Long;
              if( OrderID != CSMC_DBData::unspecString && PP_ORDER_SINGLE_AIMS.select(OrderID, HeatInfo.Plant, 1, DEF_GC_PP_ORDER_SINGLE_AIMS::AIMTEMP) )
              {
                AimTemp = CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1));
              }

              long TreatmentMode = DEF::Inv_Long;
              if( OrderID != CSMC_DBData::unspecString && PP_ORDER_SINGLE_AIMS.select(OrderID, HeatInfo.Plant, 1, DEF_GC_PP_ORDER_SINGLE_AIMS::TREATMENTMODE) )
              {
                TreatmentMode = CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1));
              }

              std::string DataKey   = pDataInterface->generateDataKey(HeatInfo.HeatId);

              pDataInterface->setString(DataKey,         DATA::OrderId,         OrderID);
              pDataInterface->setString(DataKey,         DATA::OrderIdUser,     OrderID);
              pDataInterface->setString(DataKey,         DATA::CustHeatID,      CustHeatId);
              pDataInterface->setString(DataKey,         DATA::CustTreatID,     CustTreatId);
              pDataInterface->setString(DataKey,         DATA::CustHeatIdUser,  CustHeatId);
              pDataInterface->setString(DataKey,         DATA::CustTreatIdUser, CustTreatId);
              pDataInterface->setString(DataKey,         DATA::SteelGradeCode,  SteelGradeCode);  

              pDataInterface->setDate  (DataKey.c_str(), DATA::PlanEndTime,    PlanEndTime.assDate());

              pDataInterface->setDouble(DataKey,         DATA::AimWeight,       AimWeight);
              pDataInterface->setDouble(DataKey,         DATA::AimWeightUser,   AimWeight);
              pDataInterface->setDouble(DataKey,         DATA::TempAim,         AimTemp);
              pDataInterface->setLong  (DataKey,         DATA::TreatmentMode,   TreatmentMode);
              pDataInterface->setString(DataKey,         DATA::UserCode,        UserCode);     

							//SARS
              pDataInterface->setLong  (DataKey,         DATA::LadleNo,   LadleNo);
              pDataInterface->setString(DataKey,         DATA::LadleType,        LadleType);     
              pDataInterface->setString(DataKey,         DATA::HeatID,        HeatInfo.HeatId);     
              pDataInterface->setString(DataKey,         DATA::TreatID,        HeatInfo.TreatId);     

              if ( OrderID != CSMC_DBData::unspecString && PD_PRETREATDATA.selectValidDataByProdOrderId(OrderID) )
              {
                double SteelMass              = PD_PRETREATDATA.getSTEELWEIGHT(1);
                double SlagMass               = PD_PRETREATDATA.getSLAGWEIGHT(1);

                long PRETREAT_COUNTER         = PD_PRETREATDATA.getPRETREAT_COUNTER(1); 
                long SAMPLE_REF               = PD_PRETREATDATA.getSAMPLE_REF(1);

                pDataInterface->setDouble  (DataKey,         DATA::SteelMassAct,      SteelMass);
                pDataInterface->setDouble  (DataKey,         DATA::SlagMassAct,       SlagMass);
                pDataInterface->setLong    (DataKey,         DATA::Counter,           PRETREAT_COUNTER);

                if ( SAMPLE_REF != CSMC_DBData::unspecLong && PD_SAMPLE.select(PD_SAMPLE_REF.getSampleCounter(SAMPLE_REF, DEF_GC_MEASUREMENT_TYPE::Steel)) )
                {
                  long SAMPLE_COUNTER_STEEL     = PD_SAMPLE.getSAMPLE_COUNTER(1); 

                  CDateTime SampleTime          = PD_SAMPLE.getSAMPLETIME(1);

                  long SampleNo                 = PD_SAMPLE.getSAMPLENO(1);
                  long SampleMode               = PD_SAMPLE.getSAMPLEMODE(1);
                  long SampleOrigin             = PD_SAMPLE.getORIGIN(1);

                  seqSample SeqSample = PD_SAMPLE.getSample(SAMPLE_COUNTER_STEEL);

                  seqAnalysis SteelMeasAnalysis  = PD_SAMPLE.SampleToAnalysis(SeqSample);

                  pDataInterface->setLong    (DataKey,         DATA::SampleNo,          SampleNo);
                  pDataInterface->setDate    (DataKey.c_str(), DATA::SteelSampleTime,   SampleTime.assDate());
                  pDataInterface->setLong    (DataKey,         DATA::SampleMode,        SampleMode);
                  pDataInterface->setLong    (DataKey,         DATA::SampleOrigin,      SampleOrigin);
                  pDataInterface->setAnalysis(DataKey.c_str(), DATA::SteelMeasAnalysis, SteelMeasAnalysis);
                }

                if ( SAMPLE_REF != CSMC_DBData::unspecLong && PD_SAMPLE.select(PD_SAMPLE_REF.getSampleCounter(SAMPLE_REF, DEF_GC_MEASUREMENT_TYPE::Temp)) )
                {
                  long SAMPLE_COUNTER_TEMP    = PD_SAMPLE.getSAMPLE_COUNTER(1);

                  CDateTime TempTime          = PD_SAMPLE.getSAMPLETIME(1);

                  double Temp                 = PD_SAMPLE.getSampleMeasValue(SAMPLE_COUNTER_TEMP,DEF_GC_MEASUREMENT_NAME::Temp);

                  pDataInterface->setDouble  (DataKey,         DATA::MeasTemp,          Temp);
                  pDataInterface->setDate    (DataKey.c_str(), DATA::TempMeasTime,      TempTime.assDate());    
                }                
              }// if ( OrderID != CSMC_DBData::unspecString && PD_PRETREATDATA.selectValidDataByProdOrderId(OrderID) )

              Event.setProductID(HeatInfo.ProductId);
              Event.setHeatID(HeatInfo.HeatId);
              Event.setTreatID(HeatInfo.TreatId);
              Event.setPlantID(PlantId);
              Event.setOrderID(OrderID);
              Event.setDataKey(DataKey);

              Event.setMessage(EAF_EvMsg::evEAFHeatAnnouncement);

              RetValue = true;

            }// if ( PP_HEAT.select(HeatInfo.HeatId) )
          }// if ( PP_HEAT_PLANT.selectByPlanningState( DEF_GC_PLANT_DEF::EAF, CSMC_DBData::unspecLong, 1, 0) )
          else
          {
            CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
            sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
            pEventLog->EL_DBReadError(sMessage,"","PP_HEAT_PLANT","NO PLANNING DATA AVAILABLE");
          }
        }// if ( GT_PARAM.getVALUE(1) == "Y" )
      }// if ( GT_PARAM.selectByPlant(DEF_GC_PLANT_DEF::EAF, CSMC_DBData::unspecLong, "AutoHeatAnnouncement", 0, DEF_GC_PARAM_TYPE::SDParam) )
    }// if (m_pDM_DBManagerTask != NULL)
  }
  catch(CORBA::SystemException& sExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,sExc._name(),
                                         "CDM_EAFDBManager::evAutomaticHeatAnnouncement()",
                                         ExceptionMsg.str().c_str());
  }
  catch(CORBA::Exception& cExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,cExc._name(),
                                         "CDM_EAFDBManager::evAutomaticHeatAnnouncement()",
                                         ExceptionMsg.str().c_str());
  }
  catch(...) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,"Unknown",
                                         "CDM_EAFDBManager::evAutomaticHeatAnnouncement()",
                                         ExceptionMsg.str().c_str());
  }

  return RetValue;
}

bool CDM_EAFDBManager::evCancelHeat(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evCancelHeat",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  RetValue = RetValue && CDM_DBManager::evCancelHeat(Event);

  if (RetValue)
  { 
    CPP_HEAT  PP_HEAT      (m_pDM_DBManagerTask->getStdConnection());

    sHeatInfo HeatInfo;
    setHeatInfo(Event, HeatInfo);

    RetValue = RetValue && PP_HEAT.setPlanned(HeatInfo.HeatId, 1, true, m_lastError);
  }

  return RetValue;
}

bool CDM_EAFDBManager::evChangeProdPracDataBurner(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evChangeProdPracDataBurner",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();
  long  ProdPracPointer   = pDataInterface->getLong(Event.getDataKey(),DATA::ProdPracPointer);
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  bool RetValue = isProductionPracticeChanged(Event, DEF_GC_PRODPRAC_DEF::Burner, ProdPracPointer);

  //handle PD tables
  RetValue = RetValue && CDM_DBManager::handlePDTablesOnChangeProdPrac(HeatInfo, DEF_GC_PRODPRAC_DEF::Burner, ProdPracPointer, false);

  RetValue = RetValue && CDM_DBManager::copyHDHeatData(HeatInfo, false);
  RetValue = RetValue && copyHDEPpBurners(HeatInfo, false);
  // copy new set production practice pointer
  RetValue = RetValue && CDM_DBManager::copyHDGrades(HeatInfo, "", false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evChangeProdPracPointerInjection(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evChangeProdPracPointerInjection",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();
  long  ProdPracPointer   = pDataInterface->getLong(Event.getDataKey(),DATA::ProdPracPointer);
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  bool RetValue = isProductionPracticeChanged(Event, DEF_GC_PRODPRAC_DEF::Injection, ProdPracPointer);

  //handle PD tables
  RetValue = RetValue && CDM_DBManager::handlePDTablesOnChangeProdPrac(HeatInfo, DEF_GC_PRODPRAC_DEF::Injection, ProdPracPointer, false);

  RetValue = RetValue && CDM_DBManager::copyHDHeatData(HeatInfo, false);

  RetValue = RetValue && copyHDEPpInjection(HeatInfo, false);
  // copy new set production practice pointer
  RetValue = RetValue && CDM_DBManager::copyHDGrades(HeatInfo, "", false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evChangeProdPracPointerOxygen(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evChangeProdPracPointerOxygen",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  long  ProdPracPointer   = pDataInterface->getLong(Event.getDataKey(),DATA::ProdPracPointer);
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  bool RetValue = isProductionPracticeChanged(Event, DEF_GC_PRODPRAC_DEF::Burner, ProdPracPointer);

  //handle PD tables
  RetValue = RetValue && CDM_DBManager::handlePDTablesOnChangeProdPrac(HeatInfo, DEF_GC_PRODPRAC_DEF::Burner, ProdPracPointer, false);

  RetValue = RetValue && CDM_DBManager::copyHDHeatData(HeatInfo, false);

  RetValue = RetValue && copyHDEPpInjection(HeatInfo, false);
  // copy new set production practice pointer
  RetValue = RetValue && CDM_DBManager::copyHDGrades(HeatInfo, "", false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evChangeProdPracPointerProcess (CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evChangeProdPracPointerProcess",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();
  std::string ProdOrderID = Event.getOrderID();

  long TreatmentMode      = 0;
  long ProdPracPointer    = pDataInterface->getLong(Event.getDataKey(),DATA::ProdPracPointer);
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  bool RetValue = isProductionPracticeChanged(Event, DEF_GC_PRODPRAC_DEF::Process, ProdPracPointer);

  //handle PD tables
  RetValue = RetValue && CDM_DBManager::handlePDTablesOnChangeProdPrac(HeatInfo, DEF_GC_PRODPRAC_DEF::Process, ProdPracPointer, false);

  RetValue = RetValue && getTreatmentMode(HeatInfo, ProdOrderID, TreatmentMode); 

  RetValue = RetValue && CDM_DBManager::copyHDHeatData(HeatInfo, false);
  // copy new set production practice pointer
  RetValue = RetValue && CDM_DBManager::copyHDGrades(HeatInfo, "", false);
  RetValue = RetValue && CDM_DBManager::copyHDMatFeed(HeatInfo, "", TreatmentMode, false);

  RetValue = RetValue && copyHDEPpProcess(HeatInfo, false);
  
  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evChangeProdPracPointerScrapLoading(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evChangeProdPracPointerScrapLoading",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::string OrderID     = Event.getOrderID();
  long  ProdPracPointer   = pDataInterface->getLong(Event.getDataKey(),DATA::ProdPracPointer);
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  bool RetValue = isProductionPracticeChanged(Event, DEF_GC_PRODPRAC_DEF::Scrap, ProdPracPointer);

  //handle PD tables
  RetValue = RetValue && CDM_DBManager::handlePDTablesOnChangeProdPrac(HeatInfo, DEF_GC_PRODPRAC_DEF::Scrap, ProdPracPointer, false);

  RetValue = RetValue && CDM_DBManager::copyHDHeatData(HeatInfo, false);

  RetValue = RetValue && copyHDEPpScrap(HeatInfo, OrderID, false);
  // copy new set production practice pointer
  RetValue = RetValue && CDM_DBManager::copyHDGrades(HeatInfo, "", false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evChangeProdPracPointerStirring(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evChangeProdPracPointerStirring",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  long  ProdPracPointer   = pDataInterface->getLong(Event.getDataKey(),DATA::ProdPracPointer);
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  bool RetValue = isProductionPracticeChanged(Event, DEF_GC_PRODPRAC_DEF::Stirring, ProdPracPointer);

  //handle PD tables
  RetValue = RetValue && CDM_DBManager::handlePDTablesOnChangeProdPrac(HeatInfo, DEF_GC_PRODPRAC_DEF::Stirring, ProdPracPointer, false);

  RetValue = RetValue && CDM_DBManager::copyHDHeatData(HeatInfo, false);
  RetValue = RetValue && copyHDEPpStirr(HeatInfo, "", false);
  // copy new set production practice pointer
  RetValue = RetValue && CDM_DBManager::copyHDGrades(HeatInfo, "", false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evChangeThermalStatus(CEventMessage &Event)
{
  bool RetValue = false;
  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::string DataKey       = Event.getDataKey();
  std::string FurnaceStatus = CSMC_DBData::unspecString;
  std::string HMIClientId   = pDataInterface->getString(DataKey, DATA::HMIClientId);

  long TreatmentPosition    = getActTreatmentPosition(Event);

  if (pDataInterface)
  {
    FurnaceStatus = pDataInterface->getString(DataKey,DATA::FurnaceStatus);

    if (FurnaceStatus != DEF::Inv_String && 
       (FurnaceStatus == DEF_GC_THERM_STAT::H ||
        FurnaceStatus == DEF_GC_THERM_STAT::C ||
        FurnaceStatus == DEF_GC_THERM_STAT::M))
    { 
      CPDE_HEAT_DATA         PDE_HEAT_DATA         (m_pDM_DBManagerTask->getStdConnection());
      CPD_PLANTSTATUS_PLANT  PD_PLANTSTATUS_PLANT  (m_pDM_DBManagerTask->getStdConnection());

      sHeatInfo HeatInfo;
      setHeatInfo(Event, HeatInfo);

      if( PDE_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant) &&
          PDE_HEAT_DATA.getLastRow() == 1 )
      {
        PDE_HEAT_DATA.setEAF_THERMSTATID(FurnaceStatus);

        RetValue = PDE_HEAT_DATA.update();

        if ( RetValue)
        {
          if ( FurnaceStatus != CSMC_DBData::unspecString )
          {
            RetValue = RetValue && PD_PLANTSTATUS_PLANT.updateStatus(HeatInfo.Plant, HeatInfo.PlantNo, TreatmentPosition, 3,  DEF_GC_PLANTSTATUS::THERMSTAT, FurnaceStatus, false, m_lastError);
          }
        }
        else
        {
          m_lastError = PDE_HEAT_DATA.getLastError();
        }
      }
      else
      {
        setLastError("ERROR_CHANGE_THERMAL_STATUS", 0, PDE_HEAT_DATA.getActStatement() );
      }

      RetValue = RetValue && copyHDEHeatData(HeatInfo, false);
    }
    else
    {
      setLastError("INVALID_THERMAL_STATUS", 0, "Status :" + FurnaceStatus);
    }
  }

  if (RetValue)
  {
    m_pDM_DBManagerTask->getpPlantManagementInterface()->setString(DEF_PLANT::Furnace, DATA::FurnaceStatus, FurnaceStatus);
  }

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }

  return RetValue;
}

bool CDM_EAFDBManager::evChangeTreatmentMode(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evChangeTreatmentMode",3);

  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::string OrderID     = Event.getOrderID();
  std::string DataKey     = Event.getDataKey();
  long  TreatmentMode     = pDataInterface->getLong(DataKey, DATA::TreatmentMode);
  std::string HMIClientId = pDataInterface->getString(DataKey, DATA::HMIClientId);

  if (TreatmentMode != DEF::Inv_Long)
  {
    sHeatInfo HeatInfo;
    setHeatInfo(Event, HeatInfo);

    RetValue = RetValue && CDM_DBManager::copyHDParams      (HeatInfo, false);
    RetValue = RetValue && CDM_DBManager::copyHDTreatmode   (HeatInfo, OrderID, TreatmentMode, false);
    RetValue = RetValue && CDM_DBManager::copyHDRestris     (HeatInfo, TreatmentMode, false);
    RetValue = RetValue && CDM_DBManager::copyHDMatFeed     (HeatInfo, "", TreatmentMode,  false);

    RetValue = RetValue && copyHDEProdPracData(HeatInfo, "", OrderID, false);

    RetValue = RetValue && handleOrderScrap(HeatInfo, OrderID, CSMC_DBData::unspecString, false);
    RetValue = RetValue && handlePDRecipeDataOnAnnounce(HeatInfo, OrderID, CSMC_DBData::unspecString, false);
  }
  else
  {
    setLastError("INVALID_PROD_PRAC_POINTER", 0, CDataConversion::LongToString(TreatmentMode), 1);
  }

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }

  return RetValue;
}

bool CDM_EAFDBManager::evChargedHotMetal(CEventMessage& Event)
{

  bool RetValue = false;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::stringstream ExceptionMsg;
  ExceptionMsg << "Handling event: " << Event.getSender()
    << ", " << Event.getHeatID()
    << ", " << Event.getTreatID() << ", " << Event.getDataKey();


  try
  {

    std::string HMLadleType;
    std::string HMIClientId;
    long HMLadleNo = DEF::Inv_Long;
    long ChargeSeq = DEF::Inv_Long; // charged sequence number

    // to know if HMI is the sender of event, HMIClientId is sent
    // 
    if (pDataInterface)
    {
      HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
      ChargeSeq   = pDataInterface->getLong(Event.getDataKey(), DATA::ChargeSeq);
      HMLadleNo   = pDataInterface->getLong(Event.getDataKey(), DATA::LadleNo);
      HMLadleType = pDataInterface->getString(Event.getDataKey(), DATA::LadleType);
    }


    if (ChargeSeq != DEF::Inv_Long && 
        HMLadleNo != DEF::Inv_Long)
    {
      // check if received ladle is already assigned to this order in other charging sequence.
      long Result = checkHMAssignment(Event, ChargeSeq, HMLadleNo, HMLadleType);
      if (Result == 0) // a ladle is not assigned
      {
        Result = assignHotMetalLadle(Event, ChargeSeq, HMLadleNo, HMLadleType, false);
        if (Result < 0)
        {
          setLastError("ERROR_HOT_METAL_ASSIGNMENT", 1200, "" );
          CDM_DBManager::handleError(Event, HMIClientId);
        }
        else
        {
          Result = setHotMetalData(Event, ChargeSeq, HMLadleNo, HMLadleType, false);
        }

      }
      else if (Result > 0) // assigned
      {
        if (Result != HMLadleNo) // assigned ladle is not equal to discharged
        {
          //TODO: deassignHotMetalLadle(Event, ChargeSeq, HMLadleNo, HMLadleType);
          //TODO: assignHotMetalLadle(Event, ChargeSeq, HMLadleNo, HMLadleType);

          CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_HotMetalAssignmentError(sMessage, HMLadleType.c_str(), HMLadleNo, ChargeSeq);
        }
      }

      // make discharge
      double ChargedWeight = 0;
      Result = dischargeHotMetalLadle(Event, ChargeSeq, HMLadleNo, HMLadleType, ChargedWeight, true);
      if (Result > 0)
      {
        CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_HotMetalDischarged(sMessage, HMLadleType.c_str(), HMLadleNo, ChargeSeq, ChargedWeight);

        RetValue = true;
      }
      else
      {
        CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_HotMetalDischargedError(sMessage, HMLadleType.c_str(), HMLadleNo, ChargeSeq);
      }
    }
    else
    {
      CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_HotMetalDischargedError(sMessage, HMLadleType.c_str(), HMLadleNo, ChargeSeq);
    }

    if (RetValue)
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
      CDM_DBManager::handleInformation(Event, HMIClientId);
    }
    else
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback();
      CDM_DBManager::handleError(Event, HMIClientId);
    }
  }
  catch(CORBA::SystemException& sExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,sExc._name(),
                                         "CDM_EAFDBManager::evChargedHotMetal()",
                                         ExceptionMsg.str().c_str());
  }
  catch(CORBA::Exception& cExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,cExc._name(),
                                         "CDM_EAFDBManager::evChargedHotMetal()",
                                         ExceptionMsg.str().c_str());
  }
  catch(...) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,"Unknown",
                                         "CDM_EAFDBManager::evChargedHotMetal()",
                                         ExceptionMsg.str().c_str());
  }

  return RetValue;
}

bool CDM_EAFDBManager::evCyclicMeasurementElectric(CEventMessage& Event)
{
  bool RetValue = false;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::stringstream ExceptionMsg;
  ExceptionMsg << "Handling event: " << Event.getSender()
    << ", " << Event.getHeatID()
    << ", " << Event.getTreatID() << ", " << Event.getDataKey();

  try
  {
    double ElecCons = 0.;

    if (m_pDM_DBManagerTask->getpProductManagementInterface())
    {
      CPD_PLANTSTATUS_PLANT PD_PLANTSTATUS_PLANT(m_pDM_DBManagerTask->getStdConnection());

      sHeatInfo HeatInfo;
      setHeatInfo(Event, HeatInfo);

      double ElecCons          = m_pDM_DBManagerTask->getpProductManagementInterface()->getDouble(HeatInfo.ProductId, DATA::ElecCons);
      long TreatmentPosition   = getActTreatmentPosition(Event);

      RetValue  = PD_PLANTSTATUS_PLANT.updateStatus(HeatInfo.Plant, HeatInfo.PlantNo, TreatmentPosition, 1,  DEF_GC_PLANTSTATUS::ELEC_CONS_TOTAL, CDataConversion::LongToString((long)ElecCons), true, m_lastError);
    }

  }
  catch(CORBA::SystemException& sExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,sExc._name(),
                                         "CDM_EAFDBManager::evCyclicMeasurementElectric()",
                                         ExceptionMsg.str().c_str());
  }
  catch(CORBA::Exception& cExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,cExc._name(),
                                         "CDM_EAFDBManager::evCyclicMeasurementElectric()",
                                         ExceptionMsg.str().c_str());
  }
  catch(...) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,"Unknown",
                                         "CDM_EAFDBManager::evCyclicMeasurementElectric()",
                                         ExceptionMsg.str().c_str());
  }

  return RetValue;

}

bool CDM_EAFDBManager::evHandleBasketAssignedToHeat(CEventMessage& Event)
{
  bool RetValue = false;  

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::string OrderID   = Event.getOrderID();
  std::string PlantID   = Event.getPlantID();
  std::string Plant;
  long PlantNo          = 1;

  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  std::stringstream ExceptionMsg;
  ExceptionMsg << "Handling event: " << Event.getSender()
    << ", " << Event.getHeatID()
    << ", " << Event.getTreatID() << ", " << Event.getDataKey();


  try
  {
    std::string HMIClientId;
    std::string UserCode; 
    long BasketInSeq        = DEF::Inv_Long;
    long BasketId           = DEF::Inv_Long;
    long BasketLocation     = DEF::Inv_Long;
    long RecipeStatus       = DEF::Inv_Long;
    long LastBasket         = DEF::Inv_Long;

    seqBatch RecipeContent  ;

    // to know if HMI is the sender of event HMIClientId is sent
    // 
    if (pDataInterface)
    {
      HMIClientId     = pDataInterface->getString (Event.getDataKey(), DATA::HMIClientId);
      BasketInSeq     = pDataInterface->getLong   (Event.getDataKey(), DATA::BasketInSeq);
      BasketId        = pDataInterface->getLong   (Event.getDataKey(), DATA::BasketId);
      BasketLocation  = pDataInterface->getLong   (Event.getDataKey(), DATA::BasketLocation);
      RecipeStatus    = pDataInterface->getLong   (Event.getDataKey(), DATA::RecipeStatus);
      RecipeContent   = CIntfData::ToCORBAType    (pDataInterface->getBatch(Event.getDataKey().c_str(), DATA::RecipeContent));
      UserCode        = pDataInterface->getString (Event.getDataKey(), DATA::UserCode);
    }

    // if no data transferred we assume basket data as weighing complete at yard
    BasketLocation  = CDataConversion::SetInvalidToDefault(BasketLocation,DEF_GC_SCRAP_CONTAINER_LOC::YARD );
    RecipeStatus    = CDataConversion::SetInvalidToDefault(RecipeStatus  ,DEF_GC_RECIPE_STATUS::WeighingComplete);

    // we have to regard the following situations by assigning a basket to a certain position in container sequence
    // 1. The BasketId has been assigned already        -> we have to de-assign it
    // 2. The BasketInSeq is already used by a basket   -> we can overwrite it
    // 3. The BasketInSeq is unknwon                    -> we use the next available position in container sequence

    // check if actual data of BasketId and BasketInSeq are known
    if ( checkBasketData( BasketInSeq, BasketId, HMIClientId) )
    {
      // remove assignment of BasketId for all orders and BasketInSeq
      if ( checkBasketAssignment(Event, CSMC_DBData::unspecLong, BasketId) )
      {
        if ( !deassignScrapBasket(Plant, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, BasketId, false) )
        {
          CDM_DBManager::handleError(Event, HMIClientId);
        }
      }

      RetValue = true;  

    }
    else if ( checkBasketData( BasketInSeq ) )
    {
      // get next usable ContainerInSeq from PD_SCRAP_CONTAINER_OREDER
      long ReqContainerInSeq = getNextContainerInSeqWithStatus(Event, DEF_GC_SCRAP_CONTAINER_TYPE::Basket, CSMC_DBData::unspecLong);

      if ( ReqContainerInSeq != CSMC_DBData::unspecLong && 
           ReqContainerInSeq != BasketInSeq )
      {
        CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ScrapContainerOrderError(sMessage, BasketId, ReqContainerInSeq, BasketInSeq);

        BasketInSeq = ReqContainerInSeq;
        pDataInterface->setLong(Event.getDataKey(), DATA::BasketInSeq, BasketInSeq);

        RetValue = true;  
      }
    }
    else
    {
      RetValue = false;  
    }
    
    // check if actual data of BasketId and BasketInSeq are known
    if ( RetValue )
    {
      if ( assignScrapBasket(Event, BasketInSeq, BasketId, LastBasket, false))
      {
        // update or insert RecipeContent in PD_SCRAP_CONTAINER_ENTRY
        RetValue = setBasketData(Event, BasketInSeq, BasketId, BasketLocation, RecipeStatus, RecipeContent, false);

        sHeatInfo HeatInfo;
        setHeatInfo(Event, HeatInfo);
        
        RetValue = RetValue && handlePDRecipeDataOnAssignment(HeatInfo, OrderID, BasketInSeq, BasketId, RecipeStatus, UserCode, false);
      }
      else
      {
        CDM_DBManager::handleError(Event, HMIClientId);
      }
    }
    else
    {
      CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ScrapContainerAssignmentError(sMessage, BasketInSeq, BasketId);
    }

    if (RetValue)
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
      CDM_DBManager::handleInformation(Event, HMIClientId);
    }
    else
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback();
      CDM_DBManager::handleError(Event, HMIClientId);
    }
  }
  catch(CORBA::SystemException& sExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,sExc._name(),
                                         "CDM_EAFDBManager::evHandleBasketAssignedToHeat()",
                                         ExceptionMsg.str().c_str());
  }
  catch(CORBA::Exception& cExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,cExc._name(),
                                         "CDM_EAFDBManager::evHandleBasketAssignedToHeat()",
                                         ExceptionMsg.str().c_str());
  }
  catch(...) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,"Unknown",
                                         "CDM_EAFDBManager::evHandleBasketAssignedToHeat()",
                                         ExceptionMsg.str().c_str());
  }

  return RetValue;
}

bool CDM_EAFDBManager::evHandleBasketDeAssignedFromHeat(CEventMessage& Event)
{

  bool RetValue = false;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::string OrderID   = Event.getOrderID();
  std::string PlantID   = Event.getPlantID();
  std::string Plant;
  long PlantNo          = 1;


  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  std::stringstream ExceptionMsg;
  ExceptionMsg << "Handling event: " << Event.getSender()
    << ", " << Event.getHeatID()
    << ", " << Event.getTreatID() << ", " << Event.getDataKey();

  try
  {

    std::string HMIClientId;
    std::string UserCode; 
    long BasketId     = DEF::Inv_Long;
    long BasketInSeq  = DEF::Inv_Long; // charged sequence number

    // to know if HMI is the sender of event, HMIClientId is sent
    // 
    if (pDataInterface)
    {
      HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
      BasketInSeq = pDataInterface->getLong(Event.getDataKey(), DATA::BasketInSeq);//Basket No. in Sequence
      BasketId    = pDataInterface->getLong(Event.getDataKey(), DATA::BasketId);//Physical Container ID
      UserCode    = pDataInterface->getString (Event.getDataKey(), DATA::UserCode);
    }


    if ( checkBasketData(BasketId, HMIClientId))
    {
      // remove assignment of BasketId for respecive order and all BasketInSeq
      if ( checkBasketAssignment(Event, CSMC_DBData::unspecLong, BasketId) )
      {
        if ( deassignScrapBasket(Plant, OrderID, CSMC_DBData::unspecLong, BasketId, false) )
        {
          sHeatInfo HeatInfo;
          setHeatInfo(Event, HeatInfo);

          RetValue = handlePDRecipeDataOnDeAssignment(HeatInfo, OrderID, BasketInSeq, BasketId, DEF_GC_RECIPE_STATUS::Disabled, UserCode, false);

          CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_HandleScrapContainerRemove(sMessage, BasketInSeq, BasketId);

          RetValue = true;
        }
        else
        {
          setLastError("ERROR_BASKET_DEASSIGNMENT",1200,"");
          CDM_DBManager::handleError(Event, HMIClientId);
        }
      }
    }
    else
    {
      CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ScrapContainerRemoveError(sMessage, BasketInSeq, BasketId);
    }


    if (RetValue)
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
      CDM_DBManager::handleInformation(Event, HMIClientId);
    }
    else
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback();
      CDM_DBManager::handleError(Event, HMIClientId);
    }
  }
  catch(CORBA::SystemException& sExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,sExc._name(),
                                         "CDM_EAFDBManager::evHandleBasketDeAssignedFromHeat()",
                                         ExceptionMsg.str().c_str());
  }
  catch(CORBA::Exception& cExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,cExc._name(),
                                         "CDM_EAFDBManager::evHandleBasketDeAssignedFromHeat()",
                                         ExceptionMsg.str().c_str());
  }
  catch(...) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,"Unknown",
                                         "CDM_EAFDBManager::evHandleBasketDeAssignedFromHeat()",
                                         ExceptionMsg.str().c_str());
  }

  return RetValue;

}

bool CDM_EAFDBManager::evHandleBasketDischarged(CEventMessage& Event)
{
  log("++++++ CDM_EAFDBManager::evHandleBasketDischarged",3);

  bool RetValue = true;

  std::string OrderID   = Event.getOrderID();
  std::string PlantID   = Event.getPlantID();
  std::string Plant;
  long PlantNo          = 1;

  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  std::stringstream ExceptionMsg;
  ExceptionMsg << "Handling event: " << Event.getSender()
    << ", " << Event.getHeatID()
    << ", " << Event.getTreatID() << ", " << Event.getDataKey();

  try
  {
    long BasketId         = DEF::Inv_Long;
    long BasketInSeq      = DEF::Inv_Long;
    long BasketLocation   = DEF::Inv_Long;
    long RecipeStatus     = DEF::Inv_Long;
    long LastBasket       = DEF::Inv_Long;


    std::string HMIClientId;
    std::string UserCode; 

    seqBatch RecipeContent;

    // if Basket is discharged from HMI L2 we get Basket id
    // to know if HMI is the sender of event HMIClientId is sent

    if (pDataInterface)
    {
      BasketInSeq    = pDataInterface->getLong   (Event.getDataKey(), DATA::BasketInSeq);
      BasketId       = pDataInterface->getLong   (Event.getDataKey(), DATA::BasketId);
      BasketLocation = pDataInterface->getLong   (Event.getDataKey(), DATA::BasketLocation);
      RecipeStatus   = pDataInterface->getLong   (Event.getDataKey(), DATA::RecipeStatus);
      LastBasket     = pDataInterface->getLong   (Event.getDataKey(), DATA::LastBasket); 
      UserCode       = pDataInterface->getString (Event.getDataKey(), DATA::UserCode);
      HMIClientId    = pDataInterface->getString (Event.getDataKey(), DATA::HMIClientId);

      RecipeContent  = CIntfData::ToCORBAType    (pDataInterface->getBatch(Event.getDataKey().c_str(), DATA::RecipeContent));
    }

    BasketLocation  = CDataConversion::SetInvalidToDefault(BasketLocation,DEF_GC_SCRAP_CONTAINER_LOC::EAF );
    RecipeStatus    = CDataConversion::SetInvalidToDefault(RecipeStatus  ,DEF_GC_RECIPE_STATUS::Discharged);

    // we have to regard the following situations by assigning a basket to a certain position in container sequence
    // 1. The BasketId has been assigned already        -> we have to de-assign it
    // 2. The BasketInSeq is already used by a basket   -> we can overwrite it
    // 3. The BasketInSeq is unknwon                    -> we use the next available position in container sequence

    // check if actual data of BasketId and BasketInSeq are known
    if ( checkBasketData( BasketInSeq, BasketId, HMIClientId) )
    {
      // remove assignment of BasketId for all orders and BasketInSeq
      if ( checkBasketAssignment(Event, CSMC_DBData::unspecLong, BasketId) )
      {
        if ( !deassignScrapBasket(Plant, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, BasketId, false) )
        {
          CDM_DBManager::handleError(Event, HMIClientId);
        }
      }

      RetValue = true;  

    }
    else if ( checkBasketData( BasketInSeq ) )
    {
      // get next usable ContainerInSeq from PD_SCRAP_CONTAINER_OREDER
      long ReqContainerInSeq = getNextContainerInSeqWithStatus(Event, DEF_GC_SCRAP_CONTAINER_TYPE::Basket, CSMC_DBData::unspecLong);

      if ( ReqContainerInSeq != CSMC_DBData::unspecLong && 
           ReqContainerInSeq != BasketInSeq )
      {
        CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ScrapContainerOrderError(sMessage, BasketId, ReqContainerInSeq, BasketInSeq);

        BasketInSeq = ReqContainerInSeq;
        pDataInterface->setLong(Event.getDataKey(), DATA::BasketInSeq, BasketInSeq);

        RetValue = true;  
      }
    }
    else
    {
      RetValue = false;  
    }

    if ( RetValue )
    {
      if ( assignScrapBasket(Event, BasketInSeq, BasketId, LastBasket, false) )
      {
        // update or insert RecipeContent in PD_SCRAP_CONTAINER_ENTRY
        RetValue = setBasketData(Event, BasketInSeq, BasketId, BasketLocation, RecipeStatus, RecipeContent, false);

        if( RetValue && !dischargeScrapBasket(Event, BasketInSeq, BasketId, false) )
        {
          RetValue = false;

          CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_ScrapContainerDischargedError(sMessage, BasketInSeq, BasketId);
        }
        else
        {
          sHeatInfo HeatInfo;
          setHeatInfo(Event, HeatInfo);

          RetValue = handlePDRecipeDataOnDischarged(HeatInfo, OrderID, BasketInSeq, BasketId, UserCode, false);       
        }
      }
    }
    else
    {
      CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ScrapContainerAssignmentError(sMessage, BasketInSeq, BasketId);
    }

    if (RetValue)
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
      CDM_DBManager::handleInformation(Event, HMIClientId, true);
    }
    else
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback();
      CDM_DBManager::handleError(Event, HMIClientId);
    }
  }
  catch(CORBA::SystemException& sExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,sExc._name(),
                                         "CDM_EAFDBManager::evHandleBasketDischarged()",
                                         ExceptionMsg.str().c_str());
  }
  catch(CORBA::Exception& cExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,cExc._name(),
                                         "CDM_EAFDBManager::evHandleBasketDischarged()",
                                         ExceptionMsg.str().c_str());
  }
  catch(...) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,"Unknown",
                                         "CDM_EAFDBManager::evHandleBasketDischarged()",
                                         ExceptionMsg.str().c_str());
  }

  return RetValue;

}

bool CDM_EAFDBManager::evHandleSetBasketData(CEventMessage& Event)
{
  log("++++++ CDM_EAFDBManager::evHandleSetBasketData",3);

  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::string OrderID   = Event.getOrderID();

  std::stringstream ExceptionMsg;
  ExceptionMsg << "Handling event: " << Event.getSender()
    << ", " << Event.getHeatID()
    << ", " << Event.getTreatID() << ", " << Event.getDataKey()
    << ", " << Event.getProductID() << ", " << Event.getPlantID();

  try
  {
    std::string HMIClientId;
    long BasketInSeq        = DEF::Inv_Long;
    long BasketId           = DEF::Inv_Long;
    long BasketLocation     = DEF::Inv_Long;
    long RecipeStatus       = DEF::Inv_Long;

    seqBatch RecipeContent  ;
    std::string UserCode; 

    // to know if HMI is the sender of event HMIClientId is sent
    // 
    if (pDataInterface)
    {
      HMIClientId     = pDataInterface->getString (Event.getDataKey(), DATA::HMIClientId);
      BasketInSeq     = pDataInterface->getLong   (Event.getDataKey(), DATA::BasketInSeq);
      BasketId        = pDataInterface->getLong   (Event.getDataKey(), DATA::BasketId);
      BasketLocation  = pDataInterface->getLong   (Event.getDataKey(), DATA::BasketLocation);
      RecipeStatus    = pDataInterface->getLong   (Event.getDataKey(), DATA::RecipeStatus);
      RecipeContent   = CIntfData::ToCORBAType    (pDataInterface->getBatch(Event.getDataKey().c_str(), DATA::RecipeContent));
      UserCode        = pDataInterface->getString (Event.getDataKey(), DATA::UserCode);
    }

    // if no data transferred we assume basket data as weighing complete at yard
    BasketLocation  = CDataConversion::SetInvalidToDefault(BasketLocation,DEF_GC_SCRAP_CONTAINER_LOC::YARD );
    RecipeStatus    = CDataConversion::SetInvalidToDefault(RecipeStatus  ,DEF_GC_RECIPE_STATUS::WeighingComplete);

    if ( checkBasketData(BasketInSeq, BasketId, HMIClientId) )
    {
      RetValue = setBasketData(Event, BasketInSeq, BasketId, BasketLocation, RecipeStatus, RecipeContent, false);

      RetValue = handlePDHeatStatusOnSetBasketData(Event, BasketInSeq, BasketId, BasketLocation, RecipeStatus, false);

      sHeatInfo HeatInfo;
      setHeatInfo(Event, HeatInfo);

      if ( RecipeStatus == DEF_GC_RECIPE_STATUS::Disabled )
      {
        RetValue = RetValue && handlePDRecipeDataOnDeAssignment(HeatInfo, OrderID, BasketInSeq, BasketId, RecipeStatus, UserCode, false);
      }
      else
      {
        RetValue = RetValue && handlePDRecipeDataOnAssignment(HeatInfo, OrderID, BasketInSeq, BasketId, RecipeStatus, UserCode, false);
      }
    }
    else
    {
      CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ScrapContainerSetDataError(sMessage, BasketInSeq, BasketId);
    }

    if (RetValue)
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
      CDM_DBManager::handleInformation(Event, HMIClientId);
    }
    else
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback();
      CDM_DBManager::handleError(Event, HMIClientId);
    }
  }
  catch(CORBA::SystemException& sExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,sExc._name(),
                                         "CDM_EAFDBManager::evHandleSetBasketData()",
                                         ExceptionMsg.str().c_str());
  }
  catch(CORBA::Exception& cExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,cExc._name(),
                                         "CDM_EAFDBManager::evHandleSetBasketData()",
                                         ExceptionMsg.str().c_str());
  }
  catch(...) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,"Unknown",
                                         "CDM_EAFDBManager::evHandleSetBasketData()",
                                         ExceptionMsg.str().c_str());
  }

  return RetValue;

}

bool CDM_EAFDBManager::evHeatAnnouncement(CEventMessage &Event, bool commit)
{
  log("++++++ CDM_EAFDBManager::evHeatAnnouncement",3);

  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::string EvOrderId         = Event.getOrderID();
  std::string OrderID           = pDataInterface->getString(Event.getDataKey(), DATA::OrderId);
  std::string OrderIdUser       = pDataInterface->getString(Event.getDataKey(), DATA::OrderIdUser);
  std::string SteelGradeCode    = pDataInterface->getString(Event.getDataKey(), DATA::SteelGradeCode);
  std::string HMIClientId       = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  long   TreatmentMode          = pDataInterface->getLong  (Event.getDataKey(), DATA::TreatmentMode);
  
  // *******************************************************
  // OrderID
  // *******************************************************
  std::string mOrd = OrderID;

  if ( (OrderID.empty() || OrderID == DEF::Inv_String) )
  {
    mOrd = EvOrderId;
  }
  if ( !OrderIdUser.empty() && OrderIdUser != DEF::Inv_String )
  {
    mOrd = OrderIdUser;
  }
  if ( (mOrd.empty() || mOrd == DEF::Inv_String) )
  {
    setLastError("INVALID_PRODUCTION_ORDER", 0, "", 1);
    RetValue = false;
  }


  // *******************************************************
  RetValue = RetValue && CDM_DBManager::evHeatAnnouncement(Event, false);

	//sankar for test
	//setHotMetalData(Event, 1, 1, "H", false);
	RetValue = RetValue && handlePDLiqAdditionOnHeatAnnouncement(Event, false);


  //Copy data into HD tables    
  if ( TreatmentMode == DEF::Inv_Long )
  {
    TreatmentMode = 0;
  }

  // Event.HeatId and Event.TreatId will be set in CDM_DBManager::evHeatAnnouncement
  // calling setHeatInfo must not be performed earlier
  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);


	//SARS
	CPD_HEAT_DATA         PD_HEAT_DATA          (m_pDM_DBManagerTask->getStdConnection());	
	long LadleNo = pDataInterface->getLong(Event.getDataKey().c_str(),   DATA::LadleNo);
	std::string LadleType = pDataInterface->getString(Event.getDataKey().c_str(), DATA::LadleType);	
	if(PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
	{
		if(CSMC_DBData::unspecLong == PD_HEAT_DATA.getLADLENO(1) && checkLadleData(LadleNo, LadleType, HMIClientId, "UNKNOWN_TAPPING_LADLE"))
		{
			PD_HEAT_DATA.setLADLENO(LadleNo);
			PD_HEAT_DATA.setLADLETYPE(LadleType);
			RetValue = RetValue && PD_HEAT_DATA.update();
		}
	}


  RetValue = RetValue && CDM_DBManager::copyHDMatFeed (HeatInfo, "", TreatmentMode,  false);
  RetValue = RetValue && copyHDEHeatData              (HeatInfo, false);

  m_pDM_DBManagerTask->getStdConnection()->commit();


  RetValue = RetValue && copyHDEProdPracData          (HeatInfo, "", OrderID, false);

  //  // read Furnace status from PD_PLANTSTATUS_PLANT
  if ( RetValue )
  {
    CPD_PLANTSTATUS_PLANT PD_PLANTSTATUS_PLANT(m_pDM_DBManagerTask->getStdConnection());

    if ( PD_PLANTSTATUS_PLANT.select(HeatInfo.Plant, HeatInfo.PlantNo, 1, 3, DEF_GC_PLANTSTATUS::THERMSTAT) )
    {
      std::string FurnaceStatus = PD_PLANTSTATUS_PLANT.getVALUE(1);
      m_pDM_DBManagerTask->getpPlantManagementInterface()->setString(DEF_PLANT::Furnace, DATA::FurnaceStatus, FurnaceStatus);
    }
  }

  if ( commit )
  {
    if ( RetValue )
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
    }
    else
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback(); 
    }
  }

  if ( RetValue )
  {
    CDM_DBManager::handleInformation(Event, HMIClientId, true);
  }
  else
  {
    CDM_DBManager::handleError(Event, HMIClientId);
  }

  return RetValue;
}

bool CDM_EAFDBManager::evHeatDeparture(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evHeatDeparture",3);

  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::string OrderID     = Event.getOrderID();
  
  long LadleNo            = pDataInterface->getLong  (Event.getDataKey(), DATA::LadleNo) ;
  std::string LadleType   = pDataInterface->getString(Event.getDataKey(), DATA::LadleType) ;
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
  std::string UserCode    = pDataInterface->getString(Event.getDataKey(), DATA::UserCode);

  //set equipment Age
  double TappedWeight     = pDataInterface->getDouble(Event.getDataKey(), DATA::TappingMass);

  if (TappedWeight == DEF::Inv_Double)
    TappedWeight = 0.;

  long TreatmentPosition  = getActTreatmentPosition(Event);

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  // handle general items
  RetValue = RetValue && CDM_DBManager::evHeatDeparture(Event);

  // *******************************************************
  // check Ladle Data against L2 data
  // check LadleNo <= 0 due possible to HMI initialization
  // *******************************************************
  if ( LadleNo == DEF::Inv_Long || LadleNo <= 0 || LadleType == DEF::Inv_String )
  {
    if ( CDM_DBManager::getLadleFromHeatData(HeatInfo, LadleNo, LadleType) )
    {
      std::string Message = "LadleID is adapted to last known database entry: " +  LadleType + CDataConversion::LongToString(LadleNo);

      cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_DBReadWarning(sMessage,"LADLEID","PD_HEAT_DATA",Message.c_str());
    }
  }

  // *******************************************************
  // check Ladle Data against ladle catalogue
  // *******************************************************
  checkLadleData(LadleNo, LadleType, HMIClientId, "UNKNOWN_TAPPING_LADLE");

  //Schedule Heat
  RetValue = RetValue && CDM_DBManager::heatScheduleOnDeparture(HeatInfo, UserCode, TreatmentPosition, false);

  // Prepare PD tables
  RetValue = RetValue && CDM_DBManager::handlePDTablesOnDeparture(HeatInfo, OrderID, UserCode, TreatmentPosition, false);
  // handlePDLadleTablesOnDeparture will return LadleNo/LadelType from PD_HEAT_DATA if required

	//as per JSW: SARS
	CPD_PRETREATDATA      PD_PRETREATDATA       (m_pDM_DBManagerTask->getStdConnection());
	CPDE_HEAT_DATA        PDE_HEAT_DATA         (m_pDM_DBManagerTask->getStdConnection());
	//CPD_HEAT_DATA         PD_HEAT_DATA          (m_pDM_DBManagerTask->getStdConnection());
	//
	//if(PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
	//{
	//	if(CSMC_DBData::unspecLong == PD_HEAT_DATA.getLADLENO(1) && checkLadleData(LadleNo, LadleType, HMIClientId, "UNKNOWN_TAPPING_LADLE"))
	//	{
	//		PD_HEAT_DATA.setLADLENO(LadleNo);
	//		PD_HEAT_DATA.setLADLETYPE(LadleType);
	//		RetValue = RetValue && PD_HEAT_DATA.update();
	//	}
	//}

	double tapMass = 0.;

	if(PDE_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
	{
		tapMass = PDE_HEAT_DATA.getTAPMASS(1);
	}

	if(PD_PRETREATDATA.selectValidDataByProdOrderIdAndPlant(OrderID,HeatInfo.Plant))
	{
		long preCounter = PD_PRETREATDATA.getPRETREAT_COUNTER(1);
		if(preCounter != CSMC_DBData::unspecLong && PD_PRETREATDATA.select(preCounter))
		{
			if(tapMass != CSMC_DBData::unspecDouble && tapMass > 0)
			{
				PD_PRETREATDATA.setSTEELWEIGHT(tapMass);
				RetValue = RetValue && PD_PRETREATDATA.update();
			}
		}
	}


  RetValue = RetValue && CDM_DBManager::handlePDLadleTablesOnDeparture(HeatInfo, LadleNo, LadleType, DEF_GC_LADLE_POS::TT, UserCode, false );  

  RetValue = RetValue && handlePDETablesOnHeatEnd(Event, UserCode, false);

  //Add Action, make commit
  RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo, DEF_GC_ACTION_DEF::Departure, "", "", false, false, false);

  std::string SteelGradeCode = "";
  // special, to see test data in the database, when no tapping end was available
  RetValue = RetValue && CDM_DBManager::copyHDTablesOnHeatEnd(HeatInfo, SteelGradeCode, CSMC_DBData::unspecLong, false);

  RetValue = RetValue && copyHDECyclMeasData(HeatInfo, false);
  RetValue = RetValue && copyHDEHeatData(HeatInfo, false);
  RetValue = RetValue && checkHDEHeatData(HeatInfo, false);

  RetValue = RetValue && copyHDEHeatDataMelt(HeatInfo, false);
  RetValue = RetValue && copyHDEHeatPhaseData(HeatInfo, false);

  CPD_PLANTSTATUS_PLANT PD_PLANTSTATUS_PLANT  (m_pDM_DBManagerTask->getStdConnection());
  
  if(PDE_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId,HeatInfo.Plant))
  {
    std::string FurnaceStatus = PDE_HEAT_DATA.getEAF_THERMSTATID(1);

    if ( FurnaceStatus != CSMC_DBData::unspecString )
    {
      RetValue = RetValue && PD_PLANTSTATUS_PLANT.updateStatus(HeatInfo.Plant, HeatInfo.PlantNo, TreatmentPosition, 3,  DEF_GC_PLANTSTATUS::THERMSTAT, FurnaceStatus, false, m_lastError);
    }
  }


	//SARS	
  CHD_HEAT_DATA_LIQADD HD_HEAT_DATA_LIQADD (m_pDM_DBManagerTask->getStdConnection());
	RetValue = RetValue && HD_HEAT_DATA_LIQADD.copy(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,false,m_lastError);
	
  CHD_HEAT_DATA_STIRR HD_HEAT_DATA_STIRR (m_pDM_DBManagerTask->getStdConnection());
	RetValue = RetValue && HD_HEAT_DATA_STIRR.copy(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,false,m_lastError);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId, true);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evHeatStart(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evHeatStart",3);
  
  bool RetValue = true;

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);
  
  CPD_TAPCH_DATA      PD_TAPCH_DATA     (m_pDM_DBManagerTask->getStdConnection());

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
  long LadleNo            = pDataInterface->getLong  (Event.getDataKey(), DATA::LadleNo) ;
  std::string LadleType   = pDataInterface->getString(Event.getDataKey(), DATA::LadleType) ;

  CDM_PlantManagementInterface_Impl *pPlantInterface = m_pDM_DBManagerTask->getpPlantManagementInterface();

  long VoltTapNo      = pPlantInterface->getLong(DEF_PLANT::Furnace,DATA::VoltTapNo);
  long EltrdRegCurve  = pPlantInterface->getLong(DEF_PLANT::Furnace,DATA::ElectrodRegCurve);

  RetValue = RetValue && CDM_DBManager::evHeatStart(Event);

  RetValue = RetValue && PD_TAPCH_DATA.doHeatStart(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, VoltTapNo, EltrdRegCurve, 0.0, DEF_GEN_STATES::Off, true, m_lastError);

  return RetValue;
}

bool CDM_EAFDBManager::evHeatEnd(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evHeatEnd",3);

   bool RetValue = true;
   sHeatInfo HeatInfo;
   setHeatInfo(Event, HeatInfo);

   CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

   std::string OrderID     = Event.getOrderID();

   long LadleNo            = m_pDM_DBManagerTask->getpProductManagementInterface()->getLong(HeatInfo.ProductId, DATA::LadleNo);
   std::string LadleType   = m_pDM_DBManagerTask->getpProductManagementInterface()->getString(HeatInfo.ProductId, DATA::LadleType);

   std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
   std::string UserCode    = pDataInterface->getString(Event.getDataKey(), DATA::UserCode);

   long TreatmentPosition  = getActTreatmentPosition(Event);

   RetValue = RetValue && CDM_DBManager::evHeatEnd(Event);

   RetValue = RetValue && handlePDETablesOnHeatEnd(Event, UserCode, false);

   if ( RetValue && m_pDM_DBManagerTask != NULL)
   {
     CGT_PARAM             GT_PARAM              (m_pDM_DBManagerTask->getStdConnection());
     CPP_HEAT_PLANT        PP_HEAT_PLANT         (m_pDM_DBManagerTask->getStdConnection());
     CPD_PLANTSTATUS_PLANT PD_PLANTSTATUS_PLANT  (m_pDM_DBManagerTask->getStdConnection());
     CPDE_HEAT_DATA        PDE_HEAT_DATA         (m_pDM_DBManagerTask->getStdConnection());

     if ( GT_PARAM.selectByPlant(HeatInfo.Plant, CSMC_DBData::unspecLong, "AutoHeatAnnouncement", 0, DEF_GC_PARAM_TYPE::SParam) )
     {
       if ( GT_PARAM.getVALUE(1) == "Y" )
       {
         //Schedule Heat
         RetValue = RetValue && CDM_DBManager::heatScheduleOnDeparture(HeatInfo, UserCode, TreatmentPosition, false);

         // Prepare PD tables
         RetValue = RetValue && CDM_DBManager::handlePDTablesOnDeparture(HeatInfo, OrderID, UserCode, TreatmentPosition, false);

         // handlePDLadleTablesOnTappingEnd will return LadleNo/LadelType from PD_HEAT_DATA if required
         RetValue = RetValue && CDM_DBManager::handlePDLadleTablesOnTappingEnd(HeatInfo, LadleNo, LadleType, DEF_GC_LADLE_POS::TT, UserCode, false );

         // handlePDLadleTablesOnDeparture will return LadleNo/LadelType from PD_HEAT_DATA if required
         RetValue = RetValue && CDM_DBManager::handlePDLadleTablesOnDeparture(HeatInfo, LadleNo, LadleType, DEF_GC_LADLE_POS::TT, UserCode, false );

         RetValue = RetValue && handlePDETablesOnHeatEnd(Event, UserCode, false);
       }// if ( GT_PARAM.getVALUE(1) == "Y" )
     }// if ( GT_PARAM.selectByPlant(HeatInfo.Plant, CSMC_DBData::unspecLong, "AutoHeatAnnouncement", 0, DEF_GC_PARAM_TYPE::SParam) )

     // write THERMSTAT to PD_PLANTSTATUS_PLANT be present for next heat on announcement
     if (PDE_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId,HeatInfo.Plant))
     {
       std::string FurnaceStatus = PDE_HEAT_DATA.getEAF_THERMSTATID(1);

       if ( FurnaceStatus != CSMC_DBData::unspecString )
       {
         RetValue = RetValue && PD_PLANTSTATUS_PLANT.updateStatus(HeatInfo.Plant, HeatInfo.PlantNo, 1, 3,  DEF_GC_PLANTSTATUS::THERMSTAT, 
           FurnaceStatus, false, m_lastError);
       }
     }
   }// if ( m_pDM_DBManagerTask != NULL )

   if (RetValue)
   {
     m_pDM_DBManagerTask->getStdConnection()->commit();
     CDM_DBManager::handleInformation(Event, HMIClientId);
   }
   else
   {
     m_pDM_DBManagerTask->getStdConnection()->rollback();
     CDM_DBManager::handleError(Event, HMIClientId);
   }
   return RetValue;
}

bool CDM_EAFDBManager::evHotMetalAnalysisReceived(CEventMessage &Event)
{
  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  long SampleCounter      = CSMC_DBData::unspecLong;//pDataInterface->getLong(Event.getDataKey(),DATA::SampleCounter);
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  if( HeatInfo.Plant.empty() || HeatInfo.Plant == DEF::Inv_String )
  {
    //we should get the plant and plant no from  database because it is from lab,not BOF
    HeatInfo.Plant = DEF_GC_PLANT_DEF::HMD;
    RetValue = RetValue && CDM_DBManager::getPlantNoByHeatIDTreatID(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,HeatInfo.PlantNo );
  }


  RetValue = RetValue && CDM_DBManager::copyHDSamples(HeatInfo, SampleCounter, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();      
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evHotMetalAssigned(CEventMessage& Event)
{
  bool RetValue = false;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::stringstream ExceptionMsg;
  ExceptionMsg << "Handling event: " << Event.getSender()
    << ", " << Event.getHeatID()
    << ", " << Event.getTreatID() << ", " << Event.getDataKey();


  try
  {
    std::string HMLadleType;
    std::string HMIClientId;
    long HMLadleNo = DEF::Inv_Long;
    long ChargeSeq = DEF::Inv_Long; // charged sequence number

    // to know if HMI is the sender of event, HMIClientId is sent
    // 
    if (pDataInterface)
    {
      HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
      ChargeSeq   = pDataInterface->getLong(Event.getDataKey(), DATA::ChargeSeq);
      HMLadleNo   = pDataInterface->getLong(Event.getDataKey(), DATA::LadleNo);
      HMLadleType = pDataInterface->getString(Event.getDataKey(), DATA::LadleType);
    }

    if (ChargeSeq != DEF::Inv_Long && 
        HMLadleNo != DEF::Inv_Long)
    {
      // check if received ladle is already assigned to this order in other charging sequence.
      long Result = checkHMAssignment(Event, ChargeSeq, HMLadleNo, HMLadleType);
      if (Result == 0) // a ladle is not assigned
      {
        Result = assignHotMetalLadle(Event, ChargeSeq, HMLadleNo, HMLadleType, true);
        if (Result < 0)
        {
          setLastError("ERROR_HOT_METAL_ASSIGNMENT", 1200, "");
          CDM_DBManager::handleError(Event, HMIClientId);
        }
        else
        {
          CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_HotMetalAssignment(sMessage, HMLadleType.c_str(), HMLadleNo, ChargeSeq);

          RetValue = true;
        }
      }
      else
      {
        CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_HotMetalAssignmentError(sMessage, HMLadleType.c_str(), HMLadleNo, ChargeSeq);

        std::stringstream Ladle;
        Ladle << HMLadleType << HMLadleNo ;
        setLastError("LADLE_ALREADY_USED", 1200, Ladle.str());
        CDM_DBManager::handleError(Event, HMIClientId);
      }
    }
    else
    {
      CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_HotMetalAssignmentError(sMessage, HMLadleType.c_str(), HMLadleNo, ChargeSeq);
    }

    if (RetValue)
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
      CDM_DBManager::handleInformation(Event, HMIClientId);
    }
    else
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback();
      CDM_DBManager::handleError(Event, HMIClientId);
    }
  }
  catch(CORBA::SystemException& sExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,sExc._name(),
                                         "CDM_EAFDBManager::evHotMetalAssigned()",
                                         ExceptionMsg.str().c_str());
  }
  catch(CORBA::Exception& cExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,cExc._name(),
                                         "CDM_EAFDBManager::evHotMetalAssigned()",
                                         ExceptionMsg.str().c_str());
  }
  catch(...) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,"Unknown",
                                         "CDM_EAFDBManager::evHotMetalAssigned()",
                                         ExceptionMsg.str().c_str());
  }

  return RetValue;

}

bool CDM_EAFDBManager::evHotMetalLadleData(CEventMessage& Event)
{
  bool RetValue = false;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::stringstream ExceptionMsg;
  ExceptionMsg << "Handling event: " << Event.getSender()
    << ", " << Event.getHeatID()
    << ", " << Event.getTreatID() << ", " << Event.getDataKey();


  try
  {

    std::string HMLadleType;
    std::string HMIClientId;
    long HMLadleNo = DEF::Inv_Long;
    long ChargeSeq = DEF::Inv_Long; // charged sequence number
    long Result    = 0;

    // to know if HMI is the sender of event, HMIClientId is sent
    // 
    if (pDataInterface)
    {
      HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
      ChargeSeq   = pDataInterface->getLong(Event.getDataKey(), DATA::ChargeSeq);
      HMLadleNo   = pDataInterface->getLong(Event.getDataKey(), DATA::LadleNo);
      HMLadleType = pDataInterface->getString(Event.getDataKey(), DATA::LadleType);
    }


    if (ChargeSeq != DEF::Inv_Long && 
        HMLadleNo != DEF::Inv_Long)
    {
      // check if received ladle is already assigned to this order in other charging sequence.
      Result = getAssignedHotMetalLadle(Event, ChargeSeq);
      if (Result > 0) // ladle is available
      {
        Result = setHotMetalData(Event, ChargeSeq, HMLadleNo, HMLadleType, true);
        if (Result < 0)
        {
          setLastError("ERROR_SET_HOT_METAL_LADLE_DATA", 1200, "" );
          CDM_DBManager::handleError(Event, HMIClientId);
        }
      }
      else if (Result == 0) // no ladle is assigned
      {
        Result = assignHotMetalLadle(Event, ChargeSeq, HMLadleNo, HMLadleType, false);
        if (Result == HMLadleNo) // assignment was ok
        {
          Result = setHotMetalData(Event, ChargeSeq, HMLadleNo, HMLadleType, true);
          if (Result < 0)
          {
            setLastError("ERROR_SET_HOT_METAL_LADLE_DATA", 1200, "" );
            CDM_DBManager::handleError(Event, HMIClientId);
          }
        }
        else
        {
          CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_HotMetalDataError(sMessage, HMLadleType.c_str(), HMLadleNo, ChargeSeq);
        }
      }
      else // error
      {
        CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_HotMetalDataError(sMessage, HMLadleType.c_str(), HMLadleNo, ChargeSeq);
      }
    }
    else
    {
      CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_HotMetalDataError(sMessage, HMLadleType.c_str(), HMLadleNo, ChargeSeq);
    }

    if (Result > 0)
    {
      CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_HotMetalData(sMessage, HMLadleType.c_str(), HMLadleNo, ChargeSeq);

      RetValue = true;
    }

    if (RetValue)
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
      CDM_DBManager::handleInformation(Event, HMIClientId);
    }
    else
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback();
      CDM_DBManager::handleError(Event, HMIClientId);
    }
  }
  catch(CORBA::SystemException& sExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,sExc._name(),
                                         "CDM_EAFDBManager::evHotMetalLadleData()",
                                         ExceptionMsg.str().c_str());
  }
  catch(CORBA::Exception& cExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,cExc._name(),
                                         "CDM_EAFDBManager::evHotMetalLadleData()",
                                         ExceptionMsg.str().c_str());
  }
  catch(...) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,"Unknown",
                                         "CDM_EAFDBManager::evHotMetalLadleData()",
                                         ExceptionMsg.str().c_str());
  }

  return RetValue;

}

bool CDM_EAFDBManager::evLadleStirringStart(CEventMessage &Event)
{
  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  RetValue = RetValue && CDM_DBManager::handleAction( HeatInfo, DEF_GC_ACTION_DEF::LadleStirringStart, "", "", false, false, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evLadleStirringStop(CEventMessage &Event)
{
  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo, DEF_GC_ACTION_DEF::LadleStirringEnd, "", "", false, false, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evMatFeeding(CEventMessage &Event)
{
  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();
  std::string ActMessage  = Event.getMessage();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string OrderID     = Event.getOrderID();
  std::string DataKey     = Event.getDataKey();
  std::string UserCode    = pDataInterface->getString(DataKey, DATA::UserCode);
  std::string HMIClientId = pDataInterface->getString(DataKey, DATA::HMIClientId);

  seqBatch sqMatFeedingBatch;

  sqMatFeedingBatch = CIntfData::ToCORBAType(pDataInterface->getBatch(DataKey.c_str(), DATA::MatFeedingData));

  bool RetValue = false;

  if(ActMessage == EAF_EvMsg::evEAFMatFeedingStart)
  {
    RetValue = CDM_DBManager::handleMatFeedingStart( HeatInfo,sqMatFeedingBatch, false);
    //Add Action
    RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo, DEF_GC_ACTION_DEF::MaterialFeedingStart, "", "", false, false, false);

    RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo,DEF_GC_ACTION_DEF::FirstMaterialFeedingStart, "", "", true, true, false);

  }
  else if(ActMessage == EAF_EvMsg::evEAFMatFeedingStop)
  {
    RetValue = CDM_DBManager::handleMatFeedingStop( HeatInfo,sqMatFeedingBatch, false);
    //Add Action
    RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo, DEF_GC_ACTION_DEF::MaterialFeedingStop, "", "", false, false, false);

    RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo,DEF_GC_ACTION_DEF::LastMaterialFeedingStop, "", "", true, false, false);
  }

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}
bool CDM_EAFDBManager::evPowerOff(CEventMessage &Event)
{
  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();
  
  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string ActMessage  = Event.getMessage();
  std::string OrderID     = Event.getOrderID();
  std::string DataKey     = Event.getDataKey();
 
  std::string UserCode    = pDataInterface->getString(DataKey, DATA::UserCode);
  std::string HMIClientId = pDataInterface->getString(DataKey, DATA::HMIClientId);

  bool RetValue = true;

  //Add Action
  RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo,DEF_GC_ACTION_DEF::PowerOff, "", "", false, false, false);

  RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo,DEF_GC_ACTION_DEF::LastPowerOff, "", "", true, false, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evPowerOn(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evPowerOn",3);

  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();
  std::string ActMessage  = Event.getMessage();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string OrderID     = Event.getOrderID();
  std::string DataKey     = Event.getDataKey();
  std::string UserCode    = pDataInterface->getString(DataKey, DATA::UserCode);
  std::string HMIClientId = pDataInterface->getString(DataKey, DATA::HMIClientId);

  long TreatmentPosition      = getActTreatmentPosition(Event);

  RetValue = RetValue && CDM_DBManager::handlePDHeatStatus(HeatInfo, m_HeatStatus.Melting, UserCode, TreatmentPosition, false);


  //Add Action
  RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo,DEF_GC_ACTION_DEF::PowerOn, "", "", false, false, false);

  RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo,DEF_GC_ACTION_DEF::FirstPowerOn, "", "", true, true, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evProductionOrderChanged(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evProductionOrderChanged",3);

  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string OrderID     = Event.getOrderID();
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  RetValue = RetValue && CDM_DBManager::evProductionOrderChanged(Event);

  RetValue = RetValue && copyHDEHeatData                (HeatInfo, false);
  RetValue = RetValue && copyHDEProdPracData            (HeatInfo, "", OrderID, false);
 

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();      
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evRemoveHotMetalData(CEventMessage& Event)
{
  bool RetValue = false;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::stringstream ExceptionMsg;
  ExceptionMsg << "Handling event: " << Event.getSender()
    << ", " << Event.getHeatID()
    << ", " << Event.getTreatID() << ", " << Event.getDataKey();


  try
  {
    std::string HMLadleType;
    std::string HMIClientId;
    long HMLadleNo = DEF::Inv_Long;
    long ChargeSeq = DEF::Inv_Long; // charged sequence number

    // to know if HMI is the sender of event, HMIClientId is sent
    // 
    if (pDataInterface)
    {
      HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
      ChargeSeq   = pDataInterface->getLong(Event.getDataKey(), DATA::ChargeSeq);
      HMLadleNo   = pDataInterface->getLong(Event.getDataKey(), DATA::LadleNo);
      HMLadleType = pDataInterface->getString(Event.getDataKey(), DATA::LadleType);
    }


    if (ChargeSeq != DEF::Inv_Long && 
        HMLadleNo != DEF::Inv_Long)
    {
      long Result = deassignHotMetalLadle(Event, ChargeSeq, HMLadleNo, HMLadleType, true);
      if (Result < 0)
      {
        CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_HotMetalRemoveError(sMessage, HMLadleType.c_str(), HMLadleNo, ChargeSeq);

        setLastError("ERROR_HOT_METAL_DEASSIGNMENT", 1200, "");
        CDM_DBManager::handleError(Event, HMIClientId);
      }
      else if (Result == 0)
      {
        CDM_DBManager::handleError(Event, HMIClientId);
      }
      else
      {
        CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_HotMetalRemove(sMessage, HMLadleType.c_str(), HMLadleNo, ChargeSeq);

        RetValue = true;
      }
    }
    else
    {
      CSMC_EventLogEAF *pEventLog = CSMC_EventLogEAFController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_HotMetalRemoveError(sMessage, HMLadleType.c_str(), HMLadleNo, ChargeSeq);
    }

    if (RetValue)
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
      CDM_DBManager::handleInformation(Event, HMIClientId);
    }
    else
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback();
      CDM_DBManager::handleError(Event, HMIClientId);
    }
  }
  catch(CORBA::SystemException& sExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,sExc._name(),
                                         "CDM_EAFDBManager::evRemoveHotMetalData()",
                                         ExceptionMsg.str().c_str());
  }
  catch(CORBA::Exception& cExc) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,cExc._name(),
                                         "CDM_EAFDBManager::evRemoveHotMetalData()",
                                         ExceptionMsg.str().c_str());
  }
  catch(...) 
  {
	  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,"Unknown",
                                         "CDM_EAFDBManager::evRemoveHotMetalData()",
                                         ExceptionMsg.str().c_str());
  }

  return RetValue;

}

bool CDM_EAFDBManager::evRetreatment(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evRetreatment",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string OrderID         = Event.getOrderID();
  std::string OrderIdUser     = pDataInterface->getString(Event.getDataKey(),DATA::OrderIdUser);
  std::string CustHeatId      = pDataInterface->getString(Event.getDataKey(),DATA::CustHeatID);
  std::string CustTreatId     = pDataInterface->getString(Event.getDataKey(),DATA::CustTreatID);
  std::string CustHeatIdUser  = pDataInterface->getString(Event.getDataKey(),DATA::CustHeatIdUser);
  std::string CustTreatIdUser = pDataInterface->getString(Event.getDataKey(),DATA::CustTreatIdUser);
  std::string SteelGradeCode  = pDataInterface->getString(Event.getDataKey(),DATA::SteelGradeCode);
  std::string UserCode        = pDataInterface->getString(Event.getDataKey(),DATA::UserCode);
  double AimWeight            = pDataInterface->getDouble(Event.getDataKey(),DATA::AimWeightUser);
  double AimTemp              = pDataInterface->getDouble(Event.getDataKey(), DATA::TempAim);
  CDateTime mPlanEndTime(pDataInterface->getDate(Event.getDataKey().c_str(), DATA::PlanEndTime));
  std::string HMIClientId     = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  long TreatmentPosition      = getActTreatmentPosition(Event);

  sPDData PDData;
  // now within construction  PDData.init();
  PDData.SteelMass       = pDataInterface->getDouble(Event.getDataKey().c_str(),  DATA::SteelMassAct);
  PDData.SlagMass        = pDataInterface->getDouble(Event.getDataKey().c_str(),  DATA::SlagMassAct);

  // Incoming ladle
  PDData.PreLadleNo      = pDataInterface->getLong(Event.getDataKey().c_str(),    DATA::LadleNo);
  PDData.PreLadleType    = pDataInterface->getString(Event.getDataKey().c_str(),  DATA::LadleType);
  PDData.PreLadleState   = pDataInterface->getString(Event.getDataKey().c_str(), DATA::LadleStatus);

  PDData.SampleNo        = pDataInterface->getLong(Event.getDataKey().c_str(),    DATA::SampleNo);
  PDData.SteelSampleTime = pDataInterface->getDate(Event.getDataKey().c_str(),    DATA::SteelSampleTime);
  PDData.SlagSampleTime  = pDataInterface->getDate(Event.getDataKey().c_str(),    DATA::SlagSampleTime);
  PDData.Temp            = pDataInterface->getDouble(Event.getDataKey().c_str(),  DATA::MeasTemp);
  PDData.TempTime        = pDataInterface->getDate(Event.getDataKey().c_str(),    DATA::TempMeasTime);
  PDData.SampleMode      = pDataInterface->getLong(Event.getDataKey().c_str(),    DATA::SampleMode);
  PDData.SampleOrigin    = pDataInterface->getLong(Event.getDataKey().c_str(),    DATA::SampleOrigin);
  PDData.SteelAnalysis   = CIntfData::ToCORBAType(pDataInterface->getAnalysis(Event.getDataKey().c_str(), DATA::SteelMeasAnalysis));
  PDData.PretreatCounter = pDataInterface->getLong(Event.getDataKey().c_str(),    DATA::Counter);

  bool RetValue = true;
  if (!OrderID.empty() || !OrderIdUser.empty()) 
  {
    std::string mOrd        = OrderIdUser.empty()     ? OrderID : OrderIdUser;
    std::string mHeatCust   = CustHeatIdUser.empty()  ? CustHeatId : CustHeatIdUser;
    std::string mTreatCust  = CustTreatIdUser.empty() ? CustTreatId : CustTreatIdUser;

    long TreatmentMode      = 0;
    
    getTreatmentMode(HeatInfo, mOrd, TreatmentMode);

    //Check if Heat is onRequest or doesn't exest
    if (CDM_DBManager::isOnRequest(CustHeatId, CustHeatIdUser) || !CDM_DBManager::isHeatPlanned(HeatInfo))  
    {
      RetValue = RetValue && CDM_DBManager::handlePPTabelsOnAnnounce(HeatInfo, PDData, mHeatCust, mTreatCust, mOrd, SteelGradeCode, mPlanEndTime, true, UserCode, AimWeight, AimTemp, TreatmentMode, false);
    }
    else
    {
      RetValue = RetValue && CDM_DBManager::handlePPTabelsOnAnnounce(HeatInfo, PDData, mHeatCust, mTreatCust, mOrd, SteelGradeCode, mPlanEndTime, false, UserCode, AimWeight, AimTemp, TreatmentMode, false);
    } 

    //Schedule Heat
    RetValue = RetValue && CDM_DBManager::heatScheduleOnAnnouncement(HeatInfo, UserCode, TreatmentPosition, false);

    if (RetValue)
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
      CDM_DBManager::handleInformation(Event, HMIClientId);
    }
    else
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback();      
      CDM_DBManager::handleError(Event, HMIClientId);
    }
  }

  return RetValue;
}

bool CDM_EAFDBManager::evSetupOfHeat(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evSetupOfHeat",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string OrderID		      = Event.getOrderID();
  std::string HMIClientId     = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
  std::string UserCode	      = pDataInterface->getString(Event.getDataKey(), DATA::UserCode);
  std::string SteelGradeCode  = pDataInterface->getString(Event.getDataKey(), DATA::SteelGradeCode);
  long mStatus		            = pDataInterface->getLong(Event.getDataKey()  , DATA::Status);
  CDateTime mTreatStart	      = pDataInterface->getDate(Event.getDataKey().c_str(), DATA::TreatStartAim);
  CDateTime mTreatEnd		      = pDataInterface->getDate(Event.getDataKey().c_str(), DATA::TreatEndAim);

  long TreatmentPosition      = getActTreatmentPosition(Event);

  sPDData PDData;
  // now within construction  PDData.init();
  PDData.SteelMass	    = pDataInterface->getDouble(Event.getDataKey(), DATA::SteelMassAct);

  // Incoming ladle
  PDData.PreLadleNo		  = pDataInterface->getLong(Event.getDataKey(), DATA::LadleNo);
  PDData.PreLadleType	  = pDataInterface->getString(Event.getDataKey(), DATA::LadleType);

  PDData.Temp		        = pDataInterface->getDouble(Event.getDataKey(), DATA::TempAim); 
  PDData.TempTime	      = CDateTime().assDate();
  PDData.SteelMass      = pDataInterface->getDouble(Event.getDataKey(), DATA::SteelMassAct);

  bool result = handlePDTablesOnSetupOfHeat(HeatInfo, PDData, mStatus, OrderID, mTreatStart, mTreatEnd, SteelGradeCode, UserCode, TreatmentPosition, false);
    
  if (result)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }

  //======================= update the heat stack  ==============================
  setHeatStack();  
  //======================= update the heat stack  ==============================

  return result;
}

bool CDM_EAFDBManager::evSlagAnalysisReceived(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evSlagAnalysisReceived",3);

  bool RetValue = true;
  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string OrderID    = Event.getOrderID();

  long  LadleNo           = pDataInterface->getLong   (Event.getDataKey(), DATA::LadleNo );
  std::string LadleType   = pDataInterface->getString (Event.getDataKey(), DATA::LadleType);

  long  SampleOrigin          = pDataInterface->getLong   (Event.getDataKey(), DATA::SampleOrigin);
  long  SampleNo              = pDataInterface->getLong   (Event.getDataKey(), DATA::SampleNo);
  long  SampleMode            = pDataInterface->getLong   (Event.getDataKey(), DATA::SampleMode);

  std::string SampleLocation  = pDataInterface->getString (Event.getDataKey(), DATA::SampleLocation);
  std::string SampleId        = pDataInterface->getString (Event.getDataKey(), DATA::SampleId);

  std::string UserCode    = pDataInterface->getString(Event.getDataKey(), DATA::UserCode);
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
  seqAnalysis SeqAnalysis = CIntfData::ToCORBAType(pDataInterface->getAnalysis(Event.getDataKey().c_str(), DATA::SlagMeasAnalysis));
  CDateTime SampleTime    = pDataInterface->getDate(Event.getDataKey().c_str(), DATA::SlagSampleTime);
  long SampleCounter      = CSMC_DBData::unspecLong;

  long TreatmentPosition  = getActTreatmentPosition(Event);

  if( HeatInfo.Plant.empty() || HeatInfo.Plant ==DEF::Inv_String )
  {
    HeatInfo.Plant = DEF_GC_PLANT_DEF::EAF;
    RetValue = RetValue && CDM_DBManager::getPlantNoByHeatIDTreatID(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo );
  }

  if( UserCode == DEF::Inv_String )
  {
    UserCode = "";
  }

  RetValue = CDM_DBManager::handlePDTablesOnAnalysisReceived(HeatInfo, SeqAnalysis, LadleNo, LadleType, SampleTime, DEF_GC_MEASUREMENT_TYPE::Slag, SampleNo, SampleMode, 
                                                            SampleOrigin, SampleLocation, SampleCounter, SampleId, OrderID, UserCode, TreatmentPosition, false); 

  //Add Action

  RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo,DEF_GC_ACTION_DEF::AnalysisReceived, "", "", false, false, false);

  RetValue = RetValue && CDM_DBManager::copyHDSamples(HeatInfo, SampleCounter, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();      
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evSlagSampleTaken(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evSlagSampleTaken",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  long SampleCounter      = CSMC_DBData::unspecLong;
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  bool RetValue = CDM_DBManager::copyHDSamples(HeatInfo, SampleCounter, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();      
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evSteelAnalysisReceived(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evSteelAnalysisReceived",3);

  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string OrderID    = Event.getOrderID();

  long  LadleNo           = pDataInterface->getLong   (Event.getDataKey(), DATA::LadleNo );
  std::string LadleType   = pDataInterface->getString (Event.getDataKey(), DATA::LadleType);

  long  SampleOrigin          = pDataInterface->getLong   (Event.getDataKey(), DATA::SampleOrigin);
  long  SampleNo              = pDataInterface->getLong   (Event.getDataKey(), DATA::SampleNo);
  long  SampleMode            = pDataInterface->getLong   (Event.getDataKey(), DATA::SampleMode);
  std::string SampleLocation  = pDataInterface->getString (Event.getDataKey(), DATA::SampleLocation);
  std::string SampleId        = pDataInterface->getString (Event.getDataKey(), DATA::SampleId);
  

  std::string UserCode    = pDataInterface->getString(Event.getDataKey(), DATA::UserCode);
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
  seqAnalysis SeqAnalysis = CIntfData::ToCORBAType(pDataInterface->getAnalysis(Event.getDataKey().c_str(), DATA::SteelMeasAnalysis));
  CDateTime SampleTime      (pDataInterface->getDate(Event.getDataKey().c_str(), DATA::SteelSampleTime));
  long  SampleCounter     = CSMC_DBData::unspecLong;

  long TreatmentPosition  = getActTreatmentPosition(Event);

  if( HeatInfo.Plant.empty() || HeatInfo.Plant ==DEF::Inv_String )
  {
    HeatInfo.Plant = DEF_GC_PLANT_DEF::EAF;//of cause it was EAF because it in EAF_Frame
    RetValue = RetValue && CDM_DBManager::getPlantNoByHeatIDTreatID(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo );
  }

  if( UserCode == DEF::Inv_String )
  {
    UserCode = "";
  }


  RetValue = CDM_DBManager::handlePDTablesOnAnalysisReceived(HeatInfo, SeqAnalysis, LadleNo, LadleType, SampleTime, DEF_GC_MEASUREMENT_TYPE::Steel, SampleNo, SampleMode, SampleOrigin, SampleLocation, SampleCounter, SampleId, OrderID , UserCode, TreatmentPosition, false); 

  //Add Action

  RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo,DEF_GC_ACTION_DEF::AnalysisReceived, "", "", false, false, false);

  RetValue = RetValue && CDM_DBManager::copyHDSamples(HeatInfo, SampleCounter, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evSteelGradeChanged(CEventMessage& Event)
{
  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string OrderID         = Event.getOrderID();
  std::string SteelGradeCode  = pDataInterface->getString(Event.getDataKey(), DATA::SteelGradeCode);
  std::string UserCode        = pDataInterface->getString(Event.getDataKey(), DATA::UserCode);
  std::string HMIClientId     = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  if (SteelGradeCode.empty() || SteelGradeCode == DEF::Inv_String)
  {
    setLastError("INVALID_GRADE_CODE", 0, SteelGradeCode, 1);
    return false;
  }

  bool RetValue = CDM_DBManager::handlePDTablesOnSteelGradeChanged(HeatInfo, SteelGradeCode, OrderID, UserCode, false);

  long TreatmentMode = 0;
  RetValue = RetValue && getTreatmentMode(HeatInfo, OrderID, TreatmentMode);

  RetValue = RetValue && CDM_DBManager::copyHDHeatData  (HeatInfo, false);
  RetValue = RetValue && CDM_DBManager::copyHDGrades    (HeatInfo, "", false);
  RetValue = RetValue && CDM_DBManager::copyHDParams    (HeatInfo, false);
  RetValue = RetValue && CDM_DBManager::copyHDRestris   (HeatInfo, TreatmentMode, false);
  RetValue = RetValue && CDM_DBManager::copyHDMatFeed   (HeatInfo, "", TreatmentMode,  false);

  RetValue = RetValue && copyHDEHeatData                (HeatInfo, false);
  RetValue = RetValue && copyHDEProdPracData            (HeatInfo, SteelGradeCode, OrderID, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();      
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evSteelSampleTaken(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evSteelSampleTaken",3);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  long SampleCounter      = CSMC_DBData::unspecLong;

  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);

  bool RetValue = CDM_DBManager::copyHDSamples(HeatInfo, SampleCounter, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();      
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::evTappingEnd(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evTappingEnd",3);

  bool RetValue = true;

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string OrderID     = Event.getOrderID();

  long LadleNo            = pDataInterface->getLong  (Event.getDataKey(), DATA::LadleNo) ;
  std::string LadleType   = pDataInterface->getString(Event.getDataKey(), DATA::LadleType) ;
  std::string HMIClientId = pDataInterface->getString(Event.getDataKey(), DATA::HMIClientId);
  std::string UserCode    = pDataInterface->getString(Event.getDataKey(),DATA::UserCode);

  //set equipment Age
  double TappedWeight     = pDataInterface->getDouble(Event.getDataKey(), DATA::TappingMass);

  long TreatmentPosition  = getActTreatmentPosition(Event);

  long SampleCounter      = CSMC_DBData::unspecLong;

  if (m_pDM_DBManagerTask->getpProductManagementInterface())
  {
    if (TappedWeight == DEF::Inv_Double)
    {
      TappedWeight = m_pDM_DBManagerTask->getpProductManagementInterface()->getDouble(HeatInfo.ProductId, DATA::TappingMass);
      TappedWeight = CDataConversion::SetInvalidToDefault(TappedWeight,0.);
    }
  }
  else
  {
    TappedWeight = 0.;
  }

  // *******************************************************
  // check Ladle Data against L2 data
  // check LadleNo <= 0 due possible to HMI initialization
  // *******************************************************
  if ( LadleNo == DEF::Inv_Long || LadleNo <= 0 || LadleType == DEF::Inv_String )
  {
    if ( CDM_DBManager::getLadleFromHeatData(HeatInfo, LadleNo, LadleType) )
    {
      std::string Message = "LadleID is adapted to last known database entry: " +  LadleType + CDataConversion::LongToString(LadleNo);

      cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_DBReadWarning(sMessage,"LADLEID","PD_HEAT_DATA",Message.c_str());
    }
  }
 
  // *******************************************************
  // check Ladle Data against ladle catalogue
  // *******************************************************
  checkLadleData(LadleNo, LadleType, HMIClientId, "UNKNOWN_TAPPING_LADLE"); 

  RetValue = RetValue && handlePDETablesOnTappingEnd(Event, TappedWeight, OrderID, UserCode, false);

  //don't care the return value, for sometime return false if no equipment is mount
  CDM_DBManager::setEquipmentAgeByHeat(HeatInfo, false);
  CDM_DBManager::setEquipmentAgeByWeight(HeatInfo, TappedWeight, false);

  //Add Action, make commit
  RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo, DEF_GC_ACTION_DEF::TappingEnd, "", "", false, false, false);

  RetValue = RetValue && CDM_DBManager::copyHDAction(HeatInfo, false);

  if ( RetValue && m_pDM_DBManagerTask != NULL)
  {
    CPD_PLANTSTATUS_PLANT PD_PLANTSTATUS_PLANT  (m_pDM_DBManagerTask->getStdConnection());
    CPDE_HEAT_DATA        PDE_HEAT_DATA         (m_pDM_DBManagerTask->getStdConnection());

    // write THERMSTAT to PD_PLANTSTATUS_PLANT be present for next heat on announcement
    if(PDE_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId,HeatInfo.Plant))
    {
      std::string FurnaceStatus = PDE_HEAT_DATA.getEAF_THERMSTATID(1);

      if ( FurnaceStatus != CSMC_DBData::unspecString )
      {
        RetValue = RetValue && PD_PLANTSTATUS_PLANT.updateStatus(HeatInfo.Plant, HeatInfo.PlantNo, TreatmentPosition, 3,  DEF_GC_PLANTSTATUS::THERMSTAT, FurnaceStatus, false, m_lastError);
      }
    }
  }// if ( RetValue && m_pDM_DBManagerTask != NULL)

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();   
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }

  return RetValue;
}

bool CDM_EAFDBManager::evTappingStart(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evTappingStart",3);

  bool RetValue = true;
  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string DataKey     = Event.getDataKey();
  std::string OrderID     = Event.getOrderID();
  
  std::string UserCode    = pDataInterface->getString(DataKey, DATA::UserCode);
  std::string HMIClientId = pDataInterface->getString(DataKey, DATA::HMIClientId);
  long Sample_Ref         = CSMC_DBData::unspecLong;

  RetValue = RetValue && CDM_DBManager::handlePDTablesOnTappingStart(HeatInfo, UserCode, 1, false);

  // Set hot heel data
  RetValue = RetValue && CDM_DBManager::changeHotHeelData(HeatInfo, Sample_Ref, CSMC_DBData::unspecDouble, CSMC_DBData::unspecDouble, false);

  // Set calculated analysis as hot heel analysis
  RetValue = RetValue && CDM_DBManager::writeHotHeelAnalysisOnTappingStart(HeatInfo, Sample_Ref, false);
  
  //Add Action
  RetValue = RetValue && CDM_DBManager::handleAction(HeatInfo, DEF_GC_ACTION_DEF::TappingStart, "", "", false, false, false);

  RetValue = RetValue && CDM_DBManager::handleNewTreatmentPosition(HeatInfo.Plant, HeatInfo.PlantNo, DEF_GC_TRETMENTPOSITION::Furnace, DEF_GC_TRETMENTPOSITION::TappingArea, false);

  if (RetValue)
  {
    m_pDM_DBManagerTask->getStdConnection()->commit();
    CDM_DBManager::handleInformation(Event, HMIClientId);
  }
  else
  {
    m_pDM_DBManagerTask->getStdConnection()->rollback();
    CDM_DBManager::handleError(Event, HMIClientId);
  }
  return RetValue;
}

bool CDM_EAFDBManager::AutomaticlyFillRelativeDelays(CEventMessage &Event,bool pCommit,bool &isDelay)
{
  bool result = true;

	//SARS
	isDelay = false;
  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

	CGT_PARAM      GT_PARAM(m_pDM_DBManagerTask->getStdConnection());
	CPD_HEAT_DATA  PD_HEAT_DATA(m_pDM_DBManagerTask->getStdConnection());
		
  if( PD_HEAT_DATA.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant ) )
  {
    CDateTime	 mActTreatStart,mActTreatEnd;

    mActTreatStart = PD_HEAT_DATA.getTREATSTART_ACT(1);
    mActTreatEnd = PD_HEAT_DATA.getTREATEND_ACT(1);
	  string mDelayCode = "1209";  

    CDeltaTime actProdDur = CDateTime::subTimes(mActTreatEnd, mActTreatStart);
    long DefltTreatDur = 1800; // 30 minutes in seconds
		if(GT_PARAM.select(DEF_GC_PLANTGROUP_DESC::All_EAF,"DefltTreatDuration", 0, CSMC_DBData::unspecLong))
    {
      DefltTreatDur = CDataConversion::StringToLong(GT_PARAM.getVALUE(1)) * 60; //DB contains minutes, we need seconds
    }
                  
    if( actProdDur.asSeconds() > DefltTreatDur)
    {
      CDateTime mdelayStartTime; 
			mdelayStartTime = mActTreatStart ; 
			mdelayStartTime.addTime((double)DefltTreatDur);

			CDM_DataInterface_Impl *dataProvider = m_pDM_DBManagerTask->getpDataInterface();
			dataProvider->setString(Event.getDataKey(), DATA::DelayCode, mDelayCode);
			dataProvider->setDate(Event.getDataKey().c_str(), DATA::DelayStartDate, mdelayStartTime.assDate());
			dataProvider->setDate(Event.getDataKey().c_str(), DATA::DelayEndDate, mActTreatEnd.assDate());
			dataProvider->setString(Event.getDataKey(), DATA::UserCode, "ADM");
			dataProvider->setString(Event.getDataKey(), DATA::Comment, " "); //Operator has to fill via HMI.
			dataProvider->setLong(Event.getDataKey(), DATA::Status, DEF_GEN_STATES::New);

			isDelay = true;
    }   
  }

  return result;
}

bool CDM_EAFDBManager::LastTapEndToPowerOnDelays(CEventMessage &Event,bool pCommit,bool &isDelay)
{
  bool result = true;

	//SARS
	isDelay = false;
  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

	CPD_ACTION                 PD_ACTION(m_pDM_DBManagerTask->getStdConnection());
	CPD_PLANTSTATUS_PLANT      PD_PLANTSTATUS_PLANT(m_pDM_DBManagerTask->getStdConnection());
	CGT_PARAM                  GT_PARAM(m_pDM_DBManagerTask->getStdConnection());

	if(PD_ACTION.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,DEF_GC_ACTION_DEF::PowerOn,CSMC_DBData::unspecDate)  && PD_ACTION.getLastRow() == 1) //only for 1st power on 
	{
			CDateTime LastTapTime;
			CDateTime Now;
			long TreatmentPosition  = 2 ; //getActTreatmentPosition(Event);

			if ( PD_PLANTSTATUS_PLANT.select(HeatInfo.Plant, HeatInfo.PlantNo, TreatmentPosition, 3, DEF_GC_PLANTSTATUS::LASTTAPTIME) )
			{
				std::string Value =  PD_PLANTSTATUS_PLANT.getVALUE(1);

				if ( Value != CSMC_DBData::unspecString )
				{
					LastTapTime.fromDBString(Value); 
				}
			}
			CDeltaTime duration = CDateTime::subTimes(Now,LastTapTime);

			long DefltSetUpDur = 900; // 15 minutes in seconds
			if(GT_PARAM.select(DEF_GC_PLANTGROUP_DESC::All_EAF,"DefltHeatSetUpDuration", 0, CSMC_DBData::unspecLong))
			{
				DefltSetUpDur = CDataConversion::StringToLong(GT_PARAM.getVALUE(1)) * 60; //DB contains minutes, we need seconds
			}
			if( duration.asSeconds() > DefltSetUpDur)
			{
				CDateTime delayStartTime; 
				delayStartTime = LastTapTime ; 
				delayStartTime.addTime((double)DefltSetUpDur);

				string DelayCode = "1212"; //setUp delay

				CDM_DataInterface_Impl *dataProvider = m_pDM_DBManagerTask->getpDataInterface();
				dataProvider->setString(Event.getDataKey(), DATA::DelayCode, DelayCode);
				dataProvider->setDate(Event.getDataKey().c_str(), DATA::DelayStartDate, delayStartTime.assDate());
				dataProvider->setDate(Event.getDataKey().c_str(), DATA::DelayEndDate, Now.assDate());
				dataProvider->setString(Event.getDataKey(), DATA::UserCode, "ADM");
				dataProvider->setString(Event.getDataKey(), DATA::Comment, " "); //Operator has to fill via HMI.
				dataProvider->setLong(Event.getDataKey(), DATA::Status, DEF_GEN_STATES::New);

				isDelay = true;
			}
	}//if..m_pPD_ACTION

	
  return result;
}

bool CDM_EAFDBManager::LastPowerOffToTapStartDelays(CEventMessage &Event,bool pCommit,bool &isDelay)
{
  bool result = true;

	//SARS
	isDelay = false;
  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

	CPD_ACTION                 PD_ACTION(m_pDM_DBManagerTask->getStdConnection());
	CPD_PLANTSTATUS_PLANT      PD_PLANTSTATUS_PLANT(m_pDM_DBManagerTask->getStdConnection());
	CGT_PARAM                  GT_PARAM(m_pDM_DBManagerTask->getStdConnection());

	if(PD_ACTION.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,DEF_GC_ACTION_DEF::PowerOff,CSMC_DBData::unspecDate)  && PD_ACTION.getLastRow() > 0)  
	{
			CDateTime LastPowerOffTime;
			CDateTime Now;
			long TreatmentPosition  = getActTreatmentPosition(Event);
			LastPowerOffTime = PD_ACTION.getREVTIME(PD_ACTION.getLastRow());

			CDeltaTime duration = CDateTime::subTimes(Now,LastPowerOffTime);

			long DefltSetUpDur = 120; // 2 minutes in seconds
			if(GT_PARAM.select(DEF_GC_PLANTGROUP_DESC::All_EAF,"DefltTapStartDuration", 0, CSMC_DBData::unspecLong))
			{
				DefltSetUpDur = CDataConversion::StringToLong(GT_PARAM.getVALUE(1)) * 60; //DB contains minutes, we need seconds
			}
			if( duration.asSeconds() > DefltSetUpDur)
			{
				CDateTime delayStartTime; 
				delayStartTime = LastPowerOffTime ; 
				delayStartTime.addTime((double)DefltSetUpDur);

				string DelayCode = "1214"; //setUp delay

				CDM_DataInterface_Impl *dataProvider = m_pDM_DBManagerTask->getpDataInterface();
				dataProvider->setString(Event.getDataKey(), DATA::DelayCode, DelayCode);
				dataProvider->setDate(Event.getDataKey().c_str(), DATA::DelayStartDate, delayStartTime.assDate());
				dataProvider->setDate(Event.getDataKey().c_str(), DATA::DelayEndDate, Now.assDate());
				dataProvider->setString(Event.getDataKey(), DATA::UserCode, "ADM");
				dataProvider->setString(Event.getDataKey(), DATA::Comment, " "); //Operator has to fill via HMI.
				dataProvider->setLong(Event.getDataKey(), DATA::Status, DEF_GEN_STATES::New);

				isDelay = true;
			}
	}//if..m_pPD_ACTION

	
  return result;
}

bool CDM_EAFDBManager::ExtraPowerOnDelays(CEventMessage &Event,bool pCommit,bool &isDelay)
{
  bool result = true;

	//SARS
	isDelay = false;
  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

	CPD_ACTION                 PD_ACTION(m_pDM_DBManagerTask->getStdConnection());
	CPD_PLANTSTATUS_PLANT      PD_PLANTSTATUS_PLANT(m_pDM_DBManagerTask->getStdConnection());
	CGT_PARAM                  GT_PARAM(m_pDM_DBManagerTask->getStdConnection());
	CPDE_HEAT_DATA             PDE_HEAT_DATA(m_pDM_DBManagerTask->getStdConnection());

	if(PD_ACTION.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,DEF_GC_ACTION_DEF::LastPowerOff,CSMC_DBData::unspecDate)  && PD_ACTION.getLastRow() > 0)  
	{
			CDateTime LastPowerOffTime;
			CDateTime Now;
			long TreatmentPosition  = getActTreatmentPosition(Event);
			LastPowerOffTime = PD_ACTION.getREVTIME(PD_ACTION.getLastRow());

			long duration;
			if(PDE_HEAT_DATA.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant))
			{
				duration = (long)PDE_HEAT_DATA.getPOWER_ON_DUR(1);
				duration = duration * 60 ; //sec
			}

			//CDeltaTime duration = CDateTime::subTimes(Now,LastPowerOffTime);

			long DefltSetUpDur = 4800; // 80 minutes in seconds
			if(GT_PARAM.select(DEF_GC_PLANTGROUP_DESC::All_EAF,"DefltExtraPowerOnDuration", 0, CSMC_DBData::unspecLong))
			{
				DefltSetUpDur = CDataConversion::StringToLong(GT_PARAM.getVALUE(1)) * 60; //DB contains minutes, we need seconds
			}
			if( duration > DefltSetUpDur)
			{
				CDateTime delayStartTime; 
				delayStartTime = LastPowerOffTime ; 

				double diff = duration - DefltSetUpDur;
				delayStartTime.addTime(-diff);

				string DelayCode = "1211"; //extra power on delay

				CDM_DataInterface_Impl *dataProvider = m_pDM_DBManagerTask->getpDataInterface();
				dataProvider->setString(Event.getDataKey(), DATA::DelayCode, DelayCode);
				dataProvider->setDate(Event.getDataKey().c_str(), DATA::DelayStartDate, delayStartTime.assDate());
				dataProvider->setDate(Event.getDataKey().c_str(), DATA::DelayEndDate, LastPowerOffTime.assDate());
				dataProvider->setString(Event.getDataKey(), DATA::UserCode, "ADM");
				dataProvider->setString(Event.getDataKey(), DATA::Comment, " "); //Operator has to fill via HMI.
				dataProvider->setLong(Event.getDataKey(), DATA::Status, DEF_GEN_STATES::New);

				isDelay = true;
			}
	}//if..m_pPD_ACTION

	
  return result;
}

bool CDM_EAFDBManager::TapStartToTapEndDelays(CEventMessage &Event,bool pCommit,bool &isDelay)
{
  bool result = true;

	//SARS
	isDelay = false;
  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

	CPD_ACTION                 PD_ACTION(m_pDM_DBManagerTask->getStdConnection());
	CPD_PLANTSTATUS_PLANT      PD_PLANTSTATUS_PLANT(m_pDM_DBManagerTask->getStdConnection());
	CGT_PARAM                  GT_PARAM(m_pDM_DBManagerTask->getStdConnection());

	if(PD_ACTION.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,DEF_GC_ACTION_DEF::TappingStart,CSMC_DBData::unspecDate)  && PD_ACTION.getLastRow() > 0)  
	{
			CDateTime LastTapStartTime;
			CDateTime Now;
			long TreatmentPosition  = getActTreatmentPosition(Event);
			LastTapStartTime = PD_ACTION.getREVTIME(PD_ACTION.getLastRow());

			CDeltaTime duration = CDateTime::subTimes(Now,LastTapStartTime);

			long DefltSetUpDur = 300; // 5 minutes in seconds
			if(GT_PARAM.select(DEF_GC_PLANTGROUP_DESC::All_EAF,"DefltTapEndDuration", 0, CSMC_DBData::unspecLong))
			{
				DefltSetUpDur = CDataConversion::StringToLong(GT_PARAM.getVALUE(1)) * 60; //DB contains minutes, we need seconds
			}
			if( duration.asSeconds() > DefltSetUpDur)
			{
				CDateTime delayStartTime; 
				delayStartTime = LastTapStartTime ; 
				delayStartTime.addTime((double)DefltSetUpDur);

				string DelayCode = "1213"; //Tapstart to tapEnd delay

				CDM_DataInterface_Impl *dataProvider = m_pDM_DBManagerTask->getpDataInterface();
				dataProvider->setString(Event.getDataKey(), DATA::DelayCode, DelayCode);
				dataProvider->setDate(Event.getDataKey().c_str(), DATA::DelayStartDate, delayStartTime.assDate());
				dataProvider->setDate(Event.getDataKey().c_str(), DATA::DelayEndDate, Now.assDate());
				dataProvider->setString(Event.getDataKey(), DATA::UserCode, "ADM");
				dataProvider->setString(Event.getDataKey(), DATA::Comment, " "); //Operator has to fill via HMI.
				dataProvider->setLong(Event.getDataKey(), DATA::Status, DEF_GEN_STATES::New);

				isDelay = true;
			}
	}//if..m_pPD_ACTION

	
  return result;
}

bool CDM_EAFDBManager::PowerOffToPowerOnDelays(CEventMessage &Event,bool pCommit,bool &isDelay)
{
  bool result = true;

	//SARS
	isDelay = false;
  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

	CPD_ACTION                 PD_ACTION(m_pDM_DBManagerTask->getStdConnection());
	CPD_PLANTSTATUS_PLANT      PD_PLANTSTATUS_PLANT(m_pDM_DBManagerTask->getStdConnection());
	CGT_PARAM                  GT_PARAM(m_pDM_DBManagerTask->getStdConnection());

	if(PD_ACTION.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,DEF_GC_ACTION_DEF::PowerOff,CSMC_DBData::unspecDate)  && PD_ACTION.getLastRow() > 0)  
	{
			CDateTime LastPowerOffTime;
			CDateTime Now;
			long TreatmentPosition  = getActTreatmentPosition(Event);
			LastPowerOffTime = PD_ACTION.getREVTIME(PD_ACTION.getLastRow());

			CDeltaTime duration = CDateTime::subTimes(Now,LastPowerOffTime);

			long DefltSetUpDur = 60; // 1 minutes in seconds
			if(GT_PARAM.select(DEF_GC_PLANTGROUP_DESC::All_EAF,"DefltPowerOffOnDuration", 0, CSMC_DBData::unspecLong))
			{
				DefltSetUpDur = CDataConversion::StringToLong(GT_PARAM.getVALUE(1)) * 60; //DB contains minutes, we need seconds
			}
			if( duration.asSeconds() > DefltSetUpDur)
			{
				CDateTime delayStartTime; 
				delayStartTime = LastPowerOffTime ; 
				delayStartTime.addTime((double)DefltSetUpDur);

				string DelayCode = "1210"; //powerOff to Poweon delay

				CDM_DataInterface_Impl *dataProvider = m_pDM_DBManagerTask->getpDataInterface();
				dataProvider->setString(Event.getDataKey(), DATA::DelayCode, DelayCode);
				dataProvider->setDate(Event.getDataKey().c_str(), DATA::DelayStartDate, delayStartTime.assDate());
				dataProvider->setDate(Event.getDataKey().c_str(), DATA::DelayEndDate, Now.assDate());
				dataProvider->setString(Event.getDataKey(), DATA::UserCode, "ADM");
				dataProvider->setString(Event.getDataKey(), DATA::Comment, " "); //Operator has to fill via HMI.
				dataProvider->setLong(Event.getDataKey(), DATA::Status, DEF_GEN_STATES::New);

				isDelay = true;
			}
	}//if..m_pPD_ACTION

	
  return result;
}


bool CDM_EAFDBManager::evHeatScheduleUpdate(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evHeatScheduleUpdate",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  if (RetValue)
  { 
    std::string OrderID = CSMC_DBData::unspecString;

    RetValue = handleOrderScrap(HeatInfo, OrderID, CSMC_DBData::unspecString, true);
  }

  return RetValue;
}

bool CDM_EAFDBManager::evOrderScrap(CEventMessage &Event)
{
  log("++++++ CDM_EAFDBManager::evOrderScrap",3);

  bool RetValue = (m_pDM_DBManagerTask != NULL);

  CDM_DataInterface_Impl *pDataInterface = m_pDM_DBManagerTask->getpDataInterface();

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  std::string OrderID     = Event.getOrderID();
  
  if (RetValue)
  { 
    RetValue = handleOrderScrap(HeatInfo, OrderID, CSMC_DBData::unspecString, true);
  }

  return RetValue;
}



long CDM_EAFDBManager::getAssignedHotMetalLadle(CEventMessage& Event, long ChargeSeq)
{
  std::string ProductID = Event.getProductID();
  std::string OrderID   = Event.getOrderID();
  std::string PlantID   = Event.getPlantID();
  std::string Plant;
  long HMLadleNo        = 0;
  long PlantNo          = 1;

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_EAFDBManager::getAssignedHotMetalLadle");

    return false;
  }

  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  if (m_pDM_DBManagerTask->getpDataInterface())
  {
    // =======================================================================================
    // 
    // Get hot metal counter from PD_HOT_METAL_ORDER 
    // and read ladle number from PD_HOT_METAL
    // 
    // =======================================================================================

    CPD_HOT_METAL_ORDER PD_HOT_METAL_ORDER(m_pDM_DBManagerTask->getStdConnection());
    CPD_HOT_METAL PD_HOT_METAL(m_pDM_DBManagerTask->getStdConnection());
    //CPD_LADLE PD_LADLE(m_pDM_DBManagerTask->getStdConnection());

    //============  read counter from PD_HOT_METAL_ORDER =================================

  
    if (PD_HOT_METAL_ORDER.select(Plant, OrderID, ChargeSeq) &&
        PD_HOT_METAL_ORDER.getLastRow() == 1 )
    {

      if (!PD_HOT_METAL_ORDER.isNull(CPD_HOT_METAL_ORDER::HOTMETAL_COUNTER,1))
      {
        if (PD_HOT_METAL.select(PD_HOT_METAL_ORDER.getHOTMETAL_COUNTER(1)))
        {
          if (!PD_HOT_METAL.isNull(CPD_HOT_METAL::LADLENO,1))
          {
            // get assigned ladle
            HMLadleNo = PD_HOT_METAL.getLADLENO(1);
          }
        }
      }
    }
    else
    {
      std::stringstream SearchKey;
      SearchKey << Plant << ", " << OrderID << ", " << ChargeSeq;
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorSearchingData(sMessage, SearchKey.str().c_str(), "PD_HOT_METAL_ORDER");
    }
  }
  return HMLadleNo;
}

long CDM_EAFDBManager::getAssignedScrapBasket(CEventMessage& Event,long BasketInSeq)
{
  std::string HeatID    = Event.getHeatID();
  std::string OrderID   = Event.getOrderID();
  std::string PlantID   = Event.getPlantID();
  std::string ProductID = Event.getProductID();

  std::string Plant;
  long AssignedBasket   = CSMC_DBData::unspecLong;
  long PlantNo          = 1;

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_EAFDBManager::getAssignedScrapBasket");

    return CSMC_DBData::unspecLong;
  }

  if (BasketInSeq == DEF::Inv_Long)
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_InconsistentDataReceived(sMessage, "BasketInSeq", Event.getMessage().c_str());

    return CSMC_DBData::unspecLong;
  }

  if (OrderID.empty() || OrderID == DEF::Inv_String)
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_InconsistentDataReceived(sMessage, "OrderID", Event.getMessage().c_str());

    return false;
  }
  
  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  if (m_pDM_DBManagerTask->getpDataInterface())
  {
    //============  read Basket from PD_SCRAP_CONTAINER_ORDER =================================
    // read Basket id from this table
    CPD_SCRAP_CONTAINER_ORDER PD_SCRAP_CONTAINER_ORDER (m_pDM_DBManagerTask->getStdConnection());

    if (PD_SCRAP_CONTAINER_ORDER.select(Plant, OrderID, BasketInSeq) &&
        PD_SCRAP_CONTAINER_ORDER.getLastRow() == 1 )
    {
      // get assigned Basket
      if (!PD_SCRAP_CONTAINER_ORDER.isNull(CPD_SCRAP_CONTAINER_ORDER::CONTAINERNO,1))
      {
        AssignedBasket = PD_SCRAP_CONTAINER_ORDER.getCONTAINERNO(1);
      }
    }
    else
    {
      std::stringstream SearchKey;
      SearchKey << Plant << ", " << OrderID << ", " << BasketInSeq;
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ErrorSearchingData(sMessage, SearchKey.str().c_str(), "PD_SCRAP_CONTAINER_ORDER");
    }
  }
  return AssignedBasket;
}


bool CDM_EAFDBManager::getTreatmentMode(sHeatInfo &HeatInfo, const std::string& PRODORDERID, long& TreatmentMode)
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);

  RetValue = RetValue && (m_pDM_DBManagerTask->getStdConnection() != NULL);

  if (RetValue)
  {
    CPP_ORDER_SINGLE_AIMS PP_ORDER_SINGLE_AIMS(m_pDM_DBManagerTask->getStdConnection());
    CHD_TREATMODE         HD_TREATMODE        (m_pDM_DBManagerTask->getStdConnection());

    if ( HD_TREATMODE.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, CSMC_DBData::unspecLong) )
    {
      TreatmentMode = HD_TREATMODE.getTREATMODENO(1);
      std::string Message = "USING HD_TREATMENTMODE " + CDataConversion::LongToString(TreatmentMode);
      log(Message,3);
    }
    else if( PP_ORDER_SINGLE_AIMS.select(PRODORDERID, HeatInfo.Plant, 1, DEF_GC_PP_ORDER_SINGLE_AIMS::TREATMENTMODE) )
    {
      TreatmentMode = CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1));
      std::string Message = "USING PP_TREATMENTMODE " + CDataConversion::LongToString(TreatmentMode);
      log(Message,3);
    }
    else
    {
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_DBReadWarning(sMessage,"","PP_ORDER_SINGLE_AIMS",std::string("NO_TREATMENT_MODE_DEFINED").c_str());

      // set to default value;
      TreatmentMode = 1;
   
      RetValue = PP_ORDER_SINGLE_AIMS.updateInsertPP(PRODORDERID, HeatInfo.Plant, std::string(DEF_GC_PP_ORDER_SINGLE_AIMS::TREATMENTMODE), CDataConversion::LongToString(TreatmentMode), false, m_lastError);

      std::string Message = "USING TREATMENTMODE " + CDataConversion::LongToString(TreatmentMode);

      pEventLog->EL_DBWriteInfo(sMessage, DEF_GC_PP_ORDER_SINGLE_AIMS::TREATMENTMODE.c_str(), "PP_ORDER_SINGLE_AIMS", Message.c_str());
    }
  }
  return RetValue;
}

bool CDM_EAFDBManager::handleOrderScrap(sHeatInfo &HeatInfo, const std::string &OrderID, const std::string & ContainerType, bool commit)
{
  bool RetValue = true;
  bool done     = true;

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_EAFDBManager::HandleOrderScrap");

    return false;
  }

  std::string sContainerType  = CDataConversion::SetInvalidToDefault(ContainerType, DEF_GC_SCRAP_CONTAINER_TYPE::Basket);

  std::set<std::string> OrderIdList; 

  // return false if no OrderID
  if ( OrderID.empty() ||  OrderID == DEF::Inv_String || OrderID == CSMC_DBData::unspecString )
  {
    CPP_HEAT_PLANT        PP_HEAT_PLANT       (m_pDM_DBManagerTask->getStdConnection());
    CPP_HEAT              PP_HEAT             (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA         PD_HEAT_DATA        (m_pDM_DBManagerTask->getStdConnection());

    // ***************************************************************************************
    // select heats in production that need update
    // ***************************************************************************************
    if  ( PD_HEAT_DATA.selectCurrentHeat(HeatInfo.Plant) )
    {
      for( long i = 1 ; i <= PD_HEAT_DATA.getLastRow(); ++i )
      {
        if  ( PP_HEAT.select(PD_HEAT_DATA.getHEATID(i)) )
        {
          CPD_SCRAP_CONTAINER_ORDER PD_SCRAP_CONTAINER_ORDER(m_pDM_DBManagerTask->getStdConnection());

          std::string PRODORDERID = PP_HEAT.getPRODORDERID(1);

          if ( PD_SCRAP_CONTAINER_ORDER.selectByContainerTypeAndState(HeatInfo.Plant, PRODORDERID, CSMC_DBData::unspecString, DEF_GC_SCRAP_CONT_ORDER_STATUS::Planned) || 
              !PD_SCRAP_CONTAINER_ORDER.selectByContainerTypeAndState(HeatInfo.Plant, PRODORDERID, CSMC_DBData::unspecString, CSMC_DBData::unspecLong) )
          {
            log ("HEATID " + PD_HEAT_DATA.getHEATID(i) + " IS ANNOUNCED",3);
            log ("OrderID = " + PRODORDERID + ", FOUND = " + CDataConversion::LongToString(i), 1);

            OrderIdList.insert(PRODORDERID);
          }
        }// if  ( PP_HEAT.select(PD_HEAT_PLANT_REF.getHEATID(i)) )
      }// for( long i = 1 ; i <= PD_HEAT_PLANT_REF.getLastRow(); ++i )
    }// if  ( PD_HEAT_DATA.selectCurrentHeat(HeatInfo.Plant) )


    // *****************************************************************************************
    // select heats that are planned that need update
    // *****************************************************************************************
    if  ( PP_HEAT_PLANT.selectByPlanningState(HeatInfo.Plant, HeatInfo.PlantNo, 1) )
    {
      for( long i = 1 ; i <= PP_HEAT_PLANT.getLastRow(); ++i )
      {
        if  ( PP_HEAT.select(PP_HEAT_PLANT.getHEATID(i)) )
        {
          CPD_SCRAP_CONTAINER_ORDER PD_SCRAP_CONTAINER_ORDER(m_pDM_DBManagerTask->getStdConnection());

          std::string PRODORDERID = PP_HEAT.getPRODORDERID(1);

          if ( PD_SCRAP_CONTAINER_ORDER.selectByContainerTypeAndState(HeatInfo.Plant, PRODORDERID, CSMC_DBData::unspecString, DEF_GC_SCRAP_CONT_ORDER_STATUS::Planned) || 
              !PD_SCRAP_CONTAINER_ORDER.selectByContainerTypeAndState(HeatInfo.Plant, PRODORDERID, CSMC_DBData::unspecString, CSMC_DBData::unspecLong) )
          {
            log ("HEATID " + PD_HEAT_DATA.getHEATID(i) + " IS PLANNED",3);
            log ("OrderID = " + PRODORDERID + ", FOUND = " + CDataConversion::LongToString(i), 1);

            OrderIdList.insert(PRODORDERID);
          }
        }// f  ( PP_HEAT.select(PP_HEAT_PLANT.getHEATID(i)) )
      }// for( long i = 1 ; i <= PP_HEAT_PLANT.getLastRow(); ++i )
    }// if  ( PP_HEAT_PLANT.selectByPlanningState(Plant,PlantNo, 1, CSMC_DBData::unspecLong ) )
    else
    {
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_DBReadError(sMessage,"","PP_HEAT_PLANT","NO PLANNING DATA AVAILABLE");
    }
  }// if ( OrderID.empty() ||  OrderID == DEF::Inv_String || OrderID == CSMC_DBData::unspecString )
  else
  {
    OrderIdList.insert(OrderID);
  }

  if ( OrderIdList.size() == 0 )
  {
    log("Not valid OrderID!",1);
    setLastError("INVALID_PRODUCTION_ORDER", 1200, OrderID, 1);
  }

  //========================= read PP_ORDER_SINGLE_AIMS ======================================
  // 
  // read  treatment mode number, liquid addition fraction and heating mode number
  // to find correct loading instruction for baskets
  // 

  std::set<std::string>::iterator itOrderIdList;

  for( itOrderIdList = OrderIdList.begin() ; itOrderIdList != OrderIdList.end() ; ++itOrderIdList)
  {
    std::string PRODORDERID = *itOrderIdList;

    CPP_ORDER_SINGLE_AIMS PP_ORDER_SINGLE_AIMS(m_pDM_DBManagerTask->getStdConnection());

    long TreatmentMode  = CSMC_DBData::unspecLong;     // treatment mode to get loading instruction
    long LiqAddAmount   = CSMC_DBData::unspecLong;     // liquid addition fraction to get loading instruction
    long HeatingMode    = CSMC_DBData::unspecLong;     // heating mode to get loading instruction
    long Fraction       = 0;

    getTreatmentMode(HeatInfo, PRODORDERID, TreatmentMode);
    getLiqAddAmount(HeatInfo.Plant, PRODORDERID, LiqAddAmount, Fraction);

    if (TreatmentMode == CSMC_DBData::unspecLong)
    {
      std::string Message = PRODORDERID + " " + HeatInfo.Plant;
      log("TreatmentMode not set for " + Message, 1);

      setLastError("TREATMENT_MODE_NOT_SET_FOR_ORDER", 1200, Message, 1);
      RetValue = false;
    }

    if (LiqAddAmount == CSMC_DBData::unspecLong)
    {
      std::string Message = PRODORDERID + " " + HeatInfo.Plant;
      log("Liquid addition fraction not defined. 0 is taken for " + Message, 2);
      LiqAddAmount = 0; // set liquid addition fraction to zero
    }

    if (HeatingMode == CSMC_DBData::unspecLong)
    {
      std::string Message = PRODORDERID + " " + HeatInfo.Plant;
      log("Heating Mode is not defined. 0 is taken for " + Message, 2);
      HeatingMode = 0;
    }

    //========================= read practice number for scrap ================================
    long ProdPracScrap = CSMC_DBData::unspecLong;
    if ( RetValue )
    {
      // 
      // Try to read practice pointer for scrap by heat from PD_HEAT_DATA_PRODPRAC first
      // because it could be modified.
      // If in this table the entry does'n exist than the practice pointer will be read
      // by grade code from GT_GRADE_PRODPRAC
      //   
      if (!HeatInfo.HeatId.empty() && !HeatInfo.TreatId.empty())
      {
        CPD_HEAT_DATA_PRODPRAC PD_HEAT_DATA_PRODPRAC(m_pDM_DBManagerTask->getStdConnection());

        if (PD_HEAT_DATA_PRODPRAC.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, DEF_GC_PRODPRAC_DEF::Scrap))
        {
          ProdPracScrap = PD_HEAT_DATA_PRODPRAC.getPRODPRACID_MOD(1);
        }
      }

      std::string GradeCode; // for logging
      if (ProdPracScrap == CSMC_DBData::unspecLong)
      {
        CPP_ORDER PP_ORDER(m_pDM_DBManagerTask->getStdConnection());
        if (PP_ORDER.select(PRODORDERID))
        {
          GradeCode = PP_ORDER.getSTEELGRADECODE(1);

          CGT_GRADE_PRODPRAC GT_GRADE_PRODPRAC(m_pDM_DBManagerTask->getStdConnection());
          if (GT_GRADE_PRODPRAC.select(HeatInfo.Plant, HeatInfo.PlantNo, GradeCode, DEF_GC_PRODPRAC_DEF::Scrap, HeatingMode))
          {
            ProdPracScrap = GT_GRADE_PRODPRAC.getPRODPRAC_ID(1);
          }
          else
          {
            std::stringstream SearchKey;
            SearchKey << HeatInfo.Plant << " ," << HeatInfo.PlantNo << " ," << GradeCode << " ," << DEF_GC_PRODPRAC_DEF::Scrap << " ," << HeatingMode;
            CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
            sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
            pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"GT_GRADE_PRODPRAC");
          }
        }
      }

      if (ProdPracScrap == CSMC_DBData::unspecLong)
      {
        log("Scrap production practice pointer not set for steel grade " + GradeCode, 1);

        setLastError("NO_PRACTICE_POINTER_SCRAP", 1200, "Grade " + GradeCode, 1);
        RetValue = false;
      }
    }// if ( RetValue )

    //========================= read GTE_PP_SCRAP_BASKET ======================================
    std::map<long, std::vector<sMaterial>> LoadInstruction;
    std::map<long, std::vector<sMaterial>>::iterator iter;

    if ( RetValue )
    {
      // 
      // find correct Loading instruction for baskets
      // loading order is decided by TREATMENTPHASEORDER
      // 

      CGTE_PP_SCRAP_BASKET GTE_PP_SCRAP_BASKET(m_pDM_DBManagerTask->getStdConnection());
      CGT_TREATMODE_ENTRY GT_TREATMODE_ENTRY(m_pDM_DBManagerTask->getStdConnection());

      if (GTE_PP_SCRAP_BASKET.selectByNextLiqAdd(HeatInfo.Plant, HeatInfo.PlantNo, ProdPracScrap, TreatmentMode, LiqAddAmount, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, CSMC_DBData::unspecLong))
      {
        std::string ProcPhase;
        long ProcPhaseNo = 1;
        long instructionNo = -1;
        for (long row = 1; row <= GTE_PP_SCRAP_BASKET.getLastRow(); row++)
        {
          ProcPhase   = GTE_PP_SCRAP_BASKET.getPROCPHASE(row);
          ProcPhaseNo = GTE_PP_SCRAP_BASKET.getPROCPHASENO(row);

          if (ProcPhase.find("Bsk") != std::string::npos)
          {
            std::vector<sMaterial> Materials;
            long LoadingOrder = -1;
            // find out to which phase belongs 
            if (GT_TREATMODE_ENTRY.select(HeatInfo.Plant, HeatInfo.PlantNo, TreatmentMode, ProcPhase, ProcPhaseNo /*CSMC_DBData::unspecLong*/ ))
            {
              LoadingOrder = GT_TREATMODE_ENTRY.getTREATMENTPHASEORDER(1);
            }
            iter = LoadInstruction.find(LoadingOrder);
            if (iter == LoadInstruction.end())
            {
              LoadInstruction.insert(std::pair<long, std::vector<sMaterial>>(LoadingOrder, Materials));
              iter = LoadInstruction.find(LoadingOrder);
            }
            sMaterial MatInfo;
            MatInfo.MatCode   = GTE_PP_SCRAP_BASKET.getMAT_CODE(row).c_str();
            MatInfo.MatWeight = GTE_PP_SCRAP_BASKET.getMAT_WEIGHT(row);
            // 'long SourceNo' from sMaterial is used for LOADINGSEQUENCE
            MatInfo.SourceNo  = GTE_PP_SCRAP_BASKET.getLOADINGSEQUENCE(row);

            (iter->second).push_back(MatInfo);
          }
        }
      }
      else
      {
        std::stringstream SearchKey;
        SearchKey << HeatInfo.Plant << " ," << HeatInfo.PlantNo << " ," << ProdPracScrap << " ," << TreatmentMode << " ," << LiqAddAmount;
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"GTE_PP_SCRAP_BASKET");
      }

      if (LoadInstruction.empty())
      {
        setLastError("NO_SCRAP_LOADING_PRACTICE_DEFINED FOR TREATMENTMODE " + CDataConversion::LongToString(TreatmentMode), 1200, GTE_PP_SCRAP_BASKET.getActStatement(), 1);
        //RetValue = false;
      }
      else
      {
        // log available loading instruction
        std::stringstream LogLoadInstr;
        std::vector<sMaterial>::iterator mat_iter;
        for( iter = LoadInstruction.begin(); iter != LoadInstruction.end() ; ++ iter )
        {
          LogLoadInstr << "\nAvailable loading istruction '" << iter->first << "' ";
          //LogLoadInstr << "' Materials: ";
          for (mat_iter = iter->second.begin(); mat_iter != iter->second.end(); ++mat_iter)
          {
            LogLoadInstr << "| MAT_CODE "     << std::string(mat_iter->MatCode);
            LogLoadInstr << " MATWEIGHT "     << mat_iter->MatWeight;
            LogLoadInstr << " MATCHARGESEQ "  << mat_iter->SourceNo;
          }
        }
        log(LogLoadInstr.str(), 3);
      }
    }// if ( RetValue )

    //========================= write loading instruction  ======================================
    bool changed = false;
    if ( RetValue )
    {
      // 
      // store loading instruction for baskets in 
      // PD_SCRAP_CONTAINER_ORDER and PD_SCRAP_CONTAINER_ORDER_ENTRY
      // 
      // Not yet discharged loading instruction will be deleted
      // and new instruction will be written
      // 
      CPD_SCRAP_CONTAINER_ORDER PD_SCRAP_CONTAINER_ORDER(m_pDM_DBManagerTask->getStdConnection());
      CPD_SCRAP_CONTAINER_ORDER_ENTRY PD_SCRAP_CONTAINER_ORDER_ENTRY(m_pDM_DBManagerTask->getStdConnection());

      // delete not discharged loading instructions
      if (PD_SCRAP_CONTAINER_ORDER.select(HeatInfo.Plant, PRODORDERID, CSMC_DBData::unspecLong))
      {
        for (long l=1; l<= PD_SCRAP_CONTAINER_ORDER.getLastRow(); l++)
        {
          if ( DEF_GC_SCRAP_CONT_ORDER_STATUS::Planned == PD_SCRAP_CONTAINER_ORDER.getSTATUSNO(l) )
          {
            PD_SCRAP_CONTAINER_ORDER.cleanWhereStatement();

            PD_SCRAP_CONTAINER_ORDER.addWhereClause(CPD_SCRAP_CONTAINER_ORDER::PLANT, HeatInfo.Plant);
            PD_SCRAP_CONTAINER_ORDER.addWhereClause(CPD_SCRAP_CONTAINER_ORDER::PRODORDERID, PRODORDERID);
            PD_SCRAP_CONTAINER_ORDER.addWhereClause(CPD_SCRAP_CONTAINER_ORDER::CONTAINERINSEQ, PD_SCRAP_CONTAINER_ORDER.getCONTAINERINSEQ(l));

            done = done && PD_SCRAP_CONTAINER_ORDER.deleteRows();
            if (done)
            {
              changed = true;
            }
          }
        }
      }

      if (!done)
      {
        m_lastError = PD_SCRAP_CONTAINER_ORDER.getLastError();
        RetValue = false;
      }

      if ( RetValue )
      {
        // insert new only
        long CONTAINERINSEQ = 1;
        std::vector<sMaterial>::iterator mat_iter;
        for( iter = LoadInstruction.begin(); iter != LoadInstruction.end() ; ++ iter )
        {
          if (!PD_SCRAP_CONTAINER_ORDER.select(HeatInfo.Plant, PRODORDERID, CONTAINERINSEQ))
          {
            CDateTime Now;
            PD_SCRAP_CONTAINER_ORDER.setPLANT(HeatInfo.Plant);
            PD_SCRAP_CONTAINER_ORDER.setPRODORDERID(PRODORDERID);
            PD_SCRAP_CONTAINER_ORDER.setCONTAINERINSEQ(CONTAINERINSEQ);
            PD_SCRAP_CONTAINER_ORDER.setREVTIME(Now);
            PD_SCRAP_CONTAINER_ORDER.setSTATUSNO(DEF_GC_SCRAP_CONT_ORDER_STATUS::Planned);

            if ( !sContainerType.empty() && sContainerType != CSMC_DBData::unspecString )
            {
              PD_SCRAP_CONTAINER_ORDER.setCONTAINERTYPE(sContainerType);
            }

            done = done && PD_SCRAP_CONTAINER_ORDER.insert();
            for (mat_iter = iter->second.begin(); mat_iter != iter->second.end(); ++mat_iter)
            {
              PD_SCRAP_CONTAINER_ORDER_ENTRY.setPLANT(HeatInfo.Plant);
              PD_SCRAP_CONTAINER_ORDER_ENTRY.setPRODORDERID(PRODORDERID);
              PD_SCRAP_CONTAINER_ORDER_ENTRY.setCONTAINERINSEQ(CONTAINERINSEQ);
              PD_SCRAP_CONTAINER_ORDER_ENTRY.setRECIPENAME("Basket"+CDataConversion::LongToString(CONTAINERINSEQ));
              PD_SCRAP_CONTAINER_ORDER_ENTRY.setMAT_CODE(std::string(mat_iter->MatCode));
              PD_SCRAP_CONTAINER_ORDER_ENTRY.setMATWEIGHT(mat_iter->MatWeight);
              PD_SCRAP_CONTAINER_ORDER_ENTRY.setMATCHARGESEQ(mat_iter->SourceNo);

              done = done && PD_SCRAP_CONTAINER_ORDER_ENTRY.insert();
            }
          }
          else
          {
            PD_SCRAP_CONTAINER_ORDER.setCONTAINERLAST(CSMC_DBData::unspecLong);
            done = done && PD_SCRAP_CONTAINER_ORDER.update();
          }

          CONTAINERINSEQ ++; // increase for next charging sequence
        }

        CONTAINERINSEQ--;
        if ( PD_SCRAP_CONTAINER_ORDER.select(HeatInfo.Plant, PRODORDERID, CONTAINERINSEQ) )
        {
          PD_SCRAP_CONTAINER_ORDER.setCONTAINERLAST(1);

          done = done && PD_SCRAP_CONTAINER_ORDER.update();
        }

        if ( !RetValue && done && changed == false)
        {
          setLastError("MAX_LOADING_INSTRUCTIONS_REACHED", 1200, PRODORDERID + " " + HeatInfo.Plant);
        }
        else if (RetValue && !done)
        {
          setLastError("ERRROR_CREATE_LOADING_INSTRUCTIONS", 1200, PRODORDERID + " " + HeatInfo.Plant, 1);
          RetValue = false;
        }
      }// if ( RetValue )
    }// if ( RetValue )


    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);

    if (RetValue) // new loading instruction available
    {     
      pEventLog->EL_DBWriteInfo(sMessage,"PRODORDERID","PD_SCRAP_CONTAINER_ORDER",PRODORDERID.c_str());
    }
    else // any db operation was bad
    {
      pEventLog->EL_DBWriteError(sMessage,"PRODORDERID","PD_SCRAP_CONTAINER_ORDER",PRODORDERID.c_str());
    }

    if (commit)
    {
      if (RetValue) // new loading instruction available
      {     
        m_pDM_DBManagerTask->getStdConnection()->commit();
      }
      else
      {
        m_pDM_DBManagerTask->getStdConnection()->rollback();
      }
    }
  }//  for( itOrderIdList = OrderIdList.begin() ; itOrderIdList != OrderIdList.end() ; ++itOrderIdList)

  return RetValue;
}



bool CDM_EAFDBManager::handlePDETablesOnTappingEnd(CEventMessage& Event, double TappingMass, const std::string &OrderID, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_EAFDBManager::handlePDETablesOnTappingEnd",3);

  bool RetValue = true;

  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  CPDE_HEAT_DATA     PDE_HEAT_DATA     (m_pDM_DBManagerTask->getStdConnection());
  CPD_HEAT_DATA      PD_HEAT_DATA      (m_pDM_DBManagerTask->getStdConnection());
  CPD_HEAT_PLANT_REF PD_HEAT_PLANT_REF (m_pDM_DBManagerTask->getStdConnection());
  CHDE_HEAT_DATA     HDE_HEAT_DATA     (m_pDM_DBManagerTask->getStdConnection());

  if(PDE_HEAT_DATA.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant))
  {
    CPD_PLANTSTATUS_PLANT   PD_PLANTSTATUS_PLANT(m_pDM_DBManagerTask->getStdConnection());
    CPDE_CYCL_MEAS_DATA     PDE_CYCL_MEAS_DATA(m_pDM_DBManagerTask->getStdConnection());
    CPP_ORDER_SINGLE_AIMS   PP_ORDER_SINGLE_AIMS(m_pDM_DBManagerTask->getStdConnection());
    CPD_LADLE               PD_LADLE(m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA           PD_HEAT_DATA(m_pDM_DBManagerTask->getStdConnection());
    CEquipmentData          EquipmentData(m_pDM_DBManagerTask->getStdConnection());
    CGT_TREATMODE_ENTRY     GT_TREATMODE_ENTRY(m_pDM_DBManagerTask->getStdConnection());


    double TapToTapDur      = CSMC_DBData::unspecDouble;
    long TreatmentPosition  = getActTreatmentPosition(Event);

    double PowerOnDur   = PDE_HEAT_DATA.getPOWER_ON_DUR(1);

    CDateTime Now;

    if(PD_HEAT_DATA.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant) )
    {
      CDateTime LastTapTime = PD_HEAT_DATA.getHEATANNOUNCE_ACT(1);

      if ( PD_PLANTSTATUS_PLANT.select(HeatInfo.Plant, HeatInfo.PlantNo, TreatmentPosition, 3, DEF_GC_PLANTSTATUS::LASTTAPTIME) )
      {
        std::string Value =  PD_PLANTSTATUS_PLANT.getVALUE(1);

        if ( Value != CSMC_DBData::unspecString )
        {
          LastTapTime.fromDBString(Value); 
        }

        if ( PD_HEAT_DATA.getTREATEND_PREV(1) ==  CSMC_DBData::unspecDate )
        {
          PD_HEAT_DATA.setTREATEND_PREV(LastTapTime);
          PD_HEAT_DATA.update();
        }
      }
      CDeltaTime duration = CDateTime::subTimes(Now,LastTapTime);

      TapToTapDur = duration.asSeconds()/60;
    }// if(PD_HEAT_DATA.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant))

    RetValue = PD_PLANTSTATUS_PLANT.updateStatus(HeatInfo.Plant, HeatInfo.PlantNo, TreatmentPosition, 3, DEF_GC_PLANTSTATUS::LASTTAPTIME, Now.toDBString(), false, m_lastError);

    double PowerOffDur  = TapToTapDur - PowerOnDur;
    
    if ( PD_HEAT_PLANT_REF.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant) )
    {
      std::string HEATID_CUST  = PD_HEAT_PLANT_REF.getHEATID_CUST(1);
      std::string TREATID_CUST = PD_HEAT_PLANT_REF.getTREATID_CUST(1);

      if ( PD_PLANTSTATUS_PLANT.select(HeatInfo.Plant, HeatInfo.PlantNo, TreatmentPosition, 3, DEF_GC_PLANTSTATUS::TAPHEATID) )
      {
        std::string TAPHEATID =  PD_PLANTSTATUS_PLANT.getVALUE(1);

        // if the heatid are equal, tapping end come second time. the last tapping end signal win
        if ( HEATID_CUST == TAPHEATID)
        {
          // should be previous heat, take taptreatid TapToTapDur += PDE_HEAT_DATA.getTAPTOTAPDURATION(1);
        }
      }

      RetValue = PD_PLANTSTATUS_PLANT.updateStatus(HeatInfo.Plant, HeatInfo.PlantNo, TreatmentPosition, 3, DEF_GC_PLANTSTATUS::TAPHEATID,  HEATID_CUST, false, m_lastError);
      RetValue = PD_PLANTSTATUS_PLANT.updateStatus(HeatInfo.Plant, HeatInfo.PlantNo, TreatmentPosition, 3, DEF_GC_PLANTSTATUS::TAPTREATID, TREATID_CUST, false, m_lastError);
    }

    if ( PD_HEAT_DATA.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant) )
    {
      RetValue = PD_PLANTSTATUS_PLANT.updateStatus(HeatInfo.Plant, HeatInfo.PlantNo, TreatmentPosition, 1, DEF_GC_PLANTSTATUS::TAPLADLENO, CDataConversion::LongToString(PD_HEAT_DATA.getLADLENO(1)), false, m_lastError);
    }

    // we expect tha data stored und "parent" with Plant, and Plantno and respective equipment !
    long furnaceShellAge      = (long)EquipmentData.getEquipmentAge(HeatInfo.Plant, HeatInfo.PlantNo, DEF_GD_EQUIP_TYPE::UPP_SHELL  , DEF_GC_COUNTER_TYPE::HEATS);
         furnaceShellAge     += (long)EquipmentData.getEquipmentAge(HeatInfo.Plant, HeatInfo.PlantNo, DEF_GD_EQUIP_TYPE::LOW_SHELL  , DEF_GC_COUNTER_TYPE::HEATS);
    long furnaceTapholeAge    = (long)EquipmentData.getEquipmentAge(HeatInfo.Plant, HeatInfo.PlantNo, DEF_GD_EQUIP_TYPE::EBT        , DEF_GC_COUNTER_TYPE::HEATS);
    long furnaceRoofAge       = (long)EquipmentData.getEquipmentAge(HeatInfo.Plant, HeatInfo.PlantNo, DEF_GD_EQUIP_TYPE::ROOF       , DEF_GC_COUNTER_TYPE::HEATS);
    

    //furnaceDeltaAge = CDataConversion::SetInvalidToDefault(furnaceDeltaAge, 0);
    furnaceTapholeAge = CDataConversion::SetInvalidToDefault(furnaceTapholeAge, 0);
    furnaceShellAge = CDataConversion::SetInvalidToDefault(furnaceShellAge, 0);
    furnaceRoofAge = CDataConversion::SetInvalidToDefault(furnaceRoofAge, 0);
    //furnaceBottomAge = CDataConversion::SetInvalidToDefault(furnaceBottomAge, 0);

    //set equipment age data
    //PDE_HEAT_DATA.setFURNACE_DELTAAGE     (furnaceDeltaAge);
    PDE_HEAT_DATA.setFURNACE_TAPHOLEAGE   (furnaceTapholeAge);
    PDE_HEAT_DATA.setFURNACE_SHELLAGE     (furnaceShellAge);
    //PDE_HEAT_DATA.setFURNACE_SHELLWALLAGE (furnaceShellWallAge);
    PDE_HEAT_DATA.setFURNACE_ROOFAGE      (furnaceRoofAge);
    //PDE_HEAT_DATA.setFURNACE_BOTTOMAGE    (furnaceBottomAge);
    //PDE_HEAT_DATA.setFURNACE_BOTWALLAGE   (furnaceBottomWallAge);

    long TreatMentMode = 0;

    if ( getTreatmentMode(HeatInfo, OrderID, TreatMentMode) )
    {
      //in order to get no_of_basket
      if(GT_TREATMODE_ENTRY.selectbyPracPhase(HeatInfo.Plant, HeatInfo.PlantNo, TreatMentMode, "LastBsk"))
      {
        long nNoOfBasket = GT_TREATMODE_ENTRY.getTREATMENTPHASENO(1); 

        nNoOfBasket = CDataConversion::SetInvalidToDefault(nNoOfBasket, 0);
        PDE_HEAT_DATA.setNO_OF_BASKETS(nNoOfBasket);
      }
    }

    // get elec cons
    double ElecCons = PDE_CYCL_MEAS_DATA.getCurrentElectricalDataByHeat(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant);

    PDE_HEAT_DATA.setTOTAL_ELEC_EGY(ElecCons);

    if ( PowerOffDur > 0)
    {
      PDE_HEAT_DATA.setPOWER_OFF_DUR(PowerOffDur);
    }

    PDE_HEAT_DATA.setTAPTOTAPDURATION(TapToTapDur);
    RetValue = PDE_HEAT_DATA.update();
  }

  if(Commit)
  {
    if ( RetValue )
    {
      PDE_HEAT_DATA.commit();
    }
    else
    {
      PDE_HEAT_DATA.rollback();
    }
  }
  
  return RetValue;
}

bool CDM_EAFDBManager::handlePDETablesOnHeatEnd(CEventMessage& Event, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_EAFDBManager::handlePDETablesOnHeatEnd",3);

  bool RetValue = true;
  CPDE_HEAT_DATA          PDE_HEAT_DATA     (m_pDM_DBManagerTask->getStdConnection());
  
  sHeatInfo HeatInfo;
  setHeatInfo(Event, HeatInfo);

  if(PDE_HEAT_DATA.select(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant))
  {
    CPDE_HEAT_DATA_BURN     PDE_HEAT_DATA_BURN(m_pDM_DBManagerTask->getStdConnection());
    CPDE_HEAT_DATA_INJ      PDE_HEAT_DATA_INJ(m_pDM_DBManagerTask->getStdConnection());

    CGT_MAT_PURP            GT_MAT_PURP(m_pDM_DBManagerTask->getStdConnection());
    CEquipmentData          EquipmentData(m_pDM_DBManagerTask->getStdConnection());
    CPD_RECIPE              PD_RECIPE(m_pDM_DBManagerTask->getStdConnection());
    CPD_RECIPE_ENTRY        PD_RECIPE_ENTRY(m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_DATA_STIRR     PD_HEAT_DATA_STIRR(m_pDM_DBManagerTask->getStdConnection());

    long TreatmentPosition  = getActTreatmentPosition(Event);

    double    TappingMass = 0.;

    if (m_pDM_DBManagerTask->getpProductManagementInterface())
    {
      TappingMass = m_pDM_DBManagerTask->getpProductManagementInterface()->getDouble(HeatInfo.ProductId, DATA::TappingMass);
      TappingMass = CDataConversion::SetInvalidToDefault(TappingMass,0.);
    }
      //set gas consumption
    if(PDE_HEAT_DATA_BURN.selectBurnerConsDataByHeat(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant))
    {
      double dTotalO2Cons   = 0.;
      double dTotalGasCons  = 0.;

      for(long i=1; i <= PDE_HEAT_DATA_BURN.getLastRow(); i++)
      {
        double o2Cons           = PDE_HEAT_DATA_BURN.getO2_CONS(i);
        double gasCons          = PDE_HEAT_DATA_BURN.getGAS_CONS(i);
        //std::string burnerName  = PDE_HEAT_DATA_BURN.getBURNERNAME(i); //SARS

        //need to calculate the sum for all burners
        if ( o2Cons != CSMC_DBData::unspecDouble )
        {
          dTotalO2Cons  = dTotalO2Cons  + o2Cons;
        }

        if ( gasCons != CSMC_DBData::unspecDouble )
        {
          dTotalGasCons = dTotalGasCons + gasCons;
        }
      }

      dTotalGasCons = CDataConversion::SetInvalidToDefault(dTotalGasCons, 0.);
      dTotalO2Cons = CDataConversion::SetInvalidToDefault(dTotalO2Cons, 0.);

      PDE_HEAT_DATA.setBURNER_TOTALGAS(dTotalGasCons);
      PDE_HEAT_DATA.setBURNER_TOTALOXY(dTotalO2Cons);

      if (TappingMass > 0.)
      {
        PDE_HEAT_DATA.setSPECIFIC_O2_CONS(dTotalO2Cons/TappingMass);
      }
    }

    // select group by DEVICENAME
    if( PDE_HEAT_DATA_INJ.selectBurnerConsDataByHeat(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant))
    {
      long rowCount = PDE_HEAT_DATA_INJ.getLastRow();

      //******************************************************
      // CARBON
      //******************************************************
      double TotalCarbon  = 0;
      double TotalFeSi    = 0;
      double TotalOxygen  = 0;

      for (int j = 1; j <= rowCount; j++)
      {
        // calculate amount for carbon injection device only
        if ( PDE_HEAT_DATA_INJ.getDEVICENAME(j) == DEF_GCE_INJECTION::Carbon_Injector )
        {
          TotalCarbon = TotalCarbon + PDE_HEAT_DATA_INJ.getINJ_AMOUNT(j);
        }
        // calculate amount for Silicon injection device only
        if ( PDE_HEAT_DATA_INJ.getDEVICENAME(j) == DEF_GCE_INJECTION::Silicon_Injector )
        {
          TotalFeSi = TotalFeSi + PDE_HEAT_DATA_INJ.getINJ_AMOUNT(j);
        }
        // calculate amount for FeSi injection device only
        if ( PDE_HEAT_DATA_INJ.getDEVICENAME(j) == DEF_GCE_INJECTION::Oxygen_Injector_1 ||
             PDE_HEAT_DATA_INJ.getDEVICENAME(j) == DEF_GCE_INJECTION::Oxygen_Injector_2 )
        {
          TotalOxygen = TotalOxygen + PDE_HEAT_DATA_INJ.getINJ_AMOUNT(j);
        }
      }

      PDE_HEAT_DATA.setINJ_CARBON(TotalCarbon);
      PDE_HEAT_DATA.setINJ_FESI(TotalFeSi);
      PDE_HEAT_DATA.setINJ_OXYGEN(TotalOxygen);
     
      //******************************************************
    }

    //get AR and N2
    double ArCons = PD_HEAT_DATA_STIRR.getStirrConsDataByHeat(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, TreatmentPosition, CSMC_DBData::unspecString, 0, DEF_GC_STIRR_GAS_TYPE::Ar);
    double N2Cons = PD_HEAT_DATA_STIRR.getStirrConsDataByHeat(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, TreatmentPosition, CSMC_DBData::unspecString, 0, DEF_GC_STIRR_GAS_TYPE::N2);

    ArCons = CDataConversion::SetInvalidToDefault(ArCons, 0.);
    N2Cons = CDataConversion::SetInvalidToDefault(N2Cons, 0.);

    PDE_HEAT_DATA.setTOTAL_AR_MOMENT(ArCons);
    PDE_HEAT_DATA.setTOTAL_N2_MOMENT(N2Cons);

    if (TappingMass > 0.)
    {
      PDE_HEAT_DATA.setTAPMASS(CDataConversion::RoundToLong(TappingMass));
      PDE_HEAT_DATA.setSPECIFIC_AR_CONS(ArCons/TappingMass);
      PDE_HEAT_DATA.setSPECIFIC_N2_CONS(N2Cons/TappingMass);
    }
    else
    { 
      PDE_HEAT_DATA.setTAPMASS(0);
      PDE_HEAT_DATA.setSPECIFIC_AR_CONS(0.);
      PDE_HEAT_DATA.setSPECIFIC_N2_CONS(0.);
    }


    std::vector<std::string> SOURCE_LIST;
    SOURCE_LIST.push_back(DEF_GC_RECIPE_SOURCE::Bin);
    SOURCE_LIST.push_back(DEF_GC_RECIPE_SOURCE::Hand);
    SOURCE_LIST.push_back(DEF_GC_RECIPE_SOURCE::Wire);

    double furnaceAdditions   = PD_RECIPE.getMatWeightForChargeDest(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,HeatInfo.PlantNo,SOURCE_LIST, DEF_GC_CHARGE_DEST::Furnace);
    double furnaceSlagFormers = PD_RECIPE.getMatWeightForChargeDestAndPurpose(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,HeatInfo.PlantNo,SOURCE_LIST, DEF_GC_CHARGE_DEST::Furnace, DEF_GT_PURP::Report_SlagFormer );
    double ladleAdditions     = PD_RECIPE.getMatWeightForChargeDest(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,HeatInfo.PlantNo,SOURCE_LIST, DEF_GC_CHARGE_DEST::TapLadle);
    double ladleSlagFormers   = PD_RECIPE.getMatWeightForChargeDestAndPurpose(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,HeatInfo.PlantNo,SOURCE_LIST, DEF_GC_CHARGE_DEST::TapLadle, DEF_GT_PURP::Report_SlagFormer );

    std::vector<std::string> SOURCE_LIST_YARD;
    SOURCE_LIST.push_back(DEF_GC_RECIPE_SOURCE::Yard);

    double basketTotalWeight  = PD_RECIPE.getMatWeightForChargeDest(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,HeatInfo.PlantNo,SOURCE_LIST_YARD, DEF_GC_CHARGE_DEST::Furnace);

    std::vector<std::string> RelatedMatCodesDRICont = GT_MAT_PURP.getRelatedMatCodes(HeatInfo.Plant,HeatInfo.PlantNo,DEF_GT_PURP::DRICont);
    std::vector<std::string> RelatedMatCodesDynFeed = GT_MAT_PURP.getRelatedMatCodes(HeatInfo.Plant,HeatInfo.PlantNo,DEF_GT_PURP::DynFeed);

    double dDRI     = PD_RECIPE_ENTRY.getSumMatWeights(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,CSMC_DBData::unspecString,CSMC_DBData::unspecLong,CSMC_DBData::unspecString,DEF_GC_RECIPE_STATUS::Discharged, RelatedMatCodesDRICont) ;
    double dDOLOMIT = PD_RECIPE_ENTRY.getSumMatWeights(HeatInfo.HeatId,HeatInfo.TreatId,HeatInfo.Plant,CSMC_DBData::unspecString,CSMC_DBData::unspecLong,CSMC_DBData::unspecString,DEF_GC_RECIPE_STATUS::Discharged, RelatedMatCodesDynFeed) ;

    furnaceAdditions = CDataConversion::SetInvalidToDefault(furnaceAdditions, 0);
    furnaceSlagFormers = CDataConversion::SetInvalidToDefault(furnaceSlagFormers, 0);
    ladleAdditions = CDataConversion::SetInvalidToDefault(ladleAdditions, 0);
    ladleSlagFormers = CDataConversion::SetInvalidToDefault(ladleSlagFormers, 0);


    //set material consumption data
    PDE_HEAT_DATA.setFURNACE_ADDITIONS(furnaceAdditions);
    PDE_HEAT_DATA.setFURNACE_SLAGFORMER(furnaceSlagFormers);
    PDE_HEAT_DATA.setLADLE_ADDITIONS(ladleAdditions);
    PDE_HEAT_DATA.setLADLE_SLAGFORMER(ladleSlagFormers);
    PDE_HEAT_DATA.setBASKET_TOTALWEIGHT(basketTotalWeight);
    PDE_HEAT_DATA.setDRI(dDRI);
    PDE_HEAT_DATA.setDOLOMITE(dDOLOMIT);

    RetValue = PDE_HEAT_DATA.update();
  }
  
  return RetValue;
}

bool CDM_EAFDBManager::handlePDRecipeDataOnAnnounce(sHeatInfo &HeatInfo, const std::string &OrderID, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_EAFDBManager::handlePDRecipeDataOnAnnounce",3);

  return handlePDRecipeDataOnScrapContainerOnAnnounce(HeatInfo, OrderID, DEF_GC_SCRAP_CONTAINER_TYPE::Basket, UserCode, Commit);
}

bool CDM_EAFDBManager::handlePDRecipeDataOnAssignment(sHeatInfo &HeatInfo, const std::string &OrderID, long ContainerInSeq, long ContainerNo, long RecipeStatus, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_EAFDBManager::handlePDRecipeDataOnAssignment",3);

  return handlePDRecipeDataOnScrapContainerAssignment(HeatInfo, OrderID, DEF_GC_SCRAP_CONTAINER_TYPE::Basket, ContainerInSeq, ContainerNo, RecipeStatus, UserCode, Commit);
}

bool CDM_EAFDBManager::handlePDRecipeDataOnDeAssignment(sHeatInfo &HeatInfo, const std::string &OrderID, long ContainerInSeq, long ContainerNo, long RecipeStatus, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_EAFDBManager::handlePDRecipeDataOnDeAssignment",3);

  return handlePDRecipeDataOnScrapContainerDeAssignment(HeatInfo, OrderID, DEF_GC_SCRAP_CONTAINER_TYPE::Basket, ContainerInSeq, ContainerNo, RecipeStatus, UserCode, Commit);
}

bool CDM_EAFDBManager::handlePDRecipeDataOnDischarged(sHeatInfo &HeatInfo, const std::string &OrderID, long ContainerInSeq, long ContainerNo, const std::string &UserCode, bool Commit)
{
  log("++++++ CDM_EAFDBManager::handlePDRecipeDataOnDischarged",3);

  return handlePDRecipeDataOnScrapContainerDischarged(HeatInfo, OrderID, DEF_GC_SCRAP_CONTAINER_TYPE::Basket, ContainerInSeq, ContainerNo, UserCode, Commit);
}

//handle data in PD_ tables when Announcement occures
bool CDM_EAFDBManager::handlePDTablesOnAnnounce(sHeatInfo &HeatInfo, const std::string &Order, const std::string &SteelGradeCode, const std::string &UserCode, sPDData &PDData, long &SampleRef, long TreatmentPosition, bool Commit )
{
  bool RetValue = (m_pDM_DBManagerTask != NULL);
  if (RetValue)
  {
    CPD_SAMPLE_REF        PD_SAMPLE_REF       (m_pDM_DBManagerTask->getStdConnection());
    CPD_PLANTSTATUS       PD_PLANTSTATUS      (m_pDM_DBManagerTask->getStdConnection());
    CPD_PLANTSTATUS_PLANT PD_PLANTSTATUS_PLANT(m_pDM_DBManagerTask->getStdConnection());

    CPDE_HEAT_DATA        PDE_HEAT_DATA       (m_pDM_DBManagerTask->getStdConnection());
   
    //-> insert directly data into PD_HEAT_DATA...
    long SAMPLE_REF = CSMC_DBData::unspecLong; 
    RetValue = RetValue && CDM_DBManager::handlePDTablesOnAnnounce(HeatInfo, Order, SteelGradeCode, UserCode, PDData, SAMPLE_REF, TreatmentPosition, Commit);

    long SampleCounter = PD_SAMPLE_REF.getSampleCounter(SAMPLE_REF, DEF_GC_MEASUREMENT_TYPE::Steel);

    // Outgoing ladle
	  RetValue = RetValue && PD_PLANTSTATUS.doAnnouncement(HeatInfo.Plant,  HeatInfo.PlantNo, TreatmentPosition,  SampleCounter, 
                                                         HeatInfo.HeatId, HeatInfo.TreatId, m_HeatStatus.Announced, SteelGradeCode,  PDData.LadleNo, PDData.LadleType, 
                                                         PDData.Temp,     PDData.TempTime,  PDData.SteelMass,       PDData.SlagMass, Commit, m_lastError);
    
    std::string  FurnaceStatus = m_pDM_DBManagerTask->getpPlantManagementInterface()->getString(DEF_PLANT::Furnace, DATA::FurnaceStatus);

    // get furnace thermal status
    if ( FurnaceStatus == CSMC_DBData::unspecString )
    {
      if ( PD_PLANTSTATUS_PLANT.select(HeatInfo.Plant,HeatInfo.PlantNo,TreatmentPosition, 3, DEF_GC_PLANTSTATUS::THERMSTAT) )
      {
        FurnaceStatus = PD_PLANTSTATUS_PLANT.getVALUE(1);
      }
    }

    if ( FurnaceStatus == CSMC_DBData::unspecString )
    {
      FurnaceStatus == DEF_GC_THERM_STAT::M;

    }


    RetValue = RetValue && PDE_HEAT_DATA.doAnnouncement(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, FurnaceStatus, Commit, m_lastError);
    
    // that we have always scrap data
    RetValue = RetValue && handleOrderScrap(HeatInfo, Order, CSMC_DBData::unspecString, Commit);
    RetValue = RetValue && handlePDRecipeDataOnAnnounce(HeatInfo, Order, UserCode, Commit);
  }
  return RetValue;
}

bool CDM_EAFDBManager::handlePDTablesOnSetupOfHeat(sHeatInfo &HeatInfo, sPDData &PDData, long Status, const std::string &OrderID, const CDateTime &HeatStart, const CDateTime &HeatEnd, const std::string &SteelgradeCode, const std::string &UserCode, long TreatmentPosition, bool Commit )
{
  bool result = (m_pDM_DBManagerTask != NULL);

  if ( result )
  {
    //check if heat is planned and set outgoing parameter
    bool IsHeatPlanned      = isHeatPlanned(HeatInfo.HeatId);

    CPP_HEAT_PLANT    PP_HEAT_PLANT   (m_pDM_DBManagerTask->getStdConnection());
    CPDE_HEAT_DATA    PDE_HEAT_DATA   (m_pDM_DBManagerTask->getStdConnection());

    //select data from PP_HEAT_PLANT and check if heat is planned
    if (PP_HEAT_PLANT.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
    {
      long SampleRef = CSMC_DBData::unspecLong;

      result = result&& CDM_DBManager::handlePDTablesOnSetupOfHeat(IsHeatPlanned, HeatInfo, PDData, Status, OrderID, 
                                                                   HeatStart, HeatEnd, SteelgradeCode, UserCode, SampleRef, TreatmentPosition, false);

      if (IsHeatPlanned)
      {
        if ( Status >= m_HeatStatus.Announced )
        {
          std::string  FurnaceStatus = m_pDM_DBManagerTask->getpPlantManagementInterface()->getString(DEF_PLANT::Furnace, DATA::FurnaceStatus);

          result = result && PDE_HEAT_DATA.doAnnouncement(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant, HeatInfo.PlantNo, FurnaceStatus, Commit, m_lastError);
        }
      }// if (IsHeatPlanned) 

      if ( Status == m_HeatStatus.Tapping || Status == m_HeatStatus.Departure )
      {
        //Copy data into HD tables
        std::string SteelGradeCode = "";
        result = result && CDM_DBManager::copyHDTablesOnHeatEnd(HeatInfo, SteelGradeCode, CSMC_DBData::unspecLong, false);

        result = result && copyHDEHeatData(HeatInfo, false);
      }

    }// if (PP_HEAT_PLANT.select(HeatInfo.HeatId, HeatInfo.TreatId, HeatInfo.Plant))
    else
    {
      setLastError("NO_HEAT_DATA_FOUND", 0, PP_HEAT_PLANT.getActStatement(), 1); 
    }
  }

  return result;
}

void CDM_EAFDBManager::log(const std::string& _message, long _level)
{
  if (m_pDM_DBManagerTask)
    m_pDM_DBManagerTask->log(_message, _level);
}

bool CDM_EAFDBManager::setBasketData(CEventMessage& Event, long BasketInSeq, long BasketId, long BasketLocation, long RecipeStatus, seqBatch RecipeContent, bool commit)
{
  return setScrapContainerData(Event, DEF_GC_SCRAP_CONTAINER_TYPE::Basket, BasketInSeq, BasketId, BasketLocation, RecipeStatus, RecipeContent, commit);
}

long CDM_EAFDBManager::setHotMetalData(CEventMessage& Event, const long ChargeSeq, const long HMLadleNo, const std::string& HMLadleType, bool commit)
{
  long RetValue = 0;

  std::string DataKey   =  Event.getDataKey();
  std::string ProductID = Event.getProductID();
  std::string OrderID   = Event.getOrderID();
  std::string HeatID    = Event.getHeatID();
  std::string TreatID   = Event.getTreatID();
  std::string PlantID   = Event.getPlantID();
  std::string Plant;
  long PlantNo          = 1;
  bool done = true;

  std::stringstream Arg;
  Arg << "Argument list setHotMetalData: " << ChargeSeq << " " << HMLadleNo << " " << HMLadleType;
  log(Arg.str(), 3);

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_EAFDBManager::setHotMetalData");

    return false;
  }

  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  if (!m_pDM_DBManagerTask->getpDataInterface())
  {
    log("Not valid m_pDM_DBManagerTask->getpDataInterface",1);
    return -1;
  }
  // return false if no OrderID
  if (OrderID.empty() || 
      OrderID == DEF::Inv_String)
  {
    log("Not valid OrderID!",1);
    return -1;
  }
  if ( ChargeSeq == DEF::Inv_Long)
  {
    log("Not valid charging sequence!",1);
    return -1;
  }

  // =======================================================================================
  // 
  // Read received data about hot metal
  //   DATA::LadleLocation - actual position of the ladle
  //   DATA::LadleStatus - actual order status
  //   DATA::SteelMassAct - actual known hot metal weight
  //   DATA::SlagMassAct - actual known slag weight
  //   DATA::SteelMeasAnalysis - HM analysis
  //   DATA::DateTime - for temperature measurement
  //   DATA::MeasTemp - actual hot metal temperature
  //   DATA::UserCode - HMI user
  //
  // If hot metal counter in ladle exist this will be taken for hot metal order
  // If counter in ladle dosn't exist a new one will be created and set in order
  // 
  // =======================================================================================

  //============  read interface data ========================================

  long LadleLocation      = m_pDM_DBManagerTask->getpDataInterface()->getLong(DataKey, DATA::LadleLocation);
  long LadleStatus        = m_pDM_DBManagerTask->getpDataInterface()->getLong(DataKey, DATA::LadleStatus);
  double HotMetalMass     = m_pDM_DBManagerTask->getpDataInterface()->getDouble(DataKey, DATA::SteelMassAct);
  double HotMetalSlagMass = m_pDM_DBManagerTask->getpDataInterface()->getDouble(DataKey, DATA::SlagMassAct);
  seqAnalysis Analysis    = CIntfData::ToCORBAType(m_pDM_DBManagerTask->getpDataInterface()->getAnalysis(DataKey.c_str(), DATA::SteelMeasAnalysis));
  CDateTime TempMeasTime;
  TempMeasTime.SetTime(m_pDM_DBManagerTask->getpDataInterface()->getDate(DataKey.c_str(), DATA::TempMeasTime));
  double HotMetalTemp     = m_pDM_DBManagerTask->getpDataInterface()->getDouble(DataKey, DATA::MeasTemp);
  std::string UserCode    = m_pDM_DBManagerTask->getpDataInterface()->getString(DataKey, DATA::UserCode);
  std::string HMIClientId = m_pDM_DBManagerTask->getpDataInterface()->getString(Event.getDataKey(), DATA::HMIClientId);

  if ( !checkLadleData(HMLadleNo, HMLadleType, HMIClientId, "UNKNOWN_HOT_METAL_LADLE") )
  {
    log("Not valid ladle!",1);
    return -1;
  }


  //============ init data base classes ======================================

  CPD_HOT_METAL_ORDER PD_HOT_METAL_ORDER(m_pDM_DBManagerTask->getStdConnection());
  CPD_HOT_METAL PD_HOT_METAL(m_pDM_DBManagerTask->getStdConnection());
  CPD_LADLE PD_LADLE(m_pDM_DBManagerTask->getStdConnection());
  CPD_SAMPLE_REF PD_SAMPLE_REF(m_pDM_DBManagerTask->getStdConnection());


  //============  read counter from PD_LADLE =================================

  long HotMetalCounterLadle = CSMC_DBData::unspecLong;

  if (PD_LADLE.select(HMLadleNo, HMLadleType))
  {
    HotMetalCounterLadle = PD_LADLE.getHOTMETAL_CNT_ACT(1);
  }
  else
  {
    if ( checkLadleData(HMLadleNo, HMLadleType, HMIClientId, "UNKNOWN_HOT_METAL_LADLE") )
    {
      PD_LADLE.setLADLENO(HMLadleNo);
      PD_LADLE.setLADLETYPE(HMLadleType);
      PD_LADLE.setLADLEPOSID(DEF_GC_LADLE_POS::UNDEF);
      PD_LADLE.setSTATUSNO(DEF_GC_LADLE_STATUS::Available);   

      done = PD_LADLE.insert();
      if (!done)
      {
        std::stringstream SearchKey;
        SearchKey << HMLadleNo << " " << HMLadleType;
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PD_LADLE");
        return -1;
      }
    }
  }

  //============  create new counter if not available ===============================

  if (HotMetalCounterLadle == CSMC_DBData::unspecLong)
  {
    log("Create next hot metal counter for PD_HOT_METAL_ORDER and PD_LADLE",3);

    done = PD_HOT_METAL.getNextHOTMETAL_COUNTER(HotMetalCounterLadle, m_lastError);
    if (done)
    {
      PD_HOT_METAL.setHOTMETAL_COUNTER(HotMetalCounterLadle);
      done = PD_HOT_METAL.insert();
    }

    if (done && PD_LADLE.select(HMLadleNo, HMLadleType))
    {
      log("update hot metal counter in ladle",3);

      PD_LADLE.setHOTMETAL_CNT_ACT(HotMetalCounterLadle);
      done = done && PD_LADLE.update();
    }
  }

  //============ update counter in PD_HOT_METAL_ORDER =================================

  if (done && PD_HOT_METAL_ORDER.select(Plant, OrderID, ChargeSeq))
  {
    // take hot metal counter from ladle
    if (HotMetalCounterLadle != CSMC_DBData::unspecLong)
    {
      PD_HOT_METAL_ORDER.setHOTMETAL_COUNTER(HotMetalCounterLadle);

      done = done && PD_HOT_METAL_ORDER.update();
    }
  }// if (PD_HOT_METAL_ORDER.select(...
  else
  {
    log("Create new hot metal order",3);

    PD_HOT_METAL_ORDER.setPLANT(Plant);
    PD_HOT_METAL_ORDER.setPRODORDERID(OrderID);
    PD_HOT_METAL_ORDER.setHM_LADLE_IN_SEQ(ChargeSeq);
    PD_HOT_METAL_ORDER.setHOTMETAL_COUNTER(HotMetalCounterLadle);

    done = done && PD_HOT_METAL_ORDER.insert();
  }

  //============ update hot metal data =================================

  long SampleRef = -1;

  if (done && PD_HOT_METAL.select(HotMetalCounterLadle))
  {
    if ( checkLadleData(HMLadleNo, HMLadleType, HMIClientId, "UNKNOWN_HOT_METAL_LADLE") )
    {
      PD_HOT_METAL.setLADLENO(HMLadleNo);
      PD_HOT_METAL.setLADLETYPE(HMLadleType);
    }

    if (HotMetalMass != DEF::Inv_Double && HotMetalMass > 0)
    {
      PD_HOT_METAL.setWEIGHT(HotMetalMass);
    }
    if (HotMetalSlagMass != DEF::Inv_Double && HotMetalSlagMass > 0)
    {
      PD_HOT_METAL.setWEIGHT_SLAG(HotMetalSlagMass);
    }

    SampleRef = PD_HOT_METAL.getSAMPLE_REF(1);

    if (SampleRef == CSMC_DBData::unspecLong)
    {
      SampleRef = PD_SAMPLE_REF.insertNewSAMPLE_REF();
      PD_HOT_METAL.setSAMPLE_REF(SampleRef);
    }

    done = done && PD_HOT_METAL.update();
  }

  //=================== update analysis an temperature ================================

  if (done) // prepare samples
  {
    RetValue = HMLadleNo;

    sHeatInfo HeatInfo;
    setHeatInfo(Event, HeatInfo);

    long SampleCounter          = -1;	
    long SampleNo               = CSMC_DBData::unspecLong;
    long SampleMode             = CSMC_DBData::unspecLong;
    long SampleOrigin           = CSMC_DBData::unspecLong;
    std::string SampleLocation  = CSMC_DBData::unspecString;
    std::string SampleId        = CSMC_DBData::unspecString;
    std::string ProdOrderId     = CSMC_DBData::unspecString;
    CDateTime SampleTime;

   /* if (HotMetalTemp != DEF::Inv_Double && Analysis.length() > 0)
    {
      done = done && CDM_DBManager::addSampleAnalysisAndTemp(HeatInfo, HotMetalTemp, Analysis, HMLadleNo, HMLadleType, TempMeasTime, DEF_GC_MEASUREMENT_TYPE::HM, SampleNo, 
                                                             SampleMode, SampleOrigin, SampleLocation, SampleRef, SampleCounter, SampleId, ProdOrderId, true, UserCode, false);

      PD_SAMPLE_REF.updateSAMPLE_REF(SampleRef,SampleCounter,DEF_GC_MEASUREMENT_TYPE::Steel,false,m_lastError);
      PD_SAMPLE_REF.updateSAMPLE_REF(SampleRef,SampleCounter,DEF_GC_MEASUREMENT_TYPE::Temp,false,m_lastError);
    }
    else if (Analysis.length() > 0)
    {
      done = done && CDM_DBManager::addSampleAnalysis(HeatInfo, Analysis, HMLadleNo, HMLadleType, CDateTime(), DEF_GC_MEASUREMENT_TYPE::HM, SampleNo, SampleMode, SampleOrigin, SampleLocation, SampleRef, SampleCounter, SampleId, OrderID, true, UserCode, false);
      PD_SAMPLE_REF.updateSAMPLE_REF(SampleRef,SampleCounter,DEF_GC_MEASUREMENT_TYPE::Steel,false,m_lastError);
    }
    else if (HotMetalTemp != DEF::Inv_Double)
    {
      done = done && CDM_DBManager::addSampleValue(HeatInfo, HotMetalTemp, DEF_GC_MEASUREMENT_NAME::Temp, HMLadleNo, HMLadleType, CDateTime(), DEF_GC_MEASUREMENT_TYPE::Temp, SampleNo, SampleMode, SampleOrigin, SampleLocation, SampleRef, SampleCounter, SampleId, ProdOrderId, true, UserCode, false);
      PD_SAMPLE_REF.updateSAMPLE_REF(SampleRef,SampleCounter,DEF_GC_MEASUREMENT_TYPE::Temp,false,m_lastError);
    }*/

	if (Analysis.length() > 0)
    {
	  SampleCounter          = CSMC_DBData::unspecLong;
      done = done && CDM_DBManager::addSampleAnalysis(HeatInfo, Analysis, HMLadleNo, HMLadleType, CDateTime(), DEF_GC_MEASUREMENT_TYPE::HM, SampleNo, SampleMode, SampleOrigin, SampleLocation, SampleRef, SampleCounter, SampleId, OrderID, true, UserCode, false);
      PD_SAMPLE_REF.updateSAMPLE_REF(SampleRef,SampleCounter,DEF_GC_MEASUREMENT_TYPE::Steel,false,m_lastError);
    }
    if (HotMetalTemp != DEF::Inv_Double)
    {
	  SampleCounter          = CSMC_DBData::unspecLong;
      done = done && CDM_DBManager::addSampleValue(HeatInfo, HotMetalTemp, DEF_GC_MEASUREMENT_NAME::Temp, HMLadleNo, HMLadleType, CDateTime(), DEF_GC_MEASUREMENT_TYPE::Temp, SampleNo, SampleMode, SampleOrigin, SampleLocation, SampleRef, SampleCounter, SampleId, ProdOrderId, true, UserCode, false);
      PD_SAMPLE_REF.updateSAMPLE_REF(SampleRef,SampleCounter,DEF_GC_MEASUREMENT_TYPE::Temp,false,m_lastError);
    }


  }

  //=================== create liquid addition for model in PD_HEAT_DATA_LIQADD ======================
  // create or update liquid addition for model
  // only if ladle has content and heat is known
  if (done && !HeatID.empty() && !TreatID.empty())
  {
    long LiqAddNo = 1;

    CPD_HEAT_DATA_LIQADD PD_HEAT_DATA_LIQADD(m_pDM_DBManagerTask->getStdConnection());

		

    //if (PD_HEAT_DATA_LIQADD.selectHeatByLadle(HeatID, TreatID, Plant, HMLadleType, HMLadleNo, CSMC_DBData::unspecString))
    if (PD_HEAT_DATA_LIQADD.select(HeatID, TreatID, Plant, ChargeSeq)) //SARS
    {
      LiqAddNo = PD_HEAT_DATA_LIQADD.getLIQADDNO(1);

      if (PD_HOT_METAL.select(HotMetalCounterLadle))
      {
        PD_HEAT_DATA_LIQADD.setSTEELWEIGHT(PD_HOT_METAL.getWEIGHT(1));
        PD_HEAT_DATA_LIQADD.setSLAGWEIGHT(PD_HOT_METAL.getWEIGHT_SLAG(1));

        if (HMLadleType == DEF_GC_LADLE_TYPE::FeCrLadle)
        {
          PD_HEAT_DATA_LIQADD.setLIQADDTYPE(DEF_GC_LIQADD_TYPE::FeCr);
        }
        else
        {
          PD_HEAT_DATA_LIQADD.setLIQADDTYPE(DEF_GC_LIQADD_TYPE::HotMetal);
        }

        // check sample ref.
        // if sample ref does not exist create new
        // if sample ref exist make update
        long SampleRef = PD_HEAT_DATA_LIQADD.getSAMPLE_REF(1);

        if (SampleRef == CSMC_DBData::unspecLong)
        {
          SampleRef = PD_SAMPLE_REF.copyToNextSAMPLE_REF(PD_HOT_METAL.getSAMPLE_REF(1), false);

          if (SampleRef != CSMC_DBData::unspecLong)
          {
            PD_HEAT_DATA_LIQADD.setSAMPLE_REF(SampleRef);
          }
        }
        else
        {
          PD_SAMPLE_REF.copySampleRef(PD_HOT_METAL.getSAMPLE_REF(1),SampleRef,false, m_lastError);
        }

      }
      else
      {
        std::stringstream SearchKey;
        SearchKey << HotMetalCounterLadle;
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PD_HOT_METAL");

        //done = false;
      }

      done = done && PD_HEAT_DATA_LIQADD.update();
    }
    else if (PD_HEAT_DATA_LIQADD.getNextLiqAddNo(HeatID, TreatID, Plant, LiqAddNo, m_lastError))
    {
      PD_HEAT_DATA_LIQADD.setHEATID(HeatID);
      PD_HEAT_DATA_LIQADD.setTREATID(TreatID);
      PD_HEAT_DATA_LIQADD.setPLANT(Plant);
      PD_HEAT_DATA_LIQADD.setLIQADDNO(LiqAddNo);

      if ( checkLadleData(HMLadleNo, HMLadleType, HMIClientId, "UNKNOWN_HOT_METAL_LADLE") )
      {
        PD_HEAT_DATA_LIQADD.setLADLENO(HMLadleNo);
        PD_HEAT_DATA_LIQADD.setLADLETYPE(HMLadleType);
      }

      if (HMLadleType == DEF_GC_LADLE_TYPE::FeCrLadle)
      {
        PD_HEAT_DATA_LIQADD.setLIQADDTYPE(DEF_GC_LIQADD_TYPE::FeCr);
      }
      else
      {
        PD_HEAT_DATA_LIQADD.setLIQADDTYPE(DEF_GC_LIQADD_TYPE::HotMetal);
      }

      long NewSampleRef = CSMC_DBData::unspecLong;

      if (HotMetalCounterLadle != CSMC_DBData::unspecLong && PD_HOT_METAL.select(HotMetalCounterLadle))
      {
        PD_HEAT_DATA_LIQADD.setSTEELWEIGHT(PD_HOT_METAL.getWEIGHT(1));
        PD_HEAT_DATA_LIQADD.setSLAGWEIGHT(PD_HOT_METAL.getWEIGHT_SLAG(1));
				PD_HEAT_DATA_LIQADD.setHOTMETAL_CNT(HotMetalCounterLadle); //SARS

        // copy sample ref content to new
        NewSampleRef = PD_SAMPLE_REF.copyToNextSAMPLE_REF(PD_HOT_METAL.getSAMPLE_REF(1), false);
      }
      else
      {
        std::stringstream SearchKey;
        SearchKey << HotMetalCounterLadle;
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PD_HOT_METAL");

        //done = false;
        //RetValue = -1;
      }

      // in case of not existing sample ref
      PD_HEAT_DATA_LIQADD.setSAMPLE_REF(NewSampleRef);

      done = done && PD_HEAT_DATA_LIQADD.insert();
    }
  }
  else
  {
    log("condition not true 'if (done && !HeatID.empty() && !TreatID.empty())' to create liquid addition for model in PD_HEAT_DATA_LIQADD", 1);
  }

  // to be sure that in case of db error return value is not the ladle number
  if (!done && RetValue != -1)
    RetValue = 0;


  if (commit)
  {
    if (done)
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
      CDM_DBManager::handleInformation(Event, HMIClientId);
    }
    else
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback();
      CDM_DBManager::handleError(Event, HMIClientId);
    }
  }
  return RetValue;
}

bool CDM_EAFDBManager::evMaterialHandlingReport(CEventMessage& Event)
{
  log("++++++ CDM_EAFDBManager::evMaterialHandlingReport",3);

  sHeatInfo HeatInfo;
  setHeatInfo(Event,HeatInfo);

  // Unified exception handling *******************************************************
  std::string Scope("CDM_EAFDBManager::evMaterialHandlingReport");
  std::stringstream ExceptionMsg;
  ExceptionMsg << "Handling event: " << Event.getSender()
    << ", " << HeatInfo.ProductId << ", " << HeatInfo.HeatId
    << ", " << HeatInfo.TreatId   << ", " << Event.getDataKey();
  //***********************************************************************************

  bool RetValue = false;

  try
  {
    CSMC_DataProvider_Impl*               pDataInterface              = m_pDM_DBManagerTask->getpDataInterface();
    CDM_ProductManagementInterface_Impl*  pProductManagementInterface = m_pDM_DBManagerTask->getpProductManagementInterface();

    if ( m_pDM_DBManagerTask && 
         pDataInterface && 
         pProductManagementInterface
       )
    {
      std::string DataKey = Event.getDataKey();

      seqStirringData StirringAmount = CIntfData::ToCORBAType(pProductManagementInterface->getStirringData(HeatInfo.ProductId.c_str(),DATA::StirringAmount));
      CStirringDataHandler StirringDataHandler(StirringAmount);
      seqGasData SeqGasData = StirringDataHandler.getAccumulatedGasDataSeq(); // equals obsolete DEF_DEVICES::Total

      double ElecCons = pProductManagementInterface->getDouble(HeatInfo.ProductId.c_str(), DATA::ElecCons);

      sRecipeInfo RecipeInfo;
      seqBatch SeqBatch;

      RecipeInfo.RecipeName           = pDataInterface->getString(DataKey,DATA::RecipeName);
      RecipeInfo.RecipeSource         = pDataInterface->getString(DataKey,DATA::RecipeSource);
      RecipeInfo.RecipeStatus         = pDataInterface->getLong(DataKey,DATA::RecipeStatus);
      RecipeInfo.RecipeNo             = pDataInterface->getLong(DataKey,DATA::RecipeNo);
      RecipeInfo.RecipeTarget         = pDataInterface->getString(DataKey,DATA::RecipeTarget);
      RecipeInfo.DurSinceHeatAnnounce = pProductManagementInterface->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatAnnounce);
      RecipeInfo.DurSinceHeatStart    = pProductManagementInterface->getDouble(HeatInfo.ProductId, DATA::DurSinceHeatStart);

      SeqBatch = CIntfData::ToCORBAType(pDataInterface->getBatch(DataKey.c_str(),DATA::RecipeContent));
   
      RetValue = CDM_DBManager::handlePDTablesOnMaterialHandlingReport(HeatInfo, RecipeInfo, SeqBatch, SeqGasData, ElecCons, false );

      if (RetValue)
      {
        m_pDM_DBManagerTask->getStdConnection()->getpCBSConnection()->commit();
      }
      else
      {
        m_pDM_DBManagerTask->getStdConnection()->getpCBSConnection()->rollback();
        CDM_DBManager::handleError(Event);
      }
    }
  }
  catch (cCBS_DBExc &e)
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage, (e.getText()).c_str(),
      Scope.c_str(), ExceptionMsg.str().c_str()); 
    RetValue = false;
  }
  catch(CORBA::SystemException& sExc) 
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,sExc._name(),
      Scope.c_str(), ExceptionMsg.str().c_str());
    RetValue = false;
  }
  catch(CORBA::Exception& cExc) 
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,cExc._name(),
      Scope.c_str(), ExceptionMsg.str().c_str());
    RetValue = false;
  }
  catch(...)
  {
    std::string Msg("Unknown exception:");
    Msg += ExceptionMsg.str();

    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage, "",
      Scope.c_str(), Msg.c_str()); 
    RetValue = false;
  }

  return RetValue;
} // bool CDM_EAFDBManager::evMaterialHandlingReport(const CEventMessage& Event)

bool CDM_EAFDBManager::handlePDHeatStatusOnSetBasketData(CEventMessage& Event, long BasketInSeq, long BasketId, long BasketLocation, long RecipeStatus, bool commit)
{
  bool RetValue = true;

  log("++++++ CDM_EAFDBManager::handlePDHeatStatusOnSetBasketData",3);

  std::string ProductID = Event.getProductID();
  std::string OrderID   = Event.getOrderID();
  std::string PlantID   = Event.getPlantID(); 
  std::string DataKey   = Event.getDataKey();
  std::string Plant;
  long PlantNo          = 1;
  CDateTime Now;

  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_EAFDBManager::handlePDHeatStatusOnSetBasketData");

    return false;
  }

  // ****************************************
  // proceed only for valid order information
  // ****************************************
  if ( OrderID != DEF::Inv_String && !OrderID.empty() )
  {
    CPD_SCRAP_CONTAINER_ORDER PD_SCRAP_CONTAINER_ORDER(m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_REF        PD_HEAT_REF                   (m_pDM_DBManagerTask->getStdConnection());
    CPD_HEAT_PLANT_REF  PD_HEAT_PLANT_REF             (m_pDM_DBManagerTask->getStdConnection());

    CGC_HEAT_STATUS     GC_HEAT_STATUS                (m_pDM_DBManagerTask->getStdConnection());
    CPP_HEAT            PP_HEAT                       (m_pDM_DBManagerTask->getStdConnection());

    long Status = GC_HEAT_STATUS.getHeatStatusNo(DEF_GC_PLANT_DEF::L3, DEF_GC_HEAT_STATUS::Planned);

    if ( PD_SCRAP_CONTAINER_ORDER.isOrderInProcess(Plant, OrderID, m_lastError) )
    {
      Status = GC_HEAT_STATUS.getHeatStatusNo(DEF_GC_PLANT_DEF::YARD, DEF_GC_HEAT_STATUS::ScrapLoading);
    }

    if ( PP_HEAT.selectOrder(OrderID) )
    {
      std::string HEATID = PP_HEAT.getHEATID(1);

      // check in heat is already handled at plant
      // no status update for YARD after heat announcement at EAF!
      if ( !PD_HEAT_PLANT_REF.isHandledAtPlant(HEATID, Plant) )
      {
        RetValue = PD_HEAT_REF.switchHeatStatusNo(HEATID, Status, "", false, commit, m_lastError);

        if ( !RetValue )
        {
          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_ErrorHeatStatusChange(sMessage, HEATID.c_str(), "", Plant.c_str(), CDataConversion::LongToString(Status).c_str());
        }
      } // if ( !PD_HEAT_PLANT_REF.isHandledAtPlant(HEATID, Plant) )
    } // if ( PP_HEAT.selectOrder(OrderID) )
  } // if ( OrderID != DEF::Inv_String && !OrderID.empty() )

  checkLastError();

  return RetValue;
}

//SRKO: Added to handle PD_HEAT_DATA_LIQADD table after heat announcement.
bool CDM_EAFDBManager::handlePDLiqAdditionOnHeatAnnouncement(CEventMessage& Event, bool commit)
{
  bool RetValue = true;

  log("++++++ CDM_EAFDBManager::handlePDHeatStatusOnSetBasketData",3);

	//=================== create liquid addition for model in PD_HEAT_DATA_LIQADD ======================
  // create or update liquid addition for model

  std::string ProductID = Event.getProductID();
  std::string OrderID   = Event.getOrderID();
  std::string PlantID   = Event.getPlantID(); 
	std::string HeatID    = Event.getHeatID();
	std::string TreatID   = Event.getTreatID();
  std::string DataKey   = Event.getDataKey();
  std::string Plant;
  long PlantNo          = 1;
  CDateTime Now;

  CDM_DBManager::splitPlantPlantNo(PlantID, Plant, PlantNo);

  if (!m_pDM_DBManagerTask || !m_pDM_DBManagerTask->getStdConnection())
  {
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DatabaseConnectionError(sMessage,"","CDM_EAFDBManager::handlePDHeatStatusOnSetBasketData");

    return false;
  }


  CPD_HOT_METAL_ORDER PD_HOT_METAL_ORDER(m_pDM_DBManagerTask->getStdConnection());
  CPD_HOT_METAL PD_HOT_METAL(m_pDM_DBManagerTask->getStdConnection());
	CPD_HEAT_DATA_LIQADD PD_HEAT_DATA_LIQADD(m_pDM_DBManagerTask->getStdConnection());


	long HMLadleNo;
  std::string HMLadleType;
	long HotMetalCounterLadle;
	long dischargeSeq;


  if ( PD_HOT_METAL_ORDER.select(Plant, OrderID, CSMC_DBData::unspecLong))
  {
		for (int i=1; i<=PD_HOT_METAL_ORDER.getLastRow(); i++)
		{
			HotMetalCounterLadle=PD_HOT_METAL_ORDER.getHOTMETAL_COUNTER(i);
			dischargeSeq=PD_HOT_METAL_ORDER.getHM_LADLE_IN_SEQ(i);
			if ( PD_HOT_METAL.select(HotMetalCounterLadle) )
			{
				HMLadleNo=PD_HOT_METAL.getLADLENO(1);
				HMLadleType=PD_HOT_METAL.getLADLETYPE(1);

				if (PD_HEAT_DATA_LIQADD.select(HeatID, TreatID, Plant,dischargeSeq))
				{
					PD_HEAT_DATA_LIQADD.setLADLENO(PD_HOT_METAL.getLADLENO(1));
					PD_HEAT_DATA_LIQADD.setLADLETYPE(PD_HOT_METAL.getLADLETYPE(1));
					PD_HEAT_DATA_LIQADD.setSTEELWEIGHT(PD_HOT_METAL.getWEIGHT(1));
					PD_HEAT_DATA_LIQADD.setSLAGWEIGHT(PD_HOT_METAL.getWEIGHT_SLAG(1));
					PD_HEAT_DATA_LIQADD.setSAMPLE_REF(PD_HOT_METAL.getSAMPLE_REF(1));

					if (HMLadleType == DEF_GC_LADLE_TYPE::FeCrLadle)
					{
						PD_HEAT_DATA_LIQADD.setLIQADDTYPE(DEF_GC_LIQADD_TYPE::FeCr);
					}
					else
					{
						PD_HEAT_DATA_LIQADD.setLIQADDTYPE(DEF_GC_LIQADD_TYPE::HotMetal);
					}
					RetValue=RetValue && PD_HEAT_DATA_LIQADD.update();
				}
				else
				{
					PD_HEAT_DATA_LIQADD.setHEATID(HeatID);
					PD_HEAT_DATA_LIQADD.setTREATID(TreatID);
					PD_HEAT_DATA_LIQADD.setPLANT(Plant);
					PD_HEAT_DATA_LIQADD.setLIQADDNO(dischargeSeq);
					PD_HEAT_DATA_LIQADD.setLADLENO(PD_HOT_METAL.getLADLENO(1));
					PD_HEAT_DATA_LIQADD.setLADLETYPE(PD_HOT_METAL.getLADLETYPE(1));
					PD_HEAT_DATA_LIQADD.setSTEELWEIGHT(PD_HOT_METAL.getWEIGHT(1));
					PD_HEAT_DATA_LIQADD.setSLAGWEIGHT(PD_HOT_METAL.getWEIGHT_SLAG(1));
					PD_HEAT_DATA_LIQADD.setSAMPLE_REF(PD_HOT_METAL.getSAMPLE_REF(1));
					if (HMLadleType == DEF_GC_LADLE_TYPE::FeCrLadle)
					{
						PD_HEAT_DATA_LIQADD.setLIQADDTYPE(DEF_GC_LIQADD_TYPE::FeCr);
					}
					else
					{
						PD_HEAT_DATA_LIQADD.setLIQADDTYPE(DEF_GC_LIQADD_TYPE::HotMetal);
					}
					RetValue=RetValue && PD_HEAT_DATA_LIQADD.insert();
				}
			}		
		}  
  } 

  if (commit)
  {
    if (RetValue)
    {
      m_pDM_DBManagerTask->getStdConnection()->commit();
    }
    else
    {
      m_pDM_DBManagerTask->getStdConnection()->rollback();
    }
  }

  return RetValue;
}

