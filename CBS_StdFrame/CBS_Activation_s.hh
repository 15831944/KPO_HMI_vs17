// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __CBS__Activation_hh__
#define __CBS__Activation_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_CBS__Activation
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_CBS__Activation
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_CBS__Activation
#endif



#ifndef __CBS__Common_hh_EXTERNAL_GUARD__
#define __CBS__Common_hh_EXTERNAL_GUARD__
#include <CBS_Common_s.hh>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CBS_ExecEnv;

class CBS_ExecEnv_var;

class CBS_ExecEnv : public _CORBA_Unbounded_Sequence_String {
public:
  typedef CBS_ExecEnv_var _var_type;
  inline CBS_ExecEnv() {}
  inline CBS_ExecEnv(const CBS_ExecEnv& _s)
    : _CORBA_Unbounded_Sequence_String(_s) {}

  inline CBS_ExecEnv(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_String(_max) {}
  inline CBS_ExecEnv(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}



  inline CBS_ExecEnv& operator = (const CBS_ExecEnv& _s) {
    _CORBA_Unbounded_Sequence_String::operator=(_s);
    return *this;
  }
};

class CBS_ExecEnv_out;

class CBS_ExecEnv_var {
public:
  inline CBS_ExecEnv_var() : _pd_seq(0) {}
  inline CBS_ExecEnv_var(CBS_ExecEnv* _s) : _pd_seq(_s) {}
  inline CBS_ExecEnv_var(const CBS_ExecEnv_var& _s) {
    if (_s._pd_seq)  _pd_seq = new CBS_ExecEnv(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~CBS_ExecEnv_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline CBS_ExecEnv_var& operator = (CBS_ExecEnv* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline CBS_ExecEnv_var& operator = (const CBS_ExecEnv_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new CBS_ExecEnv;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline CBS_ExecEnv* operator -> () { return _pd_seq; }
  inline const CBS_ExecEnv* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator CBS_ExecEnv& () const { return *_pd_seq; }
#else
  inline operator const CBS_ExecEnv& () const { return *_pd_seq; }
  inline operator CBS_ExecEnv& () { return *_pd_seq; }
#endif
    
  inline const CBS_ExecEnv& in() const { return *_pd_seq; }
  inline CBS_ExecEnv&       inout()    { return *_pd_seq; }
  inline CBS_ExecEnv*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline CBS_ExecEnv* _retn() { CBS_ExecEnv* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class CBS_ExecEnv_out;
  
private:
  CBS_ExecEnv* _pd_seq;
};

class CBS_ExecEnv_out {
public:
  inline CBS_ExecEnv_out(CBS_ExecEnv*& _s) : _data(_s) { _data = 0; }
  inline CBS_ExecEnv_out(CBS_ExecEnv_var& _s)
    : _data(_s._pd_seq) { _s = (CBS_ExecEnv*) 0; }
  inline CBS_ExecEnv_out(const CBS_ExecEnv_out& _s) : _data(_s._data) {}
  inline CBS_ExecEnv_out& operator = (const CBS_ExecEnv_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline CBS_ExecEnv_out& operator = (CBS_ExecEnv* _s) {
    _data = _s;
    return *this;
  }
  inline operator CBS_ExecEnv*&()  { return _data; }
  inline CBS_ExecEnv*& ptr()       { return _data; }
  inline CBS_ExecEnv* operator->() { return _data; }

  inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  CBS_ExecEnv*& _data;

private:
  CBS_ExecEnv_out();
  CBS_ExecEnv_out& operator=(const CBS_ExecEnv_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CBS_ExecParameters;

class CBS_ExecParameters_var;

class CBS_ExecParameters : public _CORBA_Unbounded_Sequence_String {
public:
  typedef CBS_ExecParameters_var _var_type;
  inline CBS_ExecParameters() {}
  inline CBS_ExecParameters(const CBS_ExecParameters& _s)
    : _CORBA_Unbounded_Sequence_String(_s) {}

  inline CBS_ExecParameters(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_String(_max) {}
  inline CBS_ExecParameters(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}



  inline CBS_ExecParameters& operator = (const CBS_ExecParameters& _s) {
    _CORBA_Unbounded_Sequence_String::operator=(_s);
    return *this;
  }
};

class CBS_ExecParameters_out;

class CBS_ExecParameters_var {
public:
  inline CBS_ExecParameters_var() : _pd_seq(0) {}
  inline CBS_ExecParameters_var(CBS_ExecParameters* _s) : _pd_seq(_s) {}
  inline CBS_ExecParameters_var(const CBS_ExecParameters_var& _s) {
    if (_s._pd_seq)  _pd_seq = new CBS_ExecParameters(*_s._pd_seq);
    else             _pd_seq = 0;
  }
  inline ~CBS_ExecParameters_var() { if (_pd_seq)  delete _pd_seq; }
    
  inline CBS_ExecParameters_var& operator = (CBS_ExecParameters* _s) {
    if (_pd_seq)  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline CBS_ExecParameters_var& operator = (const CBS_ExecParameters_var& _s) {
    if (&_s != this) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new CBS_ExecParameters;
        *_pd_seq = *_s._pd_seq;
      }
      else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
    }
    return *this;
  }
  inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline CBS_ExecParameters* operator -> () { return _pd_seq; }
  inline const CBS_ExecParameters* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator CBS_ExecParameters& () const { return *_pd_seq; }
#else
  inline operator const CBS_ExecParameters& () const { return *_pd_seq; }
  inline operator CBS_ExecParameters& () { return *_pd_seq; }
#endif
    
  inline const CBS_ExecParameters& in() const { return *_pd_seq; }
  inline CBS_ExecParameters&       inout()    { return *_pd_seq; }
  inline CBS_ExecParameters*&      out() {
    if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline CBS_ExecParameters* _retn() { CBS_ExecParameters* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class CBS_ExecParameters_out;
  
private:
  CBS_ExecParameters* _pd_seq;
};

class CBS_ExecParameters_out {
public:
  inline CBS_ExecParameters_out(CBS_ExecParameters*& _s) : _data(_s) { _data = 0; }
  inline CBS_ExecParameters_out(CBS_ExecParameters_var& _s)
    : _data(_s._pd_seq) { _s = (CBS_ExecParameters*) 0; }
  inline CBS_ExecParameters_out(const CBS_ExecParameters_out& _s) : _data(_s._data) {}
  inline CBS_ExecParameters_out& operator = (const CBS_ExecParameters_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline CBS_ExecParameters_out& operator = (CBS_ExecParameters* _s) {
    _data = _s;
    return *this;
  }
  inline operator CBS_ExecParameters*&()  { return _data; }
  inline CBS_ExecParameters*& ptr()       { return _data; }
  inline CBS_ExecParameters* operator->() { return _data; }

  inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  CBS_ExecParameters*& _data;

private:
  CBS_ExecParameters_out();
  CBS_ExecParameters_out& operator=(const CBS_ExecParameters_var&);
};

struct CBS_ActivationParam {
  typedef _CORBA_ConstrType_Variable_Var<CBS_ActivationParam> _var_type;

  
  ::CORBA::String_member executable;

  CBS_ExecParameters parameters;

  ::CORBA::String_member hostName;

  CBS_ExecEnv environment;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef CBS_ActivationParam::_var_type CBS_ActivationParam_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< CBS_ActivationParam,CBS_ActivationParam_var > CBS_ActivationParam_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CBS_ActivationParam;

struct CBS_MonitoringParam {
  typedef _CORBA_ConstrType_Fix_Var<CBS_MonitoringParam> _var_type;

  
  ::CORBA::ULong numRestartAttempts;

  ::CORBA::ULong restartInterval;

  ::CORBA::ULong startLevel;

  ::CORBA::ULong restartCycle;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef CBS_MonitoringParam::_var_type CBS_MonitoringParam_var;

typedef CBS_MonitoringParam& CBS_MonitoringParam_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CBS_MonitoringParam;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CBS_ProcessId;

typedef ::CORBA::Long CBS_ProcessId;
typedef ::CORBA::Long_out CBS_ProcessId_out;

#ifndef __iCBS__ActivableServer__
#define __iCBS__ActivableServer__
class iCBS_ActivableServer;
class _objref_iCBS_ActivableServer;
class _impl_iCBS_ActivableServer;

typedef _objref_iCBS_ActivableServer* iCBS_ActivableServer_ptr;
typedef iCBS_ActivableServer_ptr iCBS_ActivableServerRef;

class iCBS_ActivableServer_Helper {
public:
  typedef iCBS_ActivableServer_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_iCBS_ActivableServer, iCBS_ActivableServer_Helper> iCBS_ActivableServer_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_iCBS_ActivableServer,iCBS_ActivableServer_Helper > iCBS_ActivableServer_out;

#endif

// interface iCBS_ActivableServer
class iCBS_ActivableServer {
public:
  // Declarations for this interface type.
  typedef iCBS_ActivableServer_ptr _ptr_type;
  typedef iCBS_ActivableServer_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static inline _ptr_type _fromObjRef(omniObjRef* o) {
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_iCBS_ActivableServer :
  public virtual ::CORBA::Object,
  public virtual omniObjRef
{
public:
  // IDL operations
  CBS_MonitoringParam monitoringParam();
  void monitoringParam(const ::CBS_MonitoringParam& _v);
  CBS_ActivationParam* activationParam();
  void activationParam(const ::CBS_ActivationParam& _v);
  char* serverName();
  ::CORBA::Boolean actRegister();
  ::CORBA::Boolean isRegistered(::CORBA::Boolean& isReg);
  ::CORBA::Boolean actUnregister();
  CBS_ProcessId start();
  CBS_ProcessId ping(::CORBA::String_out hostname);
  void stop();
  char* compName();

  // Constructors
  inline _objref_iCBS_ActivableServer()  { _PR_setobj(0); }  // nil
  _objref_iCBS_ActivableServer(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_iCBS_ActivableServer();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_iCBS_ActivableServer(const _objref_iCBS_ActivableServer&);
  _objref_iCBS_ActivableServer& operator = (const _objref_iCBS_ActivableServer&);
  // not implemented

  friend class iCBS_ActivableServer;
};

class _pof_iCBS_ActivableServer : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_iCBS_ActivableServer() : _OMNI_NS(proxyObjectFactory)(iCBS_ActivableServer::_PD_repoId) {}
  virtual ~_pof_iCBS_ActivableServer();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_iCBS_ActivableServer :
  public virtual omniServant
{
public:
  virtual ~_impl_iCBS_ActivableServer();

  virtual CBS_MonitoringParam monitoringParam() = 0;
  virtual void monitoringParam(const ::CBS_MonitoringParam& _v) = 0;
  virtual CBS_ActivationParam* activationParam() = 0;
  virtual void activationParam(const ::CBS_ActivationParam& _v) = 0;
  virtual char* serverName() = 0;
  virtual ::CORBA::Boolean actRegister() = 0;
  virtual ::CORBA::Boolean isRegistered(::CORBA::Boolean& isReg) = 0;
  virtual ::CORBA::Boolean actUnregister() = 0;
  virtual CBS_ProcessId start() = 0;
  virtual CBS_ProcessId ping(::CORBA::String_out hostname) = 0;
  virtual void stop() = 0;
  virtual char* compName() = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_iCBS_ActivableServer;



class POA_iCBS_ActivableServer :
  public virtual _impl_iCBS_ActivableServer,
  public virtual ::PortableServer::ServantBase
{
public:
  virtual ~POA_iCBS_ActivableServer();

  inline ::iCBS_ActivableServer_ptr _this() {
    return (::iCBS_ActivableServer_ptr) _do_this(::iCBS_ActivableServer::_PD_repoId);
  }
};







#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const CBS_ExecEnv& _s);
void operator<<=(::CORBA::Any& _a, CBS_ExecEnv* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CBS_ExecEnv*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CBS_ExecEnv*& _sp);

void operator<<=(::CORBA::Any& _a, const CBS_ExecParameters& _s);
void operator<<=(::CORBA::Any& _a, CBS_ExecParameters* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CBS_ExecParameters*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CBS_ExecParameters*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CBS_ActivationParam& _s);
extern void operator<<=(::CORBA::Any& _a, CBS_ActivationParam* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CBS_ActivationParam*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CBS_ActivationParam*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CBS_MonitoringParam& _s);
extern void operator<<=(::CORBA::Any& _a, CBS_MonitoringParam* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CBS_MonitoringParam*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CBS_MonitoringParam*& _sp);

void operator<<=(::CORBA::Any& _a, iCBS_ActivableServer_ptr _s);
void operator<<=(::CORBA::Any& _a, iCBS_ActivableServer_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, iCBS_ActivableServer_ptr& _s);



inline void
iCBS_ActivableServer::_marshalObjRef(::iCBS_ActivableServer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}



#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_CBS__Activation
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_CBS__Activation
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_CBS__Activation
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_CBS__Activation
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_CBS__Activation
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_CBS__Activation
#endif

#endif  // __CBS__Activation_hh__

