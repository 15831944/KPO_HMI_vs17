//## Copyright (C) 2009 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 

#if defined (_MSC_VER) && (_MSC_VER >= 1000)
#pragma once
#endif
#ifndef _INC_CPD_HEAT_PLANT_REF_INCLUDED
#define _INC_CPD_HEAT_PLANT_REF_INCLUDED

#include "CSMC_DBData.h"

class CPP_HEAT_PLANT;

class CPD_HEAT_PLANT_REF
: public CSMC_DBData
{

public:
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string HEATID;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string TREATID;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string PLANT;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string PLANTNO;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string STATUSNO;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string HEATID_CUST;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string TREATID_CUST;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string EXPIRATIONDATE;

  //##DBClassCodeUtility ! DO NOT EDIT !
  CPD_HEAT_PLANT_REF(cCBS_StdConnection* Connection);

  //##DBClassCodeUtility ! DO NOT EDIT !
  CPD_HEAT_PLANT_REF(cCBS_Connection* Connection);

  //##DBClassCodeUtility ! DO NOT EDIT !
  CPD_HEAT_PLANT_REF();

  //##DBClassCodeUtility ! DO NOT EDIT !
  ~CPD_HEAT_PLANT_REF();

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Internal heat identifier
  std::string getHEATID(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setHEATID(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Treatment identifier
  std::string getTREATID(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setTREATID(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Plant identifier
  std::string getPLANT(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setPLANT(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Plant number
  long getPLANTNO(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setPLANTNO(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##All major and minor heat status relevant for the buttons in the HMI are maintained in this table
  long getSTATUSNO(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setSTATUSNO(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##The customer representation of the HeatID
  std::string getHEATID_CUST(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setHEATID_CUST(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Customer TreaID
  std::string getTREATID_CUST(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setTREATID_CUST(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  CDateTime getEXPIRATIONDATE(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setEXPIRATIONDATE(const CDateTime& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  bool select(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT);

  //## ----------------------------------END-GENERATED-CODE--------------------- 

  //## ----------------------------------YOUR-CODE------------------------------ 

  bool selectByCustHeatData(const std::string& HEATID_CUST, const std::string& TREATID_CUST, const std::string& PLANT, bool ASC = true);

  bool selectByEXPIRATIONDATE(const CDateTime& EXPIRATIONDATE, const std::string& Operator);

  bool selectByHEATID_CUST(const std::string& HEATID_CUST, const std::string& PLANT);

  bool selectDataByExpirationDate(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, bool ASC = true);

  //This function should be used instead of selectByCustHeatData to get the maximum counter 
  //as the customer heat ID can be reset at new year and can be alphanumeric where the normal ordering my fail.
  //Get the maximum counter from the database.
  //As parameters we need the start and end place in the string of the counter,
  //the start and end place of the year and the year this should be equal to,
  //the same for shop, plant, unit, default.
  //Note: As the year can be set arbitrarily to avoid random setting at new year we can in general not use the planned times.
  //To order the counters we need a list of characters that will be used in non numerical counters
  //to handle the overflow in the order that they will be used.
  //E.g. 999 -> X01, X99 -> Y01 than the list should contain X,Y
  //The string starts counting at 1. We will use ORACLE specific functions in the implementation.
  //If either Start=End or the string = CSMC_DBData:unspecString we will ignore that part
  //Consider only valid heats, where the EXPIRATIONDATE is valid, because for heats that are canceled we can 
  //assign the customer heat ID to another HEATID, as there can be several cancels at once we can not just check 
  //the last counter. Beware the cancel in the middle. This one is not solved. 
  //To allow for old data to have the same customer heat ID check only heats starting from Since to now.
  //Set to CSMC_DBData::unspecDate to check all data.
  bool selectOrderedByCounter(long CounterStartPosition, long CounterEndPosition,
                              long YearStartPosition, long YearEndPosition, const std::string& Year,
                              long ShopStartPosition, long ShopEndPosition, const std::string& Shop,
                              long PlantStartPosition, long PlantEndPosition, const std::string& Plant,
                              long UnitStartPosition, long UnitEndPosition, const std::string& Unit,
                              long DefaultStartPosition, long DefaultEndPosition, const std::string& Default,
                              std::vector<std::string> HeatCounterPrefixes, const CDateTime Since, bool ASC);

  bool selectOrderedByMaxTreatID(const std::string& HEATID, const std::string& PLANT);

  bool selectValidCustData(const std::string& HEATID_CUST, const std::string& TREATID_CUST, const std::string& PLANT, bool ASC = true);

  bool selectValidCustDataInProduction(const std::string& HEATID_CUST, const std::string& TREATID_CUST, const std::string& PLANT, long PLANTNO, bool ASC /* = true */);

  bool selectValidData(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, bool ASC = true );

  bool doCancelHeat(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, bool Commit, cCBS_ODBC_DBError &Error);

  virtual void doOnConstruct();

  virtual void doOnDestruct();

  bool exists(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT);

  bool exists(const std::string& HEATID_CUST);

  bool exists(const std::string& HEATID_CUST, const CDateTime Since, bool ValidOnly);

  bool getCustData(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, std::string& HEATID_CUST, std::string& TREATID_CUST);

  CDateTime getFirstStartTimeByCustomerHeatID(const std::string& HEATID_CUST, const CDateTime Since, bool ASC);

  std::string getLastProducedHeatIdCust(const std::string& PLANT, long PLANTNO);

  long getStatusNo(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT);

  std::string getValidTreatId(const std::string& HEATID, const std::string& PLANT);

  bool isHandledAtPlant(const std::string& HEATID, const std::string& PLANT);

  bool isHandledAtPlant(const std::string& HEATID, const std::string& PLANT, std::vector<long> PlantRelatedStates);

  bool setStatus(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long STATUSNO, bool checkGreater, bool Commit, cCBS_ODBC_DBError &Error);

  bool setStatus(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& HEATSTATUS, bool Commit, cCBS_ODBC_DBError &Error);

  bool setStatus(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& HEATSTATUS, bool checkGreater, bool Commit, cCBS_ODBC_DBError &Error);

  bool write(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& HEATSTATUS, bool Commit, cCBS_ODBC_DBError &Error);

  bool write(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long STATUSNO, bool Commit, cCBS_ODBC_DBError &Error);

  CPP_HEAT_PLANT* m_pPP_HEAT_PLANT;
};

#endif /* _INC_CPD_HEAT_PLANT_REF_INCLUDED */
