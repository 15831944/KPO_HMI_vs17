//## Copyright (C) 2009 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 

#include "cCBS_StdEventLogFrameController.h"

#include "CPD_HEAT_DATA.h"
#include "CHD_HEAT_DATA.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::HEATID("HEATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::TREATID("TREATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::PLANT("PLANT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::STEELGRADECODE_PLAN("STEELGRADECODE_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::STEELGRADECODE_ACT("STEELGRADECODE_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::PRODORDERID_PLAN("PRODORDERID_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::PRODORDERID_ACT("PRODORDERID_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::AIMSTEELWGT_PLAN("AIMSTEELWGT_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::AIMSTEELWGT_MOD("AIMSTEELWGT_MOD");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::AIMTEMP_PLAN("AIMTEMP_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::AIMTEMP_MOD("AIMTEMP_MOD");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::HEATANNOUNCE_OFFLINE("HEATANNOUNCE_OFFLINE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::HEATANNOUNCE_ACT("HEATANNOUNCE_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::TREATSTART_PLAN("TREATSTART_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::TREATSTART_MOD("TREATSTART_MOD");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::TREATSTART_ACT("TREATSTART_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::TREATEND_PLAN("TREATEND_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::TREATEND_MOD("TREATEND_MOD");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::TREATEND_CALC("TREATEND_CALC");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::TREATEND_ACT("TREATEND_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::HEATDEPARTURE_ACT("HEATDEPARTURE_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::TREATEND_PREV("TREATEND_PREV");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::LADLETYPE("LADLETYPE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::LADLENO("LADLENO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::STEELMASS("STEELMASS");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::SLAGMASS("SLAGMASS");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::SAMPLE_REF("SAMPLE_REF");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::REVTIME("REVTIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::USERCODE("USERCODE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::TEMP_SAMPLES("TEMP_SAMPLES");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::STEEL_SAMPLES("STEEL_SAMPLES");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::SLAG_SAMPLES("SLAG_SAMPLES");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::STEELMASS_START("STEELMASS_START");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::SLAGMASS_START("SLAGMASS_START");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::ROUTECODE_PLAN("ROUTECODE_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::ROUTECODE_ACT("ROUTECODE_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::TREATMENTDURATION("TREATMENTDURATION");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::FINALTEMP("FINALTEMP");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::SHIFT_ID("SHIFT_ID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::CREW_ID("CREW_ID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::CREW_RESPONSIBILITY("CREW_RESPONSIBILITY");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::HEAT_RESPONSIBILITY("HEAT_RESPONSIBILITY");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_HEAT_DATA::COMMENTS("COMMENTS");

//##DBClassCodeUtility ! DO NOT EDIT !
CHD_HEAT_DATA::CHD_HEAT_DATA(cCBS_StdConnection* Connection)
:CSMC_DBData("HD_HEAT_DATA",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CHD_HEAT_DATA::CHD_HEAT_DATA(cCBS_Connection* Connection)
:CSMC_DBData("HD_HEAT_DATA",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CHD_HEAT_DATA::CHD_HEAT_DATA()
:CSMC_DBData("HD_HEAT_DATA")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CHD_HEAT_DATA::~CHD_HEAT_DATA()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Internal heat identifier
std::string CHD_HEAT_DATA::getHEATID(long Row)
{
  return getString(CHD_HEAT_DATA::HEATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setHEATID(const std::string& value)
{
  setString(CHD_HEAT_DATA::HEATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment identifier
std::string CHD_HEAT_DATA::getTREATID(long Row)
{
  return getString(CHD_HEAT_DATA::TREATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setTREATID(const std::string& value)
{
  setString(CHD_HEAT_DATA::TREATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant identifier
std::string CHD_HEAT_DATA::getPLANT(long Row)
{
  return getString(CHD_HEAT_DATA::PLANT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setPLANT(const std::string& value)
{
  setString(CHD_HEAT_DATA::PLANT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Planned steel grade code
std::string CHD_HEAT_DATA::getSTEELGRADECODE_PLAN(long Row)
{
  return getString(CHD_HEAT_DATA::STEELGRADECODE_PLAN, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setSTEELGRADECODE_PLAN(const std::string& value)
{
  setString(CHD_HEAT_DATA::STEELGRADECODE_PLAN, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Actual Steel grade code
std::string CHD_HEAT_DATA::getSTEELGRADECODE_ACT(long Row)
{
  return getString(CHD_HEAT_DATA::STEELGRADECODE_ACT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setSTEELGRADECODE_ACT(const std::string& value)
{
  setString(CHD_HEAT_DATA::STEELGRADECODE_ACT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##From PP_ORDER as planned
std::string CHD_HEAT_DATA::getPRODORDERID_PLAN(long Row)
{
  return getString(CHD_HEAT_DATA::PRODORDERID_PLAN, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setPRODORDERID_PLAN(const std::string& value)
{
  setString(CHD_HEAT_DATA::PRODORDERID_PLAN, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##From PP_ORDER but modified
std::string CHD_HEAT_DATA::getPRODORDERID_ACT(long Row)
{
  return getString(CHD_HEAT_DATA::PRODORDERID_ACT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setPRODORDERID_ACT(const std::string& value)
{
  setString(CHD_HEAT_DATA::PRODORDERID_ACT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Aim steel weight according production order.
double CHD_HEAT_DATA::getAIMSTEELWGT_PLAN(long Row)
{
  return getDouble(CHD_HEAT_DATA::AIMSTEELWGT_PLAN, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setAIMSTEELWGT_PLAN(double value)
{
  setDouble(CHD_HEAT_DATA::AIMSTEELWGT_PLAN, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Aim steel weight according operator. (= Order if not changed)
double CHD_HEAT_DATA::getAIMSTEELWGT_MOD(long Row)
{
  return getDouble(CHD_HEAT_DATA::AIMSTEELWGT_MOD, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setAIMSTEELWGT_MOD(double value)
{
  setDouble(CHD_HEAT_DATA::AIMSTEELWGT_MOD, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Aim temperature according plan.
double CHD_HEAT_DATA::getAIMTEMP_PLAN(long Row)
{
  return getDouble(CHD_HEAT_DATA::AIMTEMP_PLAN, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setAIMTEMP_PLAN(double value)
{
  setDouble(CHD_HEAT_DATA::AIMTEMP_PLAN, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Aim temperature according operator modification
double CHD_HEAT_DATA::getAIMTEMP_MOD(long Row)
{
  return getDouble(CHD_HEAT_DATA::AIMTEMP_MOD, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setAIMTEMP_MOD(double value)
{
  setDouble(CHD_HEAT_DATA::AIMTEMP_MOD, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##In case a model supports offline calculation for e.g. scrap order this time stamp is used to have a complete time line for the heat
CDateTime CHD_HEAT_DATA::getHEATANNOUNCE_OFFLINE(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_HEAT_DATA::HEATANNOUNCE_OFFLINE, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setHEATANNOUNCE_OFFLINE(const CDateTime& value)
{
 setString(CHD_HEAT_DATA::HEATANNOUNCE_OFFLINE, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Heat announcement time
CDateTime CHD_HEAT_DATA::getHEATANNOUNCE_ACT(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_HEAT_DATA::HEATANNOUNCE_ACT, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setHEATANNOUNCE_ACT(const CDateTime& value)
{
 setString(CHD_HEAT_DATA::HEATANNOUNCE_ACT, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment start from schedule
CDateTime CHD_HEAT_DATA::getTREATSTART_PLAN(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_HEAT_DATA::TREATSTART_PLAN, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setTREATSTART_PLAN(const CDateTime& value)
{
 setString(CHD_HEAT_DATA::TREATSTART_PLAN, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment start, schedule modified
CDateTime CHD_HEAT_DATA::getTREATSTART_MOD(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_HEAT_DATA::TREATSTART_MOD, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setTREATSTART_MOD(const CDateTime& value)
{
 setString(CHD_HEAT_DATA::TREATSTART_MOD, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Actual treatment start
CDateTime CHD_HEAT_DATA::getTREATSTART_ACT(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_HEAT_DATA::TREATSTART_ACT, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setTREATSTART_ACT(const CDateTime& value)
{
 setString(CHD_HEAT_DATA::TREATSTART_ACT, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment end from schedule
CDateTime CHD_HEAT_DATA::getTREATEND_PLAN(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_HEAT_DATA::TREATEND_PLAN, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setTREATEND_PLAN(const CDateTime& value)
{
 setString(CHD_HEAT_DATA::TREATEND_PLAN, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment end, schedule modified
CDateTime CHD_HEAT_DATA::getTREATEND_MOD(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_HEAT_DATA::TREATEND_MOD, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setTREATEND_MOD(const CDateTime& value)
{
 setString(CHD_HEAT_DATA::TREATEND_MOD, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment end time calculated by model
CDateTime CHD_HEAT_DATA::getTREATEND_CALC(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_HEAT_DATA::TREATEND_CALC, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setTREATEND_CALC(const CDateTime& value)
{
 setString(CHD_HEAT_DATA::TREATEND_CALC, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Actual treatment end
CDateTime CHD_HEAT_DATA::getTREATEND_ACT(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_HEAT_DATA::TREATEND_ACT, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setTREATEND_ACT(const CDateTime& value)
{
 setString(CHD_HEAT_DATA::TREATEND_ACT, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Heat departure time
CDateTime CHD_HEAT_DATA::getHEATDEPARTURE_ACT(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_HEAT_DATA::HEATDEPARTURE_ACT, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setHEATDEPARTURE_ACT(const CDateTime& value)
{
 setString(CHD_HEAT_DATA::HEATDEPARTURE_ACT, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Last treatment end, should be filled from PD_PLANTSTATUS_PLANT.LASTTREATENDTIME
CDateTime CHD_HEAT_DATA::getTREATEND_PREV(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_HEAT_DATA::TREATEND_PREV, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setTREATEND_PREV(const CDateTime& value)
{
 setString(CHD_HEAT_DATA::TREATEND_PREV, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##e.g. Hot Metal -> H, Teeming -> T
std::string CHD_HEAT_DATA::getLADLETYPE(long Row)
{
  return getString(CHD_HEAT_DATA::LADLETYPE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setLADLETYPE(const std::string& value)
{
  setString(CHD_HEAT_DATA::LADLETYPE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique ladle number
long CHD_HEAT_DATA::getLADLENO(long Row)
{
  return getLong(CHD_HEAT_DATA::LADLENO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setLADLENO(long value)
{
  setLong(CHD_HEAT_DATA::LADLENO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Cummulated steel mass from all additions, Eng. Unit : kg, 
double CHD_HEAT_DATA::getSTEELMASS(long Row)
{
  return getDouble(CHD_HEAT_DATA::STEELMASS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setSTEELMASS(double value)
{
  setDouble(CHD_HEAT_DATA::STEELMASS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Cummulated slag mass from all additions, Eng. Unit : kg, 
double CHD_HEAT_DATA::getSLAGMASS(long Row)
{
  return getDouble(CHD_HEAT_DATA::SLAGMASS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setSLAGMASS(double value)
{
  setDouble(CHD_HEAT_DATA::SLAGMASS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique sample reference
long CHD_HEAT_DATA::getSAMPLE_REF(long Row)
{
  return getLong(CHD_HEAT_DATA::SAMPLE_REF, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setSAMPLE_REF(long value)
{
  setLong(CHD_HEAT_DATA::SAMPLE_REF, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Date and time of last revision
CDateTime CHD_HEAT_DATA::getREVTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_HEAT_DATA::REVTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setREVTIME(const CDateTime& value)
{
 setString(CHD_HEAT_DATA::REVTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
std::string CHD_HEAT_DATA::getUSERCODE(long Row)
{
  return getString(CHD_HEAT_DATA::USERCODE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setUSERCODE(const std::string& value)
{
  setString(CHD_HEAT_DATA::USERCODE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Number of taken temperature measurements
long CHD_HEAT_DATA::getTEMP_SAMPLES(long Row)
{
  return getLong(CHD_HEAT_DATA::TEMP_SAMPLES, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setTEMP_SAMPLES(long value)
{
  setLong(CHD_HEAT_DATA::TEMP_SAMPLES, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Number of taken steel analysis measurements
long CHD_HEAT_DATA::getSTEEL_SAMPLES(long Row)
{
  return getLong(CHD_HEAT_DATA::STEEL_SAMPLES, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setSTEEL_SAMPLES(long value)
{
  setLong(CHD_HEAT_DATA::STEEL_SAMPLES, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Number of taken slag analysis measurements
long CHD_HEAT_DATA::getSLAG_SAMPLES(long Row)
{
  return getLong(CHD_HEAT_DATA::SLAG_SAMPLES, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setSLAG_SAMPLES(long value)
{
  setLong(CHD_HEAT_DATA::SLAG_SAMPLES, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Steel mass at begin of treatment
double CHD_HEAT_DATA::getSTEELMASS_START(long Row)
{
  return getDouble(CHD_HEAT_DATA::STEELMASS_START, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setSTEELMASS_START(double value)
{
  setDouble(CHD_HEAT_DATA::STEELMASS_START, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Slag mass at begin of treatment
double CHD_HEAT_DATA::getSLAGMASS_START(long Row)
{
  return getDouble(CHD_HEAT_DATA::SLAGMASS_START, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setSLAGMASS_START(double value)
{
  setDouble(CHD_HEAT_DATA::SLAGMASS_START, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Planned route code
std::string CHD_HEAT_DATA::getROUTECODE_PLAN(long Row)
{
  return getString(CHD_HEAT_DATA::ROUTECODE_PLAN, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setROUTECODE_PLAN(const std::string& value)
{
  setString(CHD_HEAT_DATA::ROUTECODE_PLAN, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Actual route code
std::string CHD_HEAT_DATA::getROUTECODE_ACT(long Row)
{
  return getString(CHD_HEAT_DATA::ROUTECODE_ACT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setROUTECODE_ACT(const std::string& value)
{
  setString(CHD_HEAT_DATA::ROUTECODE_ACT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment duration
double CHD_HEAT_DATA::getTREATMENTDURATION(long Row)
{
  return getDouble(CHD_HEAT_DATA::TREATMENTDURATION, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setTREATMENTDURATION(double value)
{
  setDouble(CHD_HEAT_DATA::TREATMENTDURATION, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Final temperature (measured or calculated, plant dependend)
double CHD_HEAT_DATA::getFINALTEMP(long Row)
{
  return getDouble(CHD_HEAT_DATA::FINALTEMP, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setFINALTEMP(double value)
{
  setDouble(CHD_HEAT_DATA::FINALTEMP, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Shift of Production
std::string CHD_HEAT_DATA::getSHIFT_ID(long Row)
{
  return getString(CHD_HEAT_DATA::SHIFT_ID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setSHIFT_ID(const std::string& value)
{
  setString(CHD_HEAT_DATA::SHIFT_ID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Identification of working crew
std::string CHD_HEAT_DATA::getCREW_ID(long Row)
{
  return getString(CHD_HEAT_DATA::CREW_ID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setCREW_ID(const std::string& value)
{
  setString(CHD_HEAT_DATA::CREW_ID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Responsible person of crew, typically the foreman
std::string CHD_HEAT_DATA::getCREW_RESPONSIBILITY(long Row)
{
  return getString(CHD_HEAT_DATA::CREW_RESPONSIBILITY, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setCREW_RESPONSIBILITY(const std::string& value)
{
  setString(CHD_HEAT_DATA::CREW_RESPONSIBILITY, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Crew member (MEMBER_ID), reponsible for the heat, if required
std::string CHD_HEAT_DATA::getHEAT_RESPONSIBILITY(long Row)
{
  return getString(CHD_HEAT_DATA::HEAT_RESPONSIBILITY, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setHEAT_RESPONSIBILITY(const std::string& value)
{
  setString(CHD_HEAT_DATA::HEAT_RESPONSIBILITY, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Free text for operator comments.
std::string CHD_HEAT_DATA::getCOMMENTS(long Row)
{
  return getString(CHD_HEAT_DATA::COMMENTS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_HEAT_DATA::setCOMMENTS(const std::string& value)
{
  setString(CHD_HEAT_DATA::COMMENTS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CHD_HEAT_DATA::select(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CHD_HEAT_DATA::HEATID,HEATID);
  addWhereClause(CHD_HEAT_DATA::TREATID,TREATID);
  addWhereClause(CHD_HEAT_DATA::PLANT,PLANT);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CHD_HEAT_DATA::selectByREVTIME(const CDateTime& REVTIME, const std::string& Operator)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CHD_HEAT_DATA::REVTIME, REVTIME, Operator );

  m_Statement += getWhereStatement() + " order by REVTIME desc;";

  return CSMC_DBData::select();
}

bool CHD_HEAT_DATA::copy(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = true;

  //some data found -> delete them
  if ( exists(HEATID, TREATID, PLANT) )
  {
    // preparing setting for source table
    CPD_HEAT_DATA PD_HEAT_DATA(m_pCBS_StdConnection);
    PD_HEAT_DATA.addWhereClause(CPD_HEAT_DATA::HEATID,HEATID);
    PD_HEAT_DATA.addWhereClause(CPD_HEAT_DATA::TREATID,TREATID);
    PD_HEAT_DATA.addWhereClause(CPD_HEAT_DATA::PLANT,PLANT);

    // preparing setting for aim table
    cleanWhereStatement();
    addWhereClause(CHD_HEAT_DATA::HEATID,HEATID);
    addWhereClause(CHD_HEAT_DATA::TREATID,TREATID);
    addWhereClause(CHD_HEAT_DATA::PLANT,PLANT);

    result = result && copyByUpdate(&PD_HEAT_DATA);

  }
  else
  {
    // preparing setting for source table
    CPD_HEAT_DATA PD_HEAT_DATA(m_pCBS_StdConnection);
    PD_HEAT_DATA.addWhereClause(CPD_HEAT_DATA::HEATID,HEATID);
    PD_HEAT_DATA.addWhereClause(CPD_HEAT_DATA::TREATID,TREATID);
    PD_HEAT_DATA.addWhereClause(CPD_HEAT_DATA::PLANT,PLANT);

    result = result && copyByInsert(&PD_HEAT_DATA);
  }

  if (!result)
    Error = getLastError();

  if(Commit)
  {
    if (result)
      commit();
    else
      rollback();
  }

  return result;
}

bool CHD_HEAT_DATA::exists(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
	cleanWhereStatement();

	m_Statement = "Select HEATID from " + m_TableName;

	addWhereClause(CHD_HEAT_DATA::HEATID,HEATID);
	addWhereClause(CHD_HEAT_DATA::TREATID,TREATID);
	addWhereClause(CHD_HEAT_DATA::PLANT,PLANT);
   
  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }

	return CSMC_DBData::select();
}


bool CHD_HEAT_DATA::checkNULLValues(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
  bool result = true;

  std::string Message;

  //some data found -> delete them
  if ( select(HEATID, TREATID, PLANT) )
  {
    std::vector<std::string> ColumnList  = getColumnList();
    std::vector<std::string>::iterator it;

    for (it = ColumnList.begin() ; it != ColumnList.end() ; ++it)
    {
      std::string ColName = *it;

      if ( isNull(ColName, 1 ) )
      {
        Message = Message + " - " + ColName  ;
      }
    }
  }

  if ( !Message.empty() )
  {
  	cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
	  sEventLogMessage sMessage = cCBS_StdEventLogFrame::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DBNullValueError(sMessage,m_TableName.c_str(), Message.c_str());
  }

  return result;
}
