//## Copyright (C) 2009 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 

#if defined (_MSC_VER) && (_MSC_VER >= 1000)
#pragma once
#endif
#ifndef _INC_CHD_SAMPLE_INCLUDED
#define _INC_CHD_SAMPLE_INCLUDED

#include <vector>
#include "CSMC_DBData.h"

class CHD_SAMPLE
: public CSMC_DBData
{

public:
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string SAMPLE_COUNTER;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string HEATID;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string HM_ID;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string TREATID;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string PLANT;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string PLANTNO;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string PRODORDERID;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string SAMPLENO;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string MEASTYPENO;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string GROUPNO;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string SAMPLETIME;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string RECTIME;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string RECTIMELAB;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string SAMPLEMODE;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string SAMPLELOC;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string LADLENO;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string LADLETYPE;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string DURSINCEHEATANNOUNCEMENT;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string DURSINCESTARTOFHEAT;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string SAMPLEUSABLE;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string ORIGIN;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string USERCODE;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string SAMPLEID_CUST;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string REVTIME;

  //##DBClassCodeUtility ! DO NOT EDIT !
  CHD_SAMPLE(cCBS_StdConnection* Connection);

  //##DBClassCodeUtility ! DO NOT EDIT !
  CHD_SAMPLE(cCBS_Connection* Connection);

  //##DBClassCodeUtility ! DO NOT EDIT !
  CHD_SAMPLE();

  //##DBClassCodeUtility ! DO NOT EDIT !
  ~CHD_SAMPLE();

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##SAMPLE_COUNTER is the primary key
  long getSAMPLE_COUNTER(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setSAMPLE_COUNTER(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Heat identifier, gives the possibility to select all samples for this heat.
  std::string getHEATID(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setHEATID(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Hot metal identifier, gives the possibility to select all samples for this hot metal.
  std::string getHM_ID(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setHM_ID(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Treatment identifier
  std::string getTREATID(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setTREATID(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Plant identifier
  std::string getPLANT(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setPLANT(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Plant number
  long getPLANTNO(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setPLANTNO(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Production oder identification
  std::string getPRODORDERID(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setPRODORDERID(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Sample No, Definition see Requirment Book Naming standard specification
  long getSAMPLENO(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setSAMPLENO(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Identifies the type of measurement
  long getMEASTYPENO(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setMEASTYPENO(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Grouping of measurements makes sense in the following situations:, 1. Two measurements has been taken together, e.g. with a sub lance and special devices. The results arrives the system at different times. Grouping these measurements together gives the possibility to indicate the coherence of these measurements, e.g., for statistical evaluations as introduced at BOF, 2. Assume the situation that two hot metal ladles are assigned to a heat. Then we have an entry for the PRODORDERID in the PD_SAMPLE and if the heat already exists also an entry with the HEATID. In case one ladle was de-assigned from the heat we have to delete the corresponding entries for HEATID and PRODORDERID from the table, but the entries for the other ladle must remain. Using this GROUPNO by entering the HOTMETAL_COUNTER allows the deletion of the data only for the de-assigned ladle.
  long getGROUPNO(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setGROUPNO(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Sample taken time
  CDateTime getSAMPLETIME(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setSAMPLETIME(const CDateTime& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Sample taken receive time (telegram received)
  CDateTime getRECTIME(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setRECTIME(const CDateTime& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Sample analysis receive time (telegram received)
  CDateTime getRECTIMELAB(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setRECTIMELAB(const CDateTime& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Manually, automatic
  long getSAMPLEMODE(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setSAMPLEMODE(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Sample location
  std::string getSAMPLELOC(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setSAMPLELOC(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Unique ladle number
  long getLADLENO(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setLADLENO(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##e.g. Hot Metal -> H, Teeming -> T
  std::string getLADLETYPE(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setLADLETYPE(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Duration since heat announcement
  double getDURSINCEHEATANNOUNCEMENT(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setDURSINCEHEATANNOUNCEMENT(double value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Duration since start of heat
  double getDURSINCESTARTOFHEAT(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setDURSINCESTARTOFHEAT(double value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##0: not usable, 1: usable with sample taken detected, 2: usable without sample taken detected
  long getSAMPLEUSABLE(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setSAMPLEUSABLE(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Measured -> 1, Calculated -> 2, Manual entered -> 3
  long getORIGIN(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setORIGIN(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##User who entered data
  std::string getUSERCODE(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setUSERCODE(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Customer specific representation of the sample. It is only used for display and reporting and will not used for interpretation of details.
  std::string getSAMPLEID_CUST(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setSAMPLEID_CUST(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Date and time of last revision
  CDateTime getREVTIME(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setREVTIME(const CDateTime& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  bool select(long SAMPLE_COUNTER);

  //## ----------------------------------END-GENERATED-CODE--------------------- 

  //## ----------------------------------YOUR-CODE------------------------------ 

  bool copy(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long SAMPLE_COUNTER, bool Commit, cCBS_ODBC_DBError &Error);

  bool copy(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, std::vector<long> &SampleCounterList, bool Commit, cCBS_ODBC_DBError &Error);

  std::string ArrayToString(std::vector<long> &pArray);

  bool deleteByRecTime(CDateTime& OlderThan);

  bool deleteRows(long SAMPLE_COUNTER, bool Commit, cCBS_ODBC_DBError &Error);

  bool deleteRows(std::vector<long> &SampleCounterList, bool Commit, cCBS_ODBC_DBError &Error);

  bool exists(long SAMPLE_COUNTER);

  bool exists(std::vector<long> &SampleCounterList);

  bool CHD_SAMPLE::OnTempMeasurement(const string& pHMId, const string& pTreatId, const string& pPlant, long pPlantNo, long pSampleCount, bool pCommit, cCBS_ODBC_DBError &pError);
};

#endif /* _INC_CHD_SAMPLE_INCLUDED */
