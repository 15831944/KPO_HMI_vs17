//## Copyright (C) 2010 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "CIntfData.h"
#include "CDataConversion.h"
#include "cCBS_StdEventLogFrameController.h"
#include "CGC_MEASUREMENT_NAME.h"
#include "CPD_SAMPLE_ENTRY.h"
#include "DEF_GC_MEASUREMENT_TYPE.h"
#include "DEF_GC_SAMPLEMODE.h""
#include "CPD_SAMPLE.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::SAMPLE_COUNTER("SAMPLE_COUNTER");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::HEATID("HEATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::HM_ID("HM_ID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::TREATID("TREATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::PLANT("PLANT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::PLANTNO("PLANTNO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::PRODORDERID("PRODORDERID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::SAMPLENO("SAMPLENO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::MEASTYPENO("MEASTYPENO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::GROUPNO("GROUPNO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::SAMPLETIME("SAMPLETIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::RECTIME("RECTIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::RECTIMELAB("RECTIMELAB");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::SAMPLEMODE("SAMPLEMODE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::SAMPLELOC("SAMPLELOC");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::LADLENO("LADLENO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::LADLETYPE("LADLETYPE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::DURSINCEHEATANNOUNCEMENT("DURSINCEHEATANNOUNCEMENT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::DURSINCESTARTOFHEAT("DURSINCESTARTOFHEAT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::SAMPLEUSABLE("SAMPLEUSABLE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::ORIGIN("ORIGIN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::USERCODE("USERCODE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::SAMPLEID_CUST("SAMPLEID_CUST");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE::REVTIME("REVTIME");

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_SAMPLE::CPD_SAMPLE(cCBS_StdConnection* Connection)
:CSMC_DBData("PD_SAMPLE",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_SAMPLE::CPD_SAMPLE(cCBS_Connection* Connection)
:CSMC_DBData("PD_SAMPLE",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_SAMPLE::CPD_SAMPLE()
:CSMC_DBData("PD_SAMPLE")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_SAMPLE::~CPD_SAMPLE()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique sample counter
long CPD_SAMPLE::getSAMPLE_COUNTER(long Row)
{
  return getLong(CPD_SAMPLE::SAMPLE_COUNTER, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setSAMPLE_COUNTER(long value)
{
  setLong(CPD_SAMPLE::SAMPLE_COUNTER, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Heat identifier, gives the possibility to select all samples for this heat.
std::string CPD_SAMPLE::getHEATID(long Row)
{
  return getString(CPD_SAMPLE::HEATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setHEATID(const std::string& value)
{
  setString(CPD_SAMPLE::HEATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Hot metal identifier, gives the possibility to select all samples for this hot metal.
std::string CPD_SAMPLE::getHM_ID(long Row)
{
  return getString(CPD_SAMPLE::HM_ID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setHM_ID(const std::string& value)
{
  setString(CPD_SAMPLE::HM_ID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment identifier
std::string CPD_SAMPLE::getTREATID(long Row)
{
  return getString(CPD_SAMPLE::TREATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setTREATID(const std::string& value)
{
  setString(CPD_SAMPLE::TREATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant identifier
std::string CPD_SAMPLE::getPLANT(long Row)
{
  return getString(CPD_SAMPLE::PLANT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setPLANT(const std::string& value)
{
  setString(CPD_SAMPLE::PLANT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant number
long CPD_SAMPLE::getPLANTNO(long Row)
{
  return getLong(CPD_SAMPLE::PLANTNO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setPLANTNO(long value)
{
  setLong(CPD_SAMPLE::PLANTNO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Production oder identification
std::string CPD_SAMPLE::getPRODORDERID(long Row)
{
  return getString(CPD_SAMPLE::PRODORDERID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setPRODORDERID(const std::string& value)
{
  setString(CPD_SAMPLE::PRODORDERID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Sample No, Definition see Requirment Book Naming standard specification
long CPD_SAMPLE::getSAMPLENO(long Row)
{
  return getLong(CPD_SAMPLE::SAMPLENO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setSAMPLENO(long value)
{
  setLong(CPD_SAMPLE::SAMPLENO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Identifies the type of measurement
long CPD_SAMPLE::getMEASTYPENO(long Row)
{
  return getLong(CPD_SAMPLE::MEASTYPENO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setMEASTYPENO(long value)
{
  setLong(CPD_SAMPLE::MEASTYPENO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Grouping of measurements makes sense in the following situations:, 1. Two measurements has been taken together, e.g. with a sub lance and special devices. The results arrives the system at different times. Grouping these measurements together gives the possibility to indicate the coherence of these measurements, e.g., for statistical evaluations as introduced at BOF, 2. Assume the situation that two hot metal ladles are assigned to a heat. Then we have an entry for the PRODORDERID in the PD_SAMPLE and if the heat already exists also an entry with the HEATID. In case one ladle was de-assigned from the heat we have to delete the corresponding entries for HEATID and PRODORDERID from the table, but the entries for the other ladle must remain. Using this GROUPNO by entering the HOTMETAL_COUNTER allows the deletion of the data only for the de-assigned ladle.
long CPD_SAMPLE::getGROUPNO(long Row)
{
  return getLong(CPD_SAMPLE::GROUPNO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setGROUPNO(long value)
{
  setLong(CPD_SAMPLE::GROUPNO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Sample taken time
CDateTime CPD_SAMPLE::getSAMPLETIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_SAMPLE::SAMPLETIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setSAMPLETIME(const CDateTime& value)
{
 setString(CPD_SAMPLE::SAMPLETIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Sample taken receive time (telegram received)
CDateTime CPD_SAMPLE::getRECTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_SAMPLE::RECTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setRECTIME(const CDateTime& value)
{
 setString(CPD_SAMPLE::RECTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Sample analysis receive time (telegram received)
CDateTime CPD_SAMPLE::getRECTIMELAB(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_SAMPLE::RECTIMELAB, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setRECTIMELAB(const CDateTime& value)
{
 setString(CPD_SAMPLE::RECTIMELAB, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Manually, automatic
long CPD_SAMPLE::getSAMPLEMODE(long Row)
{
  return getLong(CPD_SAMPLE::SAMPLEMODE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setSAMPLEMODE(long value)
{
  setLong(CPD_SAMPLE::SAMPLEMODE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Sample location
std::string CPD_SAMPLE::getSAMPLELOC(long Row)
{
  return getString(CPD_SAMPLE::SAMPLELOC, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setSAMPLELOC(const std::string& value)
{
  setString(CPD_SAMPLE::SAMPLELOC, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique ladle number
long CPD_SAMPLE::getLADLENO(long Row)
{
  return getLong(CPD_SAMPLE::LADLENO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setLADLENO(long value)
{
  setLong(CPD_SAMPLE::LADLENO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##e.g. Hot Metal -> H, Teeming -> T
std::string CPD_SAMPLE::getLADLETYPE(long Row)
{
  return getString(CPD_SAMPLE::LADLETYPE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setLADLETYPE(const std::string& value)
{
  setString(CPD_SAMPLE::LADLETYPE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Duration since heat announcement
double CPD_SAMPLE::getDURSINCEHEATANNOUNCEMENT(long Row)
{
  return getDouble(CPD_SAMPLE::DURSINCEHEATANNOUNCEMENT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setDURSINCEHEATANNOUNCEMENT(double value)
{
  setDouble(CPD_SAMPLE::DURSINCEHEATANNOUNCEMENT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Duration since start of heat
double CPD_SAMPLE::getDURSINCESTARTOFHEAT(long Row)
{
  return getDouble(CPD_SAMPLE::DURSINCESTARTOFHEAT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setDURSINCESTARTOFHEAT(double value)
{
  setDouble(CPD_SAMPLE::DURSINCESTARTOFHEAT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##0: not usable, 1: usable with sample taken detected, 2: usable without sample taken detected
long CPD_SAMPLE::getSAMPLEUSABLE(long Row)
{
  return getLong(CPD_SAMPLE::SAMPLEUSABLE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setSAMPLEUSABLE(long value)
{
  setLong(CPD_SAMPLE::SAMPLEUSABLE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Measured -> 1, Calculated -> 2, Manual entered -> 3
long CPD_SAMPLE::getORIGIN(long Row)
{
  return getLong(CPD_SAMPLE::ORIGIN, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setORIGIN(long value)
{
  setLong(CPD_SAMPLE::ORIGIN, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##User who entered data
std::string CPD_SAMPLE::getUSERCODE(long Row)
{
  return getString(CPD_SAMPLE::USERCODE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setUSERCODE(const std::string& value)
{
  setString(CPD_SAMPLE::USERCODE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Customer specific representation of the sample. It is only used for display and reporting and will not used for interpretation of details.
std::string CPD_SAMPLE::getSAMPLEID_CUST(long Row)
{
  return getString(CPD_SAMPLE::SAMPLEID_CUST, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setSAMPLEID_CUST(const std::string& value)
{
  setString(CPD_SAMPLE::SAMPLEID_CUST, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Date and time of last revision
CDateTime CPD_SAMPLE::getREVTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_SAMPLE::REVTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE::setREVTIME(const CDateTime& value)
{
 setString(CPD_SAMPLE::REVTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPD_SAMPLE::select(long SAMPLE_COUNTER)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_SAMPLE::SAMPLE_COUNTER,SAMPLE_COUNTER);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CPD_SAMPLE::selectByTypeAndOrigin(std::string HeatID,std::string TreatID,std::string Plant,long PlantNo,long MEASTYPENO,long ORIGIN)
{
  log("++++++ CPD_SAMPLE::selectByTypeAndOrigin",3);

  cleanWhereStatement();
  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_SAMPLE::HEATID,HeatID);
  addWhereClause(CPD_SAMPLE::TREATID,TreatID);
  addWhereClause(CPD_SAMPLE::PLANT,Plant);
  addWhereClause(CPD_SAMPLE::PLANTNO,PlantNo);
  addWhereClause(CPD_SAMPLE::MEASTYPENO,MEASTYPENO);
  addWhereClause(CPD_SAMPLE::ORIGIN,ORIGIN);

  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CPD_SAMPLE::selectHeatSample(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long MEASTYPENO , long SAMPLENO)
{
  log("++++++ CPD_SAMPLE::selectHeatSample",3);

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_SAMPLE::HEATID,HEATID);
  addWhereClause(CPD_SAMPLE::TREATID,TREATID);
  addWhereClause(CPD_SAMPLE::PLANT,PLANT);
  addWhereClause(CPD_SAMPLE::PLANTNO,PLANTNO);
  addWhereClause(CPD_SAMPLE::MEASTYPENO,MEASTYPENO);
  addWhereClause(CPD_SAMPLE::SAMPLENO,SAMPLENO);

  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CPD_SAMPLE::selectHeatSampleBySampleTime(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long MEASTYPENO, long SAMPLENO, bool ASC /*= true*/)
{
  log("++++++ CPD_SAMPLE::selectHeatSampleBySampleTime",3);

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_SAMPLE::HEATID,HEATID);
  addWhereClause(CPD_SAMPLE::TREATID,TREATID);
  addWhereClause(CPD_SAMPLE::PLANT,PLANT);
  addWhereClause(CPD_SAMPLE::PLANTNO,PLANTNO);
  addWhereClause(CPD_SAMPLE::MEASTYPENO,MEASTYPENO);
  addWhereClause(CPD_SAMPLE::SAMPLENO,SAMPLENO);

  if ( ASC )
  {
    m_Statement += getWhereStatement() + " ORDER BY SAMPLETIME ASC;";
  }
  else
  {
    m_Statement += getWhereStatement() + " ORDER BY SAMPLETIME DESC;";
  }

  return CSMC_DBData::select();
}

bool CPD_SAMPLE::selectLastHeatSample(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
  log("++++++ CPD_SAMPLE::selectLastHeatSample",3);

  cleanWhereStatement();
  
  m_Statement = "Select * from " + m_TableName;
  
  addWhereClause(CPD_SAMPLE::HEATID,HEATID);
  addWhereClause(CPD_SAMPLE::TREATID,TREATID);
  addWhereClause(CPD_SAMPLE::PLANT,PLANT);

  // select for MEASTYPENO of analysis measurements
  std::vector<long> MeasTypes;
  MeasTypes.push_back(DEF_GC_MEASUREMENT_TYPE::Steel);
  MeasTypes.push_back(DEF_GC_MEASUREMENT_TYPE::Celox);

  addWhereClause(CPD_SAMPLE::MEASTYPENO,MeasTypes,"IN");

  m_Statement += getWhereStatement();

  m_Statement += " order by SAMPLETIME desc;";

  return CSMC_DBData::select();
}

bool CPD_SAMPLE::selectLastHeatSampleByMeasTypeNo(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT,const long &MEASTYPENO)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_SAMPLE::HEATID,HEATID);
  addWhereClause(CPD_SAMPLE::TREATID,TREATID);
  addWhereClause(CPD_SAMPLE::PLANT,PLANT);
  addWhereClause(CPD_SAMPLE::MEASTYPENO,MEASTYPENO);

  m_Statement += getWhereStatement();

  m_Statement += " order by SAMPLETIME desc;";

  return CSMC_DBData::select();
}

bool CPD_SAMPLE::selectLastHeatTemp(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
  log("++++++ CPD_SAMPLE::selectLastHeatTemp",3);

  cleanWhereStatement();
  
  m_Statement = "Select * from " + m_TableName;
  
  addWhereClause(CPD_SAMPLE::HEATID,HEATID);
  addWhereClause(CPD_SAMPLE::TREATID,TREATID);
  addWhereClause(CPD_SAMPLE::PLANT,PLANT);

  // select for MEASTYPENO of temperature measurements
  std::vector<long> MeasTypes;
  MeasTypes.push_back(DEF_GC_MEASUREMENT_TYPE::Temp);
  MeasTypes.push_back(DEF_GC_MEASUREMENT_TYPE::Celox);

  addWhereClause(CPD_SAMPLE::MEASTYPENO,MeasTypes,"IN");

  m_Statement += getWhereStatement();

  m_Statement += " order by SAMPLETIME desc;";

  return CSMC_DBData::select();
}

bool CPD_SAMPLE::selectLastSampleWithoutAnalysis(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long MEASTYPENO)
{
  log("++++++ CPD_SAMPLE::selectLastSampleWithoutAnalysis",3);

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_SAMPLE::HEATID,HEATID);
  addWhereClause(CPD_SAMPLE::TREATID,TREATID);
  addWhereClause(CPD_SAMPLE::PLANT,PLANT);
  addWhereClause(CPD_SAMPLE::PLANTNO,PLANTNO);
  addWhereClause(CPD_SAMPLE::MEASTYPENO,MEASTYPENO);
  addWhereClause(CPD_SAMPLE::SAMPLEUSABLE,0L,">");

  // we are only interested in datasets that have also entries in PD_SAMPLE_ENTRY
  addWhereClause("PD_SAMPLE.SAMPLE_COUNTER NOT IN (select SAMPLE_COUNTER from PD_SAMPLE_ENTRY)");

  m_Statement += getWhereStatement() + " ORDER BY SAMPLETIME DESC;";

  return CSMC_DBData::select();
}

bool CPD_SAMPLE::selectLastSampleWithoutAnalysisHMD(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long MEASTYPENO)
{
  log("++++++ CPD_SAMPLE::selectLastSampleWithoutAnalysis",3);

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_SAMPLE::HM_ID,HEATID);
  addWhereClause(CPD_SAMPLE::TREATID,TREATID);
  addWhereClause(CPD_SAMPLE::PLANT,PLANT);
  addWhereClause(CPD_SAMPLE::PLANTNO,PLANTNO);
  addWhereClause(CPD_SAMPLE::MEASTYPENO,MEASTYPENO);
  //addWhereClause(CPD_SAMPLE::SAMPLEUSABLE,0L,">");

  // we are only interested in datasets that have also entries in PD_SAMPLE_ENTRY
  addWhereClause("PD_SAMPLE.SAMPLE_COUNTER NOT IN (select SAMPLE_COUNTER from PD_SAMPLE_ENTRY)");

  m_Statement += getWhereStatement() + " ORDER BY SAMPLETIME DESC;";

  return CSMC_DBData::select();
}

bool CPD_SAMPLE::selectPlantSample(const std::string& PLANT, long PLANTNO, long MEASTYPENO , long SAMPLENO)
{
  log("++++++ CPD_SAMPLE::selectPlantSample",3);

  cleanWhereStatement();
  
  m_Statement = "Select * from " + m_TableName;
  
  addWhereClause(CPD_SAMPLE::PLANT,PLANT);
  addWhereClause(CPD_SAMPLE::PLANTNO,PLANTNO);
  addWhereClause(CPD_SAMPLE::MEASTYPENO,MEASTYPENO);
  addWhereClause(CPD_SAMPLE::SAMPLENO,SAMPLENO);

  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CPD_SAMPLE::selectProdOrderSample(const std::string& PRODORDERID, const std::string& PLANT, long PLANTNO, long MEASTYPENO)
{
  log("++++++ CPD_SAMPLE::selectProdOrderSample",3);

  cleanWhereStatement();
  
  m_Statement = "Select * from " + m_TableName;
  
  addWhereClause(CPD_SAMPLE::PRODORDERID,PRODORDERID);
  addWhereClause(CPD_SAMPLE::PLANT,PLANT);
  addWhereClause(CPD_SAMPLE::PLANTNO,PLANTNO);
  addWhereClause(CPD_SAMPLE::MEASTYPENO,MEASTYPENO);

  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CPD_SAMPLE::selectUsableHeatSample(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long MEASTYPENO , long SAMPLENO)
{
  log("++++++ CPD_SAMPLE::selectUsableHeatSample",3);

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_SAMPLE::HEATID,HEATID);
  addWhereClause(CPD_SAMPLE::TREATID,TREATID);
  addWhereClause(CPD_SAMPLE::PLANT,PLANT);
  addWhereClause(CPD_SAMPLE::PLANTNO,PLANTNO);
  addWhereClause(CPD_SAMPLE::MEASTYPENO,MEASTYPENO);
  addWhereClause(CPD_SAMPLE::SAMPLENO,SAMPLENO);
  addWhereClause(CPD_SAMPLE::SAMPLEUSABLE,0L,">");

  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CPD_SAMPLE::selectUsedHeatSample(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long MEASTYPENO , long SAMPLENO)
{
  log("++++++ CPD_SAMPLE::selectUsedHeatSample",3);

  bool RetValue = false;

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_SAMPLE::HEATID,HEATID);
  addWhereClause(CPD_SAMPLE::TREATID,TREATID);
  addWhereClause(CPD_SAMPLE::PLANT,PLANT);
  addWhereClause(CPD_SAMPLE::PLANTNO,PLANTNO);
  addWhereClause(CPD_SAMPLE::MEASTYPENO,MEASTYPENO);
  addWhereClause(CPD_SAMPLE::SAMPLENO,SAMPLENO);

  // we are only interested in datasets that have also entries in PD_SAMPLE_ENTRY
  addWhereClause("PD_SAMPLE.SAMPLE_COUNTER IN (select SAMPLE_COUNTER from PD_SAMPLE_ENTRY)");

  m_Statement += getWhereStatement() + ";";
  
  return CSMC_DBData::select();
}

bool CPD_SAMPLE::copyToSampleCounter(long SAMPLE_COUNTER, long NEW_SAMPLE_COUNTER, long NEW_MEASTYPENO, bool Commit, cCBS_ODBC_DBError &Error)
{
  log("++++++ CPD_SAMPLE::copyToSampleCounter",3);

  bool RetValue = false;

  if ( SAMPLE_COUNTER != CSMC_DBData::unspecLong && select(SAMPLE_COUNTER) )
  {
    CDateTime Now;

    setHEATID(getHEATID(1));
    setTREATID(getTREATID(1));
    setPLANT(getPLANT(1));
    setPLANTNO(getPLANTNO(1));
    setORIGIN(getORIGIN(1));

    if ( NEW_MEASTYPENO != CSMC_DBData::unspecLong )
    {
      setMEASTYPENO(NEW_MEASTYPENO);
    }
    else
    {
      setMEASTYPENO(getMEASTYPENO(1));
    }

    setSAMPLEUSABLE(getSAMPLEUSABLE(1));
    setSAMPLENO(getSAMPLENO(1));
    setRECTIME(Now);
    setREVTIME(Now);

    // this is an update now !
    if ( select ( NEW_SAMPLE_COUNTER ) )
    {
      RetValue = update();
    }
    else
    {
      setSAMPLE_COUNTER(NEW_SAMPLE_COUNTER);

      RetValue = insert();
    }

    if ( RetValue )
    {
      seqSample SeqSample;

      if ( m_pPD_SAMPLE_ENTRY ) 
      {
        SeqSample = m_pPD_SAMPLE_ENTRY->getSample(SAMPLE_COUNTER);

        RetValue = m_pPD_SAMPLE_ENTRY->insertSample(NEW_SAMPLE_COUNTER,SeqSample);
      }
    }
  }

  if (Commit)
  {
    if ( RetValue )
    {
      commit();
    }
    else
    {
      rollback();
    }
  }

  if ( !RetValue )
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DBWriteError(sMessage, "",m_TableName.c_str(),"CPD_SAMPLE::copyToSampleCounter");
  }

  return RetValue;
}

seqSample CPD_SAMPLE::AnalysisToSample(seqAnalysis SeqAnalysis)
{
  log("++++++ CPD_SAMPLE::AnalysisToSample",3);

  // shift seqAnalyis into seqSample
  seqSample SeqSample;

  for ( long i = 0 ; i < CIntfData::getLength(SeqAnalysis) ; ++i )
  {
    sAnalysis Analysis;
    CIntfData::getAt(Analysis,SeqAnalysis,i);

    sSample Sample;

    Sample.MeasName  = std::string(Analysis.Element).c_str(); // char pointers !
    Sample.MeasValue = Analysis.Concentration;

    CIntfData::insert(SeqSample,Sample);
  }

  return SeqSample;
}

bool CPD_SAMPLE::deleteByRecTime(const CDateTime& OlderThan, bool IsNotInUse /*= false*/)
{
  log("++++++ CPD_SAMPLE::deleteByRecTime",3);

  bool RetValue = false;

  cleanWhereStatement();

  if (OlderThan != CSMC_DBData::unspecDate)
  {
    addWhereClause(CPD_SAMPLE::RECTIME, OlderThan,"<=");

    m_Statement = "Select * from " + m_TableName;
    m_Statement += getWhereStatement() + ";";

    if (CSMC_DBData::select())
    {
      long NoRows = getLastRow();
      log("INFO: Try to delete entries in PD_SAMPLE older than " + OlderThan.toDBString(),3);

      m_Statement = "Delete " + m_TableName;

      if (IsNotInUse)
      {
        // Delete all records that have no foreign key constraints
        addWhereClause("NOT EXISTS (SELECT * FROM PD_SAMPLE_REF WHERE PD_SAMPLE_REF.STEEL      = " + m_TableName + ".SAMPLE_COUNTER)");
        addWhereClause("NOT EXISTS (SELECT * FROM PD_SAMPLE_REF WHERE PD_SAMPLE_REF.STEEL_CALC = " + m_TableName + ".SAMPLE_COUNTER)");
        addWhereClause("NOT EXISTS (SELECT * FROM PD_SAMPLE_REF WHERE PD_SAMPLE_REF.SLAG       = " + m_TableName + ".SAMPLE_COUNTER)");
        addWhereClause("NOT EXISTS (SELECT * FROM PD_SAMPLE_REF WHERE PD_SAMPLE_REF.SLAG_CALC  = " + m_TableName + ".SAMPLE_COUNTER)");
        addWhereClause("NOT EXISTS (SELECT * FROM PD_SAMPLE_REF WHERE PD_SAMPLE_REF.TEMP       = " + m_TableName + ".SAMPLE_COUNTER)");
        addWhereClause("NOT EXISTS (SELECT * FROM PD_SAMPLE_REF WHERE PD_SAMPLE_REF.TEMP_CALC  = " + m_TableName + ".SAMPLE_COUNTER)");
        addWhereClause("NOT EXISTS (SELECT * FROM PD_SAMPLE_REF WHERE PD_SAMPLE_REF.CARBON     = " + m_TableName + ".SAMPLE_COUNTER)");
        addWhereClause("NOT EXISTS (SELECT * FROM PD_SAMPLE_REF WHERE PD_SAMPLE_REF.OXYGEN     = " + m_TableName + ".SAMPLE_COUNTER)");
        addWhereClause("NOT EXISTS (SELECT * FROM PD_SAMPLE_REF WHERE PD_SAMPLE_REF.HYDROGEN   = " + m_TableName + ".SAMPLE_COUNTER)");
        addWhereClause("NOT EXISTS (SELECT * FROM PD_SAMPLE_REF WHERE PD_SAMPLE_REF.CELOX_SLAG = " + m_TableName + ".SAMPLE_COUNTER)");
        addWhereClause("NOT EXISTS (SELECT * FROM PD_SAMPLE_REF WHERE PD_SAMPLE_REF.ALUMINIUM  = " + m_TableName + ".SAMPLE_COUNTER)");
        addWhereClause("NOT EXISTS (SELECT * FROM PD_SAMPLE_REF WHERE PD_SAMPLE_REF.EMF        = " + m_TableName + ".SAMPLE_COUNTER)");
      }

      m_Statement += getWhereStatement() + ";";

      std::stringstream Message;
      if (CSMC_DBData::deleteRows())
      {
        Message << "INFO: Deleted '" << NoRows << "' rows";
        log(Message.str(),3);
        RetValue = true;
      }
      else
      {
        Message << "ERROR: Delete rows in PD_SAMPLE older than " << OlderThan.toDBString();
        log(Message.str(),1);
      }
    }
    else
      log("INFO: Clean up PD_SAMPLE not necessary. No rows older than " + OlderThan.toDBString(),3);
  }
  else
    log("ERROR: CPD_SAMPLE::deleteByRecTime not possible: unspecified date!",1);

  return RetValue;
}

bool CPD_SAMPLE::deleteRow(long SAMPLE_COUNTER)
{
  log("++++++ CPD_SAMPLE::deleteRow",3);

  bool RetValue = true;
  try
  {
    cleanWhereStatement();
  
    addWhereClause(CPD_SAMPLE::SAMPLE_COUNTER,SAMPLE_COUNTER);
  
    RetValue = CSMC_DBData::deleteRows();

  }
  catch(...)
  {
    rollback(); //something wrong, rollback transaction.
    RetValue = false;
  }

  return RetValue;
}

void CPD_SAMPLE::doOnConstruct()
{
  m_pPD_SAMPLE_ENTRY = new CPD_SAMPLE_ENTRY( m_pCBS_StdConnection );
  m_pGC_MEASUREMENT_NAME = new CGC_MEASUREMENT_NAME( m_pCBS_StdConnection );
}

void CPD_SAMPLE::doOnDestruct()
{
  if ( m_pPD_SAMPLE_ENTRY )
  {
    delete m_pPD_SAMPLE_ENTRY;
    m_pPD_SAMPLE_ENTRY = 0;
  }

  if ( m_pGC_MEASUREMENT_NAME )
  {
    delete m_pGC_MEASUREMENT_NAME;
    m_pGC_MEASUREMENT_NAME = 0;
  }
}

seqAnalysis CPD_SAMPLE::getAnalysisByMeasScope(seqAnalysis SeqAnalysis, long SCOPENO)
{
  log("++++++ CPD_SAMPLE::getAnalysisByMeasScope",3);

  // shift seqAnalyis into seqSample
  seqAnalysis SeqScopeAnalysis;

  for ( long i = 0 ; i < CIntfData::getLength(SeqAnalysis) ; ++i )
  {
    sAnalysis Analysis;
    sAnalysis ScopeAnalysis;
    CIntfData::getAt(Analysis,SeqAnalysis,i);

    if ( m_pGC_MEASUREMENT_NAME->isOfElement(std::string(Analysis.Element), SCOPENO) )
    {
      ScopeAnalysis.Element          = Analysis.Element;
      ScopeAnalysis.Concentration    = Analysis.Concentration;
      CIntfData::insert(SeqScopeAnalysis,ScopeAnalysis);
    }
  }

  return SeqScopeAnalysis;
}

long CPD_SAMPLE::getHighestHMSampleNo(const std::string& HM_ID)
{
  long RetValue = CSMC_DBData::unspecLong;

  cleanWhereStatement();

  m_Statement = "select max(SAMPLENO) as SAMPLENO from "  + m_TableName;

  addWhereClause(CPD_SAMPLE::HM_ID,HM_ID);
  addWhereClause(CPD_SAMPLE::MEASTYPENO,DEF_GC_MEASUREMENT_TYPE::HM);

  if ( !HM_ID.empty() && HM_ID != CSMC_DBData::unspecString )
  {
    m_Statement += getWhereStatement();

    if ( CSMC_DBData::select() )
    {
      RetValue = getSAMPLENO(1);
    }
  }

  return RetValue;
}

long CPD_SAMPLE::getLastSampleNo(const std::string & HEATID, const std::string & TREATID, const std::string & PLANT, long PLANTNO, long MEASTYPENO)
{
  log("++++++ CPD_SAMPLE::getLastSampleNo",3);

  long LastSampleNo = 0; //CSMC_DBData::unspecLong;

  if ( selectHeatSample(HEATID,TREATID,PLANT,PLANTNO,MEASTYPENO,CSMC_DBData::unspecLong) )
  {
    //LastSampleNo = 0;

    for ( long i = 1 ; i <= getLastRow() ; ++i )
    {
      LastSampleNo = max( LastSampleNo, getSAMPLENO(i) );
    }
  }

  return LastSampleNo;

}

long CPD_SAMPLE::getNextSAMPLE_COUNTER()
{
  log("++++++ CPD_SAMPLE::getNextSAMPLE_COUNTER",3);

  long RetValue = CSMC_DBData::unspecLong;

  try
  {
    m_Statement = "select SEQ_SAMPLE_COUNTER.nextval as SAMPLE_COUNTER from dual;" ;

    if ( CSMC_DBData::select() )
    {
      RetValue = getSAMPLE_COUNTER(1);
    }
  }
  catch(...)
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DBReadError(sMessage, "",m_TableName.c_str(),"CPD_SAMPLE::getNextSAMPLE_COUNTER");
  }

  return RetValue;
}

bool CPD_SAMPLE::getNextSAMPLE_COUNTER(long &SAMPLE_COUNTER, cCBS_ODBC_DBError &Error)
{
  log("++++++ CPD_SAMPLE::getNextSAMPLE_COUNTER",3);

  
  m_Statement = "select SEQ_SAMPLE_COUNTER.nextval as SAMPLE_COUNTER from dual";

  bool result = CSMC_DBData::select();  

  if ( result )
  {
    SAMPLE_COUNTER = getSAMPLE_COUNTER(1);
  }
  else
  {
    setLastError(std::string("NO_DATA_FOUND"), 0, getActStatement());
  }

  return result;  
}

long CPD_SAMPLE::getNoOfSamples(const std::string & HEATID, const std::string & TREATID, const std::string & PLANT, long PLANTNO, long MEASTYPENO)
{
  log("++++++ CPD_SAMPLE::getNoOfSamples",3);

  long NoOfSamples = 0; 

  if ( selectHeatSample(HEATID,TREATID,PLANT,PLANTNO,MEASTYPENO,CSMC_DBData::unspecLong) )
  {
    NoOfSamples = getLastRow();
  }

  return NoOfSamples;

}

seqSample CPD_SAMPLE::getSample(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long MEASTYPENO, long SAMPLENO )
{
  log("++++++ CPD_SAMPLE::getSample",3);

  seqSample SeqSample;

  if ( selectHeatSample( HEATID, TREATID, PLANT, PLANTNO, MEASTYPENO, SAMPLENO) )
  {
    long SAMPLE_COUNTER = getSAMPLE_COUNTER(1);

    if ( SAMPLE_COUNTER != CSMC_DBData::unspecLong && m_pPD_SAMPLE_ENTRY ) 
    {
      SeqSample = m_pPD_SAMPLE_ENTRY->getSample(SAMPLE_COUNTER);
    }
  }

  return SeqSample;
}

seqSample CPD_SAMPLE::getSample(long SAMPLE_COUNTER)
{
  log("++++++ CPD_SAMPLE::getSample",3);

  seqSample SeqSample;

  if ( SAMPLE_COUNTER != CSMC_DBData::unspecLong && select( SAMPLE_COUNTER ) )
  {
    if ( m_pPD_SAMPLE_ENTRY ) 
    {
      SeqSample = m_pPD_SAMPLE_ENTRY->getSample(SAMPLE_COUNTER);
    }
  }

  return SeqSample;
}

double CPD_SAMPLE::getSampleMeasValue(long SAMPLE_COUNTER, const std::string MEASNAME)
{
  log("++++++ CPD_SAMPLE::getSampleMeasValue",3);

  double MeaseValue = CSMC_DBData::unspecDouble;

  if ( SAMPLE_COUNTER != CSMC_DBData::unspecLong && select(SAMPLE_COUNTER) )
  {
    if ( m_pPD_SAMPLE_ENTRY && m_pPD_SAMPLE_ENTRY->select(SAMPLE_COUNTER,MEASNAME) )
    {
      MeaseValue = m_pPD_SAMPLE_ENTRY->getMEASVALUE(1);
    }
  }

  return MeaseValue;
}

bool CPD_SAMPLE::hasSampleData(long SAMPLE_COUNTER)
{
  log("++++++ CPD_SAMPLE::hasSampleData",3);

  bool RetValue = false;

  if ( m_pPD_SAMPLE_ENTRY && 
       SAMPLE_COUNTER != CSMC_DBData::unspecLong && 
       m_pPD_SAMPLE_ENTRY->select(SAMPLE_COUNTER,CSMC_DBData::unspecString ) )
  {
    RetValue = true;
  }

  return RetValue;
}

long CPD_SAMPLE::insertAnalysis(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long ORIGIN, long MEASTYPENO, long SAMPLENO, seqAnalysis SeqAnalysis, bool Commit, cCBS_ODBC_DBError &Error)
{
  log("++++++ CPD_SAMPLE::insertAnalysis",3);

  // shift seqAnalyis into seqSample
  seqSample SeqSample = AnalysisToSample(SeqAnalysis);

  return insertSample(HEATID, TREATID, PLANT, PLANTNO, ORIGIN, MEASTYPENO, SAMPLENO, SeqSample, Commit, Error);

}

long CPD_SAMPLE::insertSample(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long ORIGIN, long MEASTYPENO, long SAMPLENO, seqSample SeqSample, bool Commit, cCBS_ODBC_DBError &Error)
{
  log("++++++ CPD_SAMPLE::insertSample",3);

  long RetValue = CSMC_DBData::unspecLong;

  // get new SAMPLE_COUNTER and do reservation on Database !
  long SAMPLE_COUNTER = CSMC_DBData::unspecLong;
  bool Proceed        = getNextSAMPLE_COUNTER(SAMPLE_COUNTER, m_lastError);

  if ( !Proceed )
  {
    return RetValue;
  }

  CDateTime Now;

  setHEATID(HEATID);
  setTREATID(TREATID);
  setPLANT(PLANT);
  setPLANTNO(PLANTNO);
  setORIGIN(ORIGIN);
  setMEASTYPENO(MEASTYPENO);
  setSAMPLENO(SAMPLENO);
  setRECTIME(Now);
  setREVTIME(Now);

  // this is an update now !
  if ( select ( SAMPLE_COUNTER ) )
  {
    Proceed = update();
  }
  else
  {
    setSAMPLE_COUNTER(SAMPLE_COUNTER);

    Proceed = insert();
  }

  if ( Proceed )
  {
    // m_pPD_SAMPLE_ENTRY->insert will not perform commit statement !
    if ( m_pPD_SAMPLE_ENTRY )
    {
      Proceed = m_pPD_SAMPLE_ENTRY->insertSample(SAMPLE_COUNTER, SeqSample);
      if ( !Proceed )
      {
        Error = m_pPD_SAMPLE_ENTRY->getLastError();
      }
    }
  }
  else
  {
    Error = getLastError();
  }

  if ( Proceed )
  {
    RetValue = SAMPLE_COUNTER;
  }

  if (Commit)
  {
    if ( Proceed )
    {
      commit();
    }
    else
    {
      rollback();
    }
  }

  if ( RetValue == CSMC_DBData::unspecLong )
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DBWriteError(sMessage, "",m_TableName.c_str(),"CPD_SAMPLE::insertSample");
  }

  return RetValue;
}

bool CPD_SAMPLE::insertSampleDetail(long SAMPLE_COUNTER, const std::string& MeasName, double MeasValue)
{
  log("++++++ CPD_SAMPLE::insertSampleDetail",3);

  sSample Sample;

  Sample.MeasName  = MeasName.c_str(); // char pointers !
  Sample.MeasValue = MeasValue;

  return insertSampleDetail(SAMPLE_COUNTER, Sample);

}

bool CPD_SAMPLE::insertSampleDetail(long SAMPLE_COUNTER, sSample & Sample)
{
  log("++++++ CPD_SAMPLE::insertSampleDetail",3);

  bool RetValue = false;

  seqSample SeqSample;

  CIntfData::insert(SeqSample,Sample);

  // m_pPD_SAMPLE_ENTRY->insert will not perform commit statement !
  if ( m_pPD_SAMPLE_ENTRY )
  {
    RetValue = m_pPD_SAMPLE_ENTRY->insertSample(SAMPLE_COUNTER, SeqSample);
  
    if ( RetValue )
    {
      commit();
    }
    else
    {
      rollback();
    }
  }

  return RetValue;
}

seqAnalysis CPD_SAMPLE::SampleToAnalysis(seqSample SeqSamples)
{
  log("++++++ CPD_SAMPLE::SampleToAnalysis",3);

  // shift seqAnalyis into seqSample
  seqAnalysis SeqAnalysis;

  for ( long i = 0 ; i < CIntfData::getLength(SeqSamples) ; ++i )
  {
    sSample Sample;
    CIntfData::getAt(Sample,SeqSamples,i);

    sAnalysis Analysis;

    Analysis.Element       = std::string(Sample.MeasName).c_str(); // char pointers !
    Analysis.Concentration = Sample.MeasValue;

    CIntfData::insert(SeqAnalysis,Analysis);
  }

  return SeqAnalysis;
}

bool CPD_SAMPLE::updateAnalysis(long SAMPLE_COUNTER, seqAnalysis SeqAnalysis, bool Commit, cCBS_ODBC_DBError &Error)
{
  log("++++++ CPD_SAMPLE::updateAnalysis",3);

  // shift seqAnalyis into seqSample
  seqSample SeqSample = AnalysisToSample(SeqAnalysis);

  return updateSample(SAMPLE_COUNTER, SeqSample, Commit, Error);

}

bool CPD_SAMPLE::updateSample(long SAMPLE_COUNTER, seqSample SeqSample, bool Commit, cCBS_ODBC_DBError &Error)
{
  log("++++++ CPD_SAMPLE::updateSample",3);

  bool RetValue = false;
  
  CDateTime Now;

  // insert will be done by using getNextSAMPLE_COUNTER !
  // this is an update now !
  if ( SAMPLE_COUNTER != CSMC_DBData::unspecLong && select ( SAMPLE_COUNTER ) )
  {
    if ( m_pPD_SAMPLE_ENTRY )
    {
      setREVTIME(CDateTime());
      // remove existing data first !
      m_pPD_SAMPLE_ENTRY->deleteSample(SAMPLE_COUNTER);

      // m_pPD_SAMPLE_ENTRY->insert will not perform commit statement !
      RetValue = m_pPD_SAMPLE_ENTRY->insertSample(SAMPLE_COUNTER, SeqSample);

      RetValue = RetValue && update();

      // now update
      if ( Commit )
      {
        if ( RetValue )
        {
          commit();
        }
        else
        {
          cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_DBWriteError(sMessage, "",m_TableName.c_str(),"CPD_SAMPLE::updateSample");
          rollback();
        }
      }
    }
  }

  return RetValue;
}

bool CPD_SAMPLE::updateSampleDetails(long SAMPLE_COUNTER, long SAMPLENO)
{
  log("++++++ CPD_SAMPLE::updateSampleDetails",3);

  bool RetValue = false;

  if ( SAMPLE_COUNTER != CSMC_DBData::unspecLong && select(SAMPLE_COUNTER) )
  {
    setSAMPLENO (SAMPLENO);
    setREVTIME  (CDateTime());

    RetValue = update();
  }

  return RetValue;
}

bool CPD_SAMPLE::updateSampleDetails(long SAMPLE_COUNTER, const std::string& PRODORDERID, long SAMPLEMODE,const std::string& USERCODE)
{
  log("++++++ CPD_SAMPLE::updateSampleDetails",3);

  bool RetValue = false;

  if ( SAMPLE_COUNTER != CSMC_DBData::unspecLong && select(SAMPLE_COUNTER) )
  {
    SAMPLEMODE = CDataConversion::SetInvalidToDefault(SAMPLEMODE,DEF_GC_SAMPLEMODE::automatic,0);

    setPRODORDERID(PRODORDERID);

    setSAMPLEMODE (SAMPLEMODE);
    setUSERCODE   (USERCODE);
    setREVTIME    (CDateTime());

    RetValue = update();
  }

  return RetValue;
}

bool CPD_SAMPLE::updateSampleDetails(long SAMPLE_COUNTER, const std::string& PRODORDERID, long SAMPLEMODE, const std::string& SAMPLELOC, long SAMPLEUSABLE, const std::string& USERCODE, const std::string& SAMPLEID_CUST, long ORIGIN)
{
  log("++++++ CPD_SAMPLE::updateSampleDetails",3);

  bool RetValue = false;

  if ( SAMPLE_COUNTER != CSMC_DBData::unspecLong && select(SAMPLE_COUNTER) )
  {
    SAMPLEMODE = CDataConversion::SetInvalidToDefault(SAMPLEMODE,DEF_GC_SAMPLEMODE::automatic,0);

    if ( PRODORDERID != CSMC_DBData::unspecString )
    {
      setPRODORDERID  (PRODORDERID);
    }
    if ( SAMPLEMODE != CSMC_DBData::unspecLong )
    {
      setSAMPLEMODE   (SAMPLEMODE);
    }
    if ( SAMPLELOC != CSMC_DBData::unspecString )
    {
      setSAMPLELOC    (SAMPLELOC);
    }
    if ( SAMPLEUSABLE != CSMC_DBData::unspecLong )
    {
      // as per table definition 
      // SAMPLEUSABLE == 0 -> sample not usable
      // SAMPLEUSABLE == 1 -> sample usable with sample taken
      // SAMPLEUSABLE == 2 -> sample usable without sample taken
      setSAMPLEUSABLE(SAMPLEUSABLE);
    }
    if ( USERCODE != CSMC_DBData::unspecString )
    {
      setUSERCODE     (USERCODE);
    }
    if ( SAMPLEID_CUST != CSMC_DBData::unspecString )
    {
      setSAMPLEID_CUST(SAMPLEID_CUST);
    }
    
    if ( ORIGIN == -1 )
    {
      setORIGIN       (CSMC_DBData::unspecLong);
    }
    else if ( ORIGIN != CSMC_DBData::unspecLong )
    {
      setORIGIN       (ORIGIN);
    }

    setREVTIME      (CDateTime());

    RetValue = update();
  }

  return RetValue;
}

bool CPD_SAMPLE::updateSampleHeatData(long SAMPLE_COUNTER, const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, cCBS_ODBC_DBError &Error)
{
  bool RetValue = true;

  if ( SAMPLE_COUNTER != CSMC_DBData::unspecLong && select(SAMPLE_COUNTER) )
  {
    if ( HEATID == getHEATID(1) && (TREATID != getTREATID(1) || PLANT != getPLANT(1) || PLANTNO != getPLANTNO(1)) )
    {
      // for different plant the sampleno is null
      setSAMPLENO(CSMC_DBData::unspecLong);
      setDURSINCEHEATANNOUNCEMENT(CSMC_DBData::unspecDouble);
      setDURSINCESTARTOFHEAT(CSMC_DBData::unspecDouble);
    }

    setHEATID(HEATID);
    setTREATID(TREATID);
    setPLANT(PLANT);
    setPLANTNO(PLANTNO);

    RetValue = RetValue && update();
  }

  if (!RetValue)
    Error = getLastError();

  return RetValue;
}

bool CPD_SAMPLE::updateSampleTimes(long SAMPLE_COUNTER, const CDateTime& SAMPLETIME, const CDateTime& RECTIME, const CDateTime& RECTIMELAB, double DURSINCEHEATANNOUNCEMENT, double DURSINCESTARTOFHEAT, bool OverWriteSampleTime)
{
  log("++++++ CPD_SAMPLE::updateSampleTimes",3);

  bool RetValue = false;
  CDateTime now;

  if ( select(SAMPLE_COUNTER) )
  {
    CDateTime ACTSAMPLETIME = CDataConversion::SetInvalidToDefault(SAMPLETIME,now);
              ACTSAMPLETIME = CDataConversion::SetInvalidToDefault(SAMPLETIME,now,CSMC_DBData::unspecDate);
    
    CDateTime ACTRECTIME = CDataConversion::SetInvalidToDefault(RECTIME,now);
              ACTRECTIME = CDataConversion::SetInvalidToDefault(RECTIME,now,CSMC_DBData::unspecDate);

    CDateTime ACTRECTIMELAB = CDataConversion::SetInvalidToDefault(RECTIMELAB,now);
              ACTRECTIMELAB = CDataConversion::SetInvalidToDefault(RECTIMELAB,now,CSMC_DBData::unspecDate);

    if ( OverWriteSampleTime || isNull(CPD_SAMPLE::SAMPLETIME,1) )
    {
      setSAMPLETIME(ACTSAMPLETIME);
    }
    if ( isNull(CPD_SAMPLE::RECTIME,1) )
    {
      setRECTIME(ACTRECTIME);
    }
    if ( isNull(CPD_SAMPLE::RECTIMELAB,1) )
    {
      setRECTIMELAB(ACTRECTIMELAB);
    }


    setDURSINCEHEATANNOUNCEMENT(DURSINCEHEATANNOUNCEMENT);
    setDURSINCESTARTOFHEAT(DURSINCESTARTOFHEAT);

    setREVTIME(now);

    RetValue = update();

  }

  return RetValue;
}

bool CPD_SAMPLE::insertPSSample(long pSampleCounter, const string &pHeatId, const string &pTreatId, const string &pPlant, long pPlantNo, long pLadleNo, const string &pLadleType, long pMeasType, sDate &pDateTime, const string &pUser, bool pCommit, cCBS_ODBC_DBError &pError)
{
  std::stringstream sql;
  CDateTime mSampleTime;

  mSampleTime.SetTime(pDateTime);


  char mLadleNo[256] = "NULL";
  char mLadleType[256] = "NULL";

  if (pLadleNo != DEF::Inv_Long)
    _ltoa(pLadleNo, (char*)mLadleNo, 10);
  if (pLadleType != DEF::Inv_String)
    sprintf(mLadleType,"'%s'",pLadleType.c_str());

  sql << "insert into PD_SAMPLE"
    << "  (SAMPLE_COUNTER, HM_ID, TREATID, PLANT, PLANTNO, LADLENO, LADLETYPE,"
    << "  SAMPLENO, MEASTYPENO, SAMPLETIME, RECTIME,RECTIMELAB, SAMPLEMODE, ORIGIN, USERCODE,REVTIME)"
    << " values (" << pSampleCounter << ", '" << pHeatId << "', '" << pTreatId << "',"
    << "  '" << pPlant << "'," << pPlantNo << ", " << mLadleNo << ", " << mLadleType << ","
    << "  (select nvl(max(SAMPLENO) + 1, 1)"
    << "  from PD_SAMPLE"
    << "  where HM_ID = '" << pHeatId << "'"
    << "    and TREATID = '" << pTreatId << "'"
    << "  and PLANT = '" << pPlant << "'"
    << "  and MEASTYPENO = " << pMeasType << "" 
    << "  and PLANTNO = " << pPlantNo << ")," 
    << " " << pMeasType << ", '" << mSampleTime.toDBString() << "',"
    << "  '" << CDateTime().toDBString() << "',"
    << "  '" << CDateTime().toDBString() << "', 1, 1, '" << pUser << "'," 
    << "  '" << CDateTime().toDBString() << "'"
	  << ")";

  bool result = executeSQL(sql.str());
  if (!result)
    pError = getLastError();

  if (pCommit)
  {
    if (result)
      commit();
    else
      rollback();
  }

  return result;
}


bool CPD_SAMPLE::insertByPrevSample_HMD(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO,long pSampleCounter, long pPrevSampleCounter, sDate &pDateTime, long pManEntry, const string &pUser, const std::string& mLadleType, long mLadleNo,long pMeasType,bool pCommit, cCBS_ODBC_DBError &pError)
{
	std::stringstream sql;
	CDateTime mSampleTime(pDateTime.year, pDateTime.month, pDateTime.day, pDateTime.hour, pDateTime.minute, pDateTime.second, pDateTime.msec, pDateTime.dstFlag);	
	/*sql << "insert into PD_SAMPLE"
		<< "  (SAMPLE_COUNTER, HM_ID,TREATID,PLANT,PLANTNO,LADLENO, LADLETYPE, SAMPLENO, MEASTYPENO, SAMPLETIME,"
		<< "  RECTIME, SAMPLEMODE, ORIGIN, USERCODE) values"
		<< " (select " << pSampleCounter << ",'"<<HEATID<<"','"<<TREATID<<"','"<<PLANT<<"',"<<PLANTNO<<",LADLENO, LADLETYPE, SAMPLENO+1, MEASTYPENO,"
		<< "  '" << mSampleTime.toDBString() << "', '" << CDateTime().toDBString() << "',"
		<< "  SAMPLEMODE, '" << pManEntry << "', '" << pUser << "'"
		<< " from PD_SAMPLE"
		<< " where SAMPLE_COUNTER = " << pPrevSampleCounter << ")";
	*/
	sql << "insert into PD_SAMPLE"
    << "  (SAMPLE_COUNTER, HM_ID, TREATID, PLANT, PLANTNO, LADLENO, LADLETYPE,"
    << "  SAMPLENO, MEASTYPENO, SAMPLETIME, RECTIME,RECTIMELAB, SAMPLEMODE, ORIGIN, USERCODE)"
    << " values (" << pSampleCounter << ", '" << HEATID << "', '" << TREATID << "',"
    << "  '" << PLANT << "'," << PLANTNO << ", " << mLadleNo << ", '" << mLadleType << "',"
    << "  (select nvl(max(SAMPLENO) + 1, 1)"
    << "  from PD_SAMPLE"
    << "  where HM_ID = '" << HEATID << "'"
    << "    and TREATID = '" << TREATID << "'"
    << "  and PLANT = '" << PLANT << "'"
    << "  and MEASTYPENO = " << pMeasType << "" 
    << "  and PLANTNO = " << PLANTNO << ")," 
    << " " << pMeasType << ", '" << mSampleTime.toDBString() << "',"
    << "  '" << CDateTime().toDBString() << "',"
    << "  '" << CDateTime().toDBString() << "', 1, 1, '" << pUser << "')";
	bool result = executeSQL(sql.str());
	
	if (!result)
		pError = getLastError();
	
	if (pCommit)
	{
		if (result)
			commit();
		else
			rollback();
	}

	return result;
}

bool CPD_SAMPLE::selectByType_HMD(std::string HeatID,std::string TreatID,std::string Plant,long PlantNo,long MEASTYPENO)
{
  log("++++++ CPD_SAMPLE::selectByType_HMD",3);

  cleanWhereStatement();
  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_SAMPLE::HM_ID,HeatID);
  addWhereClause(CPD_SAMPLE::TREATID,TreatID);
  addWhereClause(CPD_SAMPLE::PLANT,Plant);
  addWhereClause(CPD_SAMPLE::PLANTNO,PlantNo);
  addWhereClause(CPD_SAMPLE::MEASTYPENO,MEASTYPENO);

  m_Statement += getWhereStatement() + "  ORDER BY SAMPLE_COUNTER DESC ;";

  return CSMC_DBData::select();
}