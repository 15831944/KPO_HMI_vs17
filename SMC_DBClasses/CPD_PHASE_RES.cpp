//## Copyright (C) 2010 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "CIntfData.h"
#include "CDataConversion.h"
#include "CPD_PHASE_RES_ANL.h"
#include "CGC_PhaseContainer.h"
#include "CPD_PHASE_RES.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_PHASE_RES::HEATID("HEATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_PHASE_RES::TREATID("TREATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_PHASE_RES::PLANT("PLANT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_PHASE_RES::RES_PHASENO("RES_PHASENO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_PHASE_RES::REVTIME("REVTIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_PHASE_RES::STEELMASS("STEELMASS");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_PHASE_RES::SLAGMASS("SLAGMASS");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_PHASE_RES::TEMP("TEMP");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_PHASE_RES::DURUNTENDOFPHASE("DURUNTENDOFPHASE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_PHASE_RES::DATEUNTENDOFPHASE("DATEUNTENDOFPHASE");

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_PHASE_RES::CPD_PHASE_RES(cCBS_StdConnection* Connection)
:CSMC_DBData("PD_PHASE_RES",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_PHASE_RES::CPD_PHASE_RES(cCBS_Connection* Connection)
:CSMC_DBData("PD_PHASE_RES",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_PHASE_RES::CPD_PHASE_RES()
:CSMC_DBData("PD_PHASE_RES")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_PHASE_RES::~CPD_PHASE_RES()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Internal heat identifier
std::string CPD_PHASE_RES::getHEATID(long Row)
{
  return getString(CPD_PHASE_RES::HEATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_PHASE_RES::setHEATID(const std::string& value)
{
  setString(CPD_PHASE_RES::HEATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment identifier
std::string CPD_PHASE_RES::getTREATID(long Row)
{
  return getString(CPD_PHASE_RES::TREATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_PHASE_RES::setTREATID(const std::string& value)
{
  setString(CPD_PHASE_RES::TREATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant identifier
std::string CPD_PHASE_RES::getPLANT(long Row)
{
  return getString(CPD_PHASE_RES::PLANT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_PHASE_RES::setPLANT(const std::string& value)
{
  setString(CPD_PHASE_RES::PLANT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Result Phase No for storing into the Result tables
long CPD_PHASE_RES::getRES_PHASENO(long Row)
{
  return getLong(CPD_PHASE_RES::RES_PHASENO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_PHASE_RES::setRES_PHASENO(long value)
{
  setLong(CPD_PHASE_RES::RES_PHASENO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Date and time of last revision
CDateTime CPD_PHASE_RES::getREVTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_PHASE_RES::REVTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_PHASE_RES::setREVTIME(const CDateTime& value)
{
 setString(CPD_PHASE_RES::REVTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
double CPD_PHASE_RES::getSTEELMASS(long Row)
{
  return getDouble(CPD_PHASE_RES::STEELMASS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_PHASE_RES::setSTEELMASS(double value)
{
  setDouble(CPD_PHASE_RES::STEELMASS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
double CPD_PHASE_RES::getSLAGMASS(long Row)
{
  return getDouble(CPD_PHASE_RES::SLAGMASS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_PHASE_RES::setSLAGMASS(double value)
{
  setDouble(CPD_PHASE_RES::SLAGMASS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
double CPD_PHASE_RES::getTEMP(long Row)
{
  return getDouble(CPD_PHASE_RES::TEMP, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_PHASE_RES::setTEMP(double value)
{
  setDouble(CPD_PHASE_RES::TEMP, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Duration from Heat announcment until end of phase
double CPD_PHASE_RES::getDURUNTENDOFPHASE(long Row)
{
  return getDouble(CPD_PHASE_RES::DURUNTENDOFPHASE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_PHASE_RES::setDURUNTENDOFPHASE(double value)
{
  setDouble(CPD_PHASE_RES::DURUNTENDOFPHASE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Calculated DATE of END of Phase
CDateTime CPD_PHASE_RES::getDATEUNTENDOFPHASE(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_PHASE_RES::DATEUNTENDOFPHASE, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_PHASE_RES::setDATEUNTENDOFPHASE(const CDateTime& value)
{
 setString(CPD_PHASE_RES::DATEUNTENDOFPHASE, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPD_PHASE_RES::select(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long RES_PHASENO)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_PHASE_RES::HEATID,HEATID);
  addWhereClause(CPD_PHASE_RES::TREATID,TREATID);
  addWhereClause(CPD_PHASE_RES::PLANT,PLANT);
  addWhereClause(CPD_PHASE_RES::RES_PHASENO,RES_PHASENO);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CPD_PHASE_RES::selectOrderedByDuration(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, bool ASC)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_PHASE_RES::HEATID,HEATID);
  addWhereClause(CPD_PHASE_RES::TREATID,TREATID);
  addWhereClause(CPD_PHASE_RES::PLANT,PLANT);
  
  if ( ASC )
  {
    m_Statement += getWhereStatement() + " ORDER BY DURUNTENDOFPHASE ASC, RES_PHASENO ASC;" ;
  }
  else
  {
    m_Statement += getWhereStatement() + " ORDER BY DURUNTENDOFPHASE DESC, RES_PHASENO DESC;" ;
  }

  return CSMC_DBData::select();
}

bool CPD_PHASE_RES::selectOrderedByResPhaseNo(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, bool ASC)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_PHASE_RES::HEATID,HEATID);
  addWhereClause(CPD_PHASE_RES::TREATID,TREATID);
  addWhereClause(CPD_PHASE_RES::PLANT,PLANT);
  
  if ( ASC )
  {
    m_Statement += getWhereStatement() + " ORDER BY RES_PHASENO ASC;" ;
  }
  else
  {
    m_Statement += getWhereStatement() + " ORDER BY RES_PHASENO DESC;" ;
  }

  return CSMC_DBData::select();
}


void CPD_PHASE_RES::doOnConstruct()
{
  m_PD_PHASE_RES_ANL = new CPD_PHASE_RES_ANL( m_pCBS_StdConnection );
}

void CPD_PHASE_RES::doOnDestruct()
{
  if ( m_PD_PHASE_RES_ANL )
  {
    delete m_PD_PHASE_RES_ANL;
    m_PD_PHASE_RES_ANL = 0;
  }
}

bool CPD_PHASE_RES::exists(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
	cleanWhereStatement();

	m_Statement = "Select HEATID from " + m_TableName;

	addWhereClause(CPD_PHASE_RES::HEATID,HEATID);
	addWhereClause(CPD_PHASE_RES::TREATID,TREATID);
	addWhereClause(CPD_PHASE_RES::PLANT,PLANT);
   
  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }

	return CSMC_DBData::select();
}

bool CPD_PHASE_RES::exists(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT,long RES_PHASENO)
{
	cleanWhereStatement();

	m_Statement = "Select HEATID from " + m_TableName;

	addWhereClause(CPD_PHASE_RES::HEATID,HEATID);
	addWhereClause(CPD_PHASE_RES::TREATID,TREATID);
	addWhereClause(CPD_PHASE_RES::PLANT,PLANT);
	addWhereClause(CPD_PHASE_RES::RES_PHASENO,RES_PHASENO);
   
  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }

	return CSMC_DBData::select();
}

bool CPD_PHASE_RES::write(const std::string& HeatID, const std::string& TreatID, const std::string& Plant, const seqPredRes &SeqPredRes, CDateTime HeatAnnounceTime, bool Commit)
{
  bool      RetValue = true;
  sPredRes PredRes;
  CDateTime EndPhase;

  try
  {
    CGC_PhaseContainer      GC_PhaseContainer(m_pCBS_StdConnection, Plant);

    long PredLength = CIntfData::getLength(SeqPredRes);

    RetValue = !exists(HeatID, TreatID, Plant);
    //some data found -> delete them
    if (!RetValue && PredLength > 0 )
    {
      RetValue = deleteRows();
      if (!RetValue)
        setLastError(std::string("ERROR_DELETE_DATA"), 0, getActStatement());
    }

    for (int i = 0 ; i < PredLength; ++i)
    {
      CIntfData::getAt(PredRes, SeqPredRes, i);

      std::string sPhase = PredRes.Phase;
      long ResPhaseNo    = CSMC_DBData::unspecLong;
      long PhaseNo       = PredRes.PhaseNo;

      ResPhaseNo = GC_PhaseContainer.getResPhaseNo(sPhase,PredRes.PhaseNo);

      if ( ResPhaseNo != CSMC_DBData::unspecLong )
      {
        setHEATID(HeatID);
        setTREATID(TreatID);
        setPLANT(Plant);
        setRES_PHASENO(ResPhaseNo);
        setREVTIME(CDateTime());
        setSTEELMASS(PredRes.GenRes.SteelWeight);
        setSLAGMASS(PredRes.GenRes.SlagWeight);
        setTEMP(PredRes.GenRes.Temp);
        setDURUNTENDOFPHASE( CDataConversion::RoundToDecimals(PredRes.GenRes.MetTimeStamp.DurSinceHeatAnnouncement,1) ); // only x.x minutes
        EndPhase = HeatAnnounceTime;
        EndPhase.addTime(PredRes.GenRes.MetTimeStamp.DurSinceHeatAnnouncement * 60.0);
        setDATEUNTENDOFPHASE(EndPhase);

        RetValue = insert();
       
        if (RetValue)
        {
          RetValue = m_PD_PHASE_RES_ANL->writeAnalysis(HeatID, TreatID, Plant, ResPhaseNo, PredRes.GenRes.Analysis);
        }

        if (Commit)
        {
          if (RetValue)
          {
            commit();
          }
          else
          {
            CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
            sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
            pEventLog->EL_DBWriteError(sMessage, getWhereStatement().c_str(), m_TableName.c_str(), "CPD_PHASE_RES");
            rollback();
          }
        }
      }// if ( ResPhaseNo != CSMC_DBData::unspecLong )
      else
      {
        log("For "+ sPhase + " is no ResPhaseNo",3);
      }
    }// for (int i = 0 ; i < PredResSeqLength ; ++i)
  }
  catch(...)
  {
    RetValue = false;
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DBWriteError(sMessage, "", m_TableName.c_str(), "CPD_PHASE_RES::EXCEPTION");
    rollback();
  }

  return RetValue;
}

bool CPD_PHASE_RES::write(const std::string& HeatID, const std::string& TreatID, const std::string& Plant, const seqRHModelResult &SeqPredRes, CDateTime HeatAnnounceTime, bool Commit)
{
  bool RetValue = true;
  sRHModelResult PredRes;
  CDateTime EndPhase;

  try
  {
    CGC_PhaseContainer      GC_PhaseContainer(m_pCBS_StdConnection, Plant);

    long PredLength = CIntfData::getLength(SeqPredRes);

    RetValue = !exists(HeatID, TreatID, Plant);
    //some data found -> delete them
    if (!RetValue && PredLength > 0 )
    {
      RetValue = deleteRows();
      if (!RetValue)
        setLastError(std::string("ERROR_DELETE_DATA"), 0, getActStatement());
    }

    for (int i = 0 ; i < PredLength; ++i)
    {
      CIntfData::getAt(PredRes, SeqPredRes, i);

      std::string sPhase = PredRes.PhaseName;
      long ResPhaseNo    = CSMC_DBData::unspecLong;
      long PhaseNo       = PredRes.PhaseNo;

      ResPhaseNo = GC_PhaseContainer.getResPhaseNo(sPhase,PredRes.PhaseNo);

      if (  ResPhaseNo != PredRes.Res_PhaseNoModel)
      {
        std::string Msg = "For "+ sPhase + " is PhaseContainerNo." + CDataConversion::LongToString(ResPhaseNo) + " != RHModelNo." + CDataConversion::LongToString(PredRes.Res_PhaseNoModel);
        log(Msg,3);
      }

      setHEATID(HeatID);
      setTREATID(TreatID);
      setPLANT(Plant);
      setRES_PHASENO(ResPhaseNo);
      setREVTIME(CDateTime());
      setSTEELMASS(PredRes.SteelWeight);
      setSLAGMASS(PredRes.SlagWeight);
      setTEMP(PredRes.HeatTemp);
      setDURUNTENDOFPHASE(CDataConversion::RoundToDecimals(PredRes.DurSinceHeatAnnouncement,1)); // only x.x minutes
      EndPhase = HeatAnnounceTime;
      EndPhase.addTime(PredRes.DurSinceHeatAnnouncement * 60.0);
      setDATEUNTENDOFPHASE(EndPhase);

      if ( select(HeatID, TreatID, Plant, ResPhaseNo) )
      {
        RetValue = update();
      }
      else
      {
        RetValue = insert();
      }

      if (RetValue)
      {
        RetValue = m_PD_PHASE_RES_ANL->writeAnalysis(HeatID, TreatID, Plant, ResPhaseNo, PredRes.Analysis);
      }

      if (Commit)
      {
        if (RetValue)
        {
          commit();
        }
        else
        {
          rollback();
        }
      }
    }// for (int i = 0 ; i < PredResSeqLength ; ++i)
  }
  catch(...)
  {
    RetValue = false;
    rollback();
  }

  return RetValue;
}

bool CPD_PHASE_RES::write(const std::string& HeatID, const std::string& TreatID, const std::string& Plant, long Res_PhaseNo, const sPredRes& PredRes, CDateTime HeatAnnounceTime)
{
  bool      RetValue = true;
  CDateTime EndPhase;

  try
  {
    setHEATID(HeatID);
    setTREATID(TreatID);
    setPLANT(Plant);
    setRES_PHASENO(Res_PhaseNo);
    setREVTIME(CDateTime());
    setSTEELMASS(PredRes.GenRes.SteelWeight);
    setSLAGMASS(PredRes.GenRes.SlagWeight);
    setTEMP(PredRes.GenRes.Temp);
    setDURUNTENDOFPHASE( CDataConversion::RoundToDecimals(PredRes.GenRes.MetTimeStamp.DurSinceHeatAnnouncement,1) ); // only x.x minutes
    EndPhase = HeatAnnounceTime;
    EndPhase.addTime(PredRes.GenRes.MetTimeStamp.DurSinceHeatAnnouncement * 60.0);
    setDATEUNTENDOFPHASE(EndPhase);

    if ( select(HeatID, TreatID, Plant, Res_PhaseNo) )
    {
      RetValue = update();
    }
    else
    {
      RetValue = insert();
    }

    if (RetValue)
    {
      RetValue = m_PD_PHASE_RES_ANL->writeAnalysis(HeatID, TreatID, Plant, Res_PhaseNo, PredRes.GenRes.Analysis);
    }

    // commit only if own values and analysis values are successfully written
    if (RetValue)
    {
      commit();
    }
    else
    {
      rollback();
    }
  }
  catch(...)
  {
    RetValue = false;
    rollback();
  }

  return RetValue;
}

bool CPD_PHASE_RES::write(const std::string& HeatID, const std::string& TreatID, const std::string& Plant, long Res_PhaseNo, const sAODPredBlowRes& PredRes)
{
  bool      RetValue = true;
  CDateTime now;
  CDateTime EndPhase;

  try
  {
    cleanWhereStatement();

    addWhereClause(CPD_PHASE_RES::HEATID,HeatID);
    addWhereClause(CPD_PHASE_RES::TREATID,TreatID);
    addWhereClause(CPD_PHASE_RES::PLANT,Plant);
    addWhereClause(CPD_PHASE_RES::RES_PHASENO,Res_PhaseNo);

    setHEATID(HeatID);
    setTREATID(TreatID);
    setPLANT(Plant);
    setRES_PHASENO(Res_PhaseNo);
    setREVTIME(now);
    setSTEELMASS(PredRes.GenRes.SteelWeight);
    setSLAGMASS(PredRes.GenRes.SlagWeight);
    setTEMP(PredRes.GenRes.Temp);
    setDURUNTENDOFPHASE(PredRes.GenRes.MetTimeStamp.DurSinceHeatAnnouncement);
    EndPhase = now;
    EndPhase.addTime(PredRes.GenRes.MetTimeStamp.DurSinceHeatAnnouncement * 60.0);
    setDATEUNTENDOFPHASE(EndPhase);

    if (select(HeatID, TreatID, Plant, Res_PhaseNo))
      RetValue = update();
    else
      RetValue = insert();

    //RetValue = updateOrInsert();

    if (CIntfData::getLength(PredRes.GenRes.Analysis) > 0)
    {
      if (RetValue)
      {
        RetValue = m_PD_PHASE_RES_ANL->writeAnalysis(HeatID, TreatID, Plant, Res_PhaseNo, PredRes.GenRes.Analysis);
      }
    }
    else
      log("No analysis for ResPhaseNo",2);
  }
  catch(...)
  {
    RetValue = false;
  }
  return RetValue;
}

bool CPD_PHASE_RES::write(const std::string& HeatID, const std::string& TreatID, const std::string& Plant, long Res_PhaseNo, const sBOFPredBlowRes& PredRes)
{
  bool      RetValue = true;
  CDateTime now;
  CDateTime EndPhase;

  try
  {
    setHEATID(HeatID);
    setTREATID(TreatID);
    setPLANT(Plant);
    setRES_PHASENO(Res_PhaseNo);
    setREVTIME(now);
    setSTEELMASS(PredRes.GenRes.SteelWeight);
    setSLAGMASS(PredRes.GenRes.SlagWeight);
    setTEMP(PredRes.GenRes.Temp);
    setDURUNTENDOFPHASE(PredRes.GenRes.MetTimeStamp.DurSinceHeatAnnouncement);
    EndPhase = now;
    EndPhase.addTime(PredRes.GenRes.MetTimeStamp.DurSinceHeatAnnouncement * 60.0);
    setDATEUNTENDOFPHASE(EndPhase);

    if ( select(HeatID, TreatID, Plant, Res_PhaseNo) )
        RetValue = update();
      else
        RetValue = insert();

    if (CIntfData::getLength(PredRes.GenRes.Analysis) > 0)
    {
      if (RetValue)
      {
        RetValue = m_PD_PHASE_RES_ANL->writeAnalysis(HeatID, TreatID, Plant, Res_PhaseNo, PredRes.GenRes.Analysis);
      }
    }
    else
      log("No analysis for ResPhaseNo",2);

    // commit only if own values and analysis values are successfully written
    if (RetValue)
    {
      commit();
    }
    else
    {
      rollback();
    }
  }
  catch(...)
  {
   RetValue = false;
   rollback();
  }
  return RetValue;
}

//deb 
bool CPD_PHASE_RES::write(const std::string& HeatID, const std::string& TreatID, const std::string& Plant, const sRHModelResult& RHModelResult)
{
	bool      RetValue = true;
	CDateTime Now;
	CDateTime EndPhase;
	long Res_PhaseNo = RHModelResult.PhaseNo;

	try
	{
		setHEATID(HeatID);
		setTREATID(TreatID);
		setPLANT(Plant);
		setRES_PHASENO(Res_PhaseNo);
		setREVTIME(Now);
		setSTEELMASS(RHModelResult.SteelWeight);
		setSLAGMASS(RHModelResult.SlagWeight);
		setTEMP(RHModelResult.HeatTemp);
		setDURUNTENDOFPHASE(RHModelResult.RemDur);
		EndPhase = Now;
		EndPhase.addTime(RHModelResult.RemDur);
		setDATEUNTENDOFPHASE(EndPhase);

		if (select(HeatID, TreatID, Plant, Res_PhaseNo))
			RetValue = update();
		else
			RetValue = insert();

		if (RetValue)
		{
			RetValue = m_PD_PHASE_RES_ANL->writeAnalysis(HeatID, TreatID, Plant, Res_PhaseNo, RHModelResult.Analysis);
		}

		// commit only if own values and analysis values are successfully written
		if (RetValue)
		{
			commit();
		}
		else
		{
			rollback();
		}
	}
	catch(...)
	{
		RetValue = false;
		rollback();
	}
	return RetValue;
}

bool CPD_PHASE_RES::writeActPhase(const std::string& HeatID, const std::string& TreatID, const std::string& Plant, const seqPredRes &SeqPredRes, CDateTime HeatAnnounceTime, bool Commit)
{
  bool      RetValue = true;
  sPredRes PredRes;
  CDateTime EndPhase;

  try
  {
    CGC_PhaseContainer      GC_PhaseContainer(m_pCBS_StdConnection, Plant);

    long PredLength = CIntfData::getLength(SeqPredRes);
    //  work only for actual data, stored at first place in structure
    CIntfData::getAt(PredRes, SeqPredRes, 0);

    std::string sPhase = PredRes.Phase;
    long ResPhaseNo    = CSMC_DBData::unspecLong;
    long PhaseNo       = PredRes.PhaseNo;

    ResPhaseNo = GC_PhaseContainer.getResPhaseNo(sPhase,PredRes.PhaseNo);

    if ( ResPhaseNo != CSMC_DBData::unspecLong )
    {
       RetValue = !exists(HeatID, TreatID, Plant,ResPhaseNo);
       //some data for actual phase found -> delete them
       if (!RetValue && PredLength > 0 )
       {
         RetValue = deleteRows();
         if (!RetValue)
        setLastError(std::string("ERROR_DELETE_DATA"), 0, getActStatement());
       }

      setHEATID(HeatID);
      setTREATID(TreatID);
      setPLANT(Plant);
      setRES_PHASENO(ResPhaseNo);
      setREVTIME(CDateTime());
      setSTEELMASS(PredRes.GenRes.SteelWeight);
      setSLAGMASS(PredRes.GenRes.SlagWeight);
      setTEMP(PredRes.GenRes.Temp);
      setDURUNTENDOFPHASE( CDataConversion::RoundToDecimals(PredRes.GenRes.MetTimeStamp.DurSinceHeatAnnouncement,1) ); // only x.x minutes
      EndPhase = HeatAnnounceTime;
      EndPhase.addTime(PredRes.GenRes.MetTimeStamp.DurSinceHeatAnnouncement * 60.0);
      setDATEUNTENDOFPHASE(EndPhase);

      RetValue = insert();
       
      if (RetValue)
      {
        RetValue = m_PD_PHASE_RES_ANL->writeAnalysis(HeatID, TreatID, Plant, ResPhaseNo, PredRes.GenRes.Analysis);
      }

      if (Commit)
      {
        if (RetValue)
        {
            commit();
        }
        else
        {
            CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
            sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
            pEventLog->EL_DBWriteError(sMessage, getWhereStatement().c_str(), m_TableName.c_str(), "CPD_PHASE_RES");
            rollback();
        }
      }
    }// if ( ResPhaseNo != CSMC_DBData::unspecLong )
    else
    {
        log("For "+ sPhase + " is no ResPhaseNo",3);
    }
  }
  catch(...)
  {
    RetValue = false;
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DBWriteError(sMessage, "", m_TableName.c_str(), "CPD_PHASE_RES::EXCEPTION");
    rollback();
  }

  return RetValue;
}


