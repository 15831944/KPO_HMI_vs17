//## Copyright (C) 2010 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "CPP_HEAT.h"
#include "CPP_HEAT_PLANT.h"
#include "CPP_ORDER.h"
#include "CPP_ORDER_SINGLE_AIMS.h"
#include "CShiftCrewData.h"
#include "CPD_HEAT_REF.h"
#include "CPD_HEAT_PLANT_REF.h"
#include "CPD_LADLE_LIFE_DATA.h"
#include "CPD_LADLE.h"
#include "CPD_SAMPLE.h"
#include "CGT_PARAM.h"
#include "DEF_GC_MEASUREMENT_TYPE.h"
#include "DEF_GC_PP_ORDER_SINGLE_AIMS.h"
#include "DEF_GC_MEMBER_ROLE_CAT.h"
#include "DEF_GC_LADLE_PARTS.h"
#include "DEF_GC_PARAM_TYPE.h"
#include "CDataConversion.h"
#include "CPD_HEAT_DATA.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::HEATID("HEATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::TREATID("TREATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::PLANT("PLANT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::STEELGRADECODE_PLAN("STEELGRADECODE_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::STEELGRADECODE_ACT("STEELGRADECODE_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::PRODORDERID_PLAN("PRODORDERID_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::PRODORDERID_ACT("PRODORDERID_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::AIMSTEELWGT_PLAN("AIMSTEELWGT_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::AIMSTEELWGT_MOD("AIMSTEELWGT_MOD");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::AIMTEMP_PLAN("AIMTEMP_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::AIMTEMP_MOD("AIMTEMP_MOD");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::HEATANNOUNCE_OFFLINE("HEATANNOUNCE_OFFLINE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::HEATANNOUNCE_ACT("HEATANNOUNCE_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::TREATSTART_PLAN("TREATSTART_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::TREATSTART_MOD("TREATSTART_MOD");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::TREATSTART_ACT("TREATSTART_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::TREATEND_PLAN("TREATEND_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::TREATEND_MOD("TREATEND_MOD");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::TREATEND_CALC("TREATEND_CALC");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::TREATEND_ACT("TREATEND_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::HEATDEPARTURE_ACT("HEATDEPARTURE_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::TREATEND_PREV("TREATEND_PREV");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::LADLETYPE("LADLETYPE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::LADLENO("LADLENO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::STEELMASS("STEELMASS");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::SLAGMASS("SLAGMASS");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::SAMPLE_REF("SAMPLE_REF");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::REVTIME("REVTIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::USERCODE("USERCODE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::TEMP_SAMPLES("TEMP_SAMPLES");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::STEEL_SAMPLES("STEEL_SAMPLES");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::SLAG_SAMPLES("SLAG_SAMPLES");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::STEELMASS_START("STEELMASS_START");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::SLAGMASS_START("SLAGMASS_START");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::ROUTECODE_PLAN("ROUTECODE_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::ROUTECODE_ACT("ROUTECODE_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::TREATMENTDURATION("TREATMENTDURATION");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::FINALTEMP("FINALTEMP");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::SHIFT_ID("SHIFT_ID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::CREW_ID("CREW_ID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::CREW_RESPONSIBILITY("CREW_RESPONSIBILITY");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::HEAT_RESPONSIBILITY("HEAT_RESPONSIBILITY");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA::COMMENTS("COMMENTS");

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HEAT_DATA::CPD_HEAT_DATA(cCBS_StdConnection* Connection)
:CSMC_DBData("PD_HEAT_DATA",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HEAT_DATA::CPD_HEAT_DATA(cCBS_Connection* Connection)
:CSMC_DBData("PD_HEAT_DATA",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HEAT_DATA::CPD_HEAT_DATA()
:CSMC_DBData("PD_HEAT_DATA")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HEAT_DATA::~CPD_HEAT_DATA()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Internal heat identifier
std::string CPD_HEAT_DATA::getHEATID(long Row)
{
  return getString(CPD_HEAT_DATA::HEATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setHEATID(const std::string& value)
{
  setString(CPD_HEAT_DATA::HEATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment identifier
std::string CPD_HEAT_DATA::getTREATID(long Row)
{
  return getString(CPD_HEAT_DATA::TREATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setTREATID(const std::string& value)
{
  setString(CPD_HEAT_DATA::TREATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant identifier
std::string CPD_HEAT_DATA::getPLANT(long Row)
{
  return getString(CPD_HEAT_DATA::PLANT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setPLANT(const std::string& value)
{
  setString(CPD_HEAT_DATA::PLANT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Planned steel grade code
std::string CPD_HEAT_DATA::getSTEELGRADECODE_PLAN(long Row)
{
  return getString(CPD_HEAT_DATA::STEELGRADECODE_PLAN, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setSTEELGRADECODE_PLAN(const std::string& value)
{
  setString(CPD_HEAT_DATA::STEELGRADECODE_PLAN, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Actual Steel grade code
std::string CPD_HEAT_DATA::getSTEELGRADECODE_ACT(long Row)
{
  return getString(CPD_HEAT_DATA::STEELGRADECODE_ACT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setSTEELGRADECODE_ACT(const std::string& value)
{
  setString(CPD_HEAT_DATA::STEELGRADECODE_ACT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##From PP_ORDER as planned
std::string CPD_HEAT_DATA::getPRODORDERID_PLAN(long Row)
{
  return getString(CPD_HEAT_DATA::PRODORDERID_PLAN, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setPRODORDERID_PLAN(const std::string& value)
{
  setString(CPD_HEAT_DATA::PRODORDERID_PLAN, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##From PP_ORDER but modified
std::string CPD_HEAT_DATA::getPRODORDERID_ACT(long Row)
{
  return getString(CPD_HEAT_DATA::PRODORDERID_ACT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setPRODORDERID_ACT(const std::string& value)
{
  setString(CPD_HEAT_DATA::PRODORDERID_ACT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Aim steel weight according production order.
double CPD_HEAT_DATA::getAIMSTEELWGT_PLAN(long Row)
{
  return getDouble(CPD_HEAT_DATA::AIMSTEELWGT_PLAN, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setAIMSTEELWGT_PLAN(double value)
{
  setDouble(CPD_HEAT_DATA::AIMSTEELWGT_PLAN, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Aim steel weight according operator. (= Order if not changed)
double CPD_HEAT_DATA::getAIMSTEELWGT_MOD(long Row)
{
  return getDouble(CPD_HEAT_DATA::AIMSTEELWGT_MOD, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setAIMSTEELWGT_MOD(double value)
{
  setDouble(CPD_HEAT_DATA::AIMSTEELWGT_MOD, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Aim temperature according plan.
double CPD_HEAT_DATA::getAIMTEMP_PLAN(long Row)
{
  return getDouble(CPD_HEAT_DATA::AIMTEMP_PLAN, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setAIMTEMP_PLAN(double value)
{
  setDouble(CPD_HEAT_DATA::AIMTEMP_PLAN, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Aim temperature according operator modification
double CPD_HEAT_DATA::getAIMTEMP_MOD(long Row)
{
  return getDouble(CPD_HEAT_DATA::AIMTEMP_MOD, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setAIMTEMP_MOD(double value)
{
  setDouble(CPD_HEAT_DATA::AIMTEMP_MOD, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##In case a model supports offline calculation for e.g. scrap order this time stamp is used to have a complete time line for the heat
CDateTime CPD_HEAT_DATA::getHEATANNOUNCE_OFFLINE(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HEAT_DATA::HEATANNOUNCE_OFFLINE, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setHEATANNOUNCE_OFFLINE(const CDateTime& value)
{
 setString(CPD_HEAT_DATA::HEATANNOUNCE_OFFLINE, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Heat announcement time
CDateTime CPD_HEAT_DATA::getHEATANNOUNCE_ACT(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HEAT_DATA::HEATANNOUNCE_ACT, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setHEATANNOUNCE_ACT(const CDateTime& value)
{
 setString(CPD_HEAT_DATA::HEATANNOUNCE_ACT, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment start from schedule
CDateTime CPD_HEAT_DATA::getTREATSTART_PLAN(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HEAT_DATA::TREATSTART_PLAN, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setTREATSTART_PLAN(const CDateTime& value)
{
 setString(CPD_HEAT_DATA::TREATSTART_PLAN, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment start, schedule modified
CDateTime CPD_HEAT_DATA::getTREATSTART_MOD(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HEAT_DATA::TREATSTART_MOD, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setTREATSTART_MOD(const CDateTime& value)
{
 setString(CPD_HEAT_DATA::TREATSTART_MOD, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Actual treatment start
CDateTime CPD_HEAT_DATA::getTREATSTART_ACT(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HEAT_DATA::TREATSTART_ACT, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setTREATSTART_ACT(const CDateTime& value)
{
 setString(CPD_HEAT_DATA::TREATSTART_ACT, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment end from schedule
CDateTime CPD_HEAT_DATA::getTREATEND_PLAN(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HEAT_DATA::TREATEND_PLAN, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setTREATEND_PLAN(const CDateTime& value)
{
 setString(CPD_HEAT_DATA::TREATEND_PLAN, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment end, schedule modified
CDateTime CPD_HEAT_DATA::getTREATEND_MOD(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HEAT_DATA::TREATEND_MOD, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setTREATEND_MOD(const CDateTime& value)
{
 setString(CPD_HEAT_DATA::TREATEND_MOD, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment end time calculated by model
CDateTime CPD_HEAT_DATA::getTREATEND_CALC(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HEAT_DATA::TREATEND_CALC, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setTREATEND_CALC(const CDateTime& value)
{
 setString(CPD_HEAT_DATA::TREATEND_CALC, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Actual treatment end
CDateTime CPD_HEAT_DATA::getTREATEND_ACT(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HEAT_DATA::TREATEND_ACT, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setTREATEND_ACT(const CDateTime& value)
{
 setString(CPD_HEAT_DATA::TREATEND_ACT, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Heat departure time
CDateTime CPD_HEAT_DATA::getHEATDEPARTURE_ACT(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HEAT_DATA::HEATDEPARTURE_ACT, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setHEATDEPARTURE_ACT(const CDateTime& value)
{
 setString(CPD_HEAT_DATA::HEATDEPARTURE_ACT, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Last treatment end, should be filled from PD_PLANTSTATUS_PLANT.LASTTREATENDTIME
CDateTime CPD_HEAT_DATA::getTREATEND_PREV(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HEAT_DATA::TREATEND_PREV, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setTREATEND_PREV(const CDateTime& value)
{
 setString(CPD_HEAT_DATA::TREATEND_PREV, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##e.g. Hot Metal -> H, Teeming -> T
std::string CPD_HEAT_DATA::getLADLETYPE(long Row)
{
  return getString(CPD_HEAT_DATA::LADLETYPE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setLADLETYPE(const std::string& value)
{
  setString(CPD_HEAT_DATA::LADLETYPE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique ladle number
long CPD_HEAT_DATA::getLADLENO(long Row)
{
  return getLong(CPD_HEAT_DATA::LADLENO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setLADLENO(long value)
{
  setLong(CPD_HEAT_DATA::LADLENO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Cummulated steel mass from all additions, Eng. Unit : kg, 
double CPD_HEAT_DATA::getSTEELMASS(long Row)
{
  return getDouble(CPD_HEAT_DATA::STEELMASS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setSTEELMASS(double value)
{
  setDouble(CPD_HEAT_DATA::STEELMASS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Cummulated slag mass from all additions, Eng. Unit : kg, 
double CPD_HEAT_DATA::getSLAGMASS(long Row)
{
  return getDouble(CPD_HEAT_DATA::SLAGMASS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setSLAGMASS(double value)
{
  setDouble(CPD_HEAT_DATA::SLAGMASS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique sample reference
long CPD_HEAT_DATA::getSAMPLE_REF(long Row)
{
  return getLong(CPD_HEAT_DATA::SAMPLE_REF, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setSAMPLE_REF(long value)
{
  setLong(CPD_HEAT_DATA::SAMPLE_REF, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Date and time of last revision
CDateTime CPD_HEAT_DATA::getREVTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HEAT_DATA::REVTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setREVTIME(const CDateTime& value)
{
 setString(CPD_HEAT_DATA::REVTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
std::string CPD_HEAT_DATA::getUSERCODE(long Row)
{
  return getString(CPD_HEAT_DATA::USERCODE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setUSERCODE(const std::string& value)
{
  setString(CPD_HEAT_DATA::USERCODE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Number of taken temperature measurements
long CPD_HEAT_DATA::getTEMP_SAMPLES(long Row)
{
  return getLong(CPD_HEAT_DATA::TEMP_SAMPLES, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setTEMP_SAMPLES(long value)
{
  setLong(CPD_HEAT_DATA::TEMP_SAMPLES, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Number of taken steel analysis measurements
long CPD_HEAT_DATA::getSTEEL_SAMPLES(long Row)
{
  return getLong(CPD_HEAT_DATA::STEEL_SAMPLES, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setSTEEL_SAMPLES(long value)
{
  setLong(CPD_HEAT_DATA::STEEL_SAMPLES, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Number of taken slag analysis measurements
long CPD_HEAT_DATA::getSLAG_SAMPLES(long Row)
{
  return getLong(CPD_HEAT_DATA::SLAG_SAMPLES, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setSLAG_SAMPLES(long value)
{
  setLong(CPD_HEAT_DATA::SLAG_SAMPLES, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Steel mass at begin of treatment
double CPD_HEAT_DATA::getSTEELMASS_START(long Row)
{
  return getDouble(CPD_HEAT_DATA::STEELMASS_START, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setSTEELMASS_START(double value)
{
  setDouble(CPD_HEAT_DATA::STEELMASS_START, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Slag mass at begin of treatment
double CPD_HEAT_DATA::getSLAGMASS_START(long Row)
{
  return getDouble(CPD_HEAT_DATA::SLAGMASS_START, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setSLAGMASS_START(double value)
{
  setDouble(CPD_HEAT_DATA::SLAGMASS_START, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Planned route code
std::string CPD_HEAT_DATA::getROUTECODE_PLAN(long Row)
{
  return getString(CPD_HEAT_DATA::ROUTECODE_PLAN, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setROUTECODE_PLAN(const std::string& value)
{
  setString(CPD_HEAT_DATA::ROUTECODE_PLAN, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Actual route code
std::string CPD_HEAT_DATA::getROUTECODE_ACT(long Row)
{
  return getString(CPD_HEAT_DATA::ROUTECODE_ACT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setROUTECODE_ACT(const std::string& value)
{
  setString(CPD_HEAT_DATA::ROUTECODE_ACT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment duration
double CPD_HEAT_DATA::getTREATMENTDURATION(long Row)
{
  return getDouble(CPD_HEAT_DATA::TREATMENTDURATION, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setTREATMENTDURATION(double value)
{
  setDouble(CPD_HEAT_DATA::TREATMENTDURATION, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Final temperature (measured or calculated, plant dependend)
double CPD_HEAT_DATA::getFINALTEMP(long Row)
{
  return getDouble(CPD_HEAT_DATA::FINALTEMP, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setFINALTEMP(double value)
{
  setDouble(CPD_HEAT_DATA::FINALTEMP, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Shift of Production
std::string CPD_HEAT_DATA::getSHIFT_ID(long Row)
{
  return getString(CPD_HEAT_DATA::SHIFT_ID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setSHIFT_ID(const std::string& value)
{
  setString(CPD_HEAT_DATA::SHIFT_ID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Identification of working crew
std::string CPD_HEAT_DATA::getCREW_ID(long Row)
{
  return getString(CPD_HEAT_DATA::CREW_ID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setCREW_ID(const std::string& value)
{
  setString(CPD_HEAT_DATA::CREW_ID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Responsible person of crew, typically the foreman
std::string CPD_HEAT_DATA::getCREW_RESPONSIBILITY(long Row)
{
  return getString(CPD_HEAT_DATA::CREW_RESPONSIBILITY, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setCREW_RESPONSIBILITY(const std::string& value)
{
  setString(CPD_HEAT_DATA::CREW_RESPONSIBILITY, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Crew member (MEMBER_ID), reponsible for the heat, if required
std::string CPD_HEAT_DATA::getHEAT_RESPONSIBILITY(long Row)
{
  return getString(CPD_HEAT_DATA::HEAT_RESPONSIBILITY, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setHEAT_RESPONSIBILITY(const std::string& value)
{
  setString(CPD_HEAT_DATA::HEAT_RESPONSIBILITY, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Free text for operator comments.
std::string CPD_HEAT_DATA::getCOMMENTS(long Row)
{
  return getString(CPD_HEAT_DATA::COMMENTS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA::setCOMMENTS(const std::string& value)
{
  setString(CPD_HEAT_DATA::COMMENTS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPD_HEAT_DATA::select(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_HEAT_DATA::HEATID,HEATID);
  addWhereClause(CPD_HEAT_DATA::TREATID,TREATID);
  addWhereClause(CPD_HEAT_DATA::PLANT,PLANT);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CPD_HEAT_DATA::selectByPRODORDERID_ACT_ValidNotFinished(const std::string& PRODORDERID_ACT, const std::string& PLANT, long PLANTNO)
{
  cleanWhereStatement();

  m_Statement = "Select " + m_TableName + ".* from " + m_TableName + " , PD_HEAT_PLANT_REF hpr ";

  addWhereClause("hpr.EXPIRATIONDATE is NULL");
  addWhereClause(CPD_HEAT_DATA::PLANT,PLANT);
  
  if (CSMC_DBData::unspecLong != PLANTNO)
  {
    addWhereClause("hpr.PLANTNO = " + CDataConversion::LongToString(PLANTNO));
  }

  addWhereClause(CPD_HEAT_DATA::PRODORDERID_ACT,PRODORDERID_ACT);
  addWhereClause(CPD_HEAT_DATA::TREATEND_ACT + " is null");
  addWhereClause("hpr.HEATID = " + m_TableName + ".HEATID");
  addWhereClause("hpr.TREATID = " + m_TableName + ".TREATID");
  addWhereClause("hpr.PLANT = " + m_TableName + ".PLANT");

  m_Statement += getWhereStatement();

  return CSMC_DBData::select();
}

bool CPD_HEAT_DATA::selectByREVTIME(const CDateTime& REVTIME, const std::string& Operator)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_HEAT_DATA::REVTIME, REVTIME, Operator );

  m_Statement += getWhereStatement() + " order by REVTIME desc;";

  return CSMC_DBData::select();
}

bool CPD_HEAT_DATA::selectCurrentHeat(const std::string &PLANT)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;
  addWhereClause(CPD_HEAT_DATA::PLANT,PLANT);
  addWhereClause(CPD_HEAT_DATA::TREATEND_ACT +" is null");

  m_Statement += getWhereStatement() + " ORDER BY " + CPD_HEAT_DATA::HEATANNOUNCE_ACT + " DESC;";

  return CSMC_DBData::select();
}

// heats are defined as "in production" when
// PP_HEAT.PLANNED = 0 and
// PD_HEAT_PLANT_REF. EXPIRATIONDATE is NULL and
// PD_HEAT_DATA.HEATANNOUNCE_ACT is NOT null and
// PD_HEAT_DATA.TREATSTART_ACT is NOT null and
// PD_HEAT_DATA.TREATEND_ACT is null 
bool CPD_HEAT_DATA::selectHeatInProduction(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
  // select heats in treatment
  // select heats with start time but without end time
  // ordered by actual start time

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName + ",PD_HEAT_PLANT_REF";

  addWhereClause(CPD_HEAT_DATA::HEATID, HEATID);
  addWhereClause(CPD_HEAT_DATA::TREATID, TREATID);
  addWhereClause(CPD_HEAT_DATA::PLANT, PLANT);

  addWhereClauseforNULL(CPD_HEAT_DATA::TREATSTART_ACT, false);
  addWhereClauseforNULL(CPD_HEAT_DATA::HEATANNOUNCE_ACT, false);
  addWhereClauseforNULL(CPD_HEAT_DATA::TREATEND_ACT);

  addWhereClauseforJoin(CPD_HEAT_DATA::HEATID, "PD_HEAT_PLANT_REF", CPD_HEAT_PLANT_REF::HEATID);
  addWhereClauseforJoin(CPD_HEAT_DATA::TREATID,"PD_HEAT_PLANT_REF", CPD_HEAT_PLANT_REF::TREATID);
  addWhereClauseforJoin(CPD_HEAT_DATA::PLANT,  "PD_HEAT_PLANT_REF", CPD_HEAT_PLANT_REF::PLANT);

  m_Statement += getWhereStatement();
  m_Statement += " order by PD_HEAT_DATA.TREATSTART_ACT;";

  return CSMC_DBData::select();

}

bool CPD_HEAT_DATA::selectHeatsAnnounced(const std::string& PLANT, long PLANTNO)
{
  // select announced heats
  // select heats with announced time but without start time ordered by planed start time

  cleanWhereStatement();

  m_Statement = "Select pdh.* from " + m_TableName + " pdh, PD_HEAT_PLANT_REF hpr ";

  m_Statement += " where hpr.EXPIRATIONDATE is NULL";
  m_Statement += " and hpr.PLANTNO = " + CDataConversion::LongToString(PLANTNO); 
  m_Statement += " and pdh.HEATANNOUNCE_ACT is NOT null";
  m_Statement += " and pdh.HEATDEPARTURE_ACT is null";
  m_Statement += " and pdh.PLANT = '" + PLANT + "'";
  m_Statement += " and pdh.HEATID = hpr.HEATID";
  m_Statement += " and pdh.TREATID = hpr.TREATID";
  m_Statement += " and pdh.PLANT = hpr.PLANT";
  m_Statement += " order by pdh.TREATSTART_MOD;";

  return CSMC_DBData::select();
}

bool CPD_HEAT_DATA::selectHeatsInTreatment(const std::string& PLANT, long PLANTNO)
{
  // select heats in treatment
  // select heats with start time but without end time
  // ordered by actual start time

  cleanWhereStatement();

  m_Statement = "Select pdh.* from " + m_TableName + " pdh, PD_HEAT_PLANT_REF hpr ";

  m_Statement += " where hpr.EXPIRATIONDATE is NULL";
  m_Statement += " and hpr.PLANTNO = " + CDataConversion::LongToString(PLANTNO); 
  m_Statement += " and pdh.TREATSTART_ACT is NOT null";
  m_Statement += " and pdh.HEATANNOUNCE_ACT is NOT null";
  m_Statement += " and pdh.TREATEND_ACT is null";
  m_Statement += " and pdh.HEATDEPARTURE_ACT is null";
  m_Statement += " and pdh.PLANT = '" + PLANT + "'";
  m_Statement += " and pdh.HEATID = hpr.HEATID";
  m_Statement += " and pdh.TREATID = hpr.TREATID";
  m_Statement += " and pdh.PLANT = hpr.PLANT";
  m_Statement += " order by pdh.TREATSTART_ACT;";

  return CSMC_DBData::select();
}

bool CPD_HEAT_DATA::selectHeatsPrepared(const std::string& PLANT, long PLANTNO)
{
  // select offline announced heats
  // ordered by planed start time
  
  cleanWhereStatement();

  m_Statement = "Select pdh.* from " + m_TableName + " pdh, PD_HEAT_PLANT_REF hpr ";

  m_Statement += " where hpr.EXPIRATIONDATE is NULL";
  m_Statement += " and hpr.PLANTNO = " + CDataConversion::LongToString(PLANTNO); 
  m_Statement += " and pdh.TREATSTART_ACT is null";
  m_Statement += " and pdh.HEATANNOUNCE_ACT is null";
  m_Statement += " and pdh.TREATEND_ACT is null";
  m_Statement += " and pdh.HEATDEPARTURE_ACT is null";
  m_Statement += " and pdh.PLANT = '" + PLANT + "'";
  m_Statement += " and pdh.HEATID = hpr.HEATID";
  m_Statement += " and pdh.TREATID = hpr.TREATID";
  m_Statement += " and pdh.PLANT = hpr.PLANT";
  m_Statement += " order by pdh.TREATSTART_MOD;";

  return CSMC_DBData::select();
}

bool CPD_HEAT_DATA::selectLastFinishedHeatByPlant( const std::string& PLANT )
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName ;  
  
  addWhereClause(CPD_HEAT_DATA::PLANT,PLANT);
  addWhereClause(CPD_HEAT_DATA::HEATID + " is not null");
  addWhereClause(CPD_HEAT_DATA::TREATSTART_ACT + " is not null");
  addWhereClause(CPD_HEAT_DATA::TREATEND_ACT + " is not null");

  m_Statement += getWhereStatement() + " order by TREATEND_ACT DESC;";

  return CSMC_DBData::select();
}

bool CPD_HEAT_DATA::selectLastHeat(const std::string &PLANT)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;
  addWhereClause(CPD_HEAT_DATA::PLANT,PLANT);

  m_Statement += getWhereStatement() + " ORDER BY " + CPD_HEAT_DATA::HEATANNOUNCE_ACT + " DESC;";

  return CSMC_DBData::select();
}

bool CPD_HEAT_DATA::selectPrevHeatByPlantAndLadle(const std::string& HEATID, const std::string& PLANT, long LADLENO, const std::string& LADLETYPE)
{  
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_HEAT_DATA::HEATID,HEATID,"<>");
  addWhereClause(CPD_HEAT_DATA::PLANT,PLANT);
  addWhereClause(CPD_HEAT_DATA::LADLENO,LADLENO);
  addWhereClause(CPD_HEAT_DATA::LADLETYPE,LADLETYPE);
  addWhereClause(CPD_HEAT_DATA::TREATEND_ACT + " is not null");

  m_Statement += getWhereStatement() + " order by TREATEND_ACT desc ;";

  return CSMC_DBData::select();
}

bool CPD_HEAT_DATA::addCommentsForHeat(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& NewComment)
{
	bool ResValue = false;

  if ( select(HEATID,TREATID,PLANT) )
  {
    std::string COMMENTS = getCOMMENTS(1);

    if ( COMMENTS == CSMC_DBData::unspecString )
    {
      COMMENTS.clear();
    }

    if ( std::string::npos == COMMENTS.find(NewComment) )
    {
      COMMENTS += " ";
      COMMENTS += NewComment;

      setCOMMENTS(COMMENTS);

      if ( update() )
      {
        ResValue = true;
        commit();
      }
      else
      {
        rollback();
      }
    }
  }
	
  return ResValue;
}

bool CPD_HEAT_DATA::deleteRowsbyHeat(const std::string& HEATID )
{
  cleanWhereStatement();
  
  addWhereClause(CPD_HEAT_DATA::HEATID, HEATID);

  return deleteRows();
}

bool CPD_HEAT_DATA::doAnnouncement(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, const std::string& USERCODE, bool Commit, cCBS_ODBC_DBError& Error)
{
  return doAnnouncement(HEATID, TREATID, PLANT, PLANTNO, 
                        CSMC_DBData::unspecString, CSMC_DBData::unspecDouble, CSMC_DBData::unspecDouble, 
                        CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, CSMC_DBData::unspecString, /*CSMC_DBData::unspecString,*/
                        USERCODE, Commit, Error);
}

bool CPD_HEAT_DATA::doAnnouncement(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, const std::string& STEELGRADECODE, double STEELMASS, double SLAGMASS, long SAMPLE_REF, long LADLENO, const string& LADLETYPE, const string& USERCODE, bool Commit, cCBS_ODBC_DBError &Error)
{
  return doAnnouncement(HEATID, TREATID, PLANT, PLANTNO, STEELGRADECODE, STEELMASS, SLAGMASS, SAMPLE_REF, LADLENO, LADLETYPE, CSMC_DBData::unspecDate, USERCODE, Commit, Error);
}

bool CPD_HEAT_DATA::doAnnouncement(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, const std::string& STEELGRADECODE, double STEELMASS, double SLAGMASS, long SAMPLE_REF, long LADLENO, const string& LADLETYPE, const CDateTime& TRETEND_PREV, const string& USERCODE, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = false;

  CPP_HEAT                  PP_HEAT                 (m_pCBS_StdConnection);
  CPP_HEAT_PLANT            PP_HEAT_PLANT           (m_pCBS_StdConnection);
  CPP_ORDER                 PP_ORDER                (m_pCBS_StdConnection);
  CPP_ORDER_SINGLE_AIMS     PP_ORDER_SINGLE_AIMS    (m_pCBS_StdConnection);
  CShiftCrewData            ShiftCrewData           (m_pCBS_StdConnection);
  CPD_HEAT_REF              PD_HEAT_REF             (m_pCBS_StdConnection);
  CGT_PARAM                 GT_PARAM                (m_pCBS_StdConnection);

	if (exists(HEATID, TREATID, PLANT))
	{
    cleanWhereStatement();

    addWhereClause(CPD_HEAT_DATA::HEATID,HEATID);
    addWhereClause(CPD_HEAT_DATA::TREATID,TREATID);
    addWhereClause(CPD_HEAT_DATA::PLANT,PLANT);

		//Heat exists -> update

    CDateTime Now;

    if( LADLENO != DEF::Inv_Long && LADLENO > 0 )
    {
      setLADLENO(LADLENO);
      setLADLETYPE(LADLETYPE);
      //setLADLE_THERMALSTATUS(THERMALSTATUS);
    }
     else
    {
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_DBWriteWarning(sMessage,"LADLENO","PD_HEAT_DATA","INVALID_LADLE_RECEIVED");
    }
    
    setSTEELMASS(STEELMASS);
    setSTEELMASS_START(STEELMASS);
    setSLAGMASS(SLAGMASS);
    setSLAGMASS_START(SLAGMASS);
    setSAMPLE_REF(SAMPLE_REF);
    setREVTIME(Now);

    if ( PD_HEAT_REF.select(HEATID) )
    {
      setROUTECODE_ACT(PD_HEAT_REF.getROUTECODE_ACT(1));
    }

    if ( PP_HEAT.select(HEATID) )
    {
      setROUTECODE_PLAN   (PP_HEAT.getROUTECODE_PLAN(1));
      setPRODORDERID_PLAN (PP_HEAT.getPRODORDERID(1));
      setPRODORDERID_ACT  (PP_HEAT.getPRODORDERID(1));

      // use STEELGRADECODE from planning data if not known
      if ( STEELGRADECODE.empty() || STEELGRADECODE == CSMC_DBData::unspecString )
      {
        if ( PP_ORDER.select(PP_HEAT.getPRODORDERID(1)) )
        {
          setSTEELGRADECODE_PLAN(PP_ORDER.getSTEELGRADECODE(1));
          setSTEELGRADECODE_ACT (PP_ORDER.getSTEELGRADECODE(1));
        }
      }
      else
      {
        setSTEELGRADECODE_PLAN(STEELGRADECODE);
        setSTEELGRADECODE_ACT (STEELGRADECODE);
      }

      if ( PP_ORDER_SINGLE_AIMS.select(PP_HEAT.getPRODORDERID(1), PLANT, 1, DEF_GC_PP_ORDER_SINGLE_AIMS::AIMSTEEL) )
      {
        setAIMSTEELWGT_PLAN(CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1)));
        setAIMSTEELWGT_MOD(CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1)));
      }
      else
      {
        std::stringstream SearchKey;
        SearchKey << PP_HEAT.getPRODORDERID(1) << " ," << PLANT << " ," << 1 << " ," << DEF_GC_PP_ORDER_SINGLE_AIMS::AIMSTEEL;
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PP_ORDER_SINGLE_AIMS");
      }

      if ( PP_ORDER_SINGLE_AIMS.select(PP_HEAT.getPRODORDERID(1), PLANT, 1, DEF_GC_PP_ORDER_SINGLE_AIMS::AIMTEMP) )
      {
        setAIMTEMP_PLAN(CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1)));
        setAIMTEMP_MOD(CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1)));
      }
      else
      {
        std::stringstream SearchKey;
        SearchKey << PP_HEAT.getPRODORDERID(1) << " ," << PLANT << " ," << 1 << " ," << DEF_GC_PP_ORDER_SINGLE_AIMS::AIMTEMP;
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PP_ORDER_SINGLE_AIMS");
      }
    }

    setHEATANNOUNCE_ACT (Now);

    if ( PP_HEAT_PLANT.select(HEATID,TREATID,PLANT) )
    {
      CDateTime TreatStartTimePlan = PP_HEAT_PLANT.getTREATSTART_PLAN(1);
      CDateTime TreatEndTimePlan = PP_HEAT_PLANT.getTREATEND_PLAN(1);

      setTREATSTART_PLAN(TreatStartTimePlan);   
      setTREATEND_PLAN  (TreatEndTimePlan);

      CDeltaTime DurAimTime  = CDateTime::subTimes(TreatEndTimePlan, TreatStartTimePlan);

      double DurAim = 0.;

      std::string ParamValue;
      if ( GT_PARAM.getValue(PLANT, PLANTNO, "DefltTreatDuration", 0, DEF_GC_PARAM_TYPE::DParam, ParamValue) )
      {
        DurAim =  CDataConversion::StringToDouble(ParamValue, 0.0 ) * 60;
      }
      else
      {
        DurAim = DurAimTime.asSeconds();
      }

      setTREATSTART_MOD (Now);

      if ( CDateTime::subTimes(TreatEndTimePlan, Now).asSeconds() < 1. )      
      {
        CDateTime TREATEND_MOD;
        if ( TREATEND_MOD.addTime(DurAim) )
        { 
          Error.m_MessageText = "WARNING_USING_DEFLTTREATDURATION";
          setTREATEND_MOD   (TREATEND_MOD);
        }
        else
        {
          setTREATEND_MOD (TreatEndTimePlan);
        }
      }// if ( CDateTime::subTimes(TreatEndTimePlan, Now).asSeconds() < 1. )    
      else
      {
        setTREATEND_MOD (TreatEndTimePlan);
      }
    }

    setTREATSTART_ACT (CSMC_DBData::unspecDate);
    setTREATEND_ACT (CSMC_DBData::unspecDate);

    std::string CREW_ID;
    std::string SHIFT_ID;
    ShiftCrewData.getCrewAndShiftByDate(CREW_ID, SHIFT_ID, Now,PLANT, PLANTNO);

    setCREW_ID(CREW_ID);
    setSHIFT_ID(SHIFT_ID);

    setUSERCODE(USERCODE);
    setHEAT_RESPONSIBILITY(ShiftCrewData.getMemberIdByRole(Now, PLANT, PLANTNO, DEF_GC_MEMBER_ROLE_CAT::Melter));
    setCREW_RESPONSIBILITY(ShiftCrewData.getMemberIdByRole(Now, PLANT, PLANTNO, DEF_GC_MEMBER_ROLE_CAT::Supervisor));

    result = update();
  }
	else
	{
    CDateTime Now;

		setHEATID(HEATID);
    setTREATID(TREATID);
    setPLANT(PLANT);

    if( LADLENO != DEF::Inv_Long && LADLENO > 0 )
    {
      setLADLENO(LADLENO);
      setLADLETYPE(LADLETYPE);
      //setLADLE_THERMALSTATUS(THERMALSTATUS);
    }
    else
    {
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_DBWriteWarning(sMessage,"LADLENO","PD_HEAT_DATA","INVALID_LADLE_RECEIVED");
    }

    setSTEELMASS(STEELMASS);
    setSTEELMASS_START(STEELMASS);
    setSLAGMASS(SLAGMASS);
    setSLAGMASS_START(SLAGMASS);
    setSAMPLE_REF(SAMPLE_REF);
    setTREATEND_PREV(TREATEND_PREV);
    setREVTIME(Now);

    setUSERCODE(USERCODE);
    setHEAT_RESPONSIBILITY(ShiftCrewData.getMemberIdByRole(Now, PLANT, PLANTNO, DEF_GC_MEMBER_ROLE_CAT::Melter));
    setCREW_RESPONSIBILITY(ShiftCrewData.getMemberIdByRole(Now, PLANT, PLANTNO, DEF_GC_MEMBER_ROLE_CAT::Supervisor));

    if ( PD_HEAT_REF.select(HEATID) )
    {
      setROUTECODE_ACT(PD_HEAT_REF.getROUTECODE_ACT(1));
    }

    if ( PP_HEAT.select(HEATID) )
    {
      setROUTECODE_PLAN   (PP_HEAT.getROUTECODE_PLAN(1));
      setPRODORDERID_PLAN (PP_HEAT.getPRODORDERID(1));
      setPRODORDERID_ACT  (PP_HEAT.getPRODORDERID(1));

      // use STEELGRADECODE from planning data if not known
      if ( STEELGRADECODE.empty() || STEELGRADECODE == CSMC_DBData::unspecString )
      {
        if ( PP_ORDER.select(PP_HEAT.getPRODORDERID(1)) )
        {
          setSTEELGRADECODE_PLAN(PP_ORDER.getSTEELGRADECODE(1));
          setSTEELGRADECODE_ACT (PP_ORDER.getSTEELGRADECODE(1));
        }
      }
      else
      {
        setSTEELGRADECODE_PLAN(STEELGRADECODE);
        setSTEELGRADECODE_ACT (STEELGRADECODE);
      }

      if ( PP_ORDER_SINGLE_AIMS.select(PP_HEAT.getPRODORDERID(1), PLANT, 1, DEF_GC_PP_ORDER_SINGLE_AIMS::AIMSTEEL) )
      {
        setAIMSTEELWGT_PLAN(CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1)));
        setAIMSTEELWGT_MOD(CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1)));
      }
      else
      {
        std::stringstream SearchKey;
        SearchKey << PP_HEAT.getPRODORDERID(1) << " ," << PLANT << " ," << 1 << " ," << DEF_GC_PP_ORDER_SINGLE_AIMS::AIMSTEEL;
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PP_ORDER_SINGLE_AIMS");
      }

      if ( PP_ORDER_SINGLE_AIMS.select(PP_HEAT.getPRODORDERID(1), PLANT, 1, DEF_GC_PP_ORDER_SINGLE_AIMS::AIMTEMP) )
      {
        setAIMTEMP_PLAN(CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1)));
        setAIMTEMP_MOD(CDataConversion::StringToLong(PP_ORDER_SINGLE_AIMS.getVALUE(1)));
      }
      else
      {
        std::stringstream SearchKey;
        SearchKey << PP_HEAT.getPRODORDERID(1) << " ," << PLANT << " ," << 1 << " ," << DEF_GC_PP_ORDER_SINGLE_AIMS::AIMTEMP;
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"PP_ORDER_SINGLE_AIMS");
      }
    }

    setHEATANNOUNCE_ACT (Now);

    if ( PP_HEAT_PLANT.select(HEATID,TREATID,PLANT) )
    {
      CDateTime TreatStartTimePlan = PP_HEAT_PLANT.getTREATSTART_PLAN(1);
      CDateTime TreatEndTimePlan = PP_HEAT_PLANT.getTREATEND_PLAN(1);

      setTREATSTART_PLAN(TreatStartTimePlan);   
      setTREATEND_PLAN  (TreatEndTimePlan);

      CDeltaTime DurAimTime  = CDateTime::subTimes(TreatEndTimePlan, TreatStartTimePlan);
  
      double DurAim = 0.;

      std::string ParamValue;
      if ( GT_PARAM.getValue(PLANT, PLANTNO, "DefltTreatDuration", 0, DEF_GC_PARAM_TYPE::DParam, ParamValue) )
      {
        DurAim =  CDataConversion::StringToDouble(ParamValue, 0.0 ) * 60;
      }
      else
      {
        DurAim = DurAimTime.asSeconds();
      }

      setTREATSTART_MOD (Now);

      if ( CDateTime::subTimes(TreatEndTimePlan, Now).asSeconds() < 1. )      
      {
        CDateTime TREATEND_MOD;
        if ( TREATEND_MOD.addTime(DurAim) )
        { 
          Error.m_MessageText = "WARNING_USING_DEFLTTREATDURATION";
          setTREATEND_MOD   (TREATEND_MOD);
        }
        else
        {
          setTREATEND_MOD (TreatEndTimePlan);
        }
      }// if ( CDateTime::subTimes(TreatEndTimePlan, Now).asSeconds() < 1. )    
      else
      {
        setTREATEND_MOD (TreatEndTimePlan);
      }
    }

    setTREATSTART_ACT (CSMC_DBData::unspecDate);
    setTREATEND_ACT (CSMC_DBData::unspecDate);

    std::string CREW_ID;
    std::string SHIFT_ID;
    ShiftCrewData.getCrewAndShiftByDate(CREW_ID, SHIFT_ID, Now, PLANT, PLANTNO);

    setCREW_ID(CREW_ID);
    setSHIFT_ID(SHIFT_ID);

    result = insert();
	}

	if (!result)
		Error = getLastError();
	
	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}
	return result;
}

bool CPD_HEAT_DATA::doCancelHeat(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, bool Commit, cCBS_ODBC_DBError& Error)
{  
  bool result = true;
    
  if (select(HEATID, TREATID, PLANT))
  {
    if( getTREATEND_ACT(1) == CSMC_DBData::unspecDate )
    {
      setTREATEND_ACT     (CDateTime());
      setREVTIME          (CDateTime());

      result = result && update();
    }
  }
  else
  {
    setLastError(std::string("NO_DATA_FOUND"), 0, getActStatement() );
  }

  if (!result)
	  Error = getLastError();

  if (Commit)
  {
	  if (result)
		  commit();
	  else
		  rollback();
  }

	return result;
}

bool CPD_HEAT_DATA::doChange(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string &STEELGRADECODE, const std::string &PRODORDERID, double AIMSTEELWGT, double TEMP, const CDateTime &TREATSTART, const CDateTime &TREATEND, bool Commit, cCBS_ODBC_DBError &Error)
{
	bool result = select(HEATID, TREATID, PLANT);
	if (result)
	{
		//Heat exists -> update
    if (!STEELGRADECODE.empty() && STEELGRADECODE != DEF::Inv_String)
      setSTEELGRADECODE_ACT(STEELGRADECODE);

    if (!PRODORDERID.empty() && PRODORDERID != DEF::Inv_String)
      setPRODORDERID_ACT(PRODORDERID);

    if (AIMSTEELWGT != DEF::Inv_Double)
      setAIMSTEELWGT_MOD(AIMSTEELWGT);

    if (TEMP != DEF::Inv_Double)
      setAIMTEMP_MOD(TEMP);

    if (TREATSTART != CSMC_DBData::unspecDate)
      setTREATSTART_MOD(TREATSTART);

    if (TREATEND != CSMC_DBData::unspecDate)
      setTREATEND_MOD(TREATEND);

    setREVTIME          (CDateTime());

    result = result && update();
	}
	else
	{
		setLastError(std::string("NO_DATA_FOUND"), 0, getActStatement());
	}
	if (!result)
		Error = getLastError();
	
	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}
	return result;
}

bool CPD_HEAT_DATA::doDeparture(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = true;

  CPD_LADLE              PD_LADLE           (m_pCBS_StdConnection);
  CPD_LADLE_LIFE_DATA    PD_LADLE_LIFE_DATA (m_pCBS_StdConnection);
  CPD_SAMPLE             PD_SAMPLE          (m_pCBS_StdConnection);

  if ( select(HEATID, TREATID, PLANT) )
  {
    CDateTime StartTime  = getTREATSTART_ACT(1);
    CDateTime EndTime    = getTREATEND_ACT(1);
    CDateTime Now;

    if ( StartTime == CSMC_DBData::unspecDate )
    {
      StartTime = getTREATSTART_MOD(1);

      setTREATSTART_ACT(StartTime);
    }

    if ( EndTime == CSMC_DBData::unspecDate )
    {
      EndTime = Now;
      setTREATEND_ACT        (EndTime);
    }

    double Duration       = CDateTime::subTimes(EndTime,StartTime).asSeconds() / 60.0; // seconds -> minutes

    setHEATDEPARTURE_ACT   (Now);
    setTREATMENTDURATION(Duration);

    std::string LADLETYPE = getLADLETYPE(1);
    long        LADLENO   = getLADLENO(1);

//    if ( LADLENO    != CSMC_DBData::unspecLong    && 
//         LADLETYPE  != CSMC_DBData::unspecString  )
//    {
//      if ( PD_LADLE.select(LADLENO,LADLETYPE)       )
//      {
////        setSCULLMASS            (PD_LADLE.getSCULLMASS(1));
//        //setLADLE_THERMALSTATUS  (PD_LADLE.getTHERMALSTATUS(1));
////        setLADLE_TAREWEIGHT     (PD_LADLE.getTAREWEIGHT(1));
//      }
//
//      if ( PD_LADLE_LIFE_DATA.select(LADLENO,LADLETYPE, DEF_GC_LADLE_PARTS::LadleBottom) )
//      {
//        setLADLE_LIFE            (PD_LADLE_LIFE_DATA.getLIFE(1));
//      }
//    }

    setTEMP_SAMPLES (PD_SAMPLE.getNoOfSamples(HEATID,TREATID,PLANT,CSMC_DBData::unspecLong,DEF_GC_MEASUREMENT_TYPE::Temp));
    setSTEEL_SAMPLES(PD_SAMPLE.getNoOfSamples(HEATID,TREATID,PLANT,CSMC_DBData::unspecLong,DEF_GC_MEASUREMENT_TYPE::Steel));
    setSLAG_SAMPLES (PD_SAMPLE.getNoOfSamples(HEATID,TREATID,PLANT,CSMC_DBData::unspecLong,DEF_GC_MEASUREMENT_TYPE::Slag));

    setREVTIME          (CDateTime());

    result = result && update();
  }
  else
  {
    setLastError(std::string("NO_DATA_FOUND"), 0, getActStatement());
    result = false;
  }

  if (!result)
  {
    Error = getLastError();
  }

	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}

	return result;
}

bool CPD_HEAT_DATA::doHeatEnd(const string& HEATID, const string& TREATID, const string& PLANT, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = select(HEATID, TREATID, PLANT);
  if (result)
  {
    CDateTime dStartTime = getTREATSTART_ACT(1);
    CDateTime dEndTime;
    double Duration = CDateTime::subTimes(dEndTime,dStartTime).asSeconds() / 60.0;

    setTREATEND_ACT(dEndTime);
    setTREATMENTDURATION(Duration);

    result = update();
  }
  else
  {
    setLastError("NO_DADA_FOUND", 0, getActStatement());
  }

  if ( !result )
  {
    Error = getLastError();
  }

	if (Commit)
  {
    if (result)
      commit();
    else
      rollback();
  }

  return result;
}

bool CPD_HEAT_DATA::isHeatDeparted(const string& HEATID, const string& TREATID, const string& PLANT)
{
  bool result = false;

  if (select(HEATID, TREATID, PLANT))
  {
    if ( !isNull(CPD_HEAT_DATA::HEATDEPARTURE_ACT, 1 ) )
    {
      result = true;
    }
  }

  return result;
}


bool CPD_HEAT_DATA::doHeatStart(const string& HEATID, const string& TREATID, const string& PLANT, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = select(HEATID, TREATID, PLANT);

  if (result)
  {
    CPD_HEAT_REF              PD_HEAT_REF             (m_pCBS_StdConnection);

    CDateTime Now;

    if ( PD_HEAT_REF.select(HEATID) )
    {    
      setROUTECODE_ACT(PD_HEAT_REF.getROUTECODE_ACT(1));
    }

    // check if heat is not yet started
    if ( isNull(CPD_HEAT_DATA::TREATSTART_ACT, 1 ) )
    {
      setTREATSTART_ACT(Now);
      setTREATEND_ACT(CSMC_DBData::unspecDate);
    }
    else
    {
      setLastError("HEAT_START_REPEATED", 0, "");
    }

    setREVTIME(Now);

    result = update();

	  if (Commit)
    {
      if (result)
        commit();
      else
        rollback();
    }
  }
  else
  {
    setLastError("NO_DADA_FOUND", 0, getActStatement());
  }

  if ( !result )
  {
    Error = getLastError();
  }

  return result;
}


bool CPD_HEAT_DATA::doLadleDataChanged(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long LADLENO, const std::string &LADLETYPE/*, const std::string& THERMALSTATUS*/, bool Commit, cCBS_ODBC_DBError &Error)
{
	bool result = true;

	if ( result && select(HEATID, TREATID, PLANT) )
	{
    if ( LADLENO > 0        && LADLENO   != CSMC_DBData::unspecLong    && 
         !LADLETYPE.empty() && LADLETYPE != CSMC_DBData::unspecString  )
    {
      setLADLENO  (LADLENO);
      setLADLETYPE(LADLETYPE);
      setREVTIME  (CDateTime());

      result = true;
    }
    else
    {
      setLastError(std::string("INVALID_LADLE_RECEIVED"), 0, getActStatement());
    }

    //if ( !THERMALSTATUS.empty() && THERMALSTATUS != CSMC_DBData::unspecString )
    //{
    //  setLADLE_THERMALSTATUS(THERMALSTATUS);
    //  result = true;
    //}

    result = result && update();
	}
	else
	{
		setLastError(std::string("NO_PRODUCTION_DATA_FOUND"), 0, getActStatement());
	}

  if (!result)
  {
		Error = getLastError();
  }

	if (Commit)
	{
		if (result)
    {
			commit();
    }
		else
    {
			rollback();
    }
	}

	return result;
}

bool CPD_HEAT_DATA::doSampleRefUpdate(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long SAMPLE_REF, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = select(HEATID, TREATID, PLANT);
	if (result)
	{
    setSAMPLE_REF(SAMPLE_REF);
    setREVTIME   (CDateTime());

    result = update();
	}
	else
	{
		setLastError(std::string("NO_DATA_FOUND"), 0, getActStatement());
	}

  if (!result)
		Error = getLastError();
	
	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}
	return result;
}

bool CPD_HEAT_DATA::doSetupHeat(const std::string& HEATID,const std::string& TREATID, const std::string& PLANT, const std::string STEELGRADECODE, long LADLENO, const std::string& LADLETYPE, const CDateTime &TREATSTART, const CDateTime &TREATEND, double STEELMASS, double TEMP, long SAMPLE_REF, const std::string &USERCODE, bool Commit, cCBS_ODBC_DBError &Error)
{
	bool result = true;
  if (result && select(HEATID, TREATID, PLANT))
	{
    //Heat exists -> update
    if ( STEELGRADECODE != CSMC_DBData::unspecString )
    {
      setSTEELGRADECODE_ACT (STEELGRADECODE);
    }
    if ( STEELMASS != CSMC_DBData::unspecDouble )
    {
      setSTEELMASS          (STEELMASS);
    }
    if ( TEMP != CSMC_DBData::unspecDouble )
    {
      setFINALTEMP          (TEMP);
    }
    if ( TREATSTART != CSMC_DBData::unspecDate )
    {
      setTREATSTART_MOD     (TREATSTART);
    }
    if ( TREATEND != CSMC_DBData::unspecDate )
    {
      setTREATEND_MOD       (TREATEND);
    }
    if ( USERCODE != CSMC_DBData::unspecString )
    {
      setUSERCODE          (USERCODE);
    }
    if ( SAMPLE_REF != CSMC_DBData::unspecLong )
    {
      setSAMPLE_REF        (SAMPLE_REF);
    }

    setREVTIME            (CDateTime());

    result = result && update();
	}
	else
	{
		setLastError(std::string("NO_DATA_FOUND"), 0, getActStatement());
	}
	if (!result)
		Error = getLastError();
	
	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}
	return result;

}

bool CPD_HEAT_DATA::doSetupHeatAnnouncement(const std::string& HEATID,const std::string& TREATID, const std::string& PLANT, const std::string STEELGRADECODE, long LADLENO, const std::string& LADLETYPE, const CDateTime &TREATSTART, const CDateTime &TREATEND, double STEELMASS, double TEMP, long SAMPLE_REF, const std::string &USERCODE, bool Commit, cCBS_ODBC_DBError &Error)
{
	bool result = select(HEATID, TREATID, PLANT);
	if (result)
	{
    //Heat exists -> update
    if ( STEELGRADECODE != CSMC_DBData::unspecString )
    {
      setSTEELGRADECODE_ACT (STEELGRADECODE);
    }
    if ( STEELMASS != CSMC_DBData::unspecDouble )
    {
      setSTEELMASS          (STEELMASS);
    }
    if ( TEMP != CSMC_DBData::unspecDouble )
    {
      setFINALTEMP          (TEMP);
    }
    if ( TREATSTART != CSMC_DBData::unspecDate )
    {
      setTREATSTART_MOD     (TREATSTART);
    }
    if ( TREATEND != CSMC_DBData::unspecDate )
    {
      setTREATEND_MOD       (TREATEND);
    }
    if ( USERCODE != CSMC_DBData::unspecString )
    {
      setUSERCODE          (USERCODE);
    }
    if ( SAMPLE_REF != CSMC_DBData::unspecLong )
    {
      setSAMPLE_REF        (SAMPLE_REF);
    }

    setREVTIME            (CDateTime());
    setHEATDEPARTURE_ACT  (CDateTime::InvalidDateTime());

    result = result && update();
	}
	else
	{
		setLastError(std::string("NO_DATA_FOUND"), 0, getActStatement());
	}
	if (!result)
		Error = getLastError();
	
	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}
	return result;

}

bool CPD_HEAT_DATA::doSetupHeatTreatmentStart(const std::string& HEATID,const std::string& TREATID, const std::string& PLANT, const std::string STEELGRADECODE, long LADLENO, const std::string& LADLETYPE, const CDateTime &TREATSTART, const CDateTime &TREATEND, double STEELMASS, double TEMP, long SAMPLE_REF, const std::string &USERCODE, bool Commit, cCBS_ODBC_DBError &Error)
{
	bool result = select(HEATID, TREATID, PLANT);
	if (result)
	{
    //Heat exists -> update
    if ( STEELGRADECODE != CSMC_DBData::unspecString )
    {
      setSTEELGRADECODE_ACT (STEELGRADECODE);
    }
    if ( STEELMASS != CSMC_DBData::unspecDouble )
    {
      setSTEELMASS          (STEELMASS);
    }
    if ( TEMP != CSMC_DBData::unspecDouble )
    {
      setFINALTEMP          (TEMP);
    }
    if ( TREATSTART != CSMC_DBData::unspecDate )
    {
      setTREATSTART_MOD     (TREATSTART);
    }
    if ( TREATEND != CSMC_DBData::unspecDate )
    {
      setTREATEND_MOD       (TREATEND);
    }
    if ( USERCODE != CSMC_DBData::unspecString )
    {
      setUSERCODE          (USERCODE);
    }
    if ( SAMPLE_REF != CSMC_DBData::unspecLong )
    {
      setSAMPLE_REF        (SAMPLE_REF);
    }

    setREVTIME            (CDateTime());
    setTREATEND_ACT       (CDateTime::InvalidDateTime());
    setHEATDEPARTURE_ACT  (CDateTime::InvalidDateTime());

    result = result && update();
	}
	else
	{
		setLastError(std::string("NO_DATA_FOUND"), 0, getActStatement());
	}
	if (!result)
		Error = getLastError();
	
	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}
	return result;

}

bool CPD_HEAT_DATA::doSteelGradeChange(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& STEELGRADECODE, bool Commit, cCBS_ODBC_DBError& Error)
{
	bool result = select(HEATID, TREATID, PLANT);
	if (result)
	{
    setSTEELGRADECODE_ACT(STEELGRADECODE);
    setREVTIME           (CDateTime());

    result = update();
	}
	else
	{
    setLastError(std::string("NO_DATA_FOUND"), 0, getActStatement());
	}
	
  if (!result)
  {
		Error = getLastError();
  }

	if (Commit)
	{
		if (result)
    {
			commit();
    }
		else
    {
			rollback();
    }
	}

	return result;
}

bool CPD_HEAT_DATA::exists(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
	cleanWhereStatement();

	m_Statement = "Select HEATID from " + m_TableName;

	addWhereClause(CPD_HEAT_DATA::HEATID,HEATID);
	addWhereClause(CPD_HEAT_DATA::TREATID,TREATID);
	addWhereClause(CPD_HEAT_DATA::PLANT,PLANT);
   
  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }

	return CSMC_DBData::select();
}

CDateTime CPD_HEAT_DATA::getLastFinishedTimeByPlant(const std::string &PLANT,const long PLANTNO)
{
  CDateTime MaxTime;
  cleanWhereStatement();

  m_Statement = "Select max(TREATEND_ACT) as MaxTime from PD_HEAT_DATA, PD_HEAT_PLANT_REF hpr ";  

  addWhereClause(CPD_HEAT_DATA::PLANT,PLANT);

  if (CSMC_DBData::unspecLong != PLANTNO)
  {
    addWhereClause("hpr.PLANTNO = " + CDataConversion::LongToString(PLANTNO));
  }

  addWhereClause("TREATEND_ACT is not null");

  m_Statement += getWhereStatement() + ";";

  if(CSMC_DBData::select())
  {
    if(!isNull("MaxTime",1))
    {
      MaxTime.fromDBString(getString("MaxTime", 1));
    }
  }

  return MaxTime;
}

std::vector<long> CPD_HEAT_DATA::getSampleRefList(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
  std::vector<long> SampleRefList;

  if ( select ( HEATID,TREATID,PLANT ) )
  {
    for ( long i = 1; i <= getLastRow() ; ++i )
    {

      SampleRefList.push_back(getSAMPLE_REF(i));
    }
  }

  return SampleRefList;
}

std::string CPD_HEAT_DATA::getSteelGradeCode(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
  std::string SteelGradeCode;
  if ( select ( HEATID,TREATID,PLANT ) )
  {
    SteelGradeCode   = getSTEELGRADECODE_ACT(1);
  }

  return SteelGradeCode;
}

// heats are defined as "in production" when
// PP_HEAT.PLANNED = 0 and
// PD_HEAT_PLANT_REF. EXPIRATIONDATE is NULL and
// PD_HEAT_DATA.HEATANNOUNCE_ACT is NOT null and
// PD_HEAT_DATA.TREATSTART_ACT is NOT null and
// PD_HEAT_DATA.TREATEND_ACT is null 
bool CPD_HEAT_DATA::isHeatInProduction(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
  return selectHeatInProduction(HEATID, TREATID, PLANT) ;
}

bool CPD_HEAT_DATA::isHeatProductionDone (const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
  // select heats in treatment
  // select heats with start time AND with end time
  // ordered by actual start time

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName + ",PD_HEAT_PLANT_REF";

  addWhereClause(CPD_HEAT_DATA::HEATID, HEATID);
  addWhereClause(CPD_HEAT_DATA::TREATID, TREATID);
  addWhereClause(CPD_HEAT_DATA::PLANT, PLANT);

  addWhereClauseforNULL(CPD_HEAT_DATA::TREATSTART_ACT, false);
  addWhereClauseforNULL(CPD_HEAT_DATA::HEATANNOUNCE_ACT, false);
  addWhereClauseforNULL(CPD_HEAT_DATA::TREATEND_ACT, false);

  addWhereClauseforJoin(CPD_HEAT_DATA::HEATID, "PD_HEAT_PLANT_REF", CPD_HEAT_PLANT_REF::HEATID);
  addWhereClauseforJoin(CPD_HEAT_DATA::TREATID,"PD_HEAT_PLANT_REF", CPD_HEAT_PLANT_REF::TREATID);
  addWhereClauseforJoin(CPD_HEAT_DATA::PLANT,  "PD_HEAT_PLANT_REF", CPD_HEAT_PLANT_REF::PLANT);

  m_Statement += getWhereStatement();
  m_Statement += " order by PD_HEAT_DATA.TREATSTART_ACT;";

  return CSMC_DBData::select();

}

// Return true if ProdOrderId is assigned to any heat being produced
bool CPD_HEAT_DATA::isProdOrderInProduction   (const std::string &ProdOrderId)
{
  // Similar as in method "isHeatInProduction":
  //
  // select heats in treatment having Production Order Id as given in actual argument
  // Not limited to any particular plant
  // select heats with start time but without end time
  // ordered by actual start time

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName + ",PD_HEAT_PLANT_REF";

  addWhereClause(CPD_HEAT_DATA::PRODORDERID_ACT, ProdOrderId);

  addWhereClauseforNULL(CPD_HEAT_DATA::TREATSTART_ACT, false);
  addWhereClauseforNULL(CPD_HEAT_DATA::HEATANNOUNCE_ACT, false);
  addWhereClauseforNULL(CPD_HEAT_DATA::TREATEND_ACT);

  addWhereClauseforJoin(CPD_HEAT_DATA::HEATID, "PD_HEAT_PLANT_REF", CPD_HEAT_PLANT_REF::HEATID);
  addWhereClauseforJoin(CPD_HEAT_DATA::TREATID,"PD_HEAT_PLANT_REF", CPD_HEAT_PLANT_REF::TREATID);
  addWhereClauseforJoin(CPD_HEAT_DATA::PLANT,  "PD_HEAT_PLANT_REF", CPD_HEAT_PLANT_REF::PLANT);

  m_Statement += getWhereStatement();
  m_Statement += " order by PD_HEAT_DATA.TREATSTART_ACT;";

  return CSMC_DBData::select();

}

// Return true if ProdOrderId is assigned to any heat that has been produced at any plant
bool CPD_HEAT_DATA::isProdOrderProductionDone (const std::string &ProdOrderId)
{
  // Similar as in method "isHeatInProduction":
  //
  // select heats in treatment having Production Order Id as given in actual argument
  // Not limited to any particular plant
  // select heats with start time AND with end time
  // ordered by actual start time

  // Normally one would expect that heat must be finished at all plants, which means that it is
  // insufficient to check just if it finished somewhere: finished at EAF and in production at AOD is
  // not completely finished. But a check for this would be very cumbersome because one never knows the 
  // actual route of a heat throug the steel plant: when it's finished at AOD, it may go to the LF or to the
  // Caster: so when is it really finished. 
  // We use this method currently only for a rather unimportant check, so for the sake of efficiency and speed we
  // do just the minimum: if there is any heat with given ProdOrderId that is finished _somewhere_, we claim that the order
  // is done.


  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName + ",PD_HEAT_PLANT_REF";

  addWhereClause(CPD_HEAT_DATA::PRODORDERID_ACT, ProdOrderId);            // Has prodOrderId as gibven in Arg AND

  addWhereClauseforNULL(CPD_HEAT_DATA::TREATSTART_ACT, false);            // Has Treatment Start AND
  addWhereClauseforNULL(CPD_HEAT_DATA::HEATANNOUNCE_ACT, false);          // has been announced  AND
  addWhereClauseforNULL(CPD_HEAT_DATA::TREATEND_ACT, false);              // Has Treatment End

  addWhereClauseforJoin(CPD_HEAT_DATA::HEATID, "PD_HEAT_PLANT_REF", CPD_HEAT_PLANT_REF::HEATID);
  addWhereClauseforJoin(CPD_HEAT_DATA::TREATID,"PD_HEAT_PLANT_REF", CPD_HEAT_PLANT_REF::TREATID);
  addWhereClauseforJoin(CPD_HEAT_DATA::PLANT,  "PD_HEAT_PLANT_REF", CPD_HEAT_PLANT_REF::PLANT);

  m_Statement += getWhereStatement();
  m_Statement += " order by PD_HEAT_DATA.TREATSTART_ACT;";

  return CSMC_DBData::select();
}

bool CPD_HEAT_DATA::updateShiftCrewCode(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, const std::string& USERCODE, bool Commit, cCBS_ODBC_DBError& Error)
{
  bool result = false;

  if ( select(HEATID, TREATID, PLANT) )
  {
    CShiftCrewData ShiftCrewData(m_pCBS_StdConnection);

    CDateTime Now;
    std::string CREW_ID;
    std::string SHIFT_ID;

    ShiftCrewData.getCrewAndShiftByDate(CREW_ID, SHIFT_ID, Now, PLANT, PLANTNO);

    setCREW_ID(CREW_ID);
    setSHIFT_ID(SHIFT_ID);

    result = update();
  }

  if (!result)
    Error = getLastError();

  if (Commit)
  {
    if (result)
      commit();
    else
      rollback();
  }
  return result;
}


