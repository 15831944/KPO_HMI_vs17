//## Copyright (C) 2010 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "CDataConversion.h"
#include "CPD_PRETREATDATA.h"
#include "CPD_HEAT_DATA.h"
#include "CGC_LADLE_DEF.h"
#include "DEF_GC_LADLE_STATUS.h"
#include "DEF_GC_LADLE_POS.h"
#include "CPD_LADLE.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::LADLENO("LADLENO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::LADLETYPE("LADLETYPE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::TAREWEIGHT("TAREWEIGHT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::SCULLMASS("SCULLMASS");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::THERMALSTATUS("THERMALSTATUS");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::DESLAGGED("DESLAGGED");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::DURSINCELASTUSE("DURSINCELASTUSE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::LAST_TREATMENT_STATION("LAST_TREATMENT_STATION");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::LADLE_CIRCULATION_TIME("LADLE_CIRCULATION_TIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::LAST_FILL_TIME("LAST_FILL_TIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::LAST_EMPTY_TIME("LAST_EMPTY_TIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::STATUSNO("STATUSNO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::LADLEPOSID("LADLEPOSID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::PRETREAT_CNT_ACT("PRETREAT_CNT_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::PRETREAT_CNT_PREV("PRETREAT_CNT_PREV");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::HOTMETAL_CNT_ACT("HOTMETAL_CNT_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::HOTMETAL_CNT_PREV("HOTMETAL_CNT_PREV");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_LADLE::FREEBOARD("FREEBOARD");

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_LADLE::CPD_LADLE(cCBS_StdConnection* Connection)
:CSMC_DBData("PD_LADLE",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_LADLE::CPD_LADLE(cCBS_Connection* Connection)
:CSMC_DBData("PD_LADLE",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_LADLE::CPD_LADLE()
:CSMC_DBData("PD_LADLE")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_LADLE::~CPD_LADLE()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique ladle number
long CPD_LADLE::getLADLENO(long Row)
{
  return getLong(CPD_LADLE::LADLENO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setLADLENO(long value)
{
  setLong(CPD_LADLE::LADLENO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##e.g. Hot Metal -> H, Teeming -> T
std::string CPD_LADLE::getLADLETYPE(long Row)
{
  return getString(CPD_LADLE::LADLETYPE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setLADLETYPE(const std::string& value)
{
  setString(CPD_LADLE::LADLETYPE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Eng. Unit : kg, Tare weight of the ladle
double CPD_LADLE::getTAREWEIGHT(long Row)
{
  return getDouble(CPD_LADLE::TAREWEIGHT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setTAREWEIGHT(double value)
{
  setDouble(CPD_LADLE::TAREWEIGHT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Eng. Unit : kg, Mass of ladle scull
double CPD_LADLE::getSCULLMASS(long Row)
{
  return getDouble(CPD_LADLE::SCULLMASS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setSCULLMASS(double value)
{
  setDouble(CPD_LADLE::SCULLMASS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##H=Hot, M=Medium, C=Cold
std::string CPD_LADLE::getTHERMALSTATUS(long Row)
{
  return getString(CPD_LADLE::THERMALSTATUS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setTHERMALSTATUS(const std::string& value)
{
  setString(CPD_LADLE::THERMALSTATUS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##1 = Deslagged, 0 = Not deslagged, -1 = Not known
long CPD_LADLE::getDESLAGGED(long Row)
{
  return getLong(CPD_LADLE::DESLAGGED, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setDESLAGGED(long value)
{
  setLong(CPD_LADLE::DESLAGGED, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Set in melting units and is calculated with tapping end (teeming/pre-metal ladles) or, with filling end (hot metal ladles). This duration shows the time the ladle was empty (cooling down time).
double CPD_LADLE::getDURSINCELASTUSE(long Row)
{
  return getDouble(CPD_LADLE::DURSINCELASTUSE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setDURSINCELASTUSE(double value)
{
  setDouble(CPD_LADLE::DURSINCELASTUSE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Route Plant id of Last treatment station
std::string CPD_LADLE::getLAST_TREATMENT_STATION(long Row)
{
  return getString(CPD_LADLE::LAST_TREATMENT_STATION, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setLAST_TREATMENT_STATION(const std::string& value)
{
  setString(CPD_LADLE::LAST_TREATMENT_STATION, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##This duration corresponds to the LAST_FILL_TIME and gives the duration from previous tapping to current tapping of the ladle.
double CPD_LADLE::getLADLE_CIRCULATION_TIME(long Row)
{
  return getDouble(CPD_LADLE::LADLE_CIRCULATION_TIME, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setLADLE_CIRCULATION_TIME(double value)
{
  setDouble(CPD_LADLE::LADLE_CIRCULATION_TIME, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Last time filling time with hot metal in case of HM ladle., Tapping end time in case of teeming or pre-metal ladles.
CDateTime CPD_LADLE::getLAST_FILL_TIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_LADLE::LAST_FILL_TIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setLAST_FILL_TIME(const CDateTime& value)
{
 setString(CPD_LADLE::LAST_FILL_TIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Discharge end time in case of liquid addition or pouring end time from Caster in case of teeming.
CDateTime CPD_LADLE::getLAST_EMPTY_TIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_LADLE::LAST_EMPTY_TIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setLAST_EMPTY_TIME(const CDateTime& value)
{
 setString(CPD_LADLE::LAST_EMPTY_TIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Defined in GC_LADLE_STATUS
long CPD_LADLE::getSTATUSNO(long Row)
{
  return getLong(CPD_LADLE::STATUSNO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setSTATUSNO(long value)
{
  setLong(CPD_LADLE::STATUSNO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Valid ladle position as defined in GC_LADLE_POS
long CPD_LADLE::getLADLEPOSID(long Row)
{
  return getLong(CPD_LADLE::LADLEPOSID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setLADLEPOSID(long value)
{
  setLong(CPD_LADLE::LADLEPOSID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment data for the actual treatment in the ladle
long CPD_LADLE::getPRETREAT_CNT_ACT(long Row)
{
  return getLong(CPD_LADLE::PRETREAT_CNT_ACT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setPRETREAT_CNT_ACT(long value)
{
  setLong(CPD_LADLE::PRETREAT_CNT_ACT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment data for the previous treatment in the ladle
long CPD_LADLE::getPRETREAT_CNT_PREV(long Row)
{
  return getLong(CPD_LADLE::PRETREAT_CNT_PREV, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setPRETREAT_CNT_PREV(long value)
{
  setLong(CPD_LADLE::PRETREAT_CNT_PREV, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique counter
long CPD_LADLE::getHOTMETAL_CNT_ACT(long Row)
{
  return getLong(CPD_LADLE::HOTMETAL_CNT_ACT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setHOTMETAL_CNT_ACT(long value)
{
  setLong(CPD_LADLE::HOTMETAL_CNT_ACT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique counter
long CPD_LADLE::getHOTMETAL_CNT_PREV(long Row)
{
  return getLong(CPD_LADLE::HOTMETAL_CNT_PREV, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setHOTMETAL_CNT_PREV(long value)
{
  setLong(CPD_LADLE::HOTMETAL_CNT_PREV, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Actual freeboard of the ladle
long CPD_LADLE::getFREEBOARD(long Row)
{
  return getLong(CPD_LADLE::FREEBOARD, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_LADLE::setFREEBOARD(long value)
{
  setLong(CPD_LADLE::FREEBOARD, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPD_LADLE::select(long LADLENO, const std::string& LADLETYPE)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_LADLE::LADLENO,LADLENO);
  addWhereClause(CPD_LADLE::LADLETYPE,LADLETYPE);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CPD_LADLE::selectbySpecifiedColumn(const std::string& ColumnName, long Value)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;
  addWhereClause(ColumnName,Value);  
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CPD_LADLE::doAnnouncement(long LADLENO, const std::string& LADLETYPE, std::string LadleState, double SteelMass, double SlagMass, long PretreatCounter, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = false;

  CPD_PRETREATDATA  PD_PRETREATDATA  (m_pCBS_StdConnection);
  CGC_LADLE_DEF     GC_LADLE_DEF     (m_pCBS_StdConnection);

  if ( PretreatCounter != CSMC_DBData::unspecLong && !PD_PRETREATDATA.select(PretreatCounter) )
  {
    std::string Msg = "invalid pretreat counter received: " + CDataConversion::LongToString(PretreatCounter,"-");
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DBWriteError(sMessage,"PRETREAT_CNT_ACT","PD_LADLE",Msg.c_str());

    PretreatCounter = CSMC_DBData::unspecLong;
  }

  if( select(LADLENO, LADLETYPE) )
  {
    if ( getLastRow() == 1 ) // only one ladle found !
    {
      double TAREWEIGHT         = getTAREWEIGHT(1);
      double SCULLMASS          = getSCULLMASS(1);
      std::string THERMALSTATUS = getTHERMALSTATUS(1);

      // prevent using invalid data
      SteelMass   = CDataConversion::SetInvalidToDefault(SteelMass,0.);
      SlagMass    = CDataConversion::SetInvalidToDefault(SlagMass,0.);
      TAREWEIGHT  = CDataConversion::SetInvalidToDefault(TAREWEIGHT,0.);
      SCULLMASS   = CDataConversion::SetInvalidToDefault(SCULLMASS,0.);
      LadleState  = CDataConversion::SetInvalidToDefault(LadleState,THERMALSTATUS);

      if ( SCULLMASS < 0 )
      {
        SCULLMASS = 0;
      }

      setSCULLMASS(SCULLMASS);

      setTHERMALSTATUS(LadleState);
      setSTATUSNO(DEF_GC_LADLE_STATUS::Available);   

      if( PretreatCounter != CSMC_DBData::unspecLong )
      {
        setPRETREAT_CNT_PREV(getPRETREAT_CNT_ACT(1));
        setPRETREAT_CNT_ACT(PretreatCounter);
      }
      else
      {
        setPRETREAT_CNT_ACT(CSMC_DBData::unspecLong);
      }


      result = update();

    }// if ( PD_LADLE.getLastRow() == 1 ) // more than one ladle found !
    else
    {
      setLastError(std::string("PD_LADLE_ERROR"), 0, std::string(""));
    }
  }//  if( select(LADLENO, LADLETYPE) )
  else
  {
    // insert

    if ( GC_LADLE_DEF.isValidLadle(LADLENO, LADLETYPE) )
    {
      setLADLENO(LADLENO);
      setLADLETYPE(LADLETYPE);
      setTHERMALSTATUS(LadleState);
      setSTATUSNO(DEF_GC_LADLE_STATUS::Available);   
      setLADLEPOSID(DEF_GC_LADLE_POS::UNDEF); 

      if( PretreatCounter != CSMC_DBData::unspecLong )
      {
        setPRETREAT_CNT_ACT(PretreatCounter);
      }

      result = insert();
    }
  }

  if ( !result )
  {
    Error = getLastError();
  }

  if(Commit)
  {
    if(result)
    {
      commit();
    }
    else 
    {
      rollback();
    }
  }

  return result;
}

bool CPD_LADLE::doDeparture(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long &LadleNo, std::string &LadleType, long LadleLocation, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = true;

  CPD_HEAT_DATA     PD_HEAT_DATA     (m_pCBS_StdConnection);
  CPD_PRETREATDATA  PD_PRETREATDATA  (m_pCBS_StdConnection);
  CGC_LADLE_DEF     GC_LADLE_DEF     (m_pCBS_StdConnection);

  // we considered the incoming values for LadleNo and LadleType to be used
  // in case of invalid values, we will look at PD_HEAT_DATA to use the already stored values
  if ( LadleNo    == CSMC_DBData::unspecLong ||
       LadleType  == CSMC_DBData::unspecString )
  {
    if ( PD_HEAT_DATA.select(HEATID, TREATID, PLANT) )
    {
      long LADLENO          = PD_HEAT_DATA.getLADLENO(1);
      std::string LADLETYPE = PD_HEAT_DATA.getLADLETYPE(1);

      LadleNo   = LADLENO;
      LadleType = LADLETYPE;
    }
  }

  // still nothing found than stop processing
  if ( LadleNo    != CSMC_DBData::unspecLong && 
       LadleType  != CSMC_DBData::unspecString )
  {
    long PRETREAT_CNT_PREV = CSMC_DBData::unspecLong;
    long PRETREAT_CNT_ACT  = CSMC_DBData::unspecLong;
    double STEELWEIGHT = 0.;
    double SLAGWEIGHT  = 0.;

    // get new pretreatment counter from PD_PRETREATDATA for given heat
    if ( PD_PRETREATDATA.selectValidDataByHeat(HEATID,TREATID) )
    {
      PRETREAT_CNT_ACT  = PD_PRETREATDATA.getPRETREAT_COUNTER(1);
      STEELWEIGHT  = PD_PRETREATDATA.getSTEELWEIGHT(1);
      SLAGWEIGHT  = PD_PRETREATDATA.getSLAGWEIGHT(1);
    }

    if ( select(LadleNo,LadleType ) ) 
    {
      PRETREAT_CNT_PREV = getPRETREAT_CNT_ACT(1);
      double SCULLMASS  = getSCULLMASS(1);
      double TAREWEIGHT = getTAREWEIGHT(1);

      // prevent using invalid data
      STEELWEIGHT   = CDataConversion::SetInvalidToDefault(STEELWEIGHT,0.);
      SLAGWEIGHT    = CDataConversion::SetInvalidToDefault(SLAGWEIGHT,0.);
      TAREWEIGHT    = CDataConversion::SetInvalidToDefault(TAREWEIGHT,0.);
      SCULLMASS     = CDataConversion::SetInvalidToDefault(SCULLMASS,0.);

      setPRETREAT_CNT_ACT (PRETREAT_CNT_ACT);
      setPRETREAT_CNT_PREV(PRETREAT_CNT_PREV);

      setSTATUSNO(DEF_GC_LADLE_STATUS::Available);   
      setLADLEPOSID(LadleLocation);

      result = result && update();
    }
    else
    {
      if ( GC_LADLE_DEF.isValidLadle(LadleNo, LadleType) )
      {
        setLADLENO          (LadleNo);
        setLADLETYPE        (LadleType);
      
        setPRETREAT_CNT_ACT (PRETREAT_CNT_ACT);

        setSTATUSNO(DEF_GC_LADLE_STATUS::Available);   
        setLADLEPOSID(LadleLocation);

        result = result && insert();
      }
    }
  }
  else
  {
    setLastError(std::string("NO_DATA_FOUND"), 0, getActStatement() );
    result = true; // we dont want to stop proceeding when unknown ladle is sent
  }

  if (!result)	
  {
    Error = getLastError();
  }

	
	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}

	return result;	
}

bool CPD_LADLE::doTappingEnd(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long &LadleNo, std::string &LadleType, long LadleLocation, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = true;

  CDateTime Now;

  CPD_HEAT_DATA     PD_HEAT_DATA     (m_pCBS_StdConnection);
  CPD_PRETREATDATA  PD_PRETREATDATA  (m_pCBS_StdConnection);
  CGC_LADLE_DEF     GC_LADLE_DEF     (m_pCBS_StdConnection);

  // we considered the incoming values for LadleNo and LadleType to be used
  // in case of invalid values, we will look at PD_HEAT_DATA to use the already stored values
  if ( LadleNo    == CSMC_DBData::unspecLong ||
       LadleType  == CSMC_DBData::unspecString )
  {
    if ( PD_HEAT_DATA.select(HEATID, TREATID, PLANT) )
    {
      long LADLENO          = PD_HEAT_DATA.getLADLENO(1);
      std::string LADLETYPE = PD_HEAT_DATA.getLADLETYPE(1);

      LadleNo   = LADLENO;
      LadleType = LADLETYPE;
    }
  }

  // still nothing found than stop processing
  if ( LadleNo    != CSMC_DBData::unspecLong && 
       LadleType  != CSMC_DBData::unspecString )
  {
    double STEELWEIGHT = 0.;
    double SLAGWEIGHT  = 0.;

    // get new pretreatment counter from PD_PRETREATDATA for given heat
    if ( PD_PRETREATDATA.selectValidDataByHeat(HEATID,TREATID) )
    {
      STEELWEIGHT   = PD_PRETREATDATA.getSTEELWEIGHT(1);
      SLAGWEIGHT    = PD_PRETREATDATA.getSLAGWEIGHT(1);
    }

    if ( select(LadleNo,LadleType ) ) 
    {
      double SCULLMASS  = getSCULLMASS(1);
      double TAREWEIGHT = getTAREWEIGHT(1);

      // prevent using invalid data
      STEELWEIGHT   = CDataConversion::SetInvalidToDefault(STEELWEIGHT,0.);
      SLAGWEIGHT    = CDataConversion::SetInvalidToDefault(SLAGWEIGHT,0.);
      TAREWEIGHT    = CDataConversion::SetInvalidToDefault(TAREWEIGHT,0.);
      SCULLMASS     = CDataConversion::SetInvalidToDefault(SCULLMASS,0.);

      setSTATUSNO(DEF_GC_LADLE_STATUS::Available);   
      setLADLEPOSID(LadleLocation);
      setLAST_FILL_TIME(Now);

      result = result && update();
    }
    else
    {
      if ( GC_LADLE_DEF.isValidLadle(LadleNo, LadleType) )
      {
        setLADLENO          (LadleNo);
        setLADLETYPE        (LadleType);

        setSTATUSNO(DEF_GC_LADLE_STATUS::Available);   
        setLADLEPOSID(LadleLocation);
        setLAST_FILL_TIME(Now);

        result = result && insert();
      }
    }
  }
  else
  {
    setLastError(std::string("NO_DATA_FOUND"), 0, getActStatement() );
    result = true; // we dont want to stop proceeding when unknown ladle is sent
  }

  if (!result)	
  {
    Error = getLastError();
  }

	
	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}

	return result;	
}

bool CPD_LADLE::exists(long LADLENO, const std::string& LADLETYPE)
{
  cleanWhereStatement();

  m_Statement = "Select LADLENO from " + m_TableName;

  addWhereClause(CPD_LADLE::LADLENO,LADLENO);
  addWhereClause(CPD_LADLE::LADLETYPE,LADLETYPE);

  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }

  return CSMC_DBData::select();
}

bool CPD_LADLE::exists(long PRETREAT_CNT)
{
  cleanWhereStatement();

  m_Statement = "Select LADLENO from " + m_TableName;

  addWhereClause(CPD_LADLE::PRETREAT_CNT_ACT,PRETREAT_CNT);

  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }

  return CSMC_DBData::select();
}

std::string CPD_LADLE::getThermalStatus(long LADLENO, const std::string& LADLETYPE, cCBS_ODBC_DBError &Error)
{
  //Check if Ladle exists
  std::string THERMALSTATUS = CSMC_DBData::unspecString;
 
  if ( LADLENO   != CSMC_DBData::unspecLong &&
       LADLETYPE != CSMC_DBData::unspecString )
  {
    if ( select(LADLENO, LADLETYPE) )
    {
      THERMALSTATUS = getTHERMALSTATUS(1);
    }
    else
    {
      setLastError(std::string("NO_DATA_FOUND"), 0, getActStatement());
    }
  }
  else
  {
    setLastError(std::string("INVALID_DATA"), 0, getActStatement());
  }

  return THERMALSTATUS;
}

bool CPD_LADLE::switchHotMetalCounter(long LADLENO, const std::string& LADLETYPE, long HOTMETAL_CNT_ACT , bool Commit, cCBS_ODBC_DBError &Error)
{
  bool Result = true;

  if( LADLENO != DEF::Inv_Long )
  {
    if ( select(LADLENO, LADLETYPE) )
    {
      long HOTMETAL_CNT = getHOTMETAL_CNT_ACT(1);

      setHOTMETAL_CNT_PREV(HOTMETAL_CNT);
      setHOTMETAL_CNT_ACT(HOTMETAL_CNT_ACT);

      Result = Result && update();

      if (!Result)
        Error = getLastError();

      if (Commit)
      {
        if (Result)
          commit();
        else
          rollback();
      }
    }
  }// if( LADLENO != DEF::Inv_Long )
  else
  {
    // EL_ !!
    setLastError(std::string("PD_LADLE_ERROR"), 0, std::string(""));
  }

  return Result;
}

// function does not perform commit
bool CPD_LADLE::switchPretreatmentCounter(long LADLENO, const std::string& LADLETYPE, long PRETREAT_CNT_ACT , bool Commit, cCBS_ODBC_DBError &Error)
{
  bool Result = true;

  CPD_PRETREATDATA  PD_PRETREATDATA  (m_pCBS_StdConnection);

  if ( !PD_PRETREATDATA.select(PRETREAT_CNT_ACT) )
  {
    std::string Msg = "invalid pretreat counter received: "  + CDataConversion::LongToString(PRETREAT_CNT_ACT,"-");
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DBWriteError(sMessage,"PRETREAT_CNT_ACT","PD_LADLE",Msg.c_str());

    PRETREAT_CNT_ACT = CSMC_DBData::unspecLong;
  }

  if( LADLENO != DEF::Inv_Long )
  {
    if ( select(LADLENO, LADLETYPE) )
    {
      long PRETREAT_CNT = getPRETREAT_CNT_ACT(1);

      setPRETREAT_CNT_PREV(PRETREAT_CNT);
      setPRETREAT_CNT_ACT(PRETREAT_CNT_ACT);

      Result = Result && update();

      if (!Result)
        Error = getLastError();

      if (Commit)
      {
        if (Result)
          commit();
        else
          rollback();
      }
    }
  }// if( LADLENO != DEF::Inv_Long )
  else
  {
    // EL_ !!
    setLastError(std::string("PD_LADLE_ERROR"), 0, std::string(""));
  }

  return Result;
}

bool CPD_LADLE::updateHotMetalCounter(long LADLENO, const string& LADLETYPE, long HOTMETAL_CNT_ACT, bool Commit, cCBS_ODBC_DBError &Error)
{
  //Check if Ladle exists
  bool result = !exists(LADLENO, LADLETYPE);
  if (!result) //Ladle exists -> update
  {
    setHOTMETAL_CNT_ACT(HOTMETAL_CNT_ACT);

    result = CSMC_DBData::update();
  }
  else
  {
    setLastError("NO_DATA_FOUND", 0, getActStatement()); 
  }

  if (!result)
    Error = getLastError();

  if (Commit)
  {
    if (result)
      commit();
    else
      rollback();
  }
  return result;
}

bool CPD_LADLE::updateLocation(long LADLENO, const std::string& LADLETYPE, long Location, bool Commit, cCBS_ODBC_DBError &Error)
{
	
	bool result = false;

  if ( select(LADLENO, LADLETYPE) ) //Ladle exists -> update
	{		
    setLADLEPOSID(Location);

		result = update();
	}
	else
	{
		setLastError(string("NO_DATA_FOUND"), 0, getActStatement()); 
	}

	if (!result)
		Error = getLastError();

	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}
	return result;
}

bool CPD_LADLE::updateStatusNo(long LADLENO, const std::string& LADLETYPE, long StatusNo, bool Commit, cCBS_ODBC_DBError &Error)
{
	bool result = false;

  if ( select(LADLENO, LADLETYPE) ) //Ladle exists -> update
	{		
    setSTATUSNO(StatusNo);

		result = update();
	}
	else
	{
		setLastError(string("NO_DATA_FOUND"), 0, getActStatement()); 
	}

	if (!result)
		Error = getLastError();

	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}
	return result;
}

bool CPD_LADLE::updateTermalStatus(long LADLENO, const std::string& LADLETYPE, const std::string &THERMALSTATUS, bool Commit, cCBS_ODBC_DBError &Error)
{
  //Check if Ladle exists
  bool result = true;

  if (result && select(LADLENO, LADLETYPE) )
  {
    if ( !THERMALSTATUS.empty() && THERMALSTATUS != CSMC_DBData::unspecString )
    {
      setTHERMALSTATUS(THERMALSTATUS);
      result = update();
    }
    else
    {
      setLastError(std::string("INVALID_THERMALSTATUS_RECEIVED"), 0, getActStatement());
    }   
  }
  else
  {
    setLastError(std::string("NO_DATA_FOUND"), 0, getActStatement());
  }

  if (!result)
    Error = getLastError();

  if (Commit)
  {
    if (result)
      commit();
    else
      rollback();
  } 

  return result;
}

bool CPD_LADLE::updateTimes(long LADLENO, const std::string& LADLETYPE, const CDateTime& NewFillTime, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = select(LADLENO, LADLETYPE);
  if (result)
  {
    if ( NewFillTime != CSMC_DBData::unspecDate )
    {
      CDateTime LAST_FILL_TIME = getLAST_FILL_TIME(1);
      if ( LAST_FILL_TIME != CSMC_DBData::unspecDate )
      {
        double Duration = CDateTime::subTimes(LAST_FILL_TIME, NewFillTime).asSeconds() / 60.0;
        setLADLE_CIRCULATION_TIME(Duration);
      }
      else
      {
        log("LAST_FILL_TIME is not set to calculate LADLE_CIRCULATION_TIME",2);
      }

      CDateTime LAST_EMPTY_TIME = getLAST_EMPTY_TIME(1);
      if ( LAST_EMPTY_TIME != CSMC_DBData::unspecDate )
      {
        double Duration = CDateTime::subTimes(LAST_EMPTY_TIME, NewFillTime).asSeconds() / 60.0;
        setDURSINCELASTUSE(Duration);
      }
      else
      {
        log("LAST_EMPTY_TIME is not set to calculate LADLE_CIRCULATION_TIME",2);
      }

      setLAST_FILL_TIME(NewFillTime);
      result = update();
    }
  }
  else
  {
    setLastError("NO_DATA_FOUND", 0, getActStatement());
  }

  if (!result)
    Error = getLastError();

  if (Commit)
  {
    if (result)
      commit();
    else
      rollback();
  } 

  return result;
}


