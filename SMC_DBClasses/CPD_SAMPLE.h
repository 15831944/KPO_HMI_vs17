//## Copyright (C) 2010 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 

#if defined (_MSC_VER) && (_MSC_VER >= 1000)
#pragma once
#endif
#ifndef _INC_CPD_SAMPLE_INCLUDED
#define _INC_CPD_SAMPLE_INCLUDED

#include "CSMC_DBData.h"

class CGC_MEASUREMENT_NAME;
class CPD_SAMPLE_ENTRY;

class CPD_SAMPLE
: public CSMC_DBData
{

public:
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string SAMPLE_COUNTER;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string HEATID;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string HM_ID;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string TREATID;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string PLANT;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string PLANTNO;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string PRODORDERID;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string SAMPLENO;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string MEASTYPENO;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string GROUPNO;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string SAMPLETIME;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string RECTIME;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string RECTIMELAB;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string SAMPLEMODE;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string SAMPLELOC;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string LADLENO;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string LADLETYPE;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string DURSINCEHEATANNOUNCEMENT;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string DURSINCESTARTOFHEAT;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string SAMPLEUSABLE;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string ORIGIN;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string USERCODE;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string SAMPLEID_CUST;
  //##DBClassCodeUtility ! DO NOT EDIT !
  static const std::string REVTIME;

  //##DBClassCodeUtility ! DO NOT EDIT !
  CPD_SAMPLE(cCBS_StdConnection* Connection);

  //##DBClassCodeUtility ! DO NOT EDIT !
  CPD_SAMPLE(cCBS_Connection* Connection);

  //##DBClassCodeUtility ! DO NOT EDIT !
  CPD_SAMPLE();

  //##DBClassCodeUtility ! DO NOT EDIT !
  ~CPD_SAMPLE();

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Unique sample counter
  long getSAMPLE_COUNTER(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setSAMPLE_COUNTER(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Heat identifier, gives the possibility to select all samples for this heat.
  std::string getHEATID(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setHEATID(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Hot metal identifier, gives the possibility to select all samples for this hot metal.
  std::string getHM_ID(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setHM_ID(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Treatment identifier
  std::string getTREATID(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setTREATID(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Plant identifier
  std::string getPLANT(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setPLANT(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Plant number
  long getPLANTNO(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setPLANTNO(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Production oder identification
  std::string getPRODORDERID(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setPRODORDERID(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Sample No, Definition see Requirment Book Naming standard specification
  long getSAMPLENO(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setSAMPLENO(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Identifies the type of measurement
  long getMEASTYPENO(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setMEASTYPENO(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Grouping of measurements makes sense in the following situations:, 1. Two measurements has been taken together, e.g. with a sub lance and special devices. The results arrives the system at different times. Grouping these measurements together gives the possibility to indicate the coherence of these measurements, e.g., for statistical evaluations as introduced at BOF, 2. Assume the situation that two hot metal ladles are assigned to a heat. Then we have an entry for the PRODORDERID in the PD_SAMPLE and if the heat already exists also an entry with the HEATID. In case one ladle was de-assigned from the heat we have to delete the corresponding entries for HEATID and PRODORDERID from the table, but the entries for the other ladle must remain. Using this GROUPNO by entering the HOTMETAL_COUNTER allows the deletion of the data only for the de-assigned ladle.
  long getGROUPNO(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setGROUPNO(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Sample taken time
  CDateTime getSAMPLETIME(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setSAMPLETIME(const CDateTime& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Sample taken receive time (telegram received)
  CDateTime getRECTIME(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setRECTIME(const CDateTime& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Sample analysis receive time (telegram received)
  CDateTime getRECTIMELAB(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setRECTIMELAB(const CDateTime& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Manually, automatic
  long getSAMPLEMODE(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setSAMPLEMODE(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Sample location
  std::string getSAMPLELOC(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setSAMPLELOC(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Unique ladle number
  long getLADLENO(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setLADLENO(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##e.g. Hot Metal -> H, Teeming -> T
  std::string getLADLETYPE(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setLADLETYPE(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Duration since heat announcement
  double getDURSINCEHEATANNOUNCEMENT(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setDURSINCEHEATANNOUNCEMENT(double value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Duration since start of heat
  double getDURSINCESTARTOFHEAT(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setDURSINCESTARTOFHEAT(double value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##0: not usable, 1: usable with sample taken detected, 2: usable without sample taken detected
  long getSAMPLEUSABLE(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setSAMPLEUSABLE(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Measured -> 1, Calculated -> 2, Manual entered -> 3
  long getORIGIN(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setORIGIN(long value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##User who entered data
  std::string getUSERCODE(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setUSERCODE(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Customer specific representation of the sample. It is only used for display and reporting and will not used for interpretation of details.
  std::string getSAMPLEID_CUST(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setSAMPLEID_CUST(const std::string& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  //##Date and time of last revision
  CDateTime getREVTIME(long Row);

  //##DBClassCodeUtility ! DO NOT EDIT !
  void setREVTIME(const CDateTime& value);

  //##DBClassCodeUtility ! DO NOT EDIT !
  bool select(long SAMPLE_COUNTER);

  //## ----------------------------------END-GENERATED-CODE--------------------- 

  //## ----------------------------------YOUR-CODE------------------------------ 

  bool selectByTypeAndOrigin(std::string HeatID,std::string TreatID,std::string Plant,long PlantNo,long MEASTYPENO,long ORIGIN);

  bool selectHeatSample(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long MEASTYPENO , long SAMPLENO);

  bool selectHeatSampleBySampleTime(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long MEASTYPENO, long SAMPLENO, bool ASC /*= true*/);

  bool selectLastHeatSample(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT);

  bool selectLastHeatSampleByMeasTypeNo(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT,const long &MEASTYPENO);

  bool selectLastHeatTemp(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT);

  bool selectLastSampleWithoutAnalysis(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long MEASTYPENO);
	bool selectLastSampleWithoutAnalysisHMD(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long MEASTYPENO);

  bool selectPlantSample(const std::string& PLANT, long PLANTNO, long MEASTYPENO , long SAMPLENO);

  bool selectProdOrderSample(const std::string& PRODORDERID, const std::string& PLANT, long PLANTNO, long MEASTYPENO);

  bool selectUsableHeatSample(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long MEASTYPENO , long SAMPLENO);

  bool selectUsedHeatSample(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long MEASTYPENO , long SAMPLENO);

  bool copyToSampleCounter(long SAMPLE_COUNTER, long NEW_SAMPLE_COUNTER, long NEW_MEASTYPENO, bool Commit, cCBS_ODBC_DBError &Error);

  seqSample AnalysisToSample(seqAnalysis SeqAnalysis);

  bool deleteByRecTime(const CDateTime& OlderThan, bool IsNotInUse = false);

  bool deleteRow(long SAMPLE_COUNTER);

  virtual void doOnConstruct();

  virtual void doOnDestruct();

  seqAnalysis getAnalysisByMeasScope(seqAnalysis SeqAnalysis, long SCOPENO);

  // return highest sample no of a hot metal id 
  long getHighestHMSampleNo(const std::string& HM_ID);

  long getLastSampleNo(const std::string & HEATID, const std::string & TREATID, const std::string & PLANT, long PLANTNO, long MEASTYPENO);

  long getNextSAMPLE_COUNTER();

  bool getNextSAMPLE_COUNTER(long &SAMPLE_COUNTER, cCBS_ODBC_DBError &Error);

  long getNoOfSamples(const std::string & HEATID, const std::string & TREATID, const std::string & PLANT, long PLANTNO, long MEASTYPENO);

  seqSample getSample(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long MEASTYPENO, long SAMPLENO );

  seqSample getSample(long SAMPLE_COUNTER);

  double getSampleMeasValue(long SAMPLE_COUNTER, const std::string MEASNAME);

  bool hasSampleData(long SAMPLE_COUNTER);

  long insertAnalysis(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long ORIGIN, long MEASTYPENO, long SAMPLENO, seqAnalysis SeqAnalysis, bool Commit, cCBS_ODBC_DBError &Error);

  long insertSample(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, long ORIGIN, long MEASTYPENO, long SAMPLENO, seqSample SeqSample, bool Commit, cCBS_ODBC_DBError &Error);

  bool insertSampleDetail(long SAMPLE_COUNTER, const std::string& MeasName, double MeasValue);

  bool insertSampleDetail(long SAMPLE_COUNTER, sSample & Sample);

  seqAnalysis SampleToAnalysis(seqSample SeqSamples);

  bool updateAnalysis(long SAMPLE_COUNTER, seqAnalysis SeqAnalysis, bool Commit, cCBS_ODBC_DBError &Error);

  bool updateSample(long SAMPLE_COUNTER, seqSample SeqSample, bool Commit, cCBS_ODBC_DBError &Error);

  bool updateSampleDetails(long SAMPLE_COUNTER, long SAMPLENO);

  bool updateSampleDetails(long SAMPLE_COUNTER, const std::string& PRODORDERID, long SAMPLEMODE,const std::string& USERCODE);

  bool updateSampleDetails(long SAMPLE_COUNTER, const std::string& PRODORDERID, long SAMPLEMODE, const std::string& SAMPLELOC, long SAMPLEUSABLE, const std::string& USERCODE, const std::string& SAMPLEID_CUST, long ORIGIN);

  bool updateSampleHeatData(long SAMPLE_COUNTER, const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, cCBS_ODBC_DBError &Error);

  // OverWriteSampleTime should be false, only for special purpose is it allowed to update.  
  bool updateSampleTimes(long SAMPLE_COUNTER, const CDateTime& SAMPLETIME, const CDateTime& RECTIME, const CDateTime& RECTIMELAB, double DURSINCEHEATANNOUNCEMENT, double DURSINCESTARTOFHEAT, bool OverWriteSampleTime);

  CGC_MEASUREMENT_NAME * m_pGC_MEASUREMENT_NAME;
  CPD_SAMPLE_ENTRY * m_pPD_SAMPLE_ENTRY;


  bool CPD_SAMPLE::insertPSSample(long pSampleCounter, const string &pHeatId, const string &pTreatId, const string &pPlant, long pPlantNo, long pLadleNo, const string &pLadleType, long pMeasType, sDate &pDateTime, const string &pUser, bool pCommit, cCBS_ODBC_DBError &pError);

	bool CPD_SAMPLE::insertByPrevSample_HMD(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO,long pSampleCounter, long pPrevSampleCounter, sDate &pDateTime, long pManEntry, const string &pUser, const std::string& mLadleType, long mLadleNo,long pMeasType,bool pCommit, cCBS_ODBC_DBError &pError);

	bool selectByType_HMD(std::string HeatID,std::string TreatID,std::string Plant,long PlantNo,long MEASTYPENO);
};

#endif /* _INC_CPD_SAMPLE_INCLUDED */
