//## Copyright (C) 2010 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "CTreatID.h"
#include "CDataConversion.h"
#include "cCBS_StdEventLogFrameController.h"
#include "DEF_GC_PLANT_DEF.h"
#include "CPD_HEAT_DATA.h"
#include "CPP_HEAT.h"
#include "CPP_HEAT_PLANT.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT_PLANT::HEATID("HEATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT_PLANT::TREATID("TREATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT_PLANT::PLANT("PLANT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT_PLANT::PLANTNO("PLANTNO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT_PLANT::HEATID_CUST_PLAN("HEATID_CUST_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT_PLANT::TREATID_CUST_PLAN("TREATID_CUST_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT_PLANT::TREATSTART_PLAN("TREATSTART_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT_PLANT::TREATEND_PLAN("TREATEND_PLAN");

//##DBClassCodeUtility ! DO NOT EDIT !
CPP_HEAT_PLANT::CPP_HEAT_PLANT(cCBS_StdConnection* Connection)
:CSMC_DBData("PP_HEAT_PLANT",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPP_HEAT_PLANT::CPP_HEAT_PLANT(cCBS_Connection* Connection)
:CSMC_DBData("PP_HEAT_PLANT",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPP_HEAT_PLANT::CPP_HEAT_PLANT()
:CSMC_DBData("PP_HEAT_PLANT")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPP_HEAT_PLANT::~CPP_HEAT_PLANT()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Internal heat identifier
std::string CPP_HEAT_PLANT::getHEATID(long Row)
{
  return getString(CPP_HEAT_PLANT::HEATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT_PLANT::setHEATID(const std::string& value)
{
  setString(CPP_HEAT_PLANT::HEATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment identifier
std::string CPP_HEAT_PLANT::getTREATID(long Row)
{
  return getString(CPP_HEAT_PLANT::TREATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT_PLANT::setTREATID(const std::string& value)
{
  setString(CPP_HEAT_PLANT::TREATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant identifier
std::string CPP_HEAT_PLANT::getPLANT(long Row)
{
  return getString(CPP_HEAT_PLANT::PLANT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT_PLANT::setPLANT(const std::string& value)
{
  setString(CPP_HEAT_PLANT::PLANT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant number
long CPP_HEAT_PLANT::getPLANTNO(long Row)
{
  return getLong(CPP_HEAT_PLANT::PLANTNO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT_PLANT::setPLANTNO(long value)
{
  setLong(CPP_HEAT_PLANT::PLANTNO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Generated, if not fixed by L3
std::string CPP_HEAT_PLANT::getHEATID_CUST_PLAN(long Row)
{
  return getString(CPP_HEAT_PLANT::HEATID_CUST_PLAN, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT_PLANT::setHEATID_CUST_PLAN(const std::string& value)
{
  setString(CPP_HEAT_PLANT::HEATID_CUST_PLAN, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment planned by L3
std::string CPP_HEAT_PLANT::getTREATID_CUST_PLAN(long Row)
{
  return getString(CPP_HEAT_PLANT::TREATID_CUST_PLAN, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT_PLANT::setTREATID_CUST_PLAN(const std::string& value)
{
  setString(CPP_HEAT_PLANT::TREATID_CUST_PLAN, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Planned start time at unit
CDateTime CPP_HEAT_PLANT::getTREATSTART_PLAN(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPP_HEAT_PLANT::TREATSTART_PLAN, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT_PLANT::setTREATSTART_PLAN(const CDateTime& value)
{
 setString(CPP_HEAT_PLANT::TREATSTART_PLAN, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Planed end time at unit
CDateTime CPP_HEAT_PLANT::getTREATEND_PLAN(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPP_HEAT_PLANT::TREATEND_PLAN, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT_PLANT::setTREATEND_PLAN(const CDateTime& value)
{
 setString(CPP_HEAT_PLANT::TREATEND_PLAN, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPP_HEAT_PLANT::select(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT_PLANT::HEATID,HEATID);
  addWhereClause(CPP_HEAT_PLANT::TREATID,TREATID);
  addWhereClause(CPP_HEAT_PLANT::PLANT,PLANT);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CPP_HEAT_PLANT::selectByCustData(const std::string& HEATID_CUST_PLAN, const std::string& TREATID_CUST_PLAN, const std::string& PLANT, bool ASC /* = true */)
{
  cleanWhereStatement();

  m_Statement = "select * from " + m_TableName;

  addWhereClause(CPP_HEAT_PLANT::HEATID_CUST_PLAN, HEATID_CUST_PLAN);
  addWhereClause(CPP_HEAT_PLANT::TREATID_CUST_PLAN,TREATID_CUST_PLAN);
  addWhereClause(CPP_HEAT_PLANT::PLANT,PLANT);

  if (ASC)
  {
    m_Statement += getWhereStatement() + ";";
  }
  else
  {
    m_Statement += getWhereStatement() + " ORDER BY HEATID_CUST_PLAN DESC, TREATID_CUST_PLAN DESC;";
  }

  return CSMC_DBData::select();
}

bool CPP_HEAT_PLANT::selectByCustHeatAndPlanningState(const std::string& HEATID_CUST_PLAN, const std::string& TREATID_CUST_PLAN, long PLANNED)
{
  CPP_HEAT PP_HEAT(m_pCBS_StdConnection);

  std::vector<std::string> HeatsByPlanningState = PP_HEAT.getHeatsByPlanningState(PLANNED);

	cleanWhereStatement();
	
	m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT_PLANT::HEATID_CUST_PLAN,HEATID_CUST_PLAN);
  addWhereClause(CPP_HEAT_PLANT::TREATID_CUST_PLAN,TREATID_CUST_PLAN);

  addWhereClause(CPP_HEAT_PLANT::HEATID + " is not NULL");
  addWhereClause(CPP_HEAT_PLANT::TREATID + " is not NULL");
  addWhereClause(CPP_HEAT_PLANT::TREATSTART_PLAN + " is not NULL");

  if ( HeatsByPlanningState.size() > 0 )
  {
    addWhereClause(CPP_HEAT_PLANT::HEATID, HeatsByPlanningState, "IN");
  }
  else
  {
    addWhereClause(CPP_HEAT_PLANT::HEATID + " is NULL");
  }

  m_Statement += getWhereStatement() + " order by TREATSTART_PLAN;";

	return CSMC_DBData::select();
}

bool CPP_HEAT_PLANT::selectByHeatData(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, bool ASC /* = true */)
{
  cleanWhereStatement();

  m_Statement = "select * from " + m_TableName;

  addWhereClause(CPP_HEAT_PLANT::HEATID,HEATID);
  addWhereClause(CPP_HEAT_PLANT::TREATID,TREATID);
  addWhereClause(CPP_HEAT_PLANT::PLANT,PLANT);

  if (ASC)
  {
    m_Statement += getWhereStatement() + " ORDER BY HEATID, TREATID;";
  }
  else
  {
    m_Statement += getWhereStatement() + " ORDER BY HEATID DESC, TREATID DESC;";
  }

  return CSMC_DBData::select();
}

bool CPP_HEAT_PLANT::selectByHeatPlantData(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO)
{
	cleanWhereStatement();

  m_Statement = "select * from " + m_TableName;
	
	addWhereClause(CPP_HEAT_PLANT::HEATID,HEATID);
	addWhereClause(CPP_HEAT_PLANT::TREATID,TREATID);
  addWhereClause(CPP_HEAT_PLANT::PLANT,PLANT);
  addWhereClause(CPP_HEAT_PLANT::PLANTNO,PLANTNO);

	m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CPP_HEAT_PLANT::selectByPlanningState(const std::string& PLANT, long PLANTNO, long PLANNED)
{
  return selectByPlanningState(PLANT, PLANTNO, PLANNED, true); //as per JSW
}

bool CPP_HEAT_PLANT::selectByPlanningState(const std::string& PLANT, long PLANTNO, long PLANNED, bool OrderByHeatIdCustPlan)
{
  CPP_HEAT PP_HEAT(m_pCBS_StdConnection);

  std::vector<std::string> HeatsByPlanningState = PP_HEAT.getHeatsByPlanningState(PLANNED);

	cleanWhereStatement();
	
	m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT_PLANT::PLANT,PLANT);
  addWhereClause(CPP_HEAT_PLANT::PLANTNO,PLANTNO);

  addWhereClause(CPP_HEAT_PLANT::HEATID + " is not NULL");
  addWhereClause(CPP_HEAT_PLANT::TREATID + " is not NULL");
  addWhereClause(CPP_HEAT_PLANT::TREATSTART_PLAN + " is not NULL");

  if ( HeatsByPlanningState.size() > 0 )
  {
    addWhereClause(CPP_HEAT_PLANT::HEATID, HeatsByPlanningState, "IN");
  }
  else
  {
    addWhereClause(CPP_HEAT_PLANT::HEATID + " is NULL");
  }


  if ( OrderByHeatIdCustPlan )
  {
    m_Statement += getWhereStatement() + " order by " + CPP_HEAT_PLANT::HEATID_CUST_PLAN + " ;";
  }
  else
  {
    m_Statement += getWhereStatement() + " order by TREATSTART_PLAN, HEATID;";
  }


	return CSMC_DBData::select();
}

bool CPP_HEAT_PLANT::selectByPlanningStateAndPreset(const std::string& PLANT, long PLANTNO, long PLANNED, long PRESET_HEATID)
{
  return selectByPlanningStateAndPreset(PLANT, PLANTNO, PLANNED, PRESET_HEATID, false);
}

bool CPP_HEAT_PLANT::selectByPlanningStateAndPreset(const std::string& PLANT, long PLANTNO, long PLANNED, long PRESET_HEATID, bool OrderByHeatIdCustPlan)
{
  CPP_HEAT PP_HEAT(m_pCBS_StdConnection);

  std::vector<std::string> HeatsByPlanningStateAndPreset = PP_HEAT.getHeatsByPlanningStateAndPreset(PLANNED, PRESET_HEATID);

	cleanWhereStatement();
	
	m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT_PLANT::PLANT,PLANT);
  addWhereClause(CPP_HEAT_PLANT::PLANTNO,PLANTNO);

  addWhereClause(CPP_HEAT_PLANT::HEATID + " is not NULL");
  addWhereClause(CPP_HEAT_PLANT::TREATID + " is not NULL");
  addWhereClause(CPP_HEAT_PLANT::TREATSTART_PLAN + " is not NULL");

  if ( HeatsByPlanningStateAndPreset.size() > 0 )
  {
    addWhereClause(CPP_HEAT_PLANT::HEATID, HeatsByPlanningStateAndPreset, "IN");
  }
  else
  {
    addWhereClause(CPP_HEAT_PLANT::HEATID + " is NULL");
  }

  if ( OrderByHeatIdCustPlan )
  {
    m_Statement += getWhereStatement() + " order by " + CPP_HEAT_PLANT::HEATID_CUST_PLAN + " ;";
  }
  else
  {
    m_Statement += getWhereStatement() + " order by " + CPP_HEAT_PLANT::TREATSTART_PLAN + " ;";
  }

	return CSMC_DBData::select();
}

bool CPP_HEAT_PLANT::selectByPlantData(const std::string& PLANT, long PLANTNO)
{
	cleanWhereStatement();
	
	m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT_PLANT::PLANT,PLANT);	
  addWhereClause(CPP_HEAT_PLANT::PLANTNO,PLANTNO);
  addWhereClause(CPP_HEAT_PLANT::TREATSTART_PLAN + " is not NULL");
	
	m_Statement += getWhereStatement() + " order by TREATSTART_PLAN;";

	return CSMC_DBData::select();
}

bool  CPP_HEAT_PLANT::selectCanFillBasketOrderSerils(const std::string& BeginHeat,const std::string &Plant )
{
  cleanWhereStatement();
  m_Statement = "select * from " + m_TableName;

  addWhereClause(CPP_HEAT_PLANT::PLANT,Plant);
  addWhereClause(CPP_HEAT_PLANT::HEATID,BeginHeat,">=");

  //should the fields
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CPP_HEAT_PLANT::selectNextHeatsForPlant(const std::string& PLANT, long PLANTNO)
{
	cleanWhereStatement();
	
	m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT_PLANT::PLANT,PLANT);	
  addWhereClause(CPP_HEAT_PLANT::PLANTNO,PLANTNO);
  addWhereClause(CPP_HEAT_PLANT::TREATSTART_PLAN + " is not NULL");
	
	m_Statement += getWhereStatement() + " order by TREATSTART_PLAN DESC, HEATID, TREATID;";

	return CSMC_DBData::select();
}

bool CPP_HEAT_PLANT::selectOrderedByMaxTreatID(const std::string& HEATID, const std::string& PLANT)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT_PLANT::HEATID, HEATID);  
  addWhereClause(CPP_HEAT_PLANT::PLANT,PLANT);  

  m_Statement += getWhereStatement();
  m_Statement += " order by TREATID DESC ;";

  return CSMC_DBData::select();
}

bool CPP_HEAT_PLANT::selectOrderedByMaxTreatIDCustPlan(const std::string& HEATID_CUST_PLAN, const std::string& PLANT)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT_PLANT::HEATID_CUST_PLAN, HEATID_CUST_PLAN);  
  addWhereClause(CPP_HEAT_PLANT::PLANT,PLANT);  

  m_Statement += getWhereStatement();
  m_Statement += " order by TREATID_CUST_PLAN DESC ;";

  return CSMC_DBData::select();
}

bool CPP_HEAT_PLANT::selectOrderedByPlannedTreatmentStart(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, bool asc)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT_PLANT::HEATID,HEATID);
  addWhereClause(CPP_HEAT_PLANT::TREATID,TREATID);
  addWhereClause(CPP_HEAT_PLANT::PLANT,PLANT);
  m_Statement += getWhereStatement();
  
  m_Statement += " order by TREATSTART_PLAN ";
  
  if (asc)
    m_Statement += " ASC ";
  else
    m_Statement += " DESC ";

  m_Statement += "NULLS LAST;";

  return CSMC_DBData::select();
}

bool CPP_HEAT_PLANT::selectOrderedByPlantData(const std::string& PLANT, long PLANTNO, bool asc)
{
	cleanWhereStatement();
	
	m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT_PLANT::PLANT,PLANT);	
  addWhereClause(CPP_HEAT_PLANT::PLANTNO,PLANTNO);
	
  m_Statement += getWhereStatement() ;

  if (asc)
  {
    m_Statement += " order by " + CPP_HEAT_PLANT::HEATID_CUST_PLAN + " ASC ;";
  }
  else
  {
    m_Statement += " order by " + CPP_HEAT_PLANT::HEATID_CUST_PLAN + " DESC ;";
  }

	return CSMC_DBData::select();
}

bool CPP_HEAT_PLANT::deleteOneRow( std::string& HEATID_CUST_PLAN, std::string& TREATID_CUST_PLAN, const std::string& PLANT)
{
  cleanWhereStatement();

  addWhereClause(CPP_HEAT_PLANT::HEATID_CUST_PLAN, HEATID_CUST_PLAN);
  addWhereClause(CPP_HEAT_PLANT::TREATID_CUST_PLAN,TREATID_CUST_PLAN);
  addWhereClause(CPP_HEAT_PLANT::PLANT,PLANT);

  return deleteRows();
}

bool CPP_HEAT_PLANT::deleteRow(const std::string &HEATID, const std::string &TREATID, const std::string &PLANT, bool Commit, cCBS_ODBC_DBError &Error)
{
	std::stringstream sql;
	sql << "delete from PP_HEAT_PLANT" 
		<< "  where HEATID = '" << HEATID << "'"
		<< "   and TREATID = '" << TREATID << "'"
		<< "   and PLANT = '" << PLANT << "'";

	bool result = executeSQL(sql.str());
	if (!result)
		Error = getLastError();

	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}

	return result;
}

bool CPP_HEAT_PLANT::deleteRowsbyHeatID(const std::string& HEATID )
{
  cleanWhereStatement();

  addWhereClause(CPP_HEAT_PLANT::HEATID, HEATID);

  return deleteRows();
}

bool CPP_HEAT_PLANT::deleteRowsbyPlant(const std::string& HEATID,const std::string &PLANT )
{
  cleanWhereStatement();
  
  addWhereClause(CPP_HEAT_PLANT::HEATID, HEATID);
  addWhereClause(CPP_HEAT_PLANT::PLANT,PLANT);

  return deleteRows();
}

bool CPP_HEAT_PLANT::doCancelHeat(const std::string& HeatId, const std::string& TreatId, const std::string& Plant, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = true;

  // find maximum TreatID
  if( selectOrderedByMaxTreatID(HeatId,Plant) )
  {
    std::string MaxTreatID = getTREATID(1);

    // check if data for heat, treat, and plant exists
    if ( select(HeatId,TreatId,Plant) )
    {
      // read data for later insert
      CDateTime now;
      CDateTime TREATSTART_PLAN     = getTREATSTART_PLAN(1);
      CDateTime TREATEND_PLAN       = getTREATEND_PLAN(1);
      std::string HEATID_CUST_PLAN  = getHEATID_CUST_PLAN(1);
      std::string TREATID_CUST_PLAN = getTREATID_CUST_PLAN(1);
      long PLANTNO                  = getPLANTNO(1);

      // manage TreatID by using format !
      CTreatID TreatID;
      std::string NextTreatID = TreatID.generateNextTreatID(MaxTreatID);

      // create new line

      setHEATID(HeatId);
      setTREATID(NextTreatID);
      setPLANT(Plant);
      setPLANTNO(PLANTNO);
      setHEATID_CUST_PLAN(HEATID_CUST_PLAN);
      setTREATID_CUST_PLAN(TREATID_CUST_PLAN);
      setTREATSTART_PLAN(TREATSTART_PLAN);
      setTREATEND_PLAN(TREATEND_PLAN);

      result = result && update();

      if (!result)
        Error = getLastError();

      if (Commit)
      {
        if (result)
          commit();
        else
          rollback();
      }
    }// if ( select(HeatId,TreatId,Plant) )
    else
    {
      log("CPP_HEAT_PLANT::creatNewEntry no data found or more than one row selected !",2);
    }
  }
  else
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DBReadError(sMessage,"", m_TableName.c_str(), "" );
  }

  return result;
}

bool CPP_HEAT_PLANT::exists(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
	cleanWhereStatement();

	m_Statement = "Select HEATID from " + m_TableName;
	
  addWhereClause(CPP_HEAT_PLANT::HEATID,HEATID);
	addWhereClause(CPP_HEAT_PLANT::TREATID,TREATID);
  addWhereClause(CPP_HEAT_PLANT::PLANT,PLANT);
   
  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }

	return CSMC_DBData::select();
}

bool CPP_HEAT_PLANT::exists(const std::string& HEATID_CUST_PLAN)
{
	cleanWhereStatement();

	m_Statement = "Select HEATID_CUST_PLAN from " + m_TableName;

  addWhereClause(CPP_HEAT_PLANT::HEATID_CUST_PLAN,HEATID_CUST_PLAN);
   
  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }

	return CSMC_DBData::select();
}

std::string CPP_HEAT_PLANT::getLastCustHeatInProduction(const std::string& PLANT, long PLANTNO)
{
  std::string LastHeatInProduction = CSMC_DBData::unspecString;

  // select HEATID_CUST_PLAN with highest entry
  if ( selectOrderedByPlantData(PLANT, PLANTNO, false ) )
  {
    CPD_HEAT_DATA PD_HEAT_DATA(m_pCBS_StdConnection);

    for ( long i = 1 ; i <= getLastRow() ; ++i )
    {
      std::string HEATID  = getHEATID(i);
      std::string TREATID = getTREATID(i);

      if ( PD_HEAT_DATA.isHeatInProduction(HEATID, TREATID, PLANT ) )
      {
        LastHeatInProduction = getHEATID_CUST_PLAN(1); 
      }
    }
  }

  return LastHeatInProduction;
}

bool CPP_HEAT_PLANT::isCustHeatInProduction(const std::string& HEATID_CUST_PLAN, const std::string& TREATID_CUST_PLAN, const std::string& PLANT)
{
  bool isInProduction = false;

  // select HEATID_CUST_PLAN with highest TREATID_CUST_PLAN
  if ( selectByCustData(HEATID_CUST_PLAN, TREATID_CUST_PLAN, PLANT, false ) )
  {
    CPD_HEAT_DATA PD_HEAT_DATA(m_pCBS_StdConnection);

    std::string HEATID  = getHEATID(1);
    std::string TREATID = getTREATID(1);

    isInProduction = PD_HEAT_DATA.isHeatInProduction(HEATID, TREATID, PLANT );
  }

  return isInProduction;
}

bool CPP_HEAT_PLANT::isCustHeatPlanned(const std::string& HEATID_CUST_PLAN, const std::string& TREATID_CUST_PLAN)
{
  bool isPlanned = false;

  if ( selectByCustHeatAndPlanningState(HEATID_CUST_PLAN, TREATID_CUST_PLAN, 1 ) )
  {
    isPlanned = true;    
  }

  return isPlanned;
}

bool CPP_HEAT_PLANT::resetCustHeatId(std::vector<long> &SeqParam, const std::string & Year, std::vector<std::string> &PlantList, long ReturnHeatNo,bool Commit, cCBS_ODBC_DBError &Error)
{
  if(CSMC_DBData::unspecLong == ReturnHeatNo)
  {
    ReturnHeatNo = 0;
  }  

  bool result = true;

  return result;
}

//bool CPP_HEAT_PLANT::setPlanned(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const long pPlanned, bool Commit, cCBS_ODBC_DBError &Error)
//{
//  bool Result = true;
//  if ( select(HEATID, TREATID, PLANT) ) 
//  {
//    setPLANNED(pPlanned); 
//    Result = Result && update();
//  }
//  else
//  {
//    setLastError(string("Heat not found in PP_HEAT_PLANT"), 0, getActStatement());
//  }
//
//  if (!Result)
//    Error = getLastError();
//
//  if (Commit && Result)
//    commit();
//
//  return Result;
//}
bool CPP_HEAT_PLANT::updateInsertPP(const std::string &HEATID, std::string &TREATID, const std::string &PLANT, const long PLANTNO, const std::string &HEATID_CUST_PLAN, const std::string &TREATID_CUST_PLAN, const CDateTime &TREATSTART_PLAN, const CDateTime &TREATEND_PLAN, bool Commit, cCBS_ODBC_DBError &Error)
{
  log("++++++ CPP_HEAT_PLANT::updateInsertPP",3);

  bool Result   = true;
  bool doUpdate = false;

  try
  {
    CDateTime Now;

    if ( !HEATID_CUST_PLAN.empty() && HEATID_CUST_PLAN != CSMC_DBData::unspecString )
    {
      setHEATID_CUST_PLAN(HEATID_CUST_PLAN);
      doUpdate = true;
    }
    if ( !TREATID_CUST_PLAN.empty() && TREATID_CUST_PLAN != CSMC_DBData::unspecString )
    {
      setTREATID_CUST_PLAN(TREATID_CUST_PLAN);
      doUpdate = true;
    }
    if ( PLANTNO != CSMC_DBData::unspecLong )
    {
      setPLANTNO(PLANTNO);
      doUpdate = true;
    }

    if  ( HEATID != CSMC_DBData::unspecString && PLANT != CSMC_DBData::unspecString )
    {   
      if ( TREATEND_PLAN != CSMC_DBData::unspecDate )
      {
        setTREATEND_PLAN(TREATEND_PLAN);        
        doUpdate = true;
      }
    }

    // only one valid entry
    if ( select(HEATID, CSMC_DBData::unspecString, PLANT) ) 
    {	
      if ( getTREATSTART_PLAN(1) ==  CSMC_DBData::unspecDate)
      {
        log("Warning TREATID was no given and TREATSTART_PLAN is invalid",2);
        setTREATSTART_PLAN(Now);
        doUpdate = true;
      }

      if ( !TREATID.empty() && TREATID != CSMC_DBData::unspecString )
      {
        setTREATID(TREATID);
        doUpdate = true;
      }


      if ( doUpdate )
      {
        //Heat exists -> update
        Result = update();
      }
    }
    else 
    {
      setHEATID(HEATID);
      
      setPLANT(PLANT);

      if (TREATID.empty())
      {
        CTreatID NewTreatID;
        TREATID = NewTreatID.generateNextTreatID("0"); 
      }

      setTREATID(TREATID);

      setHEATID_CUST_PLAN(HEATID_CUST_PLAN);
      setTREATID_CUST_PLAN(TREATID_CUST_PLAN);
      setPLANTNO(PLANTNO);
      setTREATEND_PLAN(TREATEND_PLAN);
      
      if  ( TREATSTART_PLAN ==  CSMC_DBData::unspecDate)
      {
        setTREATSTART_PLAN(Now);
      }
      else
      {
        setTREATSTART_PLAN(TREATSTART_PLAN);
      }

      //Heat does n't exists ->insert
      Result = insert();
    }

    if ( !Result )
    {
      Error = getLastError();
    }

    if(Commit)
    {
      if(Result)
      {
        commit();
      }
      else 
      {
        rollback();
      }
    }
  }
  catch(...)
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage, "","CPP_HEAT_PLANT::updateInsertPP","");
  }

  return Result;
}


