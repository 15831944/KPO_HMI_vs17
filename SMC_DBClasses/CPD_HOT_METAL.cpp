//## Copyright (C) 2009 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "CGC_LADLE_DEF.h"
#include "CPD_HOT_METAL.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::HOTMETAL_COUNTER("HOTMETAL_COUNTER");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::WEIGHT("WEIGHT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::WEIGHT_CHARGED("WEIGHT_CHARGED");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::WEIGHT_SLAG("WEIGHT_SLAG");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::CHARGINGTIME("CHARGINGTIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::LOADINGTIME("LOADINGTIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::TORPEDO1("TORPEDO1");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::TORPEDO2("TORPEDO2");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::TORPEDO3("TORPEDO3");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::LADLENO("LADLENO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::LADLETYPE("LADLETYPE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::SAMPLE_REF("SAMPLE_REF");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::TORPEDO1_WEIGHT("TORPEDO1_WEIGHT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::TORPEDO2_WEIGHT("TORPEDO2_WEIGHT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::TORPEDO3_WEIGHT("TORPEDO3_WEIGHT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::TORPEDO1_SMP_REF("TORPEDO1_SMP_REF");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::TORPEDO2_SMP_REF("TORPEDO2_SMP_REF");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::TORPEDO3_SMP_REF("TORPEDO3_SMP_REF");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HOT_METAL::REVTIME("REVTIME");

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HOT_METAL::CPD_HOT_METAL(cCBS_StdConnection* Connection)
:CSMC_DBData("PD_HOT_METAL",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HOT_METAL::CPD_HOT_METAL(cCBS_Connection* Connection)
:CSMC_DBData("PD_HOT_METAL",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HOT_METAL::CPD_HOT_METAL()
:CSMC_DBData("PD_HOT_METAL")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HOT_METAL::~CPD_HOT_METAL()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique counter
long CPD_HOT_METAL::getHOTMETAL_COUNTER(long Row)
{
  return getLong(CPD_HOT_METAL::HOTMETAL_COUNTER, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setHOTMETAL_COUNTER(long value)
{
  setLong(CPD_HOT_METAL::HOTMETAL_COUNTER, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Actual charged weight
double CPD_HOT_METAL::getWEIGHT(long Row)
{
  return getDouble(CPD_HOT_METAL::WEIGHT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setWEIGHT(double value)
{
  setDouble(CPD_HOT_METAL::WEIGHT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##If material is charged the attribute is filled with copy of WEIGHT. WEIGHT is set to 0. In case of wrong assignment of HM ladle,, the previous weight can be restored in the ladle by copy from WEIGHT_CHARGED to WEIGHT.
double CPD_HOT_METAL::getWEIGHT_CHARGED(long Row)
{
  return getDouble(CPD_HOT_METAL::WEIGHT_CHARGED, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setWEIGHT_CHARGED(double value)
{
  setDouble(CPD_HOT_METAL::WEIGHT_CHARGED, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Estimated slag weight
double CPD_HOT_METAL::getWEIGHT_SLAG(long Row)
{
  return getDouble(CPD_HOT_METAL::WEIGHT_SLAG, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setWEIGHT_SLAG(double value)
{
  setDouble(CPD_HOT_METAL::WEIGHT_SLAG, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Timestamp, when the hot metal was discharged
CDateTime CPD_HOT_METAL::getCHARGINGTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HOT_METAL::CHARGINGTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setCHARGINGTIME(const CDateTime& value)
{
 setString(CPD_HOT_METAL::CHARGINGTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Time of loading start time at pouring time
CDateTime CPD_HOT_METAL::getLOADINGTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HOT_METAL::LOADINGTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setLOADINGTIME(const CDateTime& value)
{
 setString(CPD_HOT_METAL::LOADINGTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Consider charging from up to three torpedo cars
long CPD_HOT_METAL::getTORPEDO1(long Row)
{
  return getLong(CPD_HOT_METAL::TORPEDO1, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setTORPEDO1(long value)
{
  setLong(CPD_HOT_METAL::TORPEDO1, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Consider charging from up to three torpedo cars
long CPD_HOT_METAL::getTORPEDO2(long Row)
{
  return getLong(CPD_HOT_METAL::TORPEDO2, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setTORPEDO2(long value)
{
  setLong(CPD_HOT_METAL::TORPEDO2, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Consider charging from up to three torpedo cars
long CPD_HOT_METAL::getTORPEDO3(long Row)
{
  return getLong(CPD_HOT_METAL::TORPEDO3, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setTORPEDO3(long value)
{
  setLong(CPD_HOT_METAL::TORPEDO3, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique ladle number
long CPD_HOT_METAL::getLADLENO(long Row)
{
  return getLong(CPD_HOT_METAL::LADLENO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setLADLENO(long value)
{
  setLong(CPD_HOT_METAL::LADLENO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##e.g. Hot Metal -> H, Teeming -> T
std::string CPD_HOT_METAL::getLADLETYPE(long Row)
{
  return getString(CPD_HOT_METAL::LADLETYPE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setLADLETYPE(const std::string& value)
{
  setString(CPD_HOT_METAL::LADLETYPE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Measured temperature and analysis. If the values are not available data from the cars can be taken manually. Blast furnace analysis is also possible.
long CPD_HOT_METAL::getSAMPLE_REF(long Row)
{
  return getLong(CPD_HOT_METAL::SAMPLE_REF, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setSAMPLE_REF(long value)
{
  setLong(CPD_HOT_METAL::SAMPLE_REF, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Mass contribution from torpedo car 1
double CPD_HOT_METAL::getTORPEDO1_WEIGHT(long Row)
{
  return getDouble(CPD_HOT_METAL::TORPEDO1_WEIGHT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setTORPEDO1_WEIGHT(double value)
{
  setDouble(CPD_HOT_METAL::TORPEDO1_WEIGHT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Mass contribution from torpedo car 2
double CPD_HOT_METAL::getTORPEDO2_WEIGHT(long Row)
{
  return getDouble(CPD_HOT_METAL::TORPEDO2_WEIGHT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setTORPEDO2_WEIGHT(double value)
{
  setDouble(CPD_HOT_METAL::TORPEDO2_WEIGHT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Mass contribution from torpedo car 3
double CPD_HOT_METAL::getTORPEDO3_WEIGHT(long Row)
{
  return getDouble(CPD_HOT_METAL::TORPEDO3_WEIGHT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setTORPEDO3_WEIGHT(double value)
{
  setDouble(CPD_HOT_METAL::TORPEDO3_WEIGHT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Temperature and analysis from HM in car 1
long CPD_HOT_METAL::getTORPEDO1_SMP_REF(long Row)
{
  return getLong(CPD_HOT_METAL::TORPEDO1_SMP_REF, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setTORPEDO1_SMP_REF(long value)
{
  setLong(CPD_HOT_METAL::TORPEDO1_SMP_REF, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Temperature and analysis from HM in car 2
long CPD_HOT_METAL::getTORPEDO2_SMP_REF(long Row)
{
  return getLong(CPD_HOT_METAL::TORPEDO2_SMP_REF, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setTORPEDO2_SMP_REF(long value)
{
  setLong(CPD_HOT_METAL::TORPEDO2_SMP_REF, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Temperature and analysis from HM in car 3
long CPD_HOT_METAL::getTORPEDO3_SMP_REF(long Row)
{
  return getLong(CPD_HOT_METAL::TORPEDO3_SMP_REF, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setTORPEDO3_SMP_REF(long value)
{
  setLong(CPD_HOT_METAL::TORPEDO3_SMP_REF, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Date and time of last revision
CDateTime CPD_HOT_METAL::getREVTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HOT_METAL::REVTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HOT_METAL::setREVTIME(const CDateTime& value)
{
 setString(CPD_HOT_METAL::REVTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPD_HOT_METAL::select(long HOTMETAL_COUNTER)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_HOT_METAL::HOTMETAL_COUNTER,HOTMETAL_COUNTER);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CPD_HOT_METAL::selectByOrder(const std::string& Order)
{
	cleanWhereStatement();

	m_Statement = "Select hm.HOTMETAL_COUNTER, hm.WEIGHT, hm.WEIGHT_CHARGED, hm.CHARGINGTIME,"
		" hm.LOADINGTIME, hm.TORPEDO1, hm.TORPEDO2, hm.LADLENO, hm.LADLETYPE, hm.SAMPLE_REF,"
		" hm.TORPEDO1_WEIGHT, hm.TORPEDO2_WEIGHT, hm.WEIGHT_SLAG, hm.TORPEDO1_SMP_REF, hm.TORPEDO2_SMP_REF"
		" from PD_HOT_METAL hm, PD_HOT_METAL_ORDER hmo"
		" where hmo.HOTMETAL_COUNTER = hm.HOTMETAL_COUNTER"
		"   and hmo.PRODORDERID = '" + Order + "'";
	
	return CSMC_DBData::select();
}

bool CPD_HOT_METAL::changeHotMetalData(long HOTMETAL_COUNTER, double WEIGHT, double WEIGHT_SLAG, long SAMPLE_REF, bool Commit, cCBS_ODBC_DBError &Error)
{
  return changeHotMetalData(HOTMETAL_COUNTER, WEIGHT, WEIGHT_SLAG, SAMPLE_REF, CSMC_DBData::unspecLong, CSMC_DBData::unspecString, Commit, Error);
}

bool CPD_HOT_METAL::changeHotMetalData(long HOTMETAL_COUNTER, double WEIGHT, double WEIGHT_SLAG, long SAMPLE_REF, long LADLENO, const std::string& LADLETYPE, bool Commit, cCBS_ODBC_DBError &Error)
{

  bool result = false;

  CGC_LADLE_DEF GC_LADLE_DEF(m_pCBS_StdConnection);

	if (exists(HOTMETAL_COUNTER))
	{
    cleanWhereStatement();    

    addWhereClause(CPD_HOT_METAL::HOTMETAL_COUNTER,HOTMETAL_COUNTER);

    setWEIGHT(WEIGHT);
    setWEIGHT_SLAG(WEIGHT_SLAG);
    setSAMPLE_REF(SAMPLE_REF);

    if ( GC_LADLE_DEF.isValidLadle(LADLENO, LADLETYPE) )
    {
      setLADLENO(LADLENO);
      setLADLETYPE(LADLETYPE);
    }

    result = update();
	}
	else
	{
    setHOTMETAL_COUNTER(HOTMETAL_COUNTER);
    setWEIGHT(WEIGHT);
    setWEIGHT_SLAG(WEIGHT_SLAG);
    setSAMPLE_REF(SAMPLE_REF);

    if ( GC_LADLE_DEF.isValidLadle(LADLENO, LADLETYPE) )
    {
      setLADLENO(LADLENO);
      setLADLETYPE(LADLETYPE);
    }

    result = insert();
	}

	if (!result)
		Error = getLastError();

	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}
	return result;
}

bool CPD_HOT_METAL::doDischargeLadle(long pHotMetalCounter,bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = false;
  
  if(select(pHotMetalCounter))
  {
    CDateTime DischargedTime;
    double WeightCharged = getWEIGHT(1);

    setWEIGHT(CSMC_DBData::unspecDouble);
    setWEIGHT_CHARGED(WeightCharged);
    setCHARGINGTIME(DischargedTime);
    setREVTIME(DischargedTime);
  }

  if(update())
  {
    result = true;
    if(Commit)
    {
      commit();
    }
  }
  else
  {
    log("Error Update Discharged Weight",2);
    rollback();   
  }
  return result;
}

bool CPD_HOT_METAL::exists(long HOTMETAL_COUNTER)
{
	cleanWhereStatement();

	m_Statement = "Select HOTMETAL_COUNTER from " + m_TableName;

	addWhereClause(CPD_HOT_METAL::HOTMETAL_COUNTER,HOTMETAL_COUNTER);
   
  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }
  
  return CSMC_DBData::select();
}

bool CPD_HOT_METAL::getNextHOTMETAL_COUNTER(long &HOTMETAL_COUNTER, cCBS_ODBC_DBError &Error)
{
	std::stringstream sql;
	sql << "select SEQ_HOTMETAL_COUNTER.nextval as HOTMETAL_COUNTER from dual";
	
	m_Statement = sql.str();
	bool result = CSMC_DBData::select();
	if (!result)
		Error = getLastError();
	else
		HOTMETAL_COUNTER = getHOTMETAL_COUNTER(1);

	return result;	
}

bool CPD_HOT_METAL::insertLadle(long HOTMETAL_COUNTER, const std::string &LADLETYPE, long LADLENO, double WEIGHT, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = false;

  CGC_LADLE_DEF GC_LADLE_DEF(m_pCBS_StdConnection);

  if ( GC_LADLE_DEF.isValidLadle(LADLENO, LADLETYPE) )
  {
    setHOTMETAL_COUNTER(HOTMETAL_COUNTER);
    setLADLETYPE(LADLETYPE);
    setLADLENO  (LADLENO);
    setWEIGHT   (WEIGHT);

    result = insert();

	  if (!result)
		  Error = getLastError();

	  if (Commit)
	  {
		  if (result)
			  commit();
		  else
			  rollback();
	  }
  }

	return result;
}

bool CPD_HOT_METAL::updateLadle(long HOTMETAL_COUNTER, const std::string &LADLETYPE, long LADLENO, bool Commit, cCBS_ODBC_DBError &Error)
{
  return updateLadle(HOTMETAL_COUNTER, LADLETYPE, LADLENO, CSMC_DBData::unspecDouble, Commit, Error);
}

bool CPD_HOT_METAL::updateLadle(long HOTMETAL_COUNTER, const std::string &LADLETYPE, long LADLENO, double WEIGHT, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = false;

	if (select(HOTMETAL_COUNTER))
	{
    CGC_LADLE_DEF GC_LADLE_DEF(m_pCBS_StdConnection);

    if ( GC_LADLE_DEF.isValidLadle(LADLENO, LADLETYPE) )
    {
      setLADLETYPE(LADLETYPE);
      setLADLENO  (LADLENO);
    }

    if ( WEIGHT != CSMC_DBData::unspecDouble )
    {
      setWEIGHT   (WEIGHT);
    }

    result = update();
	}

	if (!result)
		Error = getLastError();

	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}

  return result;

}

//sankar
bool CPD_HOT_METAL::selectByREVTIME(const CDateTime& REVTIME, const std::string& Operator)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_HOT_METAL::REVTIME, REVTIME, Operator );

  m_Statement += getWhereStatement() + " order by REVTIME desc;";

  return CSMC_DBData::select();
}
