//## Copyright (C) 2010 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "cCBS_StdEventLogFrameController.h"
#include "CHeatID.h"
#include "CPP_ORDER.h"
#include "CGC_LADLE_DEF.h"
#include "CPP_HEAT.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT::HEATID("HEATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT::PRODORDERID("PRODORDERID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT::ROUTECODE_PLAN("ROUTECODE_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT::LADLETYPE("LADLETYPE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT::LADLENO("LADLENO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT::CASTERSEQNO("CASTERSEQNO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT::NOHEATSEQ("NOHEATSEQ");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT::PRESET_HEATID("PRESET_HEATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT::PLANNED("PLANNED");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT::ON_REQUEST("ON_REQUEST");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT::REVTIME("REVTIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HEAT::USERCODE("USERCODE");

//##DBClassCodeUtility ! DO NOT EDIT !
CPP_HEAT::CPP_HEAT(cCBS_StdConnection* Connection)
:CSMC_DBData("PP_HEAT",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPP_HEAT::CPP_HEAT(cCBS_Connection* Connection)
:CSMC_DBData("PP_HEAT",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPP_HEAT::CPP_HEAT()
:CSMC_DBData("PP_HEAT")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPP_HEAT::~CPP_HEAT()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Internal heat identifier
std::string CPP_HEAT::getHEATID(long Row)
{
  return getString(CPP_HEAT::HEATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT::setHEATID(const std::string& value)
{
  setString(CPP_HEAT::HEATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Production oder identification
std::string CPP_HEAT::getPRODORDERID(long Row)
{
  return getString(CPP_HEAT::PRODORDERID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT::setPRODORDERID(const std::string& value)
{
  setString(CPP_HEAT::PRODORDERID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Planned route code
std::string CPP_HEAT::getROUTECODE_PLAN(long Row)
{
  return getString(CPP_HEAT::ROUTECODE_PLAN, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT::setROUTECODE_PLAN(const std::string& value)
{
  setString(CPP_HEAT::ROUTECODE_PLAN, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Planned teeming ladle
std::string CPP_HEAT::getLADLETYPE(long Row)
{
  return getString(CPP_HEAT::LADLETYPE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT::setLADLETYPE(const std::string& value)
{
  setString(CPP_HEAT::LADLETYPE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique ladle number
long CPP_HEAT::getLADLENO(long Row)
{
  return getLong(CPP_HEAT::LADLENO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT::setLADLENO(long value)
{
  setLong(CPP_HEAT::LADLENO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Caster sequence number
long CPP_HEAT::getCASTERSEQNO(long Row)
{
  return getLong(CPP_HEAT::CASTERSEQNO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT::setCASTERSEQNO(long value)
{
  setLong(CPP_HEAT::CASTERSEQNO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Heat in planned caster sequence
long CPP_HEAT::getNOHEATSEQ(long Row)
{
  return getLong(CPP_HEAT::NOHEATSEQ, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT::setNOHEATSEQ(long value)
{
  setLong(CPP_HEAT::NOHEATSEQ, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Customer HeatId is presetted by L3 and must not be considered by HeatId generation. 1 -> is presetted
long CPP_HEAT::getPRESET_HEATID(long Row)
{
  return getLong(CPP_HEAT::PRESET_HEATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT::setPRESET_HEATID(long value)
{
  setLong(CPP_HEAT::PRESET_HEATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Indicator for planned heats at melting unit. Used for generation of the HEATID_CUST_PLAN together with PRESETTING and gives the possibility to select all heats wich are in a pure planning state (The heat does not exist physically). Modified after heat announcement at the melting unit (1 -> 0). If the heat is cancelled at the melting unit the flag is set to '1' again and is considered again for generation of the HEATID_CUST_PLAN in the PP_HEAT_PLANT
long CPP_HEAT::getPLANNED(long Row)
{
  return getLong(CPP_HEAT::PLANNED, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT::setPLANNED(long value)
{
  setLong(CPP_HEAT::PLANNED, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Manually (1) entered by operator if no schedule is available at the melting unit The entry is deleted in case of heat cancellation.
long CPP_HEAT::getON_REQUEST(long Row)
{
  return getLong(CPP_HEAT::ON_REQUEST, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT::setON_REQUEST(long value)
{
  setLong(CPP_HEAT::ON_REQUEST, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Date and time of last revision
CDateTime CPP_HEAT::getREVTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPP_HEAT::REVTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT::setREVTIME(const CDateTime& value)
{
 setString(CPP_HEAT::REVTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##User Code if user change heat schedule
std::string CPP_HEAT::getUSERCODE(long Row)
{
  return getString(CPP_HEAT::USERCODE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HEAT::setUSERCODE(const std::string& value)
{
  setString(CPP_HEAT::USERCODE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPP_HEAT::select(const std::string& HEATID)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT::HEATID,HEATID);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 
bool CPP_HEAT::selectOrderBy(const std::string& HEATID, bool ASC /* = true */)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT::HEATID,HEATID);
 
  if (ASC)
  {
    m_Statement += getWhereStatement() + " ORDER BY HEATID ASC;";
  }
  else
  {
    m_Statement += getWhereStatement() + " ORDER BY HEATID DESC;";
  }


  return CSMC_DBData::select();
}


bool CPP_HEAT::selectByREVTIME(const CDateTime& REVTIME, const std::string& Operator)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT::REVTIME, REVTIME, Operator );

  m_Statement += getWhereStatement() + " order by REVTIME desc;";

  return CSMC_DBData::select();
}

bool CPP_HEAT::selectOrder(const std::string& PRODORDERID)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT::PRODORDERID,PRODORDERID);

  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CPP_HEAT::selectPlanned(long PLANNED)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT::PLANNED,PLANNED);

  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CPP_HEAT::selectPlannedAndPreset(long PLANNED, long PRESET_HEATID)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HEAT::PLANNED,PLANNED);
  addWhereClause(CPP_HEAT::PRESET_HEATID,PRESET_HEATID);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CPP_HEAT::deleteRow(const std::string &HEATID, bool Commit, cCBS_ODBC_DBError &Error)
{
  cleanWhereStatement();

  addWhereClause(CPP_HEAT::HEATID, HEATID);

	bool result = deleteRows();

	if (!result)
		Error = getLastError();

	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}

	return result;
}

bool CPP_HEAT::doOrderChange(const std::string& PRODORDERID_1, const std::string& PRODORDERID_2, bool Commit, cCBS_ODBC_DBError& Error)
{
  bool result = true;

  // PRODORDERID has unique constraint
  // we have to create a temporary dataset and remove it later
  CPP_ORDER PP_ORDER(m_pCBS_StdConnection);

  PP_ORDER.copyOrder(PRODORDERID_1, CSMC_DBData::Default, false, Error);


  std::string HEATID_1;
  std::string HEATID_2;

  // PRODORDERID has unique constraint
  // we have to create a temporary dataset and remove it later
  result = result && selectOrder(PRODORDERID_1);
  if ( result )
  {
    HEATID_1 = getHEATID(1);
  }
  else //ORDER does n't exists error
  {
    setLastError(std::string("UNKNOWN_ORDER"), 0, getActStatement());
  }

  result = result && selectOrder(PRODORDERID_2);
  if ( result )
  {
    HEATID_2 = getHEATID(1);
  }
  else //ORDER does n't exists error
  {
    setLastError(std::string("UNKNOWN_ORDER"), 0, getActStatement());
  }

  result = result && select(HEATID_1);
  if ( result )
  {
    setPRODORDERID(CSMC_DBData::Default);

    result = result && update();
  }

  result = result && select(HEATID_2);
  if ( result )
  {
    setPRODORDERID(PRODORDERID_1);

    result = result && update();
  }

  result = result && select(HEATID_1);
  if ( result )
  {
    setPRODORDERID(PRODORDERID_2);

    result = result && update();
  }

  result = result && PP_ORDER.deletePP(CSMC_DBData::Default, false, Error);

  if (!result)
    Error = getLastError();

  if (Commit)
  {
    if (result)
      commit();
    else
      rollback();
  }

  return result;
}

bool CPP_HEAT::exists(const std::string& HEATID)
{
	cleanWhereStatement();

	m_Statement = "Select HEATID from " + m_TableName;

	addWhereClause(CPP_HEAT::HEATID,HEATID);
   
  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }

	return CSMC_DBData::select();
}

bool CPP_HEAT::exists(const std::string& HEATID,  const std::string &PRODORDERID)
{
	cleanWhereStatement();

	m_Statement = "Select HEATID, PRODORDERID from " + m_TableName;

	addWhereClause(CPP_HEAT::HEATID,HEATID);
  addWhereClause(CPP_HEAT::PRODORDERID,PRODORDERID);

  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }

	return CSMC_DBData::select();
}

std::vector<std::string> CPP_HEAT::getHeatsByPlanningState(long PLANNED)
{
  std::vector<std::string> HeatsByPlanningState;

  if ( selectPlanned(PLANNED) )
  {
    for ( int i = 1; i <= getLastRow(); i++ )
    {
      std::string HEATID = getHEATID(i);
      HeatsByPlanningState.push_back(HEATID);
    }
  }

  return HeatsByPlanningState;
}

std::vector<std::string> CPP_HEAT::getHeatsByPlanningStateAndPreset(long PLANNED, long PRESET_HEATID)
{
  std::vector<std::string> HeatsByPlanningStateAndPreset;

  if ( selectPlannedAndPreset(PLANNED, PRESET_HEATID) )
  {
    for ( int i = 1; i <= getLastRow(); i++ )
    {
      std::string HEATID = getHEATID(i);
      HeatsByPlanningStateAndPreset.push_back(HEATID);
    }
  }

  return HeatsByPlanningStateAndPreset;
}

bool CPP_HEAT::getNextHeatId(string &HEATID, cCBS_ODBC_DBError &Error)
{
  bool Result = true;

  try
  {
    m_Statement = "select TO_CHAR(SEQ_HEATID.nextval) as HEATID from dual;";

    if ( CSMC_DBData::select() )
    {
      HEATID = getHEATID(1);

      CHeatID HeatId;

      HEATID = HeatId.generateHeatID(HEATID);
    }
    else
    {
      Result = false;

      setLastError("No HEATID selected from sequence SEQ_HEATID", 0, m_ActStatement );
    }
  }
  catch(...)
  {
    Result = false;

    // EL_
  }

  return Result;	
}

bool CPP_HEAT::isPlanned(const std::string& HEATID)
{
  bool isPlanned = false;

  if ( select(HEATID) )
  {
    if ( 1 == getPLANNED(1) )
    {
      isPlanned = true;    
    }
  }

  return isPlanned;
}

bool CPP_HEAT::isPlannedOrder(const std::string& PRODORDERID)
{
  bool isPlanned = false;

  if ( selectOrder(PRODORDERID) )
  {
    if ( 1 == getPLANNED(1) )
    {
      isPlanned = true;    
    }
  }

  return isPlanned;
}

bool CPP_HEAT::isPreset(const std::string& HEATID)
{
  bool isPlanned = false;

  if ( select(HEATID) )
  {
    if ( 1 == getPRESET_HEATID(1) )
    {
      isPlanned = true;    
    }
  }

  return isPlanned;
}

bool CPP_HEAT::setPlanned(const std::string& HEATID, const long pPlanned, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool Result = true;
  if ( select(HEATID) ) 
  {
    setPLANNED(pPlanned); 
    Result = Result && update();
  }
  else
  {
    setLastError(string("Heat not found in PP_HEAT"), 0, getActStatement());
  }

  if (!Result)
    Error = getLastError();

  if (Commit && Result)
    commit();

  return Result;
}

// to be backward compatible
bool CPP_HEAT::updateInsertPP(std::string &HEATID, const std::string &PRODORDERID, const std::string &ROUTECODE_PLAN, const long &CASTERSEQNO, const long &NOHEATSEQ, const std::string &USERCODE, bool Commit, cCBS_ODBC_DBError &Error)
{
  return updateInsertPP(HEATID, PRODORDERID, ROUTECODE_PLAN, CASTERSEQNO, NOHEATSEQ, USERCODE, CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, CSMC_DBData::unspecLong, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, Commit, Error);
}

bool CPP_HEAT::updateInsertPP(std::string &HEATID, const std::string &PRODORDERID, const std::string &ROUTECODE_PLAN, const long &CASTERSEQNO, const long &NOHEATSEQ, const std::string &USERCODE, long PRESET_HEATID, long PLANNED, long ON_REQUEST, const std::string& LADLETYPE, long LADLENO, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool Result = true;

  try
  {
    CDateTime Now;
    CGC_LADLE_DEF GC_LADLE_DEF(m_pCBS_StdConnection);
    
    if ( HEATID.empty() || HEATID == CSMC_DBData::unspecString || !exists(HEATID,PRODORDERID))
    {
        Result = getNextHeatId(HEATID, m_lastError);
    }

    // **************************************
    // perform updates on specified data only
    // **************************************
    if ( !PRODORDERID.empty() && PRODORDERID != CSMC_DBData::unspecString )
    {
      setPRODORDERID(PRODORDERID);
    }
    if ( !ROUTECODE_PLAN.empty() && ROUTECODE_PLAN != CSMC_DBData::unspecString )
    {
      setROUTECODE_PLAN(ROUTECODE_PLAN);
    }
    if ( CASTERSEQNO != CSMC_DBData::unspecLong )
    {
      setCASTERSEQNO(CASTERSEQNO);
    }
    if ( NOHEATSEQ != CSMC_DBData::unspecLong )
    {
      setNOHEATSEQ(NOHEATSEQ);
    }

    if ( PRESET_HEATID != CSMC_DBData::unspecLong )
    {
      setPRESET_HEATID(PRESET_HEATID);
    }
    else
    {
      setPRESET_HEATID(0);
    }

    if ( PLANNED == 1 || PLANNED == 0 )
    {
      setPLANNED(PLANNED);
    }
    else if ( PLANNED != CSMC_DBData::unspecLong )
    {
      setLastError("WARNING_INVALID_VALUE", 0, "");
    }
    
    if ( !LADLETYPE.empty() && LADLETYPE != CSMC_DBData::unspecString )
    {
      setLADLETYPE(LADLETYPE);
    }

    if ( LADLENO != CSMC_DBData::unspecLong )
    {
      setLADLENO(LADLENO);
    }

    if ( !USERCODE.empty() && USERCODE != CSMC_DBData::unspecString )
    {
      setUSERCODE(USERCODE);
    }
    else
    {
      //setUSERCODE("UNKNOWN");
      setUSERCODE("HMI");         //must by HMI-User
    }

    setREVTIME(Now);

    if ( select(HEATID) ) 
    {	
      setON_REQUEST(getON_REQUEST(1)); //GEPA 20120726  save old existing value
      Result = Result && update();
    }
    else 
    {
      setHEATID(HEATID);
      setON_REQUEST(0);      //SARS         //GEPA 20120726  new heat, done by operator !
      //Heat does n't exists ->insert
      Result = Result && insert();
    }

    if ( !Result )
    {
      Error = getLastError();
    }

    if(Commit)
    {
      if(Result)
      {
        commit();
      }
      else 
      {
        rollback();
      }
    }
  }
  catch(...)
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage, "","CPP_HEAT::updateInsertPP","");
  }

  return Result;
}


