//## Copyright (C) 2011 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "CPD_HEAT_DATA_STIRR.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA_STIRR::HEATID("HEATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA_STIRR::TREATID("TREATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA_STIRR::PLANT("PLANT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA_STIRR::TREATMENTPOSITION("TREATMENTPOSITION");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA_STIRR::DEVICENAME("DEVICENAME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA_STIRR::IS_BYPASS("IS_BYPASS");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA_STIRR::STIRRGASTYPE("STIRRGASTYPE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA_STIRR::STARTTIME("STARTTIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA_STIRR::ENDTIME("ENDTIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_DATA_STIRR::CONS("CONS");

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HEAT_DATA_STIRR::CPD_HEAT_DATA_STIRR(cCBS_StdConnection* Connection)
:CSMC_DBData("PD_HEAT_DATA_STIRR",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HEAT_DATA_STIRR::CPD_HEAT_DATA_STIRR(cCBS_Connection* Connection)
:CSMC_DBData("PD_HEAT_DATA_STIRR",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HEAT_DATA_STIRR::CPD_HEAT_DATA_STIRR()
:CSMC_DBData("PD_HEAT_DATA_STIRR")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HEAT_DATA_STIRR::~CPD_HEAT_DATA_STIRR()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Internal heat identifier
std::string CPD_HEAT_DATA_STIRR::getHEATID(long Row)
{
  return getString(CPD_HEAT_DATA_STIRR::HEATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA_STIRR::setHEATID(const std::string& value)
{
  setString(CPD_HEAT_DATA_STIRR::HEATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment identifier
std::string CPD_HEAT_DATA_STIRR::getTREATID(long Row)
{
  return getString(CPD_HEAT_DATA_STIRR::TREATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA_STIRR::setTREATID(const std::string& value)
{
  setString(CPD_HEAT_DATA_STIRR::TREATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant identifier
std::string CPD_HEAT_DATA_STIRR::getPLANT(long Row)
{
  return getString(CPD_HEAT_DATA_STIRR::PLANT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA_STIRR::setPLANT(const std::string& value)
{
  setString(CPD_HEAT_DATA_STIRR::PLANT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Identification of treatment position to handle heats at Twin-LF (1-> car 1, 2-> car 2) and melting units with tapping area (1-> furnace, 2-> TapLadle)
long CPD_HEAT_DATA_STIRR::getTREATMENTPOSITION(long Row)
{
  return getLong(CPD_HEAT_DATA_STIRR::TREATMENTPOSITION, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA_STIRR::setTREATMENTPOSITION(long value)
{
  setLong(CPD_HEAT_DATA_STIRR::TREATMENTPOSITION, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Device name, plug ore emergency lance
std::string CPD_HEAT_DATA_STIRR::getDEVICENAME(long Row)
{
  return getString(CPD_HEAT_DATA_STIRR::DEVICENAME, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA_STIRR::setDEVICENAME(const std::string& value)
{
  setString(CPD_HEAT_DATA_STIRR::DEVICENAME, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Flag for bypass stirring 0-> normal stirring, 1-> bypass stirring. During bypass stirring the consumption is not measured by device but estimated on the Level 1.
long CPD_HEAT_DATA_STIRR::getIS_BYPASS(long Row)
{
  return getLong(CPD_HEAT_DATA_STIRR::IS_BYPASS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA_STIRR::setIS_BYPASS(long value)
{
  setLong(CPD_HEAT_DATA_STIRR::IS_BYPASS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Values are e.g. N2, Ar
std::string CPD_HEAT_DATA_STIRR::getSTIRRGASTYPE(long Row)
{
  return getString(CPD_HEAT_DATA_STIRR::STIRRGASTYPE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA_STIRR::setSTIRRGASTYPE(const std::string& value)
{
  setString(CPD_HEAT_DATA_STIRR::STIRRGASTYPE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
CDateTime CPD_HEAT_DATA_STIRR::getSTARTTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HEAT_DATA_STIRR::STARTTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA_STIRR::setSTARTTIME(const CDateTime& value)
{
 setString(CPD_HEAT_DATA_STIRR::STARTTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
CDateTime CPD_HEAT_DATA_STIRR::getENDTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HEAT_DATA_STIRR::ENDTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA_STIRR::setENDTIME(const CDateTime& value)
{
 setString(CPD_HEAT_DATA_STIRR::ENDTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Total consumption stirring
double CPD_HEAT_DATA_STIRR::getCONS(long Row)
{
  return getDouble(CPD_HEAT_DATA_STIRR::CONS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_DATA_STIRR::setCONS(double value)
{
  setDouble(CPD_HEAT_DATA_STIRR::CONS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPD_HEAT_DATA_STIRR::select(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long TREATMENTPOSITION, const std::string& DEVICENAME, long IS_BYPASS, const std::string& STIRRGASTYPE, const CDateTime& STARTTIME)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_HEAT_DATA_STIRR::HEATID,HEATID);
  addWhereClause(CPD_HEAT_DATA_STIRR::TREATID,TREATID);
  addWhereClause(CPD_HEAT_DATA_STIRR::PLANT,PLANT);
  addWhereClause(CPD_HEAT_DATA_STIRR::TREATMENTPOSITION,TREATMENTPOSITION);
  addWhereClause(CPD_HEAT_DATA_STIRR::DEVICENAME,DEVICENAME);
  addWhereClause(CPD_HEAT_DATA_STIRR::IS_BYPASS,IS_BYPASS);
  addWhereClause(CPD_HEAT_DATA_STIRR::STIRRGASTYPE,STIRRGASTYPE);
  addWhereClause(CPD_HEAT_DATA_STIRR::STARTTIME,STARTTIME);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CPD_HEAT_DATA_STIRR::selectActual(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long TREATMENTPOSITION, const std::string& DEVICENAME, long IS_BYPASS, const std::string& STIRRGASTYPE)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_HEAT_DATA_STIRR::HEATID,HEATID);
  addWhereClause(CPD_HEAT_DATA_STIRR::TREATID,TREATID);
  addWhereClause(CPD_HEAT_DATA_STIRR::PLANT,PLANT);
  addWhereClause(CPD_HEAT_DATA_STIRR::TREATMENTPOSITION,TREATMENTPOSITION);
  addWhereClause(CPD_HEAT_DATA_STIRR::DEVICENAME,DEVICENAME);
  addWhereClause(CPD_HEAT_DATA_STIRR::IS_BYPASS,IS_BYPASS);
  addWhereClause(CPD_HEAT_DATA_STIRR::STIRRGASTYPE,STIRRGASTYPE);

  m_Statement += getWhereStatement();
  m_Statement += " and " + CPD_HEAT_DATA_STIRR::STARTTIME + " = ( select max("+ CPD_HEAT_DATA_STIRR::STARTTIME +") from " + m_TableName;
  m_Statement += getWhereStatement() + ") and " + CPD_HEAT_DATA_STIRR::ENDTIME + " is null ";

  return CSMC_DBData::select();
}

bool CPD_HEAT_DATA_STIRR::selectOpenStirringPhase(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long TREATMENTPOSITION, const std::string& DEVICENAME, long IS_BYPASS, const std::string& STIRRGASTYPE)
{
	cleanWhereStatement();
	
	m_Statement = "Select * from " + m_TableName;
	
  addWhereClause(CPD_HEAT_DATA_STIRR::HEATID,HEATID);
  addWhereClause(CPD_HEAT_DATA_STIRR::TREATID,TREATID);
  addWhereClause(CPD_HEAT_DATA_STIRR::PLANT,PLANT);
  addWhereClause(CPD_HEAT_DATA_STIRR::TREATMENTPOSITION,TREATMENTPOSITION);
  addWhereClause(CPD_HEAT_DATA_STIRR::DEVICENAME,DEVICENAME);
  addWhereClause(CPD_HEAT_DATA_STIRR::IS_BYPASS,IS_BYPASS);
  addWhereClause(CPD_HEAT_DATA_STIRR::STIRRGASTYPE,STIRRGASTYPE);
	addWhereClause(CPD_HEAT_DATA_STIRR::ENDTIME + " is NULL");
	
	m_Statement += getWhereStatement();
	m_Statement += " order by " + CPD_HEAT_DATA_STIRR::STARTTIME + " DESC ;";
	
	return CSMC_DBData::select();
}

bool CPD_HEAT_DATA_STIRR::selectOrdered(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long TREATMENTPOSITION, const std::string& DEVICENAME, long IS_BYPASS, const std::string& STIRRGASTYPE)
{
	cleanWhereStatement();
	
	m_Statement = "Select * from " + m_TableName;
	
  addWhereClause(CPD_HEAT_DATA_STIRR::HEATID,HEATID);
  addWhereClause(CPD_HEAT_DATA_STIRR::TREATID,TREATID);
  addWhereClause(CPD_HEAT_DATA_STIRR::PLANT,PLANT);
  addWhereClause(CPD_HEAT_DATA_STIRR::TREATMENTPOSITION,TREATMENTPOSITION);
  addWhereClause(CPD_HEAT_DATA_STIRR::DEVICENAME,DEVICENAME);
  addWhereClause(CPD_HEAT_DATA_STIRR::IS_BYPASS,IS_BYPASS);
	
	m_Statement += getWhereStatement();
	m_Statement += " order by " + CPD_HEAT_DATA_STIRR::STARTTIME + " DESC ;";
	
	return CSMC_DBData::select();
}

// we assume increasing consumtions over complete treatment
double CPD_HEAT_DATA_STIRR::getConsumption(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long TREATMENTPOSITION, const std::string& DEVICENAME, long IS_BYPASS, const std::string& STIRRGASTYPE)
{
  double Consumption = CSMC_DBData::unspecDouble;

  cleanWhereStatement();

  addWhereClause(CPD_HEAT_DATA_STIRR::HEATID,HEATID);
  addWhereClause(CPD_HEAT_DATA_STIRR::TREATID,TREATID);
  addWhereClause(CPD_HEAT_DATA_STIRR::PLANT,PLANT);
  addWhereClause(CPD_HEAT_DATA_STIRR::TREATMENTPOSITION,TREATMENTPOSITION);
  addWhereClause(CPD_HEAT_DATA_STIRR::DEVICENAME,DEVICENAME);
  addWhereClause(CPD_HEAT_DATA_STIRR::IS_BYPASS,IS_BYPASS);

  m_Statement = "Select max(CONS) as CONS from " + m_TableName;  
  m_Statement += getWhereStatement() + ";";


  if( CSMC_DBData::select() )
  {
    Consumption = getCONS(1);
  }

  return Consumption;
}

double CPD_HEAT_DATA_STIRR::getDuration(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long TREATMENTPOSITION, const std::string& DEVICENAME, long IS_BYPASS, const std::string& STIRRGASTYPE)
{
  double Duration = CSMC_DBData::unspecDouble;

  // select all stirring phases
  if ( select(HEATID, TREATID, PLANT, TREATMENTPOSITION, DEVICENAME, IS_BYPASS, STIRRGASTYPE, CSMC_DBData::unspecDate) )
  {
    Duration = 0.;

    for (long i = 1; i <= getLastRow(); i++)
    {
      // calculate duration for each START/END period and summerize
      CDateTime STARTTIME = getSTARTTIME(i);
      CDateTime ENDTIME   = getENDTIME(i);

      // for calculation regard only stirring phases that have been ended
      if ( ENDTIME != CSMC_DBData::unspecDate )
      {
        CDeltaTime DiffTime = CDateTime::subTimes(ENDTIME, STARTTIME);

        Duration += DiffTime.asSeconds() / 60;
      }
    }
  }

	return Duration;
}

double CPD_HEAT_DATA_STIRR::getStirrConsDataByHeat(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long TREATMENTPOSITION, const std::string& DEVICENAME, long IS_BYPASS, const std::string& STIRRGASTYPE)
{
  double RetValue = CSMC_DBData::unspecDouble;

  if ( selectOrdered(HEATID, TREATID, PLANT, TREATMENTPOSITION, DEVICENAME, IS_BYPASS, STIRRGASTYPE) )
  {
    for ( long i = 1; i <= getLastRow(); ++i )
    {
      if ( !isNull(CPD_HEAT_DATA_STIRR::CONS,i) )
      {
        RetValue = RetValue + getCONS(i);
      }
    }
  }

  return RetValue;
}

bool CPD_HEAT_DATA_STIRR::handleStirringEnd(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long TREATMENTPOSITION, const std::string& DEVICENAME, long IS_BYPASS, const std::string& STIRRGASTYPE, CDateTime ENDTIME, double CONS, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = false;

  if ( selectOpenStirringPhase(HEATID, TREATID, PLANT, TREATMENTPOSITION, DEVICENAME, IS_BYPASS, STIRRGASTYPE) )
  {
    setENDTIME(ENDTIME);
    setCONS(CONS);

    result = update();

    if (!result)
    {
	    Error = getLastError();
    }
  }

  if (Commit)
  {
	  if (result)
		  commit();
	  else
		  rollback();
  }

	return result;

}

bool CPD_HEAT_DATA_STIRR::handleStirringStart(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long TREATMENTPOSITION, const std::string& DEVICENAME, long IS_BYPASS, const std::string& STIRRGASTYPE, CDateTime STARTTIME, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = false;

  if ( !selectOpenStirringPhase(HEATID, TREATID, PLANT, TREATMENTPOSITION, DEVICENAME, IS_BYPASS, STIRRGASTYPE) )
  {
    setHEATID(HEATID);
    setTREATID(TREATID);
    setPLANT(PLANT);
    setTREATMENTPOSITION(TREATMENTPOSITION);
    setDEVICENAME(DEVICENAME);
    setIS_BYPASS(IS_BYPASS);

    setSTARTTIME(STARTTIME);

    result = insert();

    if (!result)
    {
	    Error = getLastError();
    }
  }

  if (Commit)
  {
	  if (result)
		  commit();
	  else
		  rollback();
  }

	return result;

}


