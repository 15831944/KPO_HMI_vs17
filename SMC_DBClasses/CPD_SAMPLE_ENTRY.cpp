//## Copyright (C) 2009 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "CIntfData.h"
#include "CPD_SAMPLE_ENTRY.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE_ENTRY::SAMPLE_COUNTER("SAMPLE_COUNTER");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE_ENTRY::MEASNAME("MEASNAME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_SAMPLE_ENTRY::MEASVALUE("MEASVALUE");

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_SAMPLE_ENTRY::CPD_SAMPLE_ENTRY(cCBS_StdConnection* Connection)
:CSMC_DBData("PD_SAMPLE_ENTRY",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_SAMPLE_ENTRY::CPD_SAMPLE_ENTRY(cCBS_Connection* Connection)
:CSMC_DBData("PD_SAMPLE_ENTRY",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_SAMPLE_ENTRY::CPD_SAMPLE_ENTRY()
:CSMC_DBData("PD_SAMPLE_ENTRY")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_SAMPLE_ENTRY::~CPD_SAMPLE_ENTRY()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique sample counter
long CPD_SAMPLE_ENTRY::getSAMPLE_COUNTER(long Row)
{
  return getLong(CPD_SAMPLE_ENTRY::SAMPLE_COUNTER, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE_ENTRY::setSAMPLE_COUNTER(long value)
{
  setLong(CPD_SAMPLE_ENTRY::SAMPLE_COUNTER, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Measured Element/compound concentration in case of analysis, otherwise the type name
std::string CPD_SAMPLE_ENTRY::getMEASNAME(long Row)
{
  return getString(CPD_SAMPLE_ENTRY::MEASNAME, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE_ENTRY::setMEASNAME(const std::string& value)
{
  setString(CPD_SAMPLE_ENTRY::MEASNAME, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Measured value
double CPD_SAMPLE_ENTRY::getMEASVALUE(long Row)
{
  return getDouble(CPD_SAMPLE_ENTRY::MEASVALUE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_SAMPLE_ENTRY::setMEASVALUE(double value)
{
  setDouble(CPD_SAMPLE_ENTRY::MEASVALUE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPD_SAMPLE_ENTRY::select(long SAMPLE_COUNTER, const std::string& MEASNAME)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_SAMPLE_ENTRY::SAMPLE_COUNTER,SAMPLE_COUNTER);
  addWhereClause(CPD_SAMPLE_ENTRY::MEASNAME,MEASNAME);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CPD_SAMPLE_ENTRY::deleteSample(long SAMPLE_COUNTER)
{
  bool RetValue = false;

  try
  {
    cleanWhereStatement();
	
    addWhereClause(CPD_SAMPLE_ENTRY::SAMPLE_COUNTER,SAMPLE_COUNTER);

    RetValue = CSMC_DBData::deleteRows();
    
  }
  catch(...)
  {
    rollback(); //something wrong, rollback transaction.
    RetValue = false;
  }

  return RetValue;
}

seqSample CPD_SAMPLE_ENTRY::getSample(long SAMPLE_COUNTER)
{
  seqSample SeqSample;

  if ( select(SAMPLE_COUNTER,CSMC_DBData::unspecString) )
  {
    for ( long i = 1 ; i <= getLastRow(); i++)
    {
      sSample Sample;

      Sample.MeasName   = getMEASNAME(i).c_str();
      Sample.MeasValue  = getMEASVALUE(i);

      CIntfData::insert(SeqSample,Sample);
    }
  }

  return SeqSample;
}

bool CPD_SAMPLE_ENTRY::insertAnalysis(long SAMPLE_COUNTER, seqAnalysis &pAnalysis, bool Commit, cCBS_ODBC_DBError &Error)
{
	bool result = true;	
	for (unsigned int i = 0; result && i < pAnalysis.length(); i++)
	{		
		string mCaption = pAnalysis[i].Element;
		double mValue = pAnalysis[i].Concentration;
		result = insertValue(SAMPLE_COUNTER, mCaption, mValue, Commit, Error); 
	}

	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}
	
	return result;	
}

bool CPD_SAMPLE_ENTRY::insertSample(long SAMPLE_COUNTER, const std::string& MEASNAME, double MEASVALUE)
{
  bool RetValue = false;

  if ( select(SAMPLE_COUNTER, MEASNAME) )
  {
    setMEASNAME(MEASNAME);
    setMEASVALUE(MEASVALUE);

    RetValue = update();
  }
  else 
  {
    setSAMPLE_COUNTER(SAMPLE_COUNTER);
    setMEASNAME(MEASNAME);
    setMEASVALUE(MEASVALUE);

    RetValue = insert();
  }

  //setSAMPLE_COUNTER(SAMPLE_COUNTER);
  //setMEASNAME(MEASNAME);
  //setMEASVALUE(MEASVALUE);

  //RetValue = updateOrInsert();

  return RetValue;
}

bool CPD_SAMPLE_ENTRY::insertSample(long SAMPLE_COUNTER, seqSample SeqSample)
{
  bool RetValue = true;

  for ( long i = 0 ; i < CIntfData::getLength(SeqSample) ; ++i )
  {
    sSample Sample;
    CIntfData::getAt(Sample,SeqSample,i);

    RetValue = RetValue && insertSample(SAMPLE_COUNTER,std::string(Sample.MeasName),Sample.MeasValue);
  }

  return RetValue;
}

bool CPD_SAMPLE_ENTRY::insertValue(long SAMPLE_COUNTER, const std::string &MEASNAME, double MEASVALUE, bool Commit, cCBS_ODBC_DBError &Error)
{
	bool result = true;		

	if( MEASNAME.empty() ) 
      return result;//refuse the empty measname

  setSAMPLE_COUNTER(SAMPLE_COUNTER);
  setMEASNAME(MEASNAME);
  setMEASVALUE(MEASVALUE);
	
	result = insert();

	if (!result)
		Error = getLastError();

	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}
	
	return result;	
}


