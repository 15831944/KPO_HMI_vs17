//## Copyright (C) 2010 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "CGC_HEAT_STATUS.h"
#include "CPP_HEAT.h"
#include "CPP_HEAT_PLANT.h"
#include "CPD_HEAT_PLANT_REF.h"
#include "CPD_PLANTSTATUS.h"
#include "DEF_GC_PLANT_DEF.h"
#include "DEF_GC_HEAT_STATUS.h"
#include "CHeatStatusContainer.h"
#include "CGC_Plant_Container.h"
#include "CDataConversion.h"
#include "CPD_HEAT_REF.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_REF::HEATID("HEATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_REF::HEATSTATUSNO("HEATSTATUSNO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_REF::ROUTECODE_ACT("ROUTECODE_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_REF::HEATSTATUSNO_LAST("HEATSTATUSNO_LAST");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_REF::USERCODE("USERCODE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_HEAT_REF::REVTIME("REVTIME");

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HEAT_REF::CPD_HEAT_REF(cCBS_StdConnection* Connection)
:CSMC_DBData("PD_HEAT_REF",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HEAT_REF::CPD_HEAT_REF(cCBS_Connection* Connection)
:CSMC_DBData("PD_HEAT_REF",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HEAT_REF::CPD_HEAT_REF()
:CSMC_DBData("PD_HEAT_REF")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_HEAT_REF::~CPD_HEAT_REF()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Internal heat identifier
std::string CPD_HEAT_REF::getHEATID(long Row)
{
  return getString(CPD_HEAT_REF::HEATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_REF::setHEATID(const std::string& value)
{
  setString(CPD_HEAT_REF::HEATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Heat Status as defined in the Requirement Book Naming standard specification.
long CPD_HEAT_REF::getHEATSTATUSNO(long Row)
{
  return getLong(CPD_HEAT_REF::HEATSTATUSNO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_REF::setHEATSTATUSNO(long value)
{
  setLong(CPD_HEAT_REF::HEATSTATUSNO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Actual route information, use GC_PLANT:ROUTECODEID
std::string CPD_HEAT_REF::getROUTECODE_ACT(long Row)
{
  return getString(CPD_HEAT_REF::ROUTECODE_ACT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_REF::setROUTECODE_ACT(const std::string& value)
{
  setString(CPD_HEAT_REF::ROUTECODE_ACT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Last status at last plant. This status is used after heat cancellation.
long CPD_HEAT_REF::getHEATSTATUSNO_LAST(long Row)
{
  return getLong(CPD_HEAT_REF::HEATSTATUSNO_LAST, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_REF::setHEATSTATUSNO_LAST(long value)
{
  setLong(CPD_HEAT_REF::HEATSTATUSNO_LAST, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##User Code if user change heat schedule
std::string CPD_HEAT_REF::getUSERCODE(long Row)
{
  return getString(CPD_HEAT_REF::USERCODE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_REF::setUSERCODE(const std::string& value)
{
  setString(CPD_HEAT_REF::USERCODE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Date and time of last revision
CDateTime CPD_HEAT_REF::getREVTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_HEAT_REF::REVTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_HEAT_REF::setREVTIME(const CDateTime& value)
{
 setString(CPD_HEAT_REF::REVTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPD_HEAT_REF::select(const std::string& HEATID)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_HEAT_REF::HEATID,HEATID);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CPD_HEAT_REF::selectByREVTIME(const CDateTime& REVTIME, const std::string& Operator)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_HEAT_REF::REVTIME, REVTIME, Operator );

  m_Statement += getWhereStatement() + " order by REVTIME desc;";

  return CSMC_DBData::select();
}

bool CPD_HEAT_REF::doAnnouncement(const std::string& HEATID, const std::string& PLANT, const std::string &USERCODE, bool Commit, cCBS_ODBC_DBError &Error)
{
	bool result = false;

  CHeatStatusContainer HeatStatusContainer(m_pCBS_StdConnection);

  long HEATSTATUSNO_PLANNED      = HeatStatusContainer.getHeatStatus(DEF_GC_PLANT_DEF::L3, DEF_GC_HEAT_STATUS::Planned );
  long HEATSTATUSNO_ANNOUNCED    = HeatStatusContainer.getHeatStatus(PLANT, DEF_GC_HEAT_STATUS::HeatAnnounced );

  CPP_HEAT            PP_HEAT       (m_pCBS_StdConnection);

  if ( USERCODE != CSMC_DBData::unspecString )
  {
    setUSERCODE(USERCODE);
  }

	if (select(HEATID)) //Heat already exists -> do not change status for Announced here
	{
    if ( getHEATSTATUSNO_LAST(1) == CSMC_DBData::unspecLong )
    {
      setHEATSTATUSNO_LAST(HEATSTATUSNO_PLANNED);
    }

    //setHEATSTATUSNO(HEATSTATUSNO_ANNOUNCED);
    setREVTIME(CDateTime());

    result = update();
	}
	else //Heat doesn't exist yet -> insert
	{
		result = PP_HEAT.exists(HEATID);
		if (result)
    {
      //planned, we need it, otherwise cancel for a new heat(created via emergency dialog) would
      // failed because we try to write the NULL of HeatStatusLast back to HEATSTATUSNO !!!!
      setHEATID(HEATID);
      //setHEATSTATUSNO(HEATSTATUSNO_ANNOUNCED);
	  setHEATSTATUSNO(HEATSTATUSNO_PLANNED);
      setHEATSTATUSNO_LAST(HEATSTATUSNO_PLANNED);

      setREVTIME(CDateTime());

      result = insert();

		}
		else
    {
			setLastError("NO_DATA_FOUND", 0, PP_HEAT.getActStatement());
    }
	}

	if (!result)
		Error = getLastError();

	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}

  return result;
}

bool CPD_HEAT_REF::doCancelHeat(const std::string& HEATID, bool Commit, cCBS_ODBC_DBError &Error)
{
	bool result = false;

	if (select(HEATID))
  {
    if ( getHEATSTATUSNO_LAST(1) != CSMC_DBData::unspecLong )
    {
       setHEATSTATUSNO(getHEATSTATUSNO_LAST(1));
    }
    else
    {
      CHeatStatusContainer HeatStatusContainer(m_pCBS_StdConnection);

      long HEATSTATUSNO_PLANNED      = HeatStatusContainer.getHeatStatus(DEF_GC_PLANT_DEF::L3, DEF_GC_HEAT_STATUS::Planned );

      setHEATSTATUSNO(HEATSTATUSNO_PLANNED);
    }

    setREVTIME     (CDateTime());

    result = update();
  }
	else
  {
    setLastError("NO_DATA_FOUND", 0, getActStatement());
  }
	
	if (!result)
		Error = getLastError();

	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}
	return result;
}

bool CPD_HEAT_REF::doDeparture(const std::string& HEATID, const std::string& PLANT, const std::string &USERCODE, bool Commit, cCBS_ODBC_DBError &Error)
{
	bool result = false;

  CHeatStatusContainer HeatStatusContainer(m_pCBS_StdConnection);

  long HEATSTATUSNO_DEPARTURE    = HeatStatusContainer.getHeatStatus(PLANT, DEF_GC_HEAT_STATUS::LadleDeparture );

  CGC_Plant_Container GC_Plant_Container (m_pCBS_StdConnection);

  if ( select(HEATID) ) //Heat already exists -> update
  {
    if ( !isNull(CPD_HEAT_REF::HEATSTATUSNO, 1 ) )
    {
      setHEATSTATUSNO_LAST(getHEATSTATUSNO(1));
    }

    setHEATSTATUSNO(HEATSTATUSNO_DEPARTURE);

    setREVTIME(CDateTime());

    if ( USERCODE != CSMC_DBData::unspecString )
    {
      setUSERCODE(USERCODE);
    }

    result = update();
  }
  else
  {
    setLastError("NO_DATA_FOUND", 0, getActStatement());
    result = false;
  }

	if (!result)
		Error = getLastError();

	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}

  return result;
}

bool CPD_HEAT_REF::doHeatStart(const std::string& HEATID, const string& TREATID,const std::string& PLANT, const std::string &USERCODE, bool Commit, cCBS_ODBC_DBError &Error) //sankar add plant
{
	bool result = false;

  std::string ROUTECODE_ACT = "";

  CPP_HEAT_PLANT      PP_HEAT_PLANT (m_pCBS_StdConnection);

  CGC_Plant_Container GC_Plant_Container (m_pCBS_StdConnection);

  if ( PP_HEAT_PLANT.selectOrderedByMaxTreatID(HEATID, PLANT) )
  {
    if ( PP_HEAT_PLANT.select(HEATID, PP_HEAT_PLANT.getTREATID(1), PLANT) )
    {
      ROUTECODE_ACT = GC_Plant_Container.getRouteCodeID(PLANT + "_" + CDataConversion::LongToString(PP_HEAT_PLANT.getPLANTNO(1))); 
    }
  }

  if ( select(HEATID) ) //Heat already exists -> update
  {
    ROUTECODE_ACT = CDataConversion::SetInvalidToDefault(getROUTECODE_ACT(1),"") + ROUTECODE_ACT;
    
    setROUTECODE_ACT(ROUTECODE_ACT);

    if ( !isNull(CPD_HEAT_REF::HEATSTATUSNO, 1 ) )
    {
      setHEATSTATUSNO_LAST(getHEATSTATUSNO(1));
    }

    setREVTIME(CDateTime());

    if ( USERCODE != CSMC_DBData::unspecString )
    {
      setUSERCODE(USERCODE);
    }

    result = update();
  }
  else
  {
    setLastError("NO_DATA_FOUND", 0, getActStatement());
    result = false;
  }

	if (!result)
		Error = getLastError();

	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}

  return result;
}


bool CPD_HEAT_REF::doNewHeat(const std::string& HEATID, long HEATSTATUSNO, const std::string& USERCODE, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = true;

  CHeatStatusContainer HeatStatusContainer(m_pCBS_StdConnection);

  long HEATSTATUSNO_PLANNED      = HeatStatusContainer.getHeatStatus(DEF_GC_PLANT_DEF::L3, DEF_GC_HEAT_STATUS::Planned );

	if (select(HEATID)) //Heat already exists -> update
	{
    setHEATSTATUSNO(HEATSTATUSNO);
    setHEATSTATUSNO_LAST(HEATSTATUSNO);

    setUSERCODE(USERCODE);
    setREVTIME(CDateTime());

    result = update();
	}
	else //Heat doesn't exist jet -> insert
	{		
    CPP_HEAT            PP_HEAT       (m_pCBS_StdConnection);

		result = PP_HEAT.exists(HEATID);

		if (result)
		{
      setHEATID(HEATID);
      setHEATSTATUSNO(HEATSTATUSNO);
      setHEATSTATUSNO_LAST(HEATSTATUSNO_PLANNED);

      setREVTIME(CDateTime());
      setUSERCODE(USERCODE);

      result = insert();
		}
		else
    {
			setLastError("Data not found for '" + HEATID + "' in PP_HEAT", 0, "select * from PP_HEAT " + PP_HEAT.getWhereStatement());
    }
	}

	if (!result)
		Error = getLastError();

	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}
	return result;
}

bool CPD_HEAT_REF::doSetupHeat(const std::string& HEATID, const std::string& PLANT, long HEATSTATUSNO, const std::string &USERCODE, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = false;

  CHeatStatusContainer HeatStatusContainer(m_pCBS_StdConnection);

  long HEATSTATUSNO_PLANNED      = HeatStatusContainer.getHeatStatus(DEF_GC_PLANT_DEF::L3, DEF_GC_HEAT_STATUS::Planned );

  CPP_HEAT            PP_HEAT       (m_pCBS_StdConnection);

  if ( USERCODE != CSMC_DBData::unspecString )
  {
    setUSERCODE(USERCODE);
  }

  if (select(HEATID)) //Heat already exists -> update
  {
    if ( getHEATSTATUSNO_LAST(1) == CSMC_DBData::unspecLong )
    {
      setHEATSTATUSNO_LAST(HEATSTATUSNO_PLANNED);
    }

    setHEATSTATUSNO(HEATSTATUSNO);

    setREVTIME(CDateTime());

    result = update();
  }
  else //Heat doesn't exist yet -> insert
  {
    result = PP_HEAT.exists(HEATID);
    if (result)
    {
      //planned, we need it, otherwise cancel for a new heat(created via emergency dialog) would
      // failed because we try to write the NULL of HeatStatusLast back to HEATSTATUSNO !!!!
      setHEATID(HEATID);
      setHEATSTATUSNO(HEATSTATUSNO);
      setHEATSTATUSNO_LAST(HEATSTATUSNO_PLANNED);

      setREVTIME(CDateTime());

      result = insert();

    }
    else
    {
      setLastError("NO_DATA_FOUND", 0, PP_HEAT.getActStatement());
    }
  }

  if (!result)
    Error = getLastError();

  if (Commit)
  {
    if (result)
      commit();
    else
      rollback();
  }

  return result;
}

bool CPD_HEAT_REF::exists(const std::string& HEATID)
{
	cleanWhereStatement();

	m_Statement = "Select HEATID from " + m_TableName;

	addWhereClause(CPD_HEAT_REF::HEATID,HEATID);
   
  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }

	return CSMC_DBData::select();
}

std::vector<std::string> CPD_HEAT_REF::getHeatsByREVTIME(const CDateTime& REVTIME, const std::string& Operator)
{
  std::vector<std::string> HeatsByREVTIME;

  if ( selectByREVTIME(REVTIME, Operator) )
  {
    for ( int i = 1; i <= getLastRow(); i++ )
    {
      std::string HEATID = getHEATID(i);
      HeatsByREVTIME.push_back(HEATID);
    }
  }

  return HeatsByREVTIME;
}

bool CPD_HEAT_REF::hasState(const std::string& HEATID, long HEATSTATUSNO)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_HEAT_REF::HEATID, HEATID );
  addWhereClause(CPD_HEAT_REF::HEATSTATUSNO, HEATSTATUSNO );

  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

// checks if heat has any state related to the specific plant
bool CPD_HEAT_REF::isHandledAtPlant(const std::string& HEATID, const std::string& PLANT)
{
  bool retValue = false;

  CGC_HEAT_STATUS GC_HEAT_STATUS(m_pCBS_StdConnection);

  std::vector<long> PlantRelatedStates = GC_HEAT_STATUS.getPlantRelatedStates(PLANT);

  return isHandledAtPlant(HEATID, PLANT, PlantRelatedStates);
}

// checks if heat has any state related to the specific plant
bool CPD_HEAT_REF::isHandledAtPlant(const std::string& HEATID, const std::string& PLANT, std::vector<long> PlantRelatedStates)
{
  bool retValue = false;

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_HEAT_REF::HEATID, HEATID );
  addWhereClause(CPD_HEAT_REF::HEATSTATUSNO, PlantRelatedStates, "IN" );

  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CPD_HEAT_REF::isPlanned(const std::string& HEATID)
{
  bool retValue = false;

  if ( HEATID != CSMC_DBData::unspecString && !HEATID.empty() && select(HEATID) )
  {
    CHeatStatusContainer HeatStatusContainer(m_pCBS_StdConnection);

    long HEATSTATUSNO_PLANNED      = HeatStatusContainer.getHeatStatus(DEF_GC_PLANT_DEF::L3, DEF_GC_HEAT_STATUS::Planned );

    if ( getHEATSTATUSNO(1) == HEATSTATUSNO_PLANNED )
    {
      retValue = true; 
      log( "Heat is planned = " + HEATID,3);
    }
  }
  return retValue;
}

// to be backwards compatibel
bool CPD_HEAT_REF::switchHeatStatusNo(const std::string& HEATID, long HEATSTATUSNO, const std::string &USERCODE, bool Commit, cCBS_ODBC_DBError &Error)
{
  return switchHeatStatusNo(HEATID, HEATSTATUSNO, USERCODE, true, Commit, Error);
}

bool CPD_HEAT_REF::switchHeatStatusNo(const std::string& HEATID, long HEATSTATUSNO, const std::string &USERCODE, bool checkGreater, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = true;

  if (select(HEATID)) 
  {
    if( HEATSTATUSNO > -1 )
    {
      if  ( checkGreater )
      {
        if ( HEATSTATUSNO < getHEATSTATUSNO(1) )
        {
          setLastError("HEATSTATUSNO_SWITCH_NOT_PLAUSIBLE", 0, CDataConversion::LongToString(HEATSTATUSNO));
          result = false;
        }
      }

      if ( result )
      {
        if( !isNull(CPD_HEAT_REF::HEATSTATUSNO, 1) )
        {
          setHEATSTATUSNO_LAST(HEATSTATUSNO);
        }

        setHEATSTATUSNO(HEATSTATUSNO);

        if ( USERCODE != CSMC_DBData::unspecString )
        {
          setUSERCODE(USERCODE);
        }

        setREVTIME(CDateTime());

        result = result & update();
      }
    }
    else
    {
      setLastError("INVALID_HEATSTATUSNO_RECEIVED", 0, CDataConversion::LongToString(HEATSTATUSNO));
      result = false;
    } // if( HEATSTATUSNO > -1 )

    if (!result)
      Error = getLastError();

    if (Commit)
    {
      if (result)
        commit();
      else
        rollback();
    }
  }
  return result;
}

bool CPD_HEAT_REF::deleteRow(const std::string &HEATID, bool Commit, cCBS_ODBC_DBError &Error)
{
  cleanWhereStatement();

  addWhereClause(CPP_HEAT::HEATID, HEATID);

	bool result = deleteRows();

	if (!result)
		Error = getLastError();

	if (Commit)
	{
		if (result)
			commit();
		else
			rollback();
	}

	return result;
}
