//## Copyright (C) 2010 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 



//#include "iSMC_DataDefinitions_s.hh"
#include "cCBS_StdEventLogFrameController.h"
#include "CIntfData.h"
#include "CDataConversion.h"
#include "CGT_MAT.h"
#include "CGT_MAT_PURP.h"
#include "CPD_RECIPE_ENTRY.h"
#include "DEF_GC_RECIPE_STATUS.h"
#include "CPD_RECIPE.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::HEATID("HEATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::TREATID("TREATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::PLANT("PLANT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::RECIPENAME("RECIPENAME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::RECIPENO("RECIPENO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::SOURCE("SOURCE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::BATCHSTATUSNO("BATCHSTATUSNO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::CALC_BASIS_NO("CALC_BASIS_NO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::BATCHSTATUSCHGDATE("BATCHSTATUSCHGDATE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::UPDTIME("UPDTIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::WEIGHTTOTAL("WEIGHTTOTAL");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::COSTSBATCH("COSTSBATCH");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::BULKVOL("BULKVOL");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::ACTOXYGENMOMENT("ACTOXYGENMOMENT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::ACT_AR_MOMENT("ACT_AR_MOMENT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::ACT_N2_MOMENT("ACT_N2_MOMENT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::ACT_EGY("ACT_EGY");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::DURSINCEHEATANNOUNCEMENT("DURSINCEHEATANNOUNCEMENT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::DURSINCESTARTOFFHEAT("DURSINCESTARTOFFHEAT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::BATCHFEEDSPEED("BATCHFEEDSPEED");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::DISCHARGESTARTTIME("DISCHARGESTARTTIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::DISCHARGEENDTIME("DISCHARGEENDTIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::VOLUME("VOLUME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::CHARGING_DEST_NAME("CHARGING_DEST_NAME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::ACT_O2_MOMENT("ACT_O2_MOMENT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_RECIPE::CHARGE_MOMENT("CHARGE_MOMENT");

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_RECIPE::CPD_RECIPE(cCBS_StdConnection* Connection)
:CSMC_DBData("PD_RECIPE",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_RECIPE::CPD_RECIPE(cCBS_Connection* Connection)
:CSMC_DBData("PD_RECIPE",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_RECIPE::CPD_RECIPE()
:CSMC_DBData("PD_RECIPE")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_RECIPE::~CPD_RECIPE()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Internal heat identifier
std::string CPD_RECIPE::getHEATID(long Row)
{
  return getString(CPD_RECIPE::HEATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setHEATID(const std::string& value)
{
  setString(CPD_RECIPE::HEATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment identifier
std::string CPD_RECIPE::getTREATID(long Row)
{
  return getString(CPD_RECIPE::TREATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setTREATID(const std::string& value)
{
  setString(CPD_RECIPE::TREATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant identifier
std::string CPD_RECIPE::getPLANT(long Row)
{
  return getString(CPD_RECIPE::PLANT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setPLANT(const std::string& value)
{
  setString(CPD_RECIPE::PLANT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
std::string CPD_RECIPE::getRECIPENAME(long Row)
{
  return getString(CPD_RECIPE::RECIPENAME, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setRECIPENAME(const std::string& value)
{
  setString(CPD_RECIPE::RECIPENAME, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
long CPD_RECIPE::getRECIPENO(long Row)
{
  return getLong(CPD_RECIPE::RECIPENO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setRECIPENO(long value)
{
  setLong(CPD_RECIPE::RECIPENO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Valid Sources of a Recipe. SOURCE = ALL means all SOURCES for the recipe
std::string CPD_RECIPE::getSOURCE(long Row)
{
  return getString(CPD_RECIPE::SOURCE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setSOURCE(const std::string& value)
{
  setString(CPD_RECIPE::SOURCE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Batch Status number (Number in the L1/L2 Telgramm in the, Material handling report
long CPD_RECIPE::getBATCHSTATUSNO(long Row)
{
  return getLong(CPD_RECIPE::BATCHSTATUSNO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setBATCHSTATUSNO(long value)
{
  setLong(CPD_RECIPE::BATCHSTATUSNO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Basis of the related model calculation
long CPD_RECIPE::getCALC_BASIS_NO(long Row)
{
  return getLong(CPD_RECIPE::CALC_BASIS_NO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setCALC_BASIS_NO(long value)
{
  setLong(CPD_RECIPE::CALC_BASIS_NO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Date of last status change., Comment:, Weighed time = first Weighed for one recipe
CDateTime CPD_RECIPE::getBATCHSTATUSCHGDATE(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_RECIPE::BATCHSTATUSCHGDATE, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setBATCHSTATUSCHGDATE(const CDateTime& value)
{
 setString(CPD_RECIPE::BATCHSTATUSCHGDATE, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Date and time of last revision
CDateTime CPD_RECIPE::getUPDTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_RECIPE::UPDTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setUPDTIME(const CDateTime& value)
{
 setString(CPD_RECIPE::UPDTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
double CPD_RECIPE::getWEIGHTTOTAL(long Row)
{
  return getDouble(CPD_RECIPE::WEIGHTTOTAL, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setWEIGHTTOTAL(double value)
{
  setDouble(CPD_RECIPE::WEIGHTTOTAL, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Total Cost of the Batch
double CPD_RECIPE::getCOSTSBATCH(long Row)
{
  return getDouble(CPD_RECIPE::COSTSBATCH, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setCOSTSBATCH(double value)
{
  setDouble(CPD_RECIPE::COSTSBATCH, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Bulk volume
double CPD_RECIPE::getBULKVOL(long Row)
{
  return getDouble(CPD_RECIPE::BULKVOL, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setBULKVOL(double value)
{
  setDouble(CPD_RECIPE::BULKVOL, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Oxygen Moment, Only for AOD, BOF, Conarc and, Recipe Status, Enable, Processing Start, Weighing Complete, First Material in Charging Hopper, Discharge Start, Weighing Complete, Last Material In Chrging Hopper, Discharged
double CPD_RECIPE::getACTOXYGENMOMENT(long Row)
{
  return getDouble(CPD_RECIPE::ACTOXYGENMOMENT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setACTOXYGENMOMENT(double value)
{
  setDouble(CPD_RECIPE::ACTOXYGENMOMENT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Ar Moment, Only for AOD, BOF, Conarc and, Recipe Status, Enable, Processing Start, Weighing Complete, First Material in Charging Hopper, Discharge Start, Weighing Complete, Last Material In Chrging Hopper, Discharged
double CPD_RECIPE::getACT_AR_MOMENT(long Row)
{
  return getDouble(CPD_RECIPE::ACT_AR_MOMENT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setACT_AR_MOMENT(double value)
{
  setDouble(CPD_RECIPE::ACT_AR_MOMENT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##N2 Moment, Only for AOD, BOF, Conarc and, Recipe Status, Enable, Processing Start, Weighing Complete, First Material in Charging Hopper, Discharge Start, Weighing Complete, Last Material In Chrging Hopper, Discharged
double CPD_RECIPE::getACT_N2_MOMENT(long Row)
{
  return getDouble(CPD_RECIPE::ACT_N2_MOMENT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setACT_N2_MOMENT(double value)
{
  setDouble(CPD_RECIPE::ACT_N2_MOMENT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Only for EAF/LF, Only for Recipe Status, Recipe Status, Enable, Processing Start, Weighing Complete, First Material in Charging Hopper, Discharge Start, Weighing Complete, Last Material In Chrging Hopper, Discharged
double CPD_RECIPE::getACT_EGY(long Row)
{
  return getDouble(CPD_RECIPE::ACT_EGY, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setACT_EGY(double value)
{
  setDouble(CPD_RECIPE::ACT_EGY, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Duration since heat announcement
double CPD_RECIPE::getDURSINCEHEATANNOUNCEMENT(long Row)
{
  return getDouble(CPD_RECIPE::DURSINCEHEATANNOUNCEMENT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setDURSINCEHEATANNOUNCEMENT(double value)
{
  setDouble(CPD_RECIPE::DURSINCEHEATANNOUNCEMENT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Duration since start of heat
double CPD_RECIPE::getDURSINCESTARTOFFHEAT(long Row)
{
  return getDouble(CPD_RECIPE::DURSINCESTARTOFFHEAT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setDURSINCESTARTOFFHEAT(double value)
{
  setDouble(CPD_RECIPE::DURSINCESTARTOFFHEAT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Batch Material feed speed., BATCHMATFEEDSPEED=, TOTALBATCHWEIGHT/, Discharged Time Discharge Start Time, Only filled for Status 10!!!
double CPD_RECIPE::getBATCHFEEDSPEED(long Row)
{
  return getDouble(CPD_RECIPE::BATCHFEEDSPEED, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setBATCHFEEDSPEED(double value)
{
  setDouble(CPD_RECIPE::BATCHFEEDSPEED, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Timestamp when Batch status "Discharge Start" has been reached
CDateTime CPD_RECIPE::getDISCHARGESTARTTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_RECIPE::DISCHARGESTARTTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setDISCHARGESTARTTIME(const CDateTime& value)
{
 setString(CPD_RECIPE::DISCHARGESTARTTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Timestamp when Batch status "Discharge End" has been reached
CDateTime CPD_RECIPE::getDISCHARGEENDTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_RECIPE::DISCHARGEENDTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setDISCHARGEENDTIME(const CDateTime& value)
{
 setString(CPD_RECIPE::DISCHARGEENDTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
double CPD_RECIPE::getVOLUME(long Row)
{
  return getDouble(CPD_RECIPE::VOLUME, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setVOLUME(double value)
{
  setDouble(CPD_RECIPE::VOLUME, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Charging destination name, e.g TapLadle, ladle
std::string CPD_RECIPE::getCHARGING_DEST_NAME(long Row)
{
  return getString(CPD_RECIPE::CHARGING_DEST_NAME, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setCHARGING_DEST_NAME(const std::string& value)
{
  setString(CPD_RECIPE::CHARGING_DEST_NAME, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
double CPD_RECIPE::getACT_O2_MOMENT(long Row)
{
  return getDouble(CPD_RECIPE::ACT_O2_MOMENT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setACT_O2_MOMENT(double value)
{
  setDouble(CPD_RECIPE::ACT_O2_MOMENT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
double CPD_RECIPE::getCHARGE_MOMENT(long Row)
{
  return getDouble(CPD_RECIPE::CHARGE_MOMENT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_RECIPE::setCHARGE_MOMENT(double value)
{
  setDouble(CPD_RECIPE::CHARGE_MOMENT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPD_RECIPE::select(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& RECIPENAME, long RECIPENO, const std::string& SOURCE, long BATCHSTATUSNO)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_RECIPE::HEATID,HEATID);
  addWhereClause(CPD_RECIPE::TREATID,TREATID);
  addWhereClause(CPD_RECIPE::PLANT,PLANT);
  addWhereClause(CPD_RECIPE::RECIPENAME,RECIPENAME);
  addWhereClause(CPD_RECIPE::RECIPENO,RECIPENO);
  addWhereClause(CPD_RECIPE::SOURCE,SOURCE);
  addWhereClause(CPD_RECIPE::BATCHSTATUSNO,BATCHSTATUSNO);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CPD_RECIPE::selectInUse(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& RECIPENAME, long RECIPENO, const std::string& SOURCE)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_RECIPE::HEATID,HEATID);
  addWhereClause(CPD_RECIPE::TREATID,TREATID);
  addWhereClause(CPD_RECIPE::PLANT,PLANT);
  addWhereClause(CPD_RECIPE::RECIPENAME,RECIPENAME);
  addWhereClause(CPD_RECIPE::RECIPENO,RECIPENO);
  addWhereClause(CPD_RECIPE::SOURCE,SOURCE);
  addWhereClause(CPD_RECIPE::BATCHSTATUSNO,DEF_GC_RECIPE_STATUS::Calculated, "<>");
  addWhereClause(CPD_RECIPE::BATCHSTATUSNO,DEF_GC_RECIPE_STATUS::Disabled, "<>");

  m_Statement += getWhereStatement() + ";";
  
  return CSMC_DBData::select();
}

bool CPD_RECIPE::selectNotUsedRecipes(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& RECIPENAME, long RECIPENO, std::vector<std::string> SOURCE_LIST)
{
  cleanWhereStatement();

  std::stringstream Sql;
  Sql << "RECIPENAME||RECIPENO NOT IN (select RECIPENAME||RECIPENO from " <<  m_TableName
    << " where BATCHSTATUSNO IN ( " << DEF_GC_RECIPE_STATUS::Enabled << " , " 
                                    << DEF_GC_RECIPE_STATUS::Weighed << " , " 
                                    << DEF_GC_RECIPE_STATUS::WeighingComplete << " , " 
                                    << DEF_GC_RECIPE_STATUS::WeighingCompleteUpdate << " , " 
                                    << DEF_GC_RECIPE_STATUS::DischargeStart << " , " 
                                    << DEF_GC_RECIPE_STATUS::Discharged << " ) " 
      << " and HEATID = '" << HEATID << "'"
      << " and TREATID = '" << TREATID << "'"
      << " and PLANT = '" << PLANT << "')";

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_RECIPE::HEATID,HEATID);
  addWhereClause(CPD_RECIPE::TREATID,TREATID);
  addWhereClause(CPD_RECIPE::PLANT,PLANT);
  addWhereClause(CPD_RECIPE::RECIPENAME,RECIPENAME);
  addWhereClause(CPD_RECIPE::RECIPENO,RECIPENO);
  addWhereClause(CPD_RECIPE::SOURCE,SOURCE_LIST, "IN" );

  addWhereClause(Sql.str());

  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CPD_RECIPE::selectNotUsedRecipes(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& RECIPENAME, long RECIPENO, const std::string& SOURCE)
{
  cleanWhereStatement();

  std::stringstream Sql;
  Sql << "RECIPENAME||RECIPENO NOT IN (select RECIPENAME||RECIPENO from " <<  m_TableName
    << " where BATCHSTATUSNO IN ( " << DEF_GC_RECIPE_STATUS::Enabled << " , " 
                                    << DEF_GC_RECIPE_STATUS::Weighed << " , " 
                                    << DEF_GC_RECIPE_STATUS::WeighingComplete << " , " 
                                    << DEF_GC_RECIPE_STATUS::WeighingCompleteUpdate << " , " 
                                    << DEF_GC_RECIPE_STATUS::DischargeStart << " , " 
                                    << DEF_GC_RECIPE_STATUS::Discharged << " ) " 
      << " and HEATID = '" << HEATID << "'"
      << " and TREATID = '" << TREATID << "'"
      << " and PLANT = '" << PLANT << "')";

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_RECIPE::HEATID,HEATID);
  addWhereClause(CPD_RECIPE::TREATID,TREATID);
  addWhereClause(CPD_RECIPE::PLANT,PLANT);
  addWhereClause(CPD_RECIPE::RECIPENAME,RECIPENAME);
  addWhereClause(CPD_RECIPE::RECIPENO,RECIPENO);
  addWhereClause(CPD_RECIPE::SOURCE,SOURCE);

  addWhereClause(Sql.str());

  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
  
}

bool CPD_RECIPE::selectOrderdByBatchStatusNo(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& RECIPENAME, long RECIPENO, bool ASC )
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_RECIPE::HEATID,HEATID);
  addWhereClause(CPD_RECIPE::TREATID,TREATID);
  addWhereClause(CPD_RECIPE::PLANT,PLANT);
  addWhereClause(CPD_RECIPE::RECIPENAME,RECIPENAME);
  addWhereClause(CPD_RECIPE::RECIPENO,RECIPENO);
  
  if (ASC)
  {
    m_Statement += getWhereStatement() + " ORDER by BATCHSTATUSNO;";
  }
  else
  {
    m_Statement += getWhereStatement() + " ORDER by BATCHSTATUSNO DESC;";
  }

  return CSMC_DBData::select();
}

bool CPD_RECIPE::selectOrderdByRecipeName(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& RECIPENAME, long RECIPENO, const std::string& SOURCE, bool ASC )
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_RECIPE::HEATID,HEATID);
  addWhereClause(CPD_RECIPE::TREATID,TREATID);
  addWhereClause(CPD_RECIPE::PLANT,PLANT);
  addWhereClause(CPD_RECIPE::RECIPENAME,RECIPENAME);
  addWhereClause(CPD_RECIPE::RECIPENO,RECIPENO);
  addWhereClause(CPD_RECIPE::SOURCE,SOURCE);
  
  if (ASC)
  {
    m_Statement += getWhereStatement() + " ORDER by RECIPENAME, RECIPENO;";
  }
  else
  {
    m_Statement += getWhereStatement() + " ORDER by RECIPENAME DESC, RECIPENO DESC;";
  }

  return CSMC_DBData::select();
}

bool CPD_RECIPE::selectOrdered(std::string& HeatID, std::string& TreatID, std::string& Plant, long BATCHSTATUSNO, std::string& ORDERBY)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_RECIPE::HEATID,HeatID);
  addWhereClause(CPD_RECIPE::TREATID,TreatID);
  addWhereClause(CPD_RECIPE::PLANT,Plant);
  addWhereClause(CPD_RECIPE::BATCHSTATUSNO,BATCHSTATUSNO);

  m_Statement += getWhereStatement();
  m_Statement += " ORDER BY " + ORDERBY + ";";

  return CSMC_DBData::select();
}

bool CPD_RECIPE::selectPrepared(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& RECIPENAME, long RECIPENO, const std::string& SOURCE)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_RECIPE::HEATID,HEATID);
  addWhereClause(CPD_RECIPE::TREATID,TREATID);
  addWhereClause(CPD_RECIPE::PLANT,PLANT);
  addWhereClause(CPD_RECIPE::RECIPENAME,RECIPENAME);
  addWhereClause(CPD_RECIPE::RECIPENO,RECIPENO);
  addWhereClause(CPD_RECIPE::SOURCE,SOURCE);

  // prepared recipes by L1 means status between "enable" and "discharging"
  std::vector<long> BatchStatusList;

  BatchStatusList.push_back(DEF_GC_RECIPE_STATUS::Enabled);
  BatchStatusList.push_back(DEF_GC_RECIPE_STATUS::Weighed);
  BatchStatusList.push_back(DEF_GC_RECIPE_STATUS::WeighingComplete);
  BatchStatusList.push_back(DEF_GC_RECIPE_STATUS::WeighingCompleteUpdate);

  addWhereClause(CPD_RECIPE::BATCHSTATUSNO,BatchStatusList,"IN");

  m_Statement += getWhereStatement() + ";";
  
  return CSMC_DBData::select();
}

bool CPD_RECIPE::copyDataToBatchStatus(const std::string & HeatID, const std::string & TreatID,const std::string & Plant, const std::string & RECIPENAME, long RECIPENO, const std::string & SOURCE, long BATCHSTATUSNO_SOURCE, long BATCHSTATUSNO_AIM, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool RetValue = false;
  bool doInsertRecipe = true;
  bool doInsertRecipeEntry = true;

  CDateTime now;
  try
  {
    // check for existance first
    if ( select(HeatID, TreatID, Plant, RECIPENAME, RECIPENO, SOURCE, BATCHSTATUSNO_AIM) )
    {
      removeRecipeData(HeatID, TreatID, Plant,RECIPENAME, RECIPENO, SOURCE, BATCHSTATUSNO_AIM, false, Error);
    }

    // copy PD_RECIPE data
    if ( select(HeatID, TreatID, Plant, RECIPENAME, RECIPENO, SOURCE, BATCHSTATUSNO_SOURCE ) )
    {
      long Rows = getLastRow();

      for ( long i = 1; i <= Rows; ++i)
      {
        // read values for other entries
        setColumnsFromTable(this, i);
       
        // set differnet values
        setBATCHSTATUSNO(BATCHSTATUSNO_AIM);

        RetValue = copy();

        if ( RetValue )
        {
          // m_pPD_RECIPE_ENTRY->copyDataToBatchStatus does not perform commit !
          RetValue = m_pPD_RECIPE_ENTRY->copyDataToBatchStatus(HeatID, TreatID, Plant, RECIPENAME, RECIPENO, SOURCE, BATCHSTATUSNO_SOURCE, BATCHSTATUSNO_AIM, false, m_lastError );
        } // if ( RetValue )

        if ( !RetValue )
        {
          break;
        }

      } // for ( long i = 1; i <= getLastRow(); ++i)
    }
    else
    {
      setLastError("ERROR_FIND_BATCH", 0, getActStatement());
    }

    if ( !RetValue )
    {
      Error = getLastError();
    }

    if(Commit)
    {
      if ( RetValue )
      {
        commit();
      }
      else
      {
        rollback();
      }
    }
  }
  catch(cCBS_DBExc &e) 
  {
    doOnCBS_DBExc(e,"CPD_RECIPE::copyDataToBatchStatus()");

    if (m_pStatement)
    {
      getpCBSConnection()->freeStatement(m_pStatement);
    }

  }

  return RetValue;

}

bool CPD_RECIPE::copyDataToFinalBatchStatus(const std::string & HeatID, const std::string & TreatID,const std::string & Plant, const std::string & RECIPENAME, long RECIPENO, const std::string & SOURCE, long BATCHSTATUSNO, bool Commit, cCBS_ODBC_DBError &Error)
{
  return copyDataToBatchStatus(HeatID, TreatID, Plant, RECIPENAME, RECIPENO, SOURCE, BATCHSTATUSNO, DEF_GC_RECIPE_STATUS::Final, Commit, Error );
}

bool CPD_RECIPE::checkBatchForCalculatedMaterials(const std::string& HeatID, const std::string& TreatID, const std::string& Plant, sRecipeInfo &SRecipeInfo, seqBatch &SeqBatch)
{
  bool RetValue = true;

  std::set<std::string> RecipeMaterials = m_pPD_RECIPE_ENTRY->getRecipeMaterials(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, DEF_GC_RECIPE_STATUS::Calculated);
  if ( RecipeMaterials.size() > 0 )
  {
    for( long i = 0; i < CIntfData::getLength(SeqBatch); ++i )
    {
      sBatch Batch;
      CIntfData::getAt(Batch, SeqBatch, i );

      // check if materials in sequence are stored in database
      if ( RecipeMaterials.find(std::string(Batch.MatCode)) == RecipeMaterials.end() )
      {
        std::string Message = "Material not found in calculation: " + std::string(Batch.MatCode);
        CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
        sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
        pEventLog->EL_ErrorHandlingBatch(sMessage,SRecipeInfo.RecipeName.c_str(), Message.c_str());

        RetValue = false;
        break;
      } 
    } // for( long i = 0; i <= CIntfData::getLength(SeqBatch); ++i )
  }

  return RetValue;
}

bool CPD_RECIPE::checkBatchStateChange(const std::string& HeatID, const std::string& TreatID, const std::string& Plant, sRecipeInfo &SRecipeInfo)
{
  bool RetValue = true;

  if ( select(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, CSMC_DBData::unspecLong) )
  {
    for ( long i = 1; i <= getLastRow(); ++i )
    {
      // *****************************************
      // check if batch with identcal state exists
      // *****************************************
      if ( SRecipeInfo.RecipeStatus == getBATCHSTATUSNO(i) )
      {
        // *************************************
        // check if batch was already enabled
        // *************************************
        if ( SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::Enabled )
        {
          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_ErrorHandlingBatch(sMessage,SRecipeInfo.RecipeName.c_str(),"batch enable received - batch is already enabled");

          RetValue = false;
            
          break;
        } 

        // *******************************************
        // check if batch was already WeighingComplete
        // *******************************************
        if ( SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::WeighingComplete )
        {
          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_ErrorHandlingBatch(sMessage,SRecipeInfo.RecipeName.c_str(),"batch weighing complete received - batch is already weighed");

          RetValue = false;
            
          break;
        } 

        // *************************************
        // check if batch was already discharged
        // *************************************
        if ( SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::Discharged )
        {
          CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
          sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
          pEventLog->EL_ErrorHandlingBatch(sMessage,SRecipeInfo.RecipeName.c_str(),"batch discharged received - batch is already discharged");

          RetValue = false;
            
          break;
        } 



      } // if ( SRecipeInfo.RecipeStatus == getBATCHSTATUSNO(i) )
    }
  }

  return RetValue;
}

bool CPD_RECIPE::cleanRecipeData(const std::string & HeatID, const std::string & TreatID, const std::string & Plant, const std::string & RECIPENAME, long RECIPENO, const std::string & SOURCE, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool RetValue = false;
  try
  {

    cleanWhereStatement();

    addWhereClause(CPD_RECIPE::HEATID,HeatID);
    addWhereClause(CPD_RECIPE::TREATID,TreatID);
    addWhereClause(CPD_RECIPE::PLANT,Plant);
    addWhereClause(CPD_RECIPE::RECIPENAME,RECIPENAME);
    addWhereClause(CPD_RECIPE::RECIPENO,RECIPENO);
    addWhereClause(CPD_RECIPE::SOURCE,SOURCE);

    addWhereClause(CPD_RECIPE::BATCHSTATUSNO, DEF_GC_RECIPE_STATUS::Disabled   , "<>");    
    addWhereClause(CPD_RECIPE::BATCHSTATUSNO, DEF_GC_RECIPE_STATUS::Calculated , "<>");   

    RetValue = deleteRows(); // deletes on cascade at PD_RECIPE_ENTRY !!!

    if ( !RetValue )
    {
      Error = getLastError();
    }

    if(Commit)
    {
      if ( RetValue ) 
      {
        commit();
      }
      else
      {
        rollback();
      }
    }
  }
  catch(cCBS_DBExc &e) 
  {
    doOnCBS_DBExc(e,"CPD_RECIPE::cleanRecipeData");
  }
  catch(...)
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLogFrame::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,"","CPD_RECIPE::cleanRecipeData()","");
  }

  return RetValue;
}

bool CPD_RECIPE::deleteRow(const std::string & HeatID, const std::string & TreatID, const std::string & Plant, const std::string & RECIPENAME, long RECIPENO, const std::string & SOURCE, long BATCHSTATUSNO, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool RetValue = false;

  try
  {
    cleanWhereStatement();

    addWhereClause(CPD_RECIPE::HEATID,HeatID);
    addWhereClause(CPD_RECIPE::TREATID,TreatID);
    addWhereClause(CPD_RECIPE::PLANT,Plant);
    addWhereClause(CPD_RECIPE::RECIPENAME,RECIPENAME);
    addWhereClause(CPD_RECIPE::RECIPENO,RECIPENO);
    addWhereClause(CPD_RECIPE::SOURCE,SOURCE);
    addWhereClause(CPD_RECIPE::BATCHSTATUSNO,BATCHSTATUSNO);

    RetValue = deleteRows(); // deletes on cascade at PD_RECIPE_ENTRY !!!

    if ( !RetValue )
    {
      Error = getLastError();
    }

    if(Commit)
    {
      if ( RetValue )
      {
        commit();
      }
      else 
      {
        rollback();
      }
    }
  }
  catch(cCBS_DBExc &e) 
  {
    doOnCBS_DBExc(e,"CPD_RECIPE::deleteRow");
  }
  catch(...)
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLogFrame::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,"","CPD_RECIPE::deleteRow()","");
  }

  return RetValue;
}

void CPD_RECIPE::doOnConstruct()
{
  if (m_pCBS_StdConnection)
  {
    m_pGT_MAT                 = new CGT_MAT(m_pCBS_StdConnection);
    m_pPD_RECIPE_ENTRY        = new CPD_RECIPE_ENTRY(m_pCBS_StdConnection);
  }
}

void CPD_RECIPE::doOnDestruct()
{
  if ( m_pGT_MAT )                  { delete m_pGT_MAT; m_pGT_MAT = 0; }
  if ( m_pPD_RECIPE_ENTRY )         { delete m_pPD_RECIPE_ENTRY; m_pPD_RECIPE_ENTRY = 0; }
}

long CPD_RECIPE::getActRecipeNo(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& RECIPENAME, const std::string& SOURCE)
{
  long RecipeNo = CSMC_DBData::unspecLong;

  if ( select(HEATID, TREATID, PLANT, RECIPENAME, CSMC_DBData::unspecLong, SOURCE, CSMC_DBData::unspecLong) )
  {
    for ( long i = 1 ; i <= getLastRow(); ++i )
    {
      RecipeNo = max( RecipeNo, getRECIPENO(i) );
    }
  }

  return RecipeNo;
}

double CPD_RECIPE::getCostsChargedBatch(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, const std::string& PURP_CODE)
{
  double CostsBatch = 0.0;


  CGT_MAT_PURP GT_MAT_PURP(m_pCBS_StdConnection);
  CGT_MAT      GT_MAT     (m_pCBS_StdConnection);

  std::vector<std::string>::iterator it;
  std::vector<std::string> RelatedMatCodes = GT_MAT_PURP.getRelatedMatCodes(PLANT, PLANTNO, PURP_CODE);

  if ( m_pPD_RECIPE_ENTRY )
  {
    for ( it = RelatedMatCodes.begin(); it != RelatedMatCodes.end() ; ++it )
    {
      std::string MAT_CODE = (*it);

      if ( GT_MAT.select(MAT_CODE) )
      {
        double MatWeight = m_pPD_RECIPE_ENTRY->getSumMatWeights(HEATID, TREATID, PLANT, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, CSMC_DBData::unspecString, DEF_GC_RECIPE_STATUS::Discharged, MAT_CODE);
        double MatPrice  = GT_MAT.getPRICE(1);

        if ( MatWeight != CSMC_DBData::unspecDouble && 
             MatPrice != CSMC_DBData::unspecDouble      )
        {
          CostsBatch += MatWeight * MatPrice;
        }
      } // if ( GT_MAT.select(MAT_CODE) )
    } // for ( it = RelatedMatCodes.begin(); it != RelatedMatCodes.end() ; ++it )
  } // if ( m_pPD_RECIPE_ENTRY )

  if ( CostsBatch == 0.0 )
  {
    CostsBatch = CSMC_DBData::unspecDouble;
  }

  return CostsBatch;
}

double CPD_RECIPE::getMatWeightForChargeDest(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, std::vector<std::string> SOURCE_LIST,  const std::string& CHARGING_DEST_NAME)
{
  double MatWeight = 0.;

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_RECIPE::HEATID,HEATID);
  addWhereClause(CPD_RECIPE::TREATID,TREATID);
  addWhereClause(CPD_RECIPE::PLANT,PLANT);
  addWhereClause(CPD_RECIPE::SOURCE,SOURCE_LIST, "IN" );
  addWhereClause(CPD_RECIPE::CHARGING_DEST_NAME,CHARGING_DEST_NAME);
  addWhereClause(CPD_RECIPE::BATCHSTATUSNO,DEF_GC_RECIPE_STATUS::Discharged);

  m_Statement += getWhereStatement() + ";";

  if ( CSMC_DBData::select() )
  {
    for ( long i = 1; i <= getLastRow(); ++i )
    {
      std::string RECIPNAME     = getRECIPENAME(i);
      long        RECIPNO       = getRECIPENO(i);
      long        BATCHSTATUSNO = getBATCHSTATUSNO(i); 
      std::string SOURCE        = getSOURCE(i);

      if ( m_pPD_RECIPE_ENTRY )
      {
        double ActWeight = m_pPD_RECIPE_ENTRY->getSumMatWeights(HEATID, TREATID, PLANT, RECIPNAME, RECIPNO, SOURCE, BATCHSTATUSNO, CSMC_DBData::unspecString);

        if ( ActWeight != CSMC_DBData::unspecDouble )
        {
          MatWeight += ActWeight;
        }
      }
    }
  }
  else
  {
    MatWeight = CSMC_DBData::unspecDouble;
  }

  return MatWeight;
}

double CPD_RECIPE::getMatWeightForChargeDestAndPurpose(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, std::vector<std::string> SOURCE_LIST, std::vector<std::string> CHARGING_DEST_NAME_LIST, const std::string& PURP_CODE)
{
  double MatWeight = CSMC_DBData::unspecDouble;

  std::vector<std::string>::iterator it;

  for ( it = CHARGING_DEST_NAME_LIST.begin(); it != CHARGING_DEST_NAME_LIST.end(); ++it )
  {
    std::string CHARGING_DEST_NAME = (*it);
    
    double ActWeight = getMatWeightForChargeDestAndPurpose(HEATID, TREATID, PLANT, PLANTNO, SOURCE_LIST,  CHARGING_DEST_NAME, PURP_CODE);

    if ( ActWeight != CSMC_DBData::unspecDouble )
    {
      MatWeight += ActWeight;
    }
  }

  return MatWeight;

}

double CPD_RECIPE::getMatWeightForChargeDestAndPurpose(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, std::vector<std::string> SOURCE_LIST,  const std::string& CHARGING_DEST_NAME, const std::string& PURP_CODE)
{
  double MatWeight = 0.;

  CGT_MAT_PURP GT_MAT_PURP(m_pCBS_StdConnection);
  std::vector<std::string> RelatedMatCodes = GT_MAT_PURP.getRelatedMatCodes(PLANT, PLANTNO, PURP_CODE);

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_RECIPE::HEATID,HEATID);
  addWhereClause(CPD_RECIPE::TREATID,TREATID);
  addWhereClause(CPD_RECIPE::PLANT,PLANT);
  addWhereClause(CPD_RECIPE::SOURCE,SOURCE_LIST, "IN" );
  addWhereClause(CPD_RECIPE::CHARGING_DEST_NAME,CHARGING_DEST_NAME);
  addWhereClause(CPD_RECIPE::BATCHSTATUSNO,DEF_GC_RECIPE_STATUS::Discharged);

  m_Statement += getWhereStatement() + ";";

  if ( CSMC_DBData::select() )
  {
    for ( long i = 1; i <= getLastRow(); ++i )
    {
      std::string RECIPNAME     = getRECIPENAME(i);
      long        RECIPNO       = getRECIPENO(i);
      long        BATCHSTATUSNO = getBATCHSTATUSNO(i); 
      std::string SOURCE        = getSOURCE(i);

      if ( m_pPD_RECIPE_ENTRY )
      {
        double ActWeight = m_pPD_RECIPE_ENTRY->getSumMatWeights(HEATID, TREATID, PLANT, RECIPNAME, RECIPNO, SOURCE, BATCHSTATUSNO, RelatedMatCodes);

        if ( ActWeight != CSMC_DBData::unspecDouble )
        {
          MatWeight += ActWeight;
        }
      }
    }
  }
  else
  {
    MatWeight = CSMC_DBData::unspecDouble;
  }

  return MatWeight;
}

double CPD_RECIPE::getMatWeightForPurpose(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, const std::string& PURP_CODE)
{
  double MatWeight = CSMC_DBData::unspecDouble;

  CGT_MAT_PURP GT_MAT_PURP(m_pCBS_StdConnection);

  std::vector<std::string> RelatedMatCodes = GT_MAT_PURP.getRelatedMatCodes(PLANT, PLANTNO, PURP_CODE);

  if ( m_pPD_RECIPE_ENTRY )
  {
    MatWeight = m_pPD_RECIPE_ENTRY->getSumMatWeights(HEATID, TREATID, PLANT, CSMC_DBData::unspecString, CSMC_DBData::unspecLong, CSMC_DBData::unspecString, DEF_GC_RECIPE_STATUS::Discharged, RelatedMatCodes);
  }

  return MatWeight;
}

bool CPD_RECIPE::insertRecipeData(const std::string& HeatID, const std::string& TreatID, const std::string& Plant, sRecipeInfo &SRecipeInfo, sMetTimeStamp &MetTimeStamp, seqBatchPrio &SeqBatchPrio, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool RetValue = false;

  CDateTime now;
  double WEIGHTTOTAL  = 0.0;
  double COSTSBATCH   = 0.0;
  double BULKVOL      = 0.0;
  double VOLUME       = 0.0;

  // we will not store empty recipes
  if ( CIntfData::getLength(SeqBatchPrio) > 0 )
  {
    setHEATID(HeatID);
    setTREATID(TreatID);
    setPLANT(Plant);
    setRECIPENAME(SRecipeInfo.RecipeName);
    setRECIPENO(SRecipeInfo.RecipeNo);
    setSOURCE(SRecipeInfo.RecipeSource);
    setBATCHSTATUSNO(SRecipeInfo.RecipeStatus);
    setDURSINCEHEATANNOUNCEMENT(SRecipeInfo.DurSinceHeatAnnounce);
    setDURSINCESTARTOFFHEAT(SRecipeInfo.DurSinceHeatStart);
    setBATCHSTATUSCHGDATE(now);

    if ( SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::Calculated )
    {
      if ( SRecipeInfo.ChargeMoment > 0.0 )
      {
        setCHARGE_MOMENT(SRecipeInfo.ChargeMoment);
      }
    }

    //set corresponding price, density and volume
    setCalculatedValues(SeqBatchPrio);

    //set corresponding gas moment. valid gas types O2,Ar,N2
    setGasInfo(MetTimeStamp.O2_Moment, MetTimeStamp.Ar_Moment, MetTimeStamp.N2_Moment);

    //set corresponding energy
    setACT_EGY(MetTimeStamp.Elec_Moment);

    if ( SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::Weighed          || 
         SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::WeighingComplete ||
         SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::DischargeStart)
    {  
      setDISCHARGESTARTTIME(now);
    }

    if (SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::Discharged)
    {
      CDateTime DischargeStartTime(now);
      double    WeightTotal = 0.;

      setCHARGING_DEST_NAME( SRecipeInfo.RecipeTarget );
      setDISCHARGEENDTIME( now );

      // search for already started batch, if not existant, use discharged as discharge start 
      if ( !select(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, DEF_GC_RECIPE_STATUS::DischargeStart) )
      {
        setDISCHARGESTARTTIME(now);
      }

      // search for already weighed materials and use data for inserting new materials of same recipe
      if ( select(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, DEF_GC_RECIPE_STATUS::DischargeStart)   ||
           select(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, DEF_GC_RECIPE_STATUS::WeighingComplete) ||
           select(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, DEF_GC_RECIPE_STATUS::Weighed)          )
      {
        DischargeStartTime  = getDISCHARGESTARTTIME(1);
        WeightTotal         = getWEIGHTTOTAL(1);

        setDISCHARGESTARTTIME(DischargeStartTime);
      }

      // calculate feeding data
      setCalculatedFeedingValues(DischargeStartTime, now, WeightTotal);
    }

    if ( !select(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, SRecipeInfo.RecipeStatus) )
    {
      if ( insert() )
      {
        // insert recipe details
        // do not perform commit !
        RetValue = m_pPD_RECIPE_ENTRY->insertRecipeEntry(HeatID, TreatID, Plant, SRecipeInfo, SeqBatchPrio, false, m_lastError);
      }
    }

    if ( !RetValue )
    {
      Error = getLastError();
    }

    if(Commit)
    {
      if ( RetValue ) 
      {
        commit();
      }
      else
      {
        rollback();
      }
    }
  }
  else
  {
    log( "Recipe " + SRecipeInfo.RecipeName + " not stored due to empty batch list ! ",2);
  }

  return RetValue;

}

bool CPD_RECIPE::isRecipeIniUse(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& RECIPENAME, long RECIPENO, const std::string& SOURCE)
{
  bool RetValue = false;

  if ( selectInUse(HEATID, TREATID, PLANT, RECIPENAME, RECIPENO, SOURCE) )
  {
    RetValue = true;

  }
  return RetValue;
}

bool CPD_RECIPE::removeRecipeData(const std::string & HeatID, const std::string & TreatID, const std::string & Plant, const std::string & RECIPENAME, long RECIPENO, const std::string & SOURCE, long BATCHSTATUSNO, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool RetValue = false;

  if ( select(HeatID, TreatID, Plant, RECIPENAME, RECIPENO, SOURCE, BATCHSTATUSNO ) )
  {
    RetValue = deleteRow(HeatID, TreatID, Plant, RECIPENAME, RECIPENO, SOURCE, BATCHSTATUSNO, Commit, Error);
  }

  return RetValue;
}

bool CPD_RECIPE::replaceBatch(const std::string& HeatID, const std::string& TreatID, const std::string& Plant, sRecipeInfo &SRecipeInfo, sMetTimeStamp &MetTimeStamp, seqBatch &SeqBatch, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool RetValue = true;

  removeRecipeData(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, SRecipeInfo.RecipeStatus, Commit, Error);

  RetValue = writeBatch(HeatID, TreatID, Plant, SRecipeInfo, MetTimeStamp, SeqBatch, Commit, Error);

  return RetValue;
}

bool CPD_RECIPE::setCalculatedFeedingValues(CDateTime & StartTime, CDateTime & EndTime, double WeightTotal)
{
  bool RetValue = false;
  CDeltaTime Duration;

  Duration = CDateTime::subTimes(EndTime, StartTime);

  double total_feed_time  = Duration.asSeconds()/60;
  double feed_speed       = CSMC_DBData::unspecDouble;

  if (total_feed_time > 0) //to avoid divide by 0
  {
    feed_speed = WeightTotal / total_feed_time;
  }

  setBATCHFEEDSPEED( feed_speed );

  return RetValue;
}

double CPD_RECIPE::setCalculatedValues(seqBatchPrio &SeqBatchPrio)
{
  double WEIGHTTOTAL  = 0.0;
  double COSTSBATCH   = 0.0;
  double BULKVOL      = 0.0;
  double VOLUME       = 0.0;

  for (int j=0;j < CIntfData::getLength(SeqBatchPrio); j++)
  {
    sBatchPrio BatchPrio;
    CIntfData::getAt(BatchPrio,&SeqBatchPrio,j);

    log("Calculating values for Material " + (std::string)BatchPrio.BatchData.MatCode,2);

    if (m_pGT_MAT->select((std::string)BatchPrio.BatchData.MatCode))
    {
      double single_price        = m_pGT_MAT->getPRICE(1);
      double single_density      = m_pGT_MAT->getDENSITY(1);
      double single_bulkdensity  = m_pGT_MAT->getBULK_DENSITY(1);

      // single_price is in e.g. $/t, not in $/kg
      // we have to divide it by 1000
      single_price = single_price / 1000. ;
      
      // check material data
      if ( BatchPrio.BatchData.Mass > 0. && BatchPrio.BatchData.Mass != DEF::Inv_Double )
      {
        WEIGHTTOTAL  += BatchPrio.BatchData.Mass;
        COSTSBATCH   += single_price * BatchPrio.BatchData.Mass;

        if (single_density > 0. && single_density != CSMC_DBData::unspecDouble) //to avoid divided by 0
        {
          VOLUME += BatchPrio.BatchData.Mass / single_density;
        }

        if (single_bulkdensity > 0. && single_bulkdensity != CSMC_DBData::unspecDouble) //to avoid divided by 0
        {
          BULKVOL += BatchPrio.BatchData.Mass / single_bulkdensity;
        }
      }

    } // if (m_pGT_MAT->select((std::string)Batch.MatCode))
  } // for (int j=0;j < CIntfData::getLength(SeqBatch); j++)

  if ( WEIGHTTOTAL > 0. )
  {
    setWEIGHTTOTAL( WEIGHTTOTAL );
    setCOSTSBATCH( COSTSBATCH );
    setBULKVOL( BULKVOL );
    setVOLUME( VOLUME );
  }


  return WEIGHTTOTAL;
}

void CPD_RECIPE::setGasInfo(double ACT_O2_MOMENT, double ACT_AR_MOMENT, double ACT_N2_MOMENT)
{
  if ( ACT_O2_MOMENT > 0. && ACT_O2_MOMENT != DEF::Inv_Double )
  {
    setACT_O2_MOMENT(ACT_O2_MOMENT);
  }
  if ( ACT_AR_MOMENT > 0 && ACT_AR_MOMENT != DEF::Inv_Double )
  {
    setACT_AR_MOMENT(ACT_AR_MOMENT);
  }
  if ( ACT_N2_MOMENT > 0. && ACT_N2_MOMENT != DEF::Inv_Double )
  {
    setACT_N2_MOMENT(ACT_N2_MOMENT);
  }
}

// update all entries for given recipe with new gas / electrcal data
// returnes also true if recipe is not in database
bool CPD_RECIPE::updateGasAndElecData(const std::string& HeatID, const std::string& TreatID, const std::string& Plant, sRecipeInfo &SRecipeInfo, sMetTimeStamp &MetTimeStamp, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool RetValue = true;

  if ( selectPrepared(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource) )
  {
    CDateTime now;

    for ( long i = 1 ; i <= getLastRow(); ++i )
    {
      setUPDTIME(now);

      //set corresponding gas moment. valid gas types O2,Ar,N2
      setGasInfo(MetTimeStamp.O2_Moment, MetTimeStamp.Ar_Moment, MetTimeStamp.N2_Moment);

      setACT_EGY(MetTimeStamp.Elec_Moment);    

      RetValue = RetValue && update();
    }


    if ( !RetValue )
    {
      Error = getLastError();
    }

    if(Commit)
    {
      if ( RetValue ) 
      {
        commit();
      }
      else
      {
        rollback();
      }
    }
  }

  return RetValue;

}

bool CPD_RECIPE::updateChargeMoment(const std::string& HeatID, const std::string& TreatID, const std::string& Plant, sRecipeInfo &SRecipeInfo, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool RetValue = true;

  if ( selectPrepared(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource) )
  {
    CDateTime now;

    for ( long i = 1 ; i <= getLastRow(); ++i )
    {
      setUPDTIME(now);

      if ( SRecipeInfo.ChargeMoment > 0.0 )
      {
        setCHARGE_MOMENT(SRecipeInfo.ChargeMoment);
      }

      RetValue = RetValue && update();
    }


    if ( !RetValue )
    {
      Error = getLastError();
    }

    if(Commit)
    {
      if ( RetValue ) 
      {
        commit();
      }
      else
      {
        rollback();
      }
    }
  }

  return RetValue;

}


bool CPD_RECIPE::updateRecipeData(const std::string& HeatID, const std::string& TreatID, const std::string& Plant, sRecipeInfo &SRecipeInfo, sMetTimeStamp &MetTimeStamp, seqBatchPrio &SeqBatchPrio, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool RetValue = false;

  if ( select(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, SRecipeInfo.RecipeStatus) )
  {
    CDateTime now;
    double ActWeightTotal  = 0.0;
    double COSTSBATCH      = 0.0;
    double BULKVOL         = 0.0;
    double VOLUME          = 0.0;

    double WEIGHTTOTAL     = getWEIGHTTOTAL(1);

    //insert each entry into PD_RECIPE_ENTRY, sometimes do update
    for (int j=0;j < CIntfData::getLength(SeqBatchPrio); j++)
    {
      sBatchPrio BatchPrio;
      CIntfData::getAt(BatchPrio,&SeqBatchPrio,j);

      log("Handling Material " + (std::string)BatchPrio.BatchData.MatCode,2);

      // check PD_RECIPE_ENTRY
      if ( m_pPD_RECIPE_ENTRY->select(HeatID, TreatID, Plant,
        SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, 
        SRecipeInfo.RecipeStatus, (std::string)BatchPrio.BatchData.MatCode) )
      {
        // we expect existing entry in PD_RECIPE_ENTRY
        // status DEF_GC_RECIPE_STATUS::Weighed could appear several times
        if (SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::Weighed)
        {
          // do not perform commit
          m_pPD_RECIPE_ENTRY->addMatWeight(HeatID, TreatID, Plant,
            SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, 
            SRecipeInfo.RecipeStatus, (std::string)BatchPrio.BatchData.MatCode, BatchPrio.BatchData.Mass, false, m_lastError);
        }
        else
        {
          // do not perform commit
          m_pPD_RECIPE_ENTRY->updateData(HeatID, TreatID, Plant,
            SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, 
            SRecipeInfo.RecipeStatus, (std::string)BatchPrio.BatchData.MatCode, BatchPrio.BatchData.Mass, BatchPrio.ChargPrio, false, m_lastError);
          // set UPDTIME in case of material data update
          setUPDTIME(now);
        }
      }
      else
      {
        // may be entry in PD_RECIPE_ENTRY does not exist !
        // do not perform commit
        RetValue = m_pPD_RECIPE_ENTRY->insertRecipeEntry(HeatID,TreatID,Plant,SRecipeInfo,SeqBatchPrio, false, m_lastError);
      }
    } // for (int j=0;j < CIntfData::getLength(SeqBatchPrio); j++)

    //set corresponding price, density and volume
    ActWeightTotal = setCalculatedValues(SeqBatchPrio);

    if ( SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::Calculated )
    {
      if ( getCHARGE_MOMENT(1) == CSMC_DBData::unspecDouble )
      {
        if ( SRecipeInfo.ChargeMoment > 0.0 )
        {
          setCHARGE_MOMENT(SRecipeInfo.ChargeMoment);
        }
      }
    }

    if ( SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::Weighed          || 
         SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::WeighingComplete ||
         SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::DischargeStart)
    {
      if ( getDISCHARGESTARTTIME(1) == CSMC_DBData::unspecDate )
      {
        setDISCHARGESTARTTIME(now);
      }
    }
    
    if ( SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::DischargeStart )
    {
      // set metallurgical moments / energy only in case of charging start

      //set corresponding gas moment. valid gas types O2,Ar,N2
      setGasInfo(MetTimeStamp.O2_Moment, MetTimeStamp.Ar_Moment, MetTimeStamp.N2_Moment);
    
      if ( ActWeightTotal > WEIGHTTOTAL || getACT_EGY(1) == CSMC_DBData::unspecDouble )
      {
        //set corresponding energy
        setACT_EGY(MetTimeStamp.Elec_Moment);
      }

    }

    if (SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::Discharged)
    {
      setCHARGING_DEST_NAME( SRecipeInfo.RecipeTarget );

      if ( ActWeightTotal > WEIGHTTOTAL || getDISCHARGEENDTIME(1) == CSMC_DBData::unspecDate )
      {
        setDISCHARGEENDTIME( now );

        // calculate feeding data
        setCalculatedFeedingValues(getDISCHARGESTARTTIME(1), now, ActWeightTotal);
      }
      else
      {
        setCalculatedFeedingValues(getDISCHARGESTARTTIME(1), now, WEIGHTTOTAL);
      }
    }

    RetValue = update();

    if ( !RetValue )
    {
      Error = getLastError();
    }

    if(Commit)
    {
      if ( RetValue ) 
      {
        commit();
      }
      else
      {
        rollback();
      }
    }
  }

  return RetValue;

}

// inserting or updating batch data
// recipe data will be inserted
// according to Status data will be updated
// most actual recipe will be stored in status "Final"
bool CPD_RECIPE::writeBatch(const std::string& HeatID, const std::string& TreatID, const std::string& Plant, sRecipeInfo &SRecipeInfo, sMetTimeStamp &MetTimeStamp, seqBatch &SeqBatch, bool Commit, cCBS_ODBC_DBError &Error)
{
  seqBatchPrio SeqBatchPrio;

  for (long i = 0 ; i < CIntfData::getLength(SeqBatch) ; ++i)
  {
    sBatchPrio BatchPrio;
    sBatch Batch;

    CIntfData::getAt(Batch,&SeqBatch,i);

    BatchPrio.BatchData = Batch;

    // find BatchPrio 
    if ( m_pPD_RECIPE_ENTRY->select(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, DEF_GC_RECIPE_STATUS::Calculated, std::string(Batch.MatCode) ) )
    {
      BatchPrio.ChargPrio = m_pPD_RECIPE_ENTRY->getCHARGINGPRIO(1);
    }
    else
    {
      BatchPrio.ChargPrio = 1;
    }

    CIntfData::insert(SeqBatchPrio,BatchPrio);
  }

  return writeBatchPrio(HeatID, TreatID, Plant, SRecipeInfo, MetTimeStamp, SeqBatchPrio, Commit, Error);
}

bool CPD_RECIPE::writeBatchPrio(const std::string& HeatID, const std::string& TreatID,const std::string& Plant, sRecipeInfo &SRecipeInfo, sMetTimeStamp &MetTimeStamp, seqBatchPrio &SeqBatchPrio, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool RetValue = false;
  CDateTime now;  

  // we don't want any commit until procedure is finished!

  try
  {
    // insert new data
    if ( ! select(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, SRecipeInfo.RecipeStatus) )
    {
      RetValue = insertRecipeData(HeatID, TreatID, Plant, SRecipeInfo, MetTimeStamp, SeqBatchPrio, false, Error);

      // insert may fail due to empty SeqBatchPrio
      // SeqBatchPrio is empty if no data from L1 are available for discharged materials (start or stop)
      // -> we take over materials from WeighingComplete
      if ( !RetValue )
      {
        if( SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::DischargeStart ||
            SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::Discharged )
        {
          RetValue = copyDataToBatchStatus(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, DEF_GC_RECIPE_STATUS::WeighingComplete, SRecipeInfo.RecipeStatus, false, Error );
        }
      }

      if( SRecipeInfo.RecipeStatus == DEF_GC_RECIPE_STATUS::Weighed )
      {
        // copy existing data with status DEF_GC_RECIPE_STATUS::Weighed to DEF_GC_RECIPE_STATUS::Final
        RetValue = RetValue && copyDataToFinalBatchStatus(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, DEF_GC_RECIPE_STATUS::Weighed, false, Error);
	    }
    }
    // following data will be updated if required
    else
    {
      //do corresponding work according to status.
      switch (SRecipeInfo.RecipeStatus)
      {
      case DEF_GC_RECIPE_STATUS::Calculated:
      case DEF_GC_RECIPE_STATUS::Enabled:
      case DEF_GC_RECIPE_STATUS::Final:
          RetValue = updateRecipeData(HeatID, TreatID, Plant, SRecipeInfo, MetTimeStamp, SeqBatchPrio, false, Error);
          break;

      case DEF_GC_RECIPE_STATUS::Weighed:
          // removing existing data here for DEF_GC_RECIPE_STATUS::Discharged
          // removeRecipeData does not perform commit !
          removeRecipeData(HeatID,TreatID,Plant,SRecipeInfo.RecipeName,SRecipeInfo.RecipeNo,SRecipeInfo.RecipeSource,DEF_GC_RECIPE_STATUS::Discharged, false, Error);

          //recipe DEF_GC_RECIPE_STATUS::Weighed may appear several times, material masses will be added
          RetValue = updateRecipeData(HeatID, TreatID, Plant, SRecipeInfo, MetTimeStamp, SeqBatchPrio, false, Error);

          // copy existing data with status DEF_GC_RECIPE_STATUS::Weighed to DEF_GC_RECIPE_STATUS::Final
          RetValue = RetValue && copyDataToFinalBatchStatus(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, DEF_GC_RECIPE_STATUS::Weighed, false, Error);

          break;

      case DEF_GC_RECIPE_STATUS::WeighingComplete:
          //removing existing data for DEF_GC_RECIPE_STATUS::Discharged
          // removeRecipeData does not perform commit !
          removeRecipeData(HeatID,TreatID,Plant,SRecipeInfo.RecipeName,SRecipeInfo.RecipeNo,SRecipeInfo.RecipeSource,DEF_GC_RECIPE_STATUS::Discharged, false, Error);

          RetValue = updateRecipeData(HeatID, TreatID, Plant, SRecipeInfo, MetTimeStamp, SeqBatchPrio, false, Error);

          // copy existing data with status DEF_GC_RECIPE_STATUS::WeighingComplete to DEF_GC_RECIPE_STATUS::Final
          RetValue = RetValue && copyDataToFinalBatchStatus(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, DEF_GC_RECIPE_STATUS::WeighingComplete, false, Error);
          break;


      case DEF_GC_RECIPE_STATUS::DischargeStart:
          //updates DISCHARGESTARTTIME and calculates feeding values
          RetValue = updateRecipeData(HeatID, TreatID, Plant, SRecipeInfo, MetTimeStamp, SeqBatchPrio, false, Error);
          break;

      case DEF_GC_RECIPE_STATUS::WeighingCompleteUpdate:
          //removing existing data for DEF_GC_RECIPE_STATUS::DischargeStart
          // removeRecipeData does not perform commit !
          removeRecipeData(HeatID,TreatID,Plant,SRecipeInfo.RecipeName,SRecipeInfo.RecipeNo,SRecipeInfo.RecipeSource,DEF_GC_RECIPE_STATUS::DischargeStart, false, Error);
          //removing existing data for DEF_GC_RECIPE_STATUS::Discharged
          // removeRecipeData does not perform commit !
          removeRecipeData(HeatID,TreatID,Plant,SRecipeInfo.RecipeName,SRecipeInfo.RecipeNo,SRecipeInfo.RecipeSource,DEF_GC_RECIPE_STATUS::Discharged, false, Error);

          RetValue = updateRecipeData(HeatID, TreatID, Plant, SRecipeInfo, MetTimeStamp, SeqBatchPrio, false, Error);

          RetValue = RetValue && copyDataToFinalBatchStatus(HeatID, TreatID, Plant, SRecipeInfo.RecipeName, SRecipeInfo.RecipeNo, SRecipeInfo.RecipeSource, DEF_GC_RECIPE_STATUS::WeighingCompleteUpdate, false, Error);
          break;

      case DEF_GC_RECIPE_STATUS::Discharged:
          //updates DISCHARGEENDTIME 
          RetValue = updateRecipeData(HeatID, TreatID, Plant, SRecipeInfo, MetTimeStamp, SeqBatchPrio, false, Error);
          break;

      case DEF_GC_RECIPE_STATUS::Disabled:
          // removes all entries except DEF_GC_RECIPE_STATUS::Disabled and DEF_GC_RECIPE_STATUS::Calculated
          RetValue = cleanRecipeData(HeatID,TreatID,Plant,SRecipeInfo.RecipeName,SRecipeInfo.RecipeNo,SRecipeInfo.RecipeSource, false, Error);
          break;

      case DEF_GC_RECIPE_STATUS::FirstMaterialInChargingHopper:
      case DEF_GC_RECIPE_STATUS::ProcessingStart:
      case DEF_GC_RECIPE_STATUS::LastMaterialInChargingHopper:
          break;
      default: //unknown status
        ;
      } //switch
    } // if (RetValue)

    if ( !RetValue )
    {
      Error = getLastError();
      logLastError(1);
    }

    if(Commit)
    {
      if ( RetValue ) 
      {
        commit();
      }
      else
      {
        rollback();
      }
    }

  }
  catch (cCBS_DBExc &e) // db catch
  {
    cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ExceptionCaught(sMessage,(e.getText()).c_str(),
      "createStatement()",
      "writing data to table PD_RECIPE and PD_RECIPE_ENTRY ??");

    RetValue = false;
  }

  return RetValue;
}


