//## Copyright (C) 2010 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "iSMC_DataDefinitions_s.hh"
#include "CIntfData.h"
#include "CDataConversion.h"
#include "DEF_GC_STIRR_GAS_TYPE.h"
#include "DEF_GCE_BURNER_GASTYPE.h"
#include "CPDE_HEAT_DATA_MELT.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPDE_HEAT_DATA_MELT::HEATID("HEATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPDE_HEAT_DATA_MELT::TREATID("TREATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPDE_HEAT_DATA_MELT::PLANT("PLANT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPDE_HEAT_DATA_MELT::PHASE("PHASE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPDE_HEAT_DATA_MELT::STARTTIME("STARTTIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPDE_HEAT_DATA_MELT::ENDTIME("ENDTIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPDE_HEAT_DATA_MELT::DURATION("DURATION");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPDE_HEAT_DATA_MELT::ELEC_CONS("ELEC_CONS");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPDE_HEAT_DATA_MELT::LANCE_O2_CONS("LANCE_O2_CONS");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPDE_HEAT_DATA_MELT::LANCE_N2_CONS("LANCE_N2_CONS");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPDE_HEAT_DATA_MELT::STIRR_N2_CONS("STIRR_N2_CONS");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPDE_HEAT_DATA_MELT::STIRR_AR_CONS("STIRR_AR_CONS");

//##DBClassCodeUtility ! DO NOT EDIT !
CPDE_HEAT_DATA_MELT::CPDE_HEAT_DATA_MELT(cCBS_StdConnection* Connection)
:CSMC_DBData("PDE_HEAT_DATA_MELT",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPDE_HEAT_DATA_MELT::CPDE_HEAT_DATA_MELT(cCBS_Connection* Connection)
:CSMC_DBData("PDE_HEAT_DATA_MELT",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPDE_HEAT_DATA_MELT::CPDE_HEAT_DATA_MELT()
:CSMC_DBData("PDE_HEAT_DATA_MELT")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPDE_HEAT_DATA_MELT::~CPDE_HEAT_DATA_MELT()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
std::string CPDE_HEAT_DATA_MELT::getHEATID(long Row)
{
  return getString(CPDE_HEAT_DATA_MELT::HEATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPDE_HEAT_DATA_MELT::setHEATID(const std::string& value)
{
  setString(CPDE_HEAT_DATA_MELT::HEATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
std::string CPDE_HEAT_DATA_MELT::getTREATID(long Row)
{
  return getString(CPDE_HEAT_DATA_MELT::TREATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPDE_HEAT_DATA_MELT::setTREATID(const std::string& value)
{
  setString(CPDE_HEAT_DATA_MELT::TREATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
std::string CPDE_HEAT_DATA_MELT::getPLANT(long Row)
{
  return getString(CPDE_HEAT_DATA_MELT::PLANT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPDE_HEAT_DATA_MELT::setPLANT(const std::string& value)
{
  setString(CPDE_HEAT_DATA_MELT::PLANT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
std::string CPDE_HEAT_DATA_MELT::getPHASE(long Row)
{
  return getString(CPDE_HEAT_DATA_MELT::PHASE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPDE_HEAT_DATA_MELT::setPHASE(const std::string& value)
{
  setString(CPDE_HEAT_DATA_MELT::PHASE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
CDateTime CPDE_HEAT_DATA_MELT::getSTARTTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPDE_HEAT_DATA_MELT::STARTTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPDE_HEAT_DATA_MELT::setSTARTTIME(const CDateTime& value)
{
 setString(CPDE_HEAT_DATA_MELT::STARTTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
CDateTime CPDE_HEAT_DATA_MELT::getENDTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPDE_HEAT_DATA_MELT::ENDTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPDE_HEAT_DATA_MELT::setENDTIME(const CDateTime& value)
{
 setString(CPDE_HEAT_DATA_MELT::ENDTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
double CPDE_HEAT_DATA_MELT::getDURATION(long Row)
{
  return getDouble(CPDE_HEAT_DATA_MELT::DURATION, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPDE_HEAT_DATA_MELT::setDURATION(double value)
{
  setDouble(CPDE_HEAT_DATA_MELT::DURATION, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
double CPDE_HEAT_DATA_MELT::getELEC_CONS(long Row)
{
  return getDouble(CPDE_HEAT_DATA_MELT::ELEC_CONS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPDE_HEAT_DATA_MELT::setELEC_CONS(double value)
{
  setDouble(CPDE_HEAT_DATA_MELT::ELEC_CONS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
double CPDE_HEAT_DATA_MELT::getLANCE_O2_CONS(long Row)
{
  return getDouble(CPDE_HEAT_DATA_MELT::LANCE_O2_CONS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPDE_HEAT_DATA_MELT::setLANCE_O2_CONS(double value)
{
  setDouble(CPDE_HEAT_DATA_MELT::LANCE_O2_CONS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
double CPDE_HEAT_DATA_MELT::getLANCE_N2_CONS(long Row)
{
  return getDouble(CPDE_HEAT_DATA_MELT::LANCE_N2_CONS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPDE_HEAT_DATA_MELT::setLANCE_N2_CONS(double value)
{
  setDouble(CPDE_HEAT_DATA_MELT::LANCE_N2_CONS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
double CPDE_HEAT_DATA_MELT::getSTIRR_N2_CONS(long Row)
{
  return getDouble(CPDE_HEAT_DATA_MELT::STIRR_N2_CONS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPDE_HEAT_DATA_MELT::setSTIRR_N2_CONS(double value)
{
  setDouble(CPDE_HEAT_DATA_MELT::STIRR_N2_CONS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
double CPDE_HEAT_DATA_MELT::getSTIRR_AR_CONS(long Row)
{
  return getDouble(CPDE_HEAT_DATA_MELT::STIRR_AR_CONS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPDE_HEAT_DATA_MELT::setSTIRR_AR_CONS(double value)
{
  setDouble(CPDE_HEAT_DATA_MELT::STIRR_AR_CONS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPDE_HEAT_DATA_MELT::select(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& PHASE, const CDateTime& STARTTIME)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPDE_HEAT_DATA_MELT::HEATID,HEATID);
  addWhereClause(CPDE_HEAT_DATA_MELT::TREATID,TREATID);
  addWhereClause(CPDE_HEAT_DATA_MELT::PLANT,PLANT);
  addWhereClause(CPDE_HEAT_DATA_MELT::PHASE,PHASE);
  addWhereClause(CPDE_HEAT_DATA_MELT::STARTTIME,STARTTIME);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CPDE_HEAT_DATA_MELT::selectOrderedByTime(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& PHASE)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPDE_HEAT_DATA_MELT::HEATID,HEATID);
  addWhereClause(CPDE_HEAT_DATA_MELT::TREATID,TREATID);
  addWhereClause(CPDE_HEAT_DATA_MELT::PLANT,PLANT);
  addWhereClause(CPDE_HEAT_DATA_MELT::PHASE,PHASE);

  m_Statement += getWhereStatement() + " ORDER BY STARTTIME;";

  return CSMC_DBData::select();
}

// select time record
bool CPDE_HEAT_DATA_MELT::selectRecordByTime(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const CDateTime& STARTTIME, const CDateTime& ENDTIME, bool ASC /* = true*/)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPDE_HEAT_DATA_MELT::HEATID,HEATID);
  addWhereClause(CPDE_HEAT_DATA_MELT::TREATID,TREATID);
  addWhereClause(CPDE_HEAT_DATA_MELT::PLANT,PLANT);

  addWhereClause(CPDE_HEAT_DATA_MELT::STARTTIME,STARTTIME,">=");
  addWhereClause(CPDE_HEAT_DATA_MELT::ENDTIME,ENDTIME,"<=");

  if ( ASC )
  {
    m_Statement += getWhereStatement() + " ORDER BY STARTTIME ;";
  }
  else
  {
    m_Statement += getWhereStatement() + " ORDER BY STARTTIME DESC;";
  }

  return CSMC_DBData::select();
}

bool CPDE_HEAT_DATA_MELT::deletePhases(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
  bool RetValue = false;

  if ( select(HEATID,TREATID,PLANT,CSMC_DBData::unspecString,CSMC_DBData::unspecDate) )
  {
    RetValue = deleteRows();

    if  ( RetValue )
    {
      commit();
    }
    else
    {
      rollback();
    }
  }

  return RetValue;
}

double CPDE_HEAT_DATA_MELT::getPowerOffDur(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, CDateTime& STARTTIME, CDateTime& ENDTIME)
{
  double PowerOffDur = 0.;

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPDE_HEAT_DATA_MELT::HEATID,HEATID);
  addWhereClause(CPDE_HEAT_DATA_MELT::TREATID,TREATID);
  addWhereClause(CPDE_HEAT_DATA_MELT::PLANT,PLANT);
  addWhereClause(CPDE_HEAT_DATA_MELT::STARTTIME,ENDTIME,"<=");

  std::string EndTimeClause = " ( ENDTIME >= '" + STARTTIME.toDBString() + "' OR ENDTIME is NULL ) " ;

  addWhereClause(EndTimeClause);

  m_Statement += getWhereStatement() + " ORDER BY STARTTIME ;";

  if ( CSMC_DBData::select() )
  {
    double PowerOnDur = 0.;
    CDateTime Now;
    CDateTime FirstPowerOn(CDateTime::InvalidDateTime());
    CDateTime LastPowerOff(CDateTime::InvalidDateTime());

    // we are regarding the following situations

    // Power Phases             **********|******* ********      *****|*******
    // (S)tartTime/(E)ndTime              S                           E
    // PowerOnTimes                       ++++++++ ++++++++      ++++++ 
    // PowerOffTimes                              +        ++++++ 

    for ( long i = 1 ; i <= getLastRow(); ++i )
    {
      CDateTime StoredStartTime = getSTARTTIME(i);
      CDateTime StoredEndTime   = getENDTIME(i);

      if ( STARTTIME != CSMC_DBData::unspecDate && StoredStartTime < STARTTIME )
      {
        StoredStartTime = STARTTIME;
      }

      if ( StoredEndTime == CSMC_DBData::unspecDate )
      {
        StoredEndTime = Now;
      }
      else  if ( ENDTIME != CSMC_DBData::unspecDate && StoredEndTime > ENDTIME )
      {
        StoredEndTime = ENDTIME;
      }

      if ( StoredStartTime > StoredEndTime )
      {
        StoredStartTime = StoredEndTime;
      }

      if ( FirstPowerOn == CDateTime::InvalidDateTime() )
      {
        FirstPowerOn = StoredStartTime;
      }

      LastPowerOff = StoredEndTime;

      CDeltaTime DiffTimePowerOn    = CDateTime::subTimes(StoredEndTime,StoredStartTime);
      CDeltaTime DiffTimePowerTotal = CDateTime::subTimes(LastPowerOff,FirstPowerOn);

      PowerOnDur += DiffTimePowerOn.asSeconds() / 60;

      PowerOffDur = DiffTimePowerTotal.asSeconds() / 60;
      PowerOffDur = PowerOffDur - PowerOnDur;
    }
  }

  return PowerOffDur;
}

double CPDE_HEAT_DATA_MELT::getPowerOnDur(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, CDateTime& STARTTIME, CDateTime& ENDTIME)
{
  double PowerOnDur = 0.;

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPDE_HEAT_DATA_MELT::HEATID,HEATID);
  addWhereClause(CPDE_HEAT_DATA_MELT::TREATID,TREATID);
  addWhereClause(CPDE_HEAT_DATA_MELT::PLANT,PLANT);
  addWhereClause(CPDE_HEAT_DATA_MELT::STARTTIME,ENDTIME,"<=");

  std::string EndTimeClause = " ( ENDTIME >= '" + STARTTIME.toDBString() + "' OR ENDTIME is NULL ) " ;

  addWhereClause(EndTimeClause);

  m_Statement += getWhereStatement() + " ORDER BY STARTTIME ;";

  if ( CSMC_DBData::select() )
  {
    CDateTime Now;

    // we are regarding the following situations

    // Power Phases             **********|******* ********      *****|*******
    // (S)tartTime/(E)ndTime              S                           E
    // PowerOnTimes                       ++++++++ ++++++++      ++++++ 

    for ( long i = 1 ; i <= getLastRow(); ++i )
    {
      CDateTime StoredStartTime = getSTARTTIME(i);
      CDateTime StoredEndTime   = getENDTIME(i);

      if ( STARTTIME != CSMC_DBData::unspecDate && StoredStartTime < STARTTIME )
      {
        StoredStartTime = STARTTIME;
      }

      if ( StoredEndTime == CSMC_DBData::unspecDate )
      {
        StoredEndTime = Now;
      }
      else  if ( ENDTIME != CSMC_DBData::unspecDate && StoredEndTime > ENDTIME )
      {
        StoredEndTime = ENDTIME;
      }

      if ( StoredStartTime > StoredEndTime )
      {
        StoredStartTime = StoredEndTime;
      }

      CDeltaTime DiffTime = CDateTime::subTimes(StoredEndTime,StoredStartTime);

      PowerOnDur += DiffTime.asSeconds() / 60;
    }
  }

  return PowerOnDur;
}

bool CPDE_HEAT_DATA_MELT::isPhaseStarted(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT,const std::string& PHASE)
{
  bool RetValue = false;

  try
  {
    if ( selectOrderedByTime(HEATID,TREATID,PLANT,PHASE) )
    {
      // find first phase in chronological order that is started but not ended
      for ( long  i = 1 ; i <= getLastRow() ; ++ i )
      {
        CDateTime STARTTIME = getSTARTTIME(i);
        CDateTime ENDTIME   = getENDTIME(i);

        if ( STARTTIME == CSMC_DBData::unspecDate && ENDTIME != CSMC_DBData::unspecDate )
        {
          RetValue = true;
          break;
        }
      }
    }
  }
  catch(...)
  {
    RetValue = false;
  }
  
  return RetValue;
}

bool CPDE_HEAT_DATA_MELT::savePhaseDataReport(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT,const sPhaseDataReport PhaseDataReport)
{
  bool retValue = false;
  CDateTime StartTime;
  StartTime.SetTime(PhaseDataReport.StartTime);

  CDateTime EndTime;
  EndTime.SetTime(PhaseDataReport.EndTime);

  long PhaseNo          = PhaseDataReport.PhaseNo;
  std::string PhaseName = PhaseDataReport.PhaseName;

  if(PhaseNo > 0) //it means figure out Meltdown 1,2,3 etc.
  {
    PhaseName += CDataConversion::IntToString(PhaseNo);
  }

  bool isDataExist = select(HEATID,TREATID,PLANT,PhaseName,StartTime);

  setHEATID(HEATID);
  setTREATID(TREATID);
  setPLANT(PLANT);
  setPHASE(PhaseName);
  setSTARTTIME(StartTime);
  setENDTIME(EndTime);
  setDURATION(PhaseDataReport.Duration);
  setELEC_CONS(PhaseDataReport.ElecCons);


  long deviceDataLength = CIntfData::getLength(PhaseDataReport.GasCons);
  for (int i = 0 ; i < deviceDataLength ; ++i)
  {
    sDeviceGasData deviceGasData;
    CIntfData::getAt(deviceGasData,PhaseDataReport.GasCons,i);

    long GasDataLength = CIntfData::getLength(deviceGasData.GasData);
    for(int j = 0 ;j<GasDataLength;j++ )
    {
      sGasData gasData;
      CIntfData::getAt(gasData,&deviceGasData.GasData,j);
      if(deviceGasData.Device == DEF_DEVICES::Burner)
      {     
        if( std::string(gasData.GasType) == DEF_GCE_BURNER_GASTYPE::O2 )
        {
          setLANCE_O2_CONS(gasData.GasValue);
        }
        else if( std::string(gasData.GasType) == DEF_GCE_BURNER_GASTYPE::N2 )
        {
          setLANCE_N2_CONS(gasData.GasValue);
        }

      } 
      else if( deviceGasData.Device = DEF_DEVICES::TopLance)
      {
        if( std::string(gasData.GasType) == DEF_GC_STIRR_GAS_TYPE::Ar )
        {
          setSTIRR_AR_CONS(gasData.GasValue);
        }
        else if( std::string(gasData.GasType) == DEF_GC_STIRR_GAS_TYPE::N2 )
        {
          setSTIRR_N2_CONS(gasData.GasValue);
        }
      }
    }
  }

  if(isDataExist)
    retValue = update();
  else 
    retValue = insert();

  if(retValue)
    commit();
  else
    rollback();

  return true;
}

bool CPDE_HEAT_DATA_MELT::writeData(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& PHASE, const CDateTime& STARTTIME, const CDateTime& ENDTIME, double DURATION, double ELEC_CONS, seqGasData& StirrAmount)
{
  bool  RetValue  = false;

  try
  {
    {
      setHEATID(HEATID);
      setTREATID(TREATID);
      setPLANT(PLANT);
      setPHASE(PHASE);
      setSTARTTIME(STARTTIME);

      // set other data here
      setENDTIME(ENDTIME);
      setDURATION(DURATION);
      setELEC_CONS(ELEC_CONS);

      double Stirr_AR_Cons = 0.0;
      double Stirr_N2_Cons = 0.0;

      // extract AR and N2 amount from Stirring data
      for ( long i = 0 ; i < CIntfData::getLength(StirrAmount); ++i )
      {
        sGasData GasData;
        CIntfData::getAt(GasData,StirrAmount,i);

        if ( std::string(GasData.GasType) == DEF_GC_STIRR_GAS_TYPE::Ar) 
        {
          Stirr_AR_Cons = GasData.GasValue;
        }
        else if ( std::string(GasData.GasType) == DEF_GC_STIRR_GAS_TYPE::N2) 
        {
          Stirr_N2_Cons = GasData.GasValue;
        }
      }

      setSTIRR_AR_CONS(Stirr_AR_Cons);
      setSTIRR_N2_CONS(Stirr_N2_Cons);

      if (select(HEATID, TREATID, PLANT, PHASE, STARTTIME))
      {
        // data sets must only be updated if End_Time has changed !!!!
        CDateTime StoredEndTime = getENDTIME(1);

        if ( ENDTIME != StoredEndTime )
        {
          RetValue = update();
        }
        else
        {
          log("no update due to equivalent end_times",2);
        }
      }
      else
      {
        RetValue = insert();
      }
    }

    // commit only if own values  are successfully written
    if (RetValue)
    {
      commit();
    }
    else
    {
      rollback();
    }
  }
  catch(...)
  {
    RetValue = false;
    rollback();
  }
  return RetValue;
}

bool CPDE_HEAT_DATA_MELT::writeDataOnPhaseEnd(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT,const std::string& PHASE, double ELEC_CONS)
{
  bool  RetValue  = false;

  try
  {
    if ( selectOrderedByTime(HEATID, TREATID, PLANT, CSMC_DBData::unspecString) )
    {
      // find first phase in chronological order that is started but not ended
      for ( long  i = 1 ; i <= getLastRow() ; ++ i )
      {
        CDateTime STARTTIME   = getSTARTTIME(i);
        CDateTime ENDTIME     = getENDTIME(i);

        double StoredElecCons     = getELEC_CONS(i);

        if ( STARTTIME != CSMC_DBData::unspecDate && ENDTIME == CSMC_DBData::unspecDate )
        {
          CDateTime EndTime;

          CDeltaTime DiffTime = CDateTime::subTimes(EndTime,STARTTIME);

          // calculate diff values
          double Duration = DiffTime.asSeconds() / 60;

          if ( ELEC_CONS > StoredElecCons )
          {
            ELEC_CONS = ELEC_CONS - StoredElecCons;
          }

          // find the correct dataset !
          if ( select (HEATID,TREATID,PLANT,getPHASE(i),STARTTIME) )
          { 
            if ( PHASE != CSMC_DBData::unspecString && !PHASE.empty() )
            {
              setPHASE(PHASE);
            }

            setENDTIME(EndTime);
            setDURATION(Duration);
            setELEC_CONS(ELEC_CONS);

            RetValue = update();

            // commit only if own values  are successfully written
            if (RetValue)
            {
              commit();
            }
            else
            {
              rollback();
            }
          }

          break;
        }
      }
    }
  }
  catch(...)
  {
    RetValue = false;
    rollback();
  }
  return RetValue;
}

bool CPDE_HEAT_DATA_MELT::writeDataOnPhaseStart(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT,const std::string& PHASE, double ELEC_CONS)
{
  bool  RetValue  = false;

  try
  {
    CDateTime StartTime;

    setHEATID(HEATID);
    setTREATID(TREATID);
    setPLANT(PLANT);
    setPHASE(PHASE);

    setSTARTTIME(StartTime);

    setELEC_CONS(ELEC_CONS);

    if (select(HEATID, TREATID, PLANT, PHASE, StartTime))
    {
      RetValue = update();
    }
    else
    {
      RetValue = insert();
    }

    // commit only if own values  are successfully written
    if (RetValue)
    {
      commit();
    }
    else
    {
      rollback();
    }
  }
  catch(...)
  {
    RetValue = false;
    rollback();
  }
  return RetValue;
}


