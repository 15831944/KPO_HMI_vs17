//## Copyright (C) 2009 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 

#include "cCBS_StdEventLogFrameController.h"
#include "CGC_SCRAP_CONTAINER.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGC_SCRAP_CONTAINER::CONTAINERNO("CONTAINERNO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGC_SCRAP_CONTAINER::CONTAINERTYPE("CONTAINERTYPE");

//##DBClassCodeUtility ! DO NOT EDIT !
CGC_SCRAP_CONTAINER::CGC_SCRAP_CONTAINER(cCBS_StdConnection* Connection)
:CSMC_DBData("GC_SCRAP_CONTAINER",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CGC_SCRAP_CONTAINER::CGC_SCRAP_CONTAINER(cCBS_Connection* Connection)
:CSMC_DBData("GC_SCRAP_CONTAINER",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CGC_SCRAP_CONTAINER::CGC_SCRAP_CONTAINER()
:CSMC_DBData("GC_SCRAP_CONTAINER")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CGC_SCRAP_CONTAINER::~CGC_SCRAP_CONTAINER()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique identification number
long CGC_SCRAP_CONTAINER::getCONTAINERNO(long Row)
{
  return getLong(CGC_SCRAP_CONTAINER::CONTAINERNO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGC_SCRAP_CONTAINER::setCONTAINERNO(long value)
{
  setLong(CGC_SCRAP_CONTAINER::CONTAINERNO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##basket or chute
std::string CGC_SCRAP_CONTAINER::getCONTAINERTYPE(long Row)
{
  return getString(CGC_SCRAP_CONTAINER::CONTAINERTYPE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGC_SCRAP_CONTAINER::setCONTAINERTYPE(const std::string& value)
{
  setString(CGC_SCRAP_CONTAINER::CONTAINERTYPE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CGC_SCRAP_CONTAINER::select(long CONTAINERNO, const std::string& CONTAINERTYPE)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CGC_SCRAP_CONTAINER::CONTAINERNO,CONTAINERNO);
  addWhereClause(CGC_SCRAP_CONTAINER::CONTAINERTYPE,CONTAINERTYPE);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 


bool CGC_SCRAP_CONTAINER::isValidContainer(long CONTAINERNO, const std::string& CONTAINERTYPE)
{
  bool RetValue = false;

  // invalid data may not be checked againt GC table -> we will proceed with programm
  // this will force setting database field to NULL in most cases
  
  if ( CONTAINERNO   == CSMC_DBData::unspecLong && 
       CONTAINERTYPE == CSMC_DBData::unspecString )
  {
    RetValue = true;
  }
  else
  {
    RetValue = select(CONTAINERNO, CONTAINERTYPE);

    if ( !RetValue )
    {
      std::stringstream Message;
      Message << "Undefined Container Detected " << CONTAINERTYPE << CONTAINERNO ;

		  cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
		  sEventLogMessage sMessage = cCBS_StdEventLogFrame::initMessage(__FILE__,__LINE__);
      pEventLog->EL_DBReadError(sMessage,"", m_TableName.c_str(), Message.str().c_str());
    }
  }

  return RetValue;

}
