//## Copyright (C) 2009 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "CPD_DELAYS.h"
#include "CHD_DELAYS.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_DELAYS::PLANT("PLANT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_DELAYS::PLANTNO("PLANTNO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_DELAYS::CODE("CODE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_DELAYS::DELAYSTART("DELAYSTART");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_DELAYS::EXPIRATIONDATE("EXPIRATIONDATE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_DELAYS::HEATID("HEATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_DELAYS::HM_ID("HM_ID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_DELAYS::TREATID("TREATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_DELAYS::DELAYEND("DELAYEND");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_DELAYS::USERCODE("USERCODE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_DELAYS::COMMENT_OPERATOR("COMMENT_OPERATOR");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_DELAYS::REVTIME("REVTIME");

//##DBClassCodeUtility ! DO NOT EDIT !
CHD_DELAYS::CHD_DELAYS(cCBS_StdConnection* Connection)
:CSMC_DBData("HD_DELAYS",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CHD_DELAYS::CHD_DELAYS(cCBS_Connection* Connection)
:CSMC_DBData("HD_DELAYS",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CHD_DELAYS::CHD_DELAYS()
:CSMC_DBData("HD_DELAYS")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CHD_DELAYS::~CHD_DELAYS()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant identifier
std::string CHD_DELAYS::getPLANT(long Row)
{
  return getString(CHD_DELAYS::PLANT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_DELAYS::setPLANT(const std::string& value)
{
  setString(CHD_DELAYS::PLANT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant number
long CHD_DELAYS::getPLANTNO(long Row)
{
  return getLong(CHD_DELAYS::PLANTNO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_DELAYS::setPLANTNO(long value)
{
  setLong(CHD_DELAYS::PLANTNO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Delay code
std::string CHD_DELAYS::getCODE(long Row)
{
  return getString(CHD_DELAYS::CODE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_DELAYS::setCODE(const std::string& value)
{
  setString(CHD_DELAYS::CODE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Timestamp of delay start
CDateTime CHD_DELAYS::getDELAYSTART(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_DELAYS::DELAYSTART, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_DELAYS::setDELAYSTART(const CDateTime& value)
{
 setString(CHD_DELAYS::DELAYSTART, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
CDateTime CHD_DELAYS::getEXPIRATIONDATE(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_DELAYS::EXPIRATIONDATE, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_DELAYS::setEXPIRATIONDATE(const CDateTime& value)
{
 setString(CHD_DELAYS::EXPIRATIONDATE, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##It is possible that a delay cannot be assigned to a heat/treat , so we have no FK to HD_HEAT_DATA
std::string CHD_DELAYS::getHEATID(long Row)
{
  return getString(CHD_DELAYS::HEATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_DELAYS::setHEATID(const std::string& value)
{
  setString(CHD_DELAYS::HEATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Internal identifier for Desulphurisation station
std::string CHD_DELAYS::getHM_ID(long Row)
{
  return getString(CHD_DELAYS::HM_ID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_DELAYS::setHM_ID(const std::string& value)
{
  setString(CHD_DELAYS::HM_ID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment identifier
std::string CHD_DELAYS::getTREATID(long Row)
{
  return getString(CHD_DELAYS::TREATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_DELAYS::setTREATID(const std::string& value)
{
  setString(CHD_DELAYS::TREATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Timestamp of delay end
CDateTime CHD_DELAYS::getDELAYEND(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_DELAYS::DELAYEND, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_DELAYS::setDELAYEND(const CDateTime& value)
{
 setString(CHD_DELAYS::DELAYEND, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
std::string CHD_DELAYS::getUSERCODE(long Row)
{
  return getString(CHD_DELAYS::USERCODE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_DELAYS::setUSERCODE(const std::string& value)
{
  setString(CHD_DELAYS::USERCODE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Option at Delay-dialog for entering operator comments
std::string CHD_DELAYS::getCOMMENT_OPERATOR(long Row)
{
  return getString(CHD_DELAYS::COMMENT_OPERATOR, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_DELAYS::setCOMMENT_OPERATOR(const std::string& value)
{
  setString(CHD_DELAYS::COMMENT_OPERATOR, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Date and time of last revision
CDateTime CHD_DELAYS::getREVTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_DELAYS::REVTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_DELAYS::setREVTIME(const CDateTime& value)
{
 setString(CHD_DELAYS::REVTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CHD_DELAYS::select(const std::string& PLANT, long PLANTNO, const std::string& CODE, const CDateTime& DELAYSTART)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CHD_DELAYS::PLANT,PLANT);
  addWhereClause(CHD_DELAYS::PLANTNO,PLANTNO);
  addWhereClause(CHD_DELAYS::CODE,CODE);
  addWhereClause(CHD_DELAYS::DELAYSTART,DELAYSTART);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CHD_DELAYS::copy(const std::string& PLANT, long PLANTNO, bool Commit, cCBS_ODBC_DBError &Error)
{
	bool result = !exists(PLANT, PLANTNO);
	//some data found -> delete them
	if (!result)
	{
		result = deleteRows();
		if (!result)
			setLastError(std::string("ERROR_DELETE_DATA"), 0, getActStatement());
	}

  // preparing setting for source table
  CPD_DELAYS PD_DELAYS(m_pCBS_StdConnection);
  PD_DELAYS.addWhereClause(CPD_DELAYS::PLANT,PLANT);
  PD_DELAYS.addWhereClause(CPD_DELAYS::PLANTNO,PLANTNO);

  result = result && copyByInsert(&PD_DELAYS);

	if (!result)
		Error = getLastError();

	if(Commit)
	{
		if (result)
			this->commit();
		else
			rollback();
	}

	return result;
}

bool CHD_DELAYS::exists(const std::string& PLANT, long PLANTNO)
{
	cleanWhereStatement();

	m_Statement = "Select PLANT from " + m_TableName;

	addWhereClause(CHD_DELAYS::PLANT,PLANT);
	addWhereClause(CHD_DELAYS::PLANTNO,PLANTNO);
   
  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }

	return CSMC_DBData::select();
}

bool CHD_DELAYS::copy_HMD(const string& pPlant, long pPlantNo, bool pCommit, cCBS_ODBC_DBError &pError)
{
	bool result = !exists(pPlant, pPlantNo);
	std::stringstream sql;
	//some data found -> delete them
	if (!result)
	{
		result = deleteRows();
		if (!result)
			setLastError(string("delete from HD_DELAYS faild"), 0, "delete from HD_DELAYS where " + getWhereStatement());
	}

	sql << "insert into HD_DELAYS"
		<< "  (PLANT, PLANTNO, CODE, DELAYSTART, EXPIRATIONDATE, HM_ID, TREATID,"
		<< "  DELAYEND, USERCODE, COMMENT_OPERATOR, REVTIME)"
		<< " (select PLANT, PLANTNO, CODE, DELAYSTART, EXPIRATIONDATE, HM_ID, TREATID,"
		<< "   DELAYEND, USERCODE, COMMENT_OPERATOR, REVTIME"
		<< " from PD_DELAYS"
		<< " where PLANT = '" << pPlant << "'"
		<< "   and PLANTNO = " << pPlantNo << ")";

	result = result && executeSQL(sql.str());
	if (!result)
		pError = getLastError();

	if(pCommit)
	{
		if (result)
			this->commit();
		else
			rollback();
	}

	return result;
}

