//## Copyright (C) 2010 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "CSMC_EventLogFrameController.h"
#include "CPD_DELAYS.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_DELAYS::PLANT("PLANT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_DELAYS::PLANTNO("PLANTNO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_DELAYS::CODE("CODE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_DELAYS::DELAYSTART("DELAYSTART");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_DELAYS::EXPIRATIONDATE("EXPIRATIONDATE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_DELAYS::HEATID("HEATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_DELAYS::HM_ID("HM_ID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_DELAYS::TREATID("TREATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_DELAYS::DELAYEND("DELAYEND");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_DELAYS::USERCODE("USERCODE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_DELAYS::COMMENT_OPERATOR("COMMENT_OPERATOR");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPD_DELAYS::REVTIME("REVTIME");

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_DELAYS::CPD_DELAYS(cCBS_StdConnection* Connection)
:CSMC_DBData("PD_DELAYS",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_DELAYS::CPD_DELAYS(cCBS_Connection* Connection)
:CSMC_DBData("PD_DELAYS",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_DELAYS::CPD_DELAYS()
:CSMC_DBData("PD_DELAYS")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPD_DELAYS::~CPD_DELAYS()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant identifier
std::string CPD_DELAYS::getPLANT(long Row)
{
  return getString(CPD_DELAYS::PLANT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_DELAYS::setPLANT(const std::string& value)
{
  setString(CPD_DELAYS::PLANT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant number
long CPD_DELAYS::getPLANTNO(long Row)
{
  return getLong(CPD_DELAYS::PLANTNO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_DELAYS::setPLANTNO(long value)
{
  setLong(CPD_DELAYS::PLANTNO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Delay code
std::string CPD_DELAYS::getCODE(long Row)
{
  return getString(CPD_DELAYS::CODE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_DELAYS::setCODE(const std::string& value)
{
  setString(CPD_DELAYS::CODE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Timestamp of delay start
CDateTime CPD_DELAYS::getDELAYSTART(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_DELAYS::DELAYSTART, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_DELAYS::setDELAYSTART(const CDateTime& value)
{
 setString(CPD_DELAYS::DELAYSTART, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Entry as real DATETIME indicates that the delay was deleted by operator
CDateTime CPD_DELAYS::getEXPIRATIONDATE(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_DELAYS::EXPIRATIONDATE, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_DELAYS::setEXPIRATIONDATE(const CDateTime& value)
{
 setString(CPD_DELAYS::EXPIRATIONDATE, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##It is possible that a delay cannot be assigned to a heat/treat , so we have no FK to PD_HEAT_DATA
std::string CPD_DELAYS::getHEATID(long Row)
{
  return getString(CPD_DELAYS::HEATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_DELAYS::setHEATID(const std::string& value)
{
  setString(CPD_DELAYS::HEATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Internal identifier for Desulphurisation station
std::string CPD_DELAYS::getHM_ID(long Row)
{
  return getString(CPD_DELAYS::HM_ID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_DELAYS::setHM_ID(const std::string& value)
{
  setString(CPD_DELAYS::HM_ID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment identifier
std::string CPD_DELAYS::getTREATID(long Row)
{
  return getString(CPD_DELAYS::TREATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_DELAYS::setTREATID(const std::string& value)
{
  setString(CPD_DELAYS::TREATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Timestamp of delay end
CDateTime CPD_DELAYS::getDELAYEND(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_DELAYS::DELAYEND, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_DELAYS::setDELAYEND(const CDateTime& value)
{
 setString(CPD_DELAYS::DELAYEND, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
std::string CPD_DELAYS::getUSERCODE(long Row)
{
  return getString(CPD_DELAYS::USERCODE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_DELAYS::setUSERCODE(const std::string& value)
{
  setString(CPD_DELAYS::USERCODE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Option at Delay-dialog for entering operator comments
std::string CPD_DELAYS::getCOMMENT_OPERATOR(long Row)
{
  return getString(CPD_DELAYS::COMMENT_OPERATOR, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_DELAYS::setCOMMENT_OPERATOR(const std::string& value)
{
  setString(CPD_DELAYS::COMMENT_OPERATOR, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Date and time of last revision
CDateTime CPD_DELAYS::getREVTIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPD_DELAYS::REVTIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPD_DELAYS::setREVTIME(const CDateTime& value)
{
 setString(CPD_DELAYS::REVTIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPD_DELAYS::select(const std::string& PLANT, long PLANTNO, const std::string& CODE, const CDateTime& DELAYSTART)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPD_DELAYS::PLANT,PLANT);
  addWhereClause(CPD_DELAYS::PLANTNO,PLANTNO);
  addWhereClause(CPD_DELAYS::CODE,CODE);
  addWhereClause(CPD_DELAYS::DELAYSTART,DELAYSTART);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CPD_DELAYS::selectLatestDelayByHeat(const std::string& PLANT, long PLANTNO, const std::string& HEATID, const std::string& TREATID)
{
	cleanWhereStatement();

	m_Statement = "Select * from " + m_TableName;

	std::stringstream stringplantno;
	stringplantno << PLANTNO ;

	addWhereClause(CPD_DELAYS::PLANT,PLANT);
	addWhereClause(CPD_DELAYS::PLANTNO,PLANTNO);
	addWhereClause(CPD_DELAYS::HEATID,HEATID);
	addWhereClause(CPD_DELAYS::TREATID,TREATID);
  addWhereClause("DELAYSTART = (select max(DELAYSTART) from PD_DELAYS where PLANT = '" + PLANT + "' and PLANTNO = " + stringplantno.str() + " and HEATID = '" + HEATID + "' and TREATID = '" + TREATID + "' )");
		
  m_Statement += getWhereStatement() + ";";

	return CSMC_DBData::select();
}

bool CPD_DELAYS::selectValid(const std::string& PLANT, long PLANTNO, const std::string& CODE, const CDateTime &DELAYSTART)
{
	cleanWhereStatement();

	m_Statement = "Select * from " + m_TableName;

	addWhereClause(CPD_DELAYS::PLANT,PLANT);
	addWhereClause(CPD_DELAYS::PLANTNO,PLANTNO);
	addWhereClause(CPD_DELAYS::CODE,CODE);
	addWhereClause(CPD_DELAYS::DELAYSTART,DELAYSTART);
  addWhereClause(CPD_DELAYS::EXPIRATIONDATE+ " is NULL");
	
  m_Statement += getWhereStatement() + ";";

	return CSMC_DBData::select();
}

bool CPD_DELAYS::deleteByDelayStart(const std::string& PLANT, long PLANTNO, const std::string& CODE, const CDateTime& DELAYSTART)
{
  cleanWhereStatement();
  addWhereClause(CPD_DELAYS::PLANT,PLANT);
  addWhereClause(CPD_DELAYS::PLANTNO,PLANTNO);
  addWhereClause(CPD_DELAYS::CODE,CODE);  
  addWhereClause(CPD_DELAYS::DELAYSTART,DELAYSTART);

  return deleteRows();
}

bool CPD_DELAYS::deleteByStartTime(CDateTime& OlderThan)
{
  bool RetValue = false;

	cleanWhereStatement();

  if (OlderThan != CSMC_DBData::unspecDate)
  {
    addWhereClause(CPD_DELAYS::DELAYSTART, OlderThan,"<=");

    m_Statement = "Select * from " + m_TableName;
    m_Statement += getWhereStatement() + ";";

    if (CSMC_DBData::select())
    {
      long NoRows = getLastRow();
      log("INFO: Try to delete entries in PD_DELAYS older than " + OlderThan.toDBString(),3);

      m_Statement = "Delete " + m_TableName;
      m_Statement += getWhereStatement() + ";";

      std::stringstream Message;
      if (CSMC_DBData::deleteRows())
      {
        Message << "INFO: Deleted '" << NoRows << "' rows";
        log(Message.str(),3);
        RetValue = true;
      }
      else
      {
        Message << "ERROR: Delete rows in PD_DELAYS older than " << OlderThan.toDBString();
        log(Message.str(),1);
      }
    }
    else
      log("INFO: Clean up PD_DELAYS not necessary. No rows older than " + OlderThan.toDBString(),3);
  }
  else
    log("ERROR: CPD_DELAYS::deleteByStartTime not possible: unspecified date!",1);

  return RetValue;

}

bool CPD_DELAYS::deleteDelay(const std::string& PLANT, long PLANTNO, const std::string& CODE, const CDateTime& DELAYSTART)
{
  cleanWhereStatement();

  addWhereClause(CPD_DELAYS::PLANT,PLANT);
  addWhereClause(CPD_DELAYS::PLANTNO,PLANTNO);
  addWhereClause(CPD_DELAYS::CODE,CODE);  
  addWhereClause(CPD_DELAYS::DELAYSTART,DELAYSTART);

  return deleteRows();
}

bool CPD_DELAYS::exist_auto( const std::string& PLANT, long PLANTNO,const std::string& HEATID,const std::string& TREATID )
{
  bool RetValue = false;

	CDateTime Now;

  m_Statement = "Select CODE from " + m_TableName;

  if( HEATID == "" || TREATID == "" )
  {
	  addWhereClause(CPD_DELAYS::PLANT,PLANT);
	  addWhereClause(CPD_DELAYS::PLANTNO,PLANTNO);
	  addWhereClause(CPD_DELAYS::EXPIRATIONDATE + " is NULL");
    addWhereClause("(DELAYEND is NULL OR DELAYEND > '" + Now.toDBString() + "')");
  }
  else
  {
	  addWhereClause(CPD_DELAYS::PLANT,PLANT);
	  addWhereClause(CPD_DELAYS::PLANTNO,PLANTNO);
	  addWhereClause(CPD_DELAYS::HEATID,HEATID);
	  addWhereClause(CPD_DELAYS::TREATID,TREATID);
	  addWhereClause(CPD_DELAYS::EXPIRATIONDATE + "is NULL");
    addWhereClause("(DELAYEND is NULL OR DELAYEND > '" + Now.toDBString() + "')");
  }

  // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
  m_Statement += getWhereStatement() + " AND ROWNUM = 1 ;";

  return CSMC_DBData::select();
}

bool CPD_DELAYS::exists(const std::string& PLANT, long PLANTNO, const std::string& CODE, const CDateTime &DELAYSTART, const CDateTime &EXPIRATIONDATE)
{
	cleanWhereStatement();

	m_Statement = "Select PLANT from " + m_TableName;

	addWhereClause(CPD_DELAYS::PLANT,PLANT);
	addWhereClause(CPD_DELAYS::PLANTNO,PLANTNO);
	addWhereClause(CPD_DELAYS::CODE,CODE);
	addWhereClause(CPD_DELAYS::DELAYSTART,DELAYSTART);
	addWhereClause(CPD_DELAYS::EXPIRATIONDATE,EXPIRATIONDATE);
   
  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }

	return CSMC_DBData::select();
}

bool CPD_DELAYS::expireDelay(const std::string &PLANT, long PLANTNO, const std::string &CODE, CDateTime &DELAYSTART, const std::string &USERCODE, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool RetValue = true;

  if ( selectValid(PLANT, PLANTNO, CODE, DELAYSTART) )
  {
    CDateTime Now;

    setUSERCODE         (USERCODE);
    setEXPIRATIONDATE   (Now);
    setREVTIME          (Now);

    RetValue = RetValue && update();    
  }

  if (!RetValue)
    Error = getLastError();

  if (Commit)
  {
    if (RetValue)
      commit();
    else
      rollback();
  }

  return RetValue;
}

bool CPD_DELAYS::fillAutoEndTimeByEvents( const std::string& PLANT, long PLANTNO,const std::string& HEATID,const std::string& TREATID,const std::string& User,bool& bNeedAuto, bool Commit, cCBS_ODBC_DBError &Error)
{
    bool RetValue = false;

	std::stringstream sql;
	
	//check if Endtime is not NULL
	CDateTime tmEnd;

    //detected if exists and update it
    if( !exist_auto( PLANT,PLANTNO,HEATID,TREATID)  )
    {
      return true;
    }

    bNeedAuto = true;

	if( User == DEF::Inv_String )
	{
       if( HEATID == "" || TREATID == "" )
       {
	      sql << "update PD_DELAYS  set DELAYEND = '"
		      << tmEnd.toDBString() << "' where plant = '"
	          << PLANT << "' and Plantno = " << PLANTNO
		      << " and EXPIRATIONDATE is NULL and (delayend is null or DELAYEND > '"
		      << tmEnd.toDBString()
		      << "')";
       }
       else
       {
	      sql << "update PD_DELAYS  set DELAYEND = '"
		      << tmEnd.toDBString() << "' where plant = '"
	          << PLANT << "' and Plantno = " << PLANTNO
		      << " and Heatid = '"
		      << HEATID << "' and Treatid = '"
		      << TREATID << "'"
		      << "and EXPIRATIONDATE is NULL and (delayend is null or DELAYEND > '"
		      << tmEnd.toDBString()
		      << "')";
       }
	}
    else
	{
      if(  HEATID == "" || TREATID == "" )
      {
	    sql << "update PD_DELAYS  set DELAYEND = '"
		    << tmEnd.toDBString() << "',USERCODE = '"
		    << User << "' where plant = '"
	        << PLANT << "' and Plantno = " << PLANTNO
		    << " and EXPIRATIONDATE is NULL and (delayend is null or DELAYEND > '"
		    << tmEnd.toDBString()
		    << "')";
      }
      else
      {
	    sql << "update PD_DELAYS  set DELAYEND = '"
		    << tmEnd.toDBString() << "',USERCODE = '"
		    << User << "' where plant = '"
	        << PLANT << "' and Plantno = " << PLANTNO
		    << " and EXPIRATIONDATE is NULL and (delayend is null or DELAYEND > '"
		    << tmEnd.toDBString()
		    << "')";
      }
	}

	bool result = executeSQL(sql.str());

	if (Commit)
	{
		commit();
	}
	return result;
}

bool CPD_DELAYS::updateOrInsert(const std::string &HEATID, const std::string &TREATID, const std::string &PLANT, long PLANTNO, const std::string &CODE, CDateTime &DELAYSTART, CDateTime &DELAYEND, const std::string &USERCODE, const std::string &COMMENT, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool RetValue = true;

  
  if ( selectValid(PLANT, PLANTNO, CODE, DELAYSTART) )
  {
    setHEATID           (HEATID);
    setTREATID          (TREATID);
    setDELAYEND         (DELAYEND);
    setUSERCODE         (USERCODE);
    setCOMMENT_OPERATOR (COMMENT);

    setREVTIME (CDateTime());

    RetValue = RetValue && update();    
  }
  else if ( select(PLANT, PLANTNO, CODE, DELAYSTART) )
  {
    setHEATID           (HEATID);
    setTREATID          (TREATID);
    setDELAYEND         (DELAYEND);
    setUSERCODE         (USERCODE);
    setCOMMENT_OPERATOR (COMMENT);

    setREVTIME (CDateTime());

    setEXPIRATIONDATE   (CSMC_DBData::unspecDate);

    RetValue = RetValue && update();

    if ( RetValue )
    {
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ResettingData(sMessage,"PD_DELAYS.EXPIRATIONDATE to NULL",HEATID.c_str(),TREATID.c_str(),PLANT.c_str());
    }
  }
  else
  {
    setPLANT            (PLANT);
    setPLANTNO          (PLANTNO);
    setCODE             (CODE);
    setDELAYSTART       (DELAYSTART);
    setHEATID           (HEATID);
    setTREATID          (TREATID);
    setDELAYEND         (DELAYEND);
    setUSERCODE         (USERCODE);
    setCOMMENT_OPERATOR (COMMENT);

    setREVTIME (CDateTime());

    RetValue = RetValue && insert();
  }

  if (!RetValue)
    Error = getLastError();

  if (Commit)
  {
    if (RetValue)
      commit();
    else
      rollback();
  }

  return RetValue;
}


bool CPD_DELAYS::updateOrInsertHMD(const std::string &HEATID, const std::string &TREATID, const std::string &PLANT, long PLANTNO, const std::string &CODE, CDateTime &DELAYSTART, CDateTime &DELAYEND, const std::string &USERCODE, const std::string &COMMENT, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool RetValue = true;

  
  if ( selectValid(PLANT, PLANTNO, CODE, DELAYSTART) )
  {
    setHM_ID            (HEATID);
    setTREATID          (TREATID);
    setDELAYEND         (DELAYEND);
    setUSERCODE         (USERCODE);
    setCOMMENT_OPERATOR (COMMENT);

    setREVTIME (CDateTime());

    RetValue = RetValue && update();    
  }
  else if ( select(PLANT, PLANTNO, CODE, DELAYSTART) )
  {
    setHM_ID            (HEATID);
    setTREATID          (TREATID);
    setDELAYEND         (DELAYEND);
    setUSERCODE         (USERCODE);
    setCOMMENT_OPERATOR (COMMENT);

    setREVTIME (CDateTime());

    setEXPIRATIONDATE   (CSMC_DBData::unspecDate);

    RetValue = RetValue && update();

    if ( RetValue )
    {
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_ResettingData(sMessage,"PD_DELAYS.EXPIRATIONDATE to NULL",HEATID.c_str(),TREATID.c_str(),PLANT.c_str());
    }
  }
  else
  {
    setPLANT            (PLANT);
    setPLANTNO          (PLANTNO);
    setCODE             (CODE);
    setDELAYSTART       (DELAYSTART);
    setHM_ID            (HEATID);
    setTREATID          (TREATID);
    setDELAYEND         (DELAYEND);
    setUSERCODE         (USERCODE);
    setCOMMENT_OPERATOR (COMMENT);

    setREVTIME (CDateTime());

    RetValue = RetValue && insert();
  }

  if (!RetValue)
    Error = getLastError();

  if (Commit)
  {
    if (RetValue)
      commit();
    else
      rollback();
  }

  return RetValue;
}



