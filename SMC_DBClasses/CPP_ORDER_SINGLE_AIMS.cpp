//## Copyright (C) 2009 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "CDataConversion.h"
#include "DEF_GC_PP_ORDER_SINGLE_AIMS.h"
#include "CGC_PP_ORDER_SINGLE_AIMS.h"
#include "CPP_ORDER_SINGLE_AIMS.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_ORDER_SINGLE_AIMS::PRODORDERID("PRODORDERID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_ORDER_SINGLE_AIMS::PLANT("PLANT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_ORDER_SINGLE_AIMS::TYPE("TYPE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_ORDER_SINGLE_AIMS::VARNAME("VARNAME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_ORDER_SINGLE_AIMS::VALUE("VALUE");

//##DBClassCodeUtility ! DO NOT EDIT !
CPP_ORDER_SINGLE_AIMS::CPP_ORDER_SINGLE_AIMS(cCBS_StdConnection* Connection)
:CSMC_DBData("PP_ORDER_SINGLE_AIMS",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPP_ORDER_SINGLE_AIMS::CPP_ORDER_SINGLE_AIMS(cCBS_Connection* Connection)
:CSMC_DBData("PP_ORDER_SINGLE_AIMS",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPP_ORDER_SINGLE_AIMS::CPP_ORDER_SINGLE_AIMS()
:CSMC_DBData("PP_ORDER_SINGLE_AIMS")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPP_ORDER_SINGLE_AIMS::~CPP_ORDER_SINGLE_AIMS()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Production oder identification
std::string CPP_ORDER_SINGLE_AIMS::getPRODORDERID(long Row)
{
  return getString(CPP_ORDER_SINGLE_AIMS::PRODORDERID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_ORDER_SINGLE_AIMS::setPRODORDERID(const std::string& value)
{
  setString(CPP_ORDER_SINGLE_AIMS::PRODORDERID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant identifier
std::string CPP_ORDER_SINGLE_AIMS::getPLANT(long Row)
{
  return getString(CPP_ORDER_SINGLE_AIMS::PLANT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_ORDER_SINGLE_AIMS::setPLANT(const std::string& value)
{
  setString(CPP_ORDER_SINGLE_AIMS::PLANT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Specifies data type of value. 1=long, 2=double,3=string
long CPP_ORDER_SINGLE_AIMS::getTYPE(long Row)
{
  return getLong(CPP_ORDER_SINGLE_AIMS::TYPE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_ORDER_SINGLE_AIMS::setTYPE(long value)
{
  setLong(CPP_ORDER_SINGLE_AIMS::TYPE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
std::string CPP_ORDER_SINGLE_AIMS::getVARNAME(long Row)
{
  return getString(CPP_ORDER_SINGLE_AIMS::VARNAME, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_ORDER_SINGLE_AIMS::setVARNAME(const std::string& value)
{
  setString(CPP_ORDER_SINGLE_AIMS::VARNAME, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Character representation of VALUE, conversion to be done depending on TYPE
std::string CPP_ORDER_SINGLE_AIMS::getVALUE(long Row)
{
  return getString(CPP_ORDER_SINGLE_AIMS::VALUE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_ORDER_SINGLE_AIMS::setVALUE(const std::string& value)
{
  setString(CPP_ORDER_SINGLE_AIMS::VALUE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPP_ORDER_SINGLE_AIMS::select(const std::string& PRODORDERID, const std::string& PLANT, long TYPE, const std::string& VARNAME)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_ORDER_SINGLE_AIMS::PRODORDERID,PRODORDERID);
  addWhereClause(CPP_ORDER_SINGLE_AIMS::PLANT,PLANT);
  addWhereClause(CPP_ORDER_SINGLE_AIMS::TYPE,TYPE);
  addWhereClause(CPP_ORDER_SINGLE_AIMS::VARNAME,VARNAME);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CPP_ORDER_SINGLE_AIMS::deletePP(const std::string& PRODORDERID, const std::string& PLANT, std::string& VARNAME, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = true;
  //Check if order exists
  if (exists(PRODORDERID, PLANT, VARNAME))
  {
    result = CSMC_DBData::deleteRows();

    if (!result)
      Error = getLastError();

    if (Commit)
    {
      if (result)
        commit();
      else
        rollback();
    }
  }
  return result;
}

void CPP_ORDER_SINGLE_AIMS::doOnConstruct()
{
  m_pGC_PP_ORDER_SINGLE_AIMS        = new CGC_PP_ORDER_SINGLE_AIMS( m_pCBS_StdConnection );
}

void CPP_ORDER_SINGLE_AIMS::doOnDestruct()
{
  if ( m_pGC_PP_ORDER_SINGLE_AIMS )  { delete m_pGC_PP_ORDER_SINGLE_AIMS; m_pGC_PP_ORDER_SINGLE_AIMS = 0; }
}

bool CPP_ORDER_SINGLE_AIMS::exists(const std::string& PRODORDERID, const std::string& PLANT, const std::string& VARNAME)
{
  cleanWhereStatement();

  m_Statement = "Select PRODORDERID from " + m_TableName;

  addWhereClause(CPP_ORDER_SINGLE_AIMS::PRODORDERID,PRODORDERID);
  addWhereClause(CPP_ORDER_SINGLE_AIMS::PLANT,PLANT);
  addWhereClause(CPP_ORDER_SINGLE_AIMS::VARNAME,VARNAME);
   
  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }

  return CSMC_DBData::select();
}

bool CPP_ORDER_SINGLE_AIMS::updateInsertPP(const std::string& PRODORDERID, const std::string& PLANT, const std::string& VARNAME, const std::string VALUE, bool Commit, cCBS_ODBC_DBError &Error)
{
  bool result = true;
  long TYPE = m_pGC_PP_ORDER_SINGLE_AIMS->getTypeDirectly(PLANT, VARNAME);

  if( TYPE != CSMC_DBData::unspecLong )
  {
    if( VALUE != CSMC_DBData::unspecString )
    {
  
      //Check if order exists
      if ( select(PRODORDERID, PLANT, TYPE, VARNAME) )
      {
        setVALUE(VALUE);

         //Order exists -> update
        result = CSMC_DBData::update();
      }
      else
      {
        setPRODORDERID(PRODORDERID);
        setPLANT(PLANT);

        setTYPE(TYPE);
        setVARNAME(VARNAME);
        setVALUE(VALUE);

        result = CSMC_DBData::insert();
      }
    }
    else
    {
      CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
      sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
      pEventLog->EL_DBWriteInfo(sMessage,"VALUE", m_TableName.c_str(),"cannot write NULL value");
    }
  }
  else
  {
    std::stringstream SearchKey;
    SearchKey << PLANT << " ," << VARNAME;
    CSMC_EventLogFrame *pEventLog = CSMC_EventLogFrameController::getInstance()->getpEventLog();
    sEventLogMessage sMessage = cCBS_StdEventLog::initMessage(__FILE__,__LINE__);
    pEventLog->EL_ErrorSearchingData(sMessage,SearchKey.str().c_str(),"GC_PP_ORDER_SINGLE_AIMS");
  }

  if (!result)
    Error = getLastError();

  if (Commit)
  {
    if (result)
      commit();
    else
      rollback();
  }
  
  return result;
}


