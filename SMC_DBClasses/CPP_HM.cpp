//## Copyright (C) 2013 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "CPP_HM.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HM::HM_ID("HM_ID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HM::PRODORDERID("PRODORDERID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HM::PLANTNO("PLANTNO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HM::HM_ID_CUST_PLAN("HM_ID_CUST_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HM::TREATSTART_PLAN("TREATSTART_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HM::TREATEND_PLAN("TREATEND_PLAN");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HM::PLANNED("PLANNED");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HM::ON_REQUEST("ON_REQUEST");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HM::HOTMETAL_COUNTER("HOTMETAL_COUNTER");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HM::LADLEFREEBOARD("LADLEFREEBOARD");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CPP_HM::AIM_S("AIM_S");



//##DBClassCodeUtility ! DO NOT EDIT !
CPP_HM::CPP_HM(cCBS_StdConnection* Connection)
:CSMC_DBData("PP_HM",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPP_HM::CPP_HM(cCBS_Connection* Connection)
:CSMC_DBData("PP_HM",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPP_HM::CPP_HM()
:CSMC_DBData("PP_HM")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CPP_HM::~CPP_HM()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
std::string CPP_HM::getHM_ID(long Row)
{
  return getString(CPP_HM::HM_ID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HM::setHM_ID(const std::string& value)
{
  setString(CPP_HM::HM_ID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
std::string CPP_HM::getPRODORDERID(long Row)
{
  return getString(CPP_HM::PRODORDERID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HM::setPRODORDERID(const std::string& value)
{
  setString(CPP_HM::PRODORDERID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
long CPP_HM::getPLANTNO(long Row)
{
  return getLong(CPP_HM::PLANTNO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HM::setPLANTNO(long value)
{
  setLong(CPP_HM::PLANTNO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
std::string CPP_HM::getHM_ID_CUST_PLAN(long Row)
{
  return getString(CPP_HM::HM_ID_CUST_PLAN, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HM::setHM_ID_CUST_PLAN(const std::string& value)
{
  setString(CPP_HM::HM_ID_CUST_PLAN, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
CDateTime CPP_HM::getTREATSTART_PLAN(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPP_HM::TREATSTART_PLAN, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HM::setTREATSTART_PLAN(const CDateTime& value)
{
 setString(CPP_HM::TREATSTART_PLAN, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
CDateTime CPP_HM::getTREATEND_PLAN(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CPP_HM::TREATEND_PLAN, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HM::setTREATEND_PLAN(const CDateTime& value)
{
 setString(CPP_HM::TREATEND_PLAN, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
long CPP_HM::getPLANNED(long Row)
{
  return getLong(CPP_HM::PLANNED, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HM::setPLANNED(long value)
{
  setLong(CPP_HM::PLANNED, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
long CPP_HM::getON_REQUEST(long Row)
{
  return getLong(CPP_HM::ON_REQUEST, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HM::setON_REQUEST(long value)
{
  setLong(CPP_HM::ON_REQUEST, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
long CPP_HM::getHOTMETAL_COUNTER(long Row)
{
  return getLong(CPP_HM::HOTMETAL_COUNTER, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HM::setHOTMETAL_COUNTER(long value)
{
  setLong(CPP_HM::HOTMETAL_COUNTER, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
long CPP_HM::getLADLEFREEBOARD(long Row)
{
  return getLong(CPP_HM::LADLEFREEBOARD, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HM::setLADLEFREEBOARD(long value)
{
  setLong(CPP_HM::LADLEFREEBOARD, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
double CPP_HM::getAIM_S(long Row)
{
  return getDouble(CPP_HM::AIM_S, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CPP_HM::setAIM_S(double value)
{
  setDouble(CPP_HM::AIM_S, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPP_HM::select(const std::string& HM_ID)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HM::HM_ID,HM_ID);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CPP_HM::doAnnouncement(const std::string& pHMID, const std::string& pPRODORDERID, long pPLANTNo,long pONREQUEST, long pHMCOUNTER)
{
  bool retValue=true;

  try
  {
		if(!exists(pHMID,pPRODORDERID,pPLANTNo))
		{
			//SATK 02012012
			setPLANNED(0);
			setPLANTNO(pPLANTNo);
			
			setPRODORDERID(pPRODORDERID);
			cleanWhereStatement();
			addWhereClause("HM_ID",pHMID);
			retValue=update();
			retValue=true;


		}
		else
		{
			setPLANNED(0);			
			setPRODORDERID(pPRODORDERID);
			cleanWhereStatement();
			addWhereClause("HM_ID",pHMID);
			addWhereClause("PLANTNO",pPLANTNo);//SATK 02012012
			retValue=update();
		}
    // commit only if own values are successfully written
    if (retValue)
    {
      commit();
    }
    else
    {
      rollback();
      log("ERROR: CPP_HM::doAnnouncement failed",1);
    }
  }
  catch(...)
  {
    retValue = false;
  }
  return retValue;
}
bool CPP_HM::doCancelHeat(const std::string& pHMID, const std::string& pPRODORDERID, long pPLANTNo)
{
	bool result;
  std::stringstream sql;
	try
	{
	sql << "update PP_HM set " 
			<< "PLANNED = 1 "
			<< "where HM_ID = '" << pHMID << "' "
			<< "and PLANTNO = " << pPLANTNo  ;

	result = executeSQL(sql.str());
	if (result)
    {
      commit();
    }
    else
    {
      rollback();
      log("ERROR: CPP_HM::doCancelHeat failed",1);
    }
	}
	catch(...)
	{
		result=false;
	}

	return result;
}
bool CPP_HM::exists(const std::string& pHMID, const std::string& pPRODORDERID, long pPLANTNo)
{
	cleanWhereStatement();

	m_Statement = "Select count(*) as DATA_EXISTS from " + m_TableName;

	addWhereClause("HM_ID",pHMID);
	addWhereClause("PLANTNO",pPLANTNo);
	m_Statement += getWhereStatement() + ";";

  CSMC_DBData::select();

	bool result = false;

  if (getLong("DATA_EXISTS", 1) > 0)
  {
    result = true;
  }
	
  return result;
}

bool CPP_HM::existsDesignHeatID(const std::string& pHM_ID_CUST_PLAN)
{
	cleanWhereStatement();

	m_Statement = "Select count(*) as DATA_EXISTS from " + m_TableName;

	addWhereClause("HM_ID_CUST_PLAN",pHM_ID_CUST_PLAN);
	m_Statement += getWhereStatement() + ";";

  CSMC_DBData::select();

	bool result = false;

  if (getLong("DATA_EXISTS", 1) > 0)
  {
    result = true;
  }
	
  return result;
}
bool CPP_HM::selectHMCounter(const std::string& pHM_ID_CUST_PLAN)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause("PRODORDERID",pHM_ID_CUST_PLAN);
	addWhereClause("HOTMETAL_COUNTER","0");
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}
bool CPP_HM::updateHMCounter(const std::string& pHM_ID_CUST_PLAN)
{
bool result;
  std::stringstream sql;
	try
	{
	sql << "update PP_HM set " 
			<< "HOTMETAL_COUNTER = (select max(HOTMETAL_COUNTER) from PD_HOT_METAL)  "
			<< "where PRODORDERID = '" << pHM_ID_CUST_PLAN << "'";
			

	result = executeSQL(sql.str());
	if (result)
    {
      commit();
    }
    else
    {
      rollback();
      log("ERROR: CPP_HM::updateHMCounter failed",1);
    }
	}
	catch(...)
	{
		result=false;
	}

	return result;
}
bool CPP_HM::selectOrderId(std::string& HM_ID)
{
  	bool result;
  std::stringstream sql;
	try
	{
	sql << "select * from PP_HM " 
			<< "where HM_ID = '" << HM_ID << "' ";

	result = executeSQL(sql.str());
	if (result)
    {
      commit();
    }
    else
    {
      rollback();
      log("ERROR: CPP_HM::selectOrderId failed",1);
    }
	}
	catch(...)
	{
		result=false;
	}

	return result;;
}
bool CPP_HM::select_ProdOrderId(const std::string& HM_ID)
{
  cleanWhereStatement();

  m_Statement = "Select nvl(PRODORDERID, '') as PRODORDERID from " + m_TableName;

  addWhereClause("HM_ID",HM_ID);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}
bool CPP_HM::updateHMCounter(const std::string& pHM_ID_CUST_PLAN, long pHmcounter)
{
bool result;
  std::stringstream sql;
	try
	{
	sql << "update PP_HM set " 
			<< "HOTMETAL_COUNTER =  " << pHmcounter << " "
			<< "where PRODORDERID = '" << pHM_ID_CUST_PLAN << "'";
			

	result = executeSQL(sql.str());
	if (result)
    {
      commit();
    }
    else
    {
      rollback();
      log("ERROR: CPP_HM::updateHMCounter failed",1);
    }
	}
	catch(...)
	{
		result=false;
	}

	return result;
}
bool CPP_HM::Exists_HM_Id(const std::string& PRODORDERID)
{
  cleanWhereStatement();

  m_Statement = "Select HM_ID from " + m_TableName;

  addWhereClause("PRODORDERID",PRODORDERID);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
  }
bool CPP_HM::Insert_Schedule(const std::string& PRODORDERID,long HM_COUNTER)
{
	bool result;
	CDateTime now;
	std::stringstream sql;
	try
	{

	sql << "insert into PP_HM(HM_ID,PRODORDERID,TREATSTART_PLAN,TREATEND_PLAN,PLANTNO, PLANNED, ON_REQUEST,HOTMETAL_COUNTER) " 
		<< " values "
		<< "((select 'H'||lpad((select (substr(max(HM_ID),2,6)+1) from PP_HM),5,'0') from dual),'"
		<< PRODORDERID << "','"
		<< now.toDBString() << "',null,1,1,1,"
		<< HM_COUNTER  << ")";
					

	result = executeSQL(sql.str());
	if (result)
    {
      commit();
    }
    else
    {
      rollback();
      log("ERROR: CPP_HM::Insert_Schedule failed",1);
    }
	}
	catch(...)
	{
		result=false;
	}

	return result;
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CPP_HM::select_orderid(const std::string& HM_ID)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause("PRODORDERID",HM_ID);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CPP_HM::selectInternalID(const std::string& HM_ID_CUST_PLAN)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CPP_HM::HM_ID_CUST_PLAN,HM_ID_CUST_PLAN);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CPP_HM::getMaxHMID(string &pHMId, cCBS_ODBC_DBError &pError)
{
	std::stringstream sql;
	sql << "select TO_CHAR(MAX(TO_NUMBER(DECODE(HM_ID,NULL,'0',HM_ID)))) as HM_ID from PP_HM;";
	m_Statement = sql.str();
	bool result = CSMC_DBData::select();
	
	if (result)
		pHMId = getHM_ID(1);

	return result;	
}

long CPP_HM::getNextHMID()
{
   long nCounter = -1;
   cleanWhereStatement();

   m_Statement = " select SEQ_HM_ID.nextval as COUNTER from dual " ;

   if(CSMC_DBData::select())
   {
     nCounter = getLong("COUNTER", 1);
   }

   return nCounter;

}

bool CPP_HM::updateInsertPP(const string &pHMID,long pPlantNo, long pHMCounter, bool pCommit, cCBS_ODBC_DBError &pError)
{
  bool result = exists(pHMID);
  std::stringstream sql;
  if (result) //exists -> update
  {
    sql << "update PP_HM set PLANNED = 1 where HM_ID = '" << pHMID << "'" ;
  }
  else // -> insert
  {
    sql << "insert into PP_HM (HM_ID, PLANTNO,PLANNED, ON_REQUEST,HOTMETAL_COUNTER) values "
      << "('" << pHMID << "'," << pPlantNo << ",1,1," << pHMCounter << ")";
  }

  result = executeSQL(sql.str());
  if (!result)
    pError = getLastError();

  if (pCommit)
  {
    if (result)
      commit();
    else
      rollback();
  }
  
  return result;

}

bool CPP_HM::exists(const string& HM_ID)
{
	cleanWhereStatement();

	m_Statement = "Select count(*) as DATA_EXISTS from " + m_TableName;
	addWhereClause("HM_ID",HM_ID);
	m_Statement += getWhereStatement() + ";";

	bool result = CSMC_DBData::select();
	return result && getLong("DATA_EXISTS", 1) > 0;
}
