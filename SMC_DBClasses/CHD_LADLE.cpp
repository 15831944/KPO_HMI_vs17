//## Copyright (C) 2011 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "CPD_HEAT_DATA.h"
#include "CPD_LADLE.h"
#include "CHD_LADLE.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::HEATID("HEATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::TREATID("TREATID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::PLANT("PLANT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::LADLENO("LADLENO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::LADLETYPE("LADLETYPE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::TAREWEIGHT("TAREWEIGHT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::SCULLMASS("SCULLMASS");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::THERMALSTATUS("THERMALSTATUS");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::DESLAGGED("DESLAGGED");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::DURSINCELASTUSE("DURSINCELASTUSE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::LAST_TREATMENT_STATION("LAST_TREATMENT_STATION");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::LADLE_CIRCULATION_TIME("LADLE_CIRCULATION_TIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::LAST_FILL_TIME("LAST_FILL_TIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::LAST_EMPTY_TIME("LAST_EMPTY_TIME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::STATUSNO("STATUSNO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::LADLEPOSID("LADLEPOSID");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::PRETREAT_CNT_ACT("PRETREAT_CNT_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::PRETREAT_CNT_PREV("PRETREAT_CNT_PREV");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::HOTMETAL_CNT_ACT("HOTMETAL_CNT_ACT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::HOTMETAL_CNT_PREV("HOTMETAL_CNT_PREV");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CHD_LADLE::FREEBOARD("FREEBOARD");

//##DBClassCodeUtility ! DO NOT EDIT !
CHD_LADLE::CHD_LADLE(cCBS_StdConnection* Connection)
:CSMC_DBData("HD_LADLE",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CHD_LADLE::CHD_LADLE(cCBS_Connection* Connection)
:CSMC_DBData("HD_LADLE",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CHD_LADLE::CHD_LADLE()
:CSMC_DBData("HD_LADLE")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CHD_LADLE::~CHD_LADLE()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Internal heat identifier
std::string CHD_LADLE::getHEATID(long Row)
{
  return getString(CHD_LADLE::HEATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setHEATID(const std::string& value)
{
  setString(CHD_LADLE::HEATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment identifier
std::string CHD_LADLE::getTREATID(long Row)
{
  return getString(CHD_LADLE::TREATID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setTREATID(const std::string& value)
{
  setString(CHD_LADLE::TREATID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant identifier
std::string CHD_LADLE::getPLANT(long Row)
{
  return getString(CHD_LADLE::PLANT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setPLANT(const std::string& value)
{
  setString(CHD_LADLE::PLANT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique ladle number
long CHD_LADLE::getLADLENO(long Row)
{
  return getLong(CHD_LADLE::LADLENO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setLADLENO(long value)
{
  setLong(CHD_LADLE::LADLENO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##e.g. Hot Metal -> H, Teeming -> T
std::string CHD_LADLE::getLADLETYPE(long Row)
{
  return getString(CHD_LADLE::LADLETYPE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setLADLETYPE(const std::string& value)
{
  setString(CHD_LADLE::LADLETYPE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Eng. Unit : kg, Tare weight of the ladle
double CHD_LADLE::getTAREWEIGHT(long Row)
{
  return getDouble(CHD_LADLE::TAREWEIGHT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setTAREWEIGHT(double value)
{
  setDouble(CHD_LADLE::TAREWEIGHT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Eng. Unit : kg, Mass of ladle scull
double CHD_LADLE::getSCULLMASS(long Row)
{
  return getDouble(CHD_LADLE::SCULLMASS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setSCULLMASS(double value)
{
  setDouble(CHD_LADLE::SCULLMASS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##H=Hot, M=Medium, C=Cold
std::string CHD_LADLE::getTHERMALSTATUS(long Row)
{
  return getString(CHD_LADLE::THERMALSTATUS, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setTHERMALSTATUS(const std::string& value)
{
  setString(CHD_LADLE::THERMALSTATUS, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##1 = Deslagged, 0 = Not deslagged, -1 = Not known
long CHD_LADLE::getDESLAGGED(long Row)
{
  return getLong(CHD_LADLE::DESLAGGED, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setDESLAGGED(long value)
{
  setLong(CHD_LADLE::DESLAGGED, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Set in melting units and is calculated with tapping end (teeming/pre-metal ladles) or, with filling end (hot metal ladles). This duration shows the time the ladle was empty (cooling down time).
double CHD_LADLE::getDURSINCELASTUSE(long Row)
{
  return getDouble(CHD_LADLE::DURSINCELASTUSE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setDURSINCELASTUSE(double value)
{
  setDouble(CHD_LADLE::DURSINCELASTUSE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Route Plant id of Last treatment station
std::string CHD_LADLE::getLAST_TREATMENT_STATION(long Row)
{
  return getString(CHD_LADLE::LAST_TREATMENT_STATION, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setLAST_TREATMENT_STATION(const std::string& value)
{
  setString(CHD_LADLE::LAST_TREATMENT_STATION, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##This duration corresponds to the LAST_FILL_TIME and gives the duration from previous tapping to current tapping of the ladle.
double CHD_LADLE::getLADLE_CIRCULATION_TIME(long Row)
{
  return getDouble(CHD_LADLE::LADLE_CIRCULATION_TIME, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setLADLE_CIRCULATION_TIME(double value)
{
  setDouble(CHD_LADLE::LADLE_CIRCULATION_TIME, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Last time filling time with hot metal in case of HM ladle., Tapping end time in case of teeming or pre-metal ladles.
CDateTime CHD_LADLE::getLAST_FILL_TIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_LADLE::LAST_FILL_TIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setLAST_FILL_TIME(const CDateTime& value)
{
 setString(CHD_LADLE::LAST_FILL_TIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Discharge end time in case of liquid addition or pouring end time from Caster in case of teeming.
CDateTime CHD_LADLE::getLAST_EMPTY_TIME(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CHD_LADLE::LAST_EMPTY_TIME, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setLAST_EMPTY_TIME(const CDateTime& value)
{
 setString(CHD_LADLE::LAST_EMPTY_TIME, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Defined in GC_LADLE_STATUS
long CHD_LADLE::getSTATUSNO(long Row)
{
  return getLong(CHD_LADLE::STATUSNO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setSTATUSNO(long value)
{
  setLong(CHD_LADLE::STATUSNO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Valid ladle position as defined in GC_LADLE_POS
long CHD_LADLE::getLADLEPOSID(long Row)
{
  return getLong(CHD_LADLE::LADLEPOSID, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setLADLEPOSID(long value)
{
  setLong(CHD_LADLE::LADLEPOSID, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment data for the actual treatment in the ladle
long CHD_LADLE::getPRETREAT_CNT_ACT(long Row)
{
  return getLong(CHD_LADLE::PRETREAT_CNT_ACT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setPRETREAT_CNT_ACT(long value)
{
  setLong(CHD_LADLE::PRETREAT_CNT_ACT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Treatment data for the previous treatment in the ladle
long CHD_LADLE::getPRETREAT_CNT_PREV(long Row)
{
  return getLong(CHD_LADLE::PRETREAT_CNT_PREV, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setPRETREAT_CNT_PREV(long value)
{
  setLong(CHD_LADLE::PRETREAT_CNT_PREV, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique counter
long CHD_LADLE::getHOTMETAL_CNT_ACT(long Row)
{
  return getLong(CHD_LADLE::HOTMETAL_CNT_ACT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setHOTMETAL_CNT_ACT(long value)
{
  setLong(CHD_LADLE::HOTMETAL_CNT_ACT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unique counter
long CHD_LADLE::getHOTMETAL_CNT_PREV(long Row)
{
  return getLong(CHD_LADLE::HOTMETAL_CNT_PREV, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setHOTMETAL_CNT_PREV(long value)
{
  setLong(CHD_LADLE::HOTMETAL_CNT_PREV, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Actual freeboard of the ladle
long CHD_LADLE::getFREEBOARD(long Row)
{
  return getLong(CHD_LADLE::FREEBOARD, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CHD_LADLE::setFREEBOARD(long value)
{
  setLong(CHD_LADLE::FREEBOARD, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CHD_LADLE::select(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long LADLENO, const std::string& LADLETYPE)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CHD_LADLE::HEATID,HEATID);
  addWhereClause(CHD_LADLE::TREATID,TREATID);
  addWhereClause(CHD_LADLE::PLANT,PLANT);
  addWhereClause(CHD_LADLE::LADLENO,LADLENO);
  addWhereClause(CHD_LADLE::LADLETYPE,LADLETYPE);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CHD_LADLE::copy(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, const std::string& LADLETYPE, long LADLENO, 
                     bool Commit, cCBS_ODBC_DBError& Error)
{
  bool ReturnValue = false;

  CPD_LADLE PD_LADLE(m_pCBS_StdConnection);

  PD_LADLE.addWhereClause(CPD_LADLE::LADLETYPE, LADLETYPE);
  PD_LADLE.addWhereClause(CPD_LADLE::LADLENO, LADLENO);

  if ( select(HEATID, TREATID, PLANT, LADLENO, LADLETYPE) )
  {
    ReturnValue = copyByUpdate(&PD_LADLE);
  }
  else
  {
    setHEATID (HEATID);
    setTREATID(TREATID);
    setPLANT  (PLANT);
  
    ReturnValue = copyByInsert(&PD_LADLE);
  }

  if (!ReturnValue)
  {
    Error = getLastError();
  }

  if (Commit)
  {
    if (ReturnValue)
    {
      commit();
    }
    else
    {
      rollback();
      log("Rollback performed while trying to copy data from PD_LADLE to HD_LADLE.",2);
    }
  }//if (Commit)

  return ReturnValue;
}

bool CHD_LADLE::copy(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, long PLANTNO, bool Commit, cCBS_ODBC_DBError &Error)
{
	//bool result = !exists(HEATID,TREATID);
	bool result = !exists(HEATID,TREATID,PLANT);
	//some data found -> delete them
	if (!result)
	{
		result = deleteRows();
		if (!result)
			setLastError(std::string("ERROR_DELETE_DATA"), 0, getActStatement());
	}

  CPD_HEAT_DATA PD_HEAT_DATA(m_pCBS_StdConnection);

  if ( PD_HEAT_DATA.select(HEATID, TREATID, PLANT ) )
  {
    std::string LADLETYPE = PD_HEAT_DATA.getLADLETYPE(1);
    long LADLENO          = PD_HEAT_DATA.getLADLENO(1);

    // preparing setting for source table
    CPD_LADLE PD_LADLE(m_pCBS_StdConnection);
    PD_LADLE.addWhereClause(CPD_LADLE::LADLENO,LADLENO);
    PD_LADLE.addWhereClause(CPD_LADLE::LADLETYPE,LADLETYPE);

    // preparing setting for aim table
    setHEATID (HEATID);
    setTREATID(TREATID);

    setPLANT(PLANT);

    result = result && copyByInsert(&PD_LADLE);
  }

  if (!result)
		Error = getLastError();

	if(Commit)
	{
		if (result)
			this->commit();
		else
			rollback();
	}

	return result;
}

bool CHD_LADLE::copyLadleFromPD_HEAT_DATA(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT, 
                                          bool Commit, cCBS_ODBC_DBError& Error)
{
  CPD_HEAT_DATA PD_HEAT_DATA(m_pCBS_StdConnection);

  if ( !PD_HEAT_DATA.select(HEATID, TREATID, PLANT) )
  {
    setLastError("NO_DATA_FOUND",-1,PD_HEAT_DATA.getActStatement());
    Error = getLastError();
    return false;
  }

  return copy(HEATID, TREATID, PLANT, PD_HEAT_DATA.getLADLETYPE(1), PD_HEAT_DATA.getLADLENO(1), Commit, Error);
}

bool CHD_LADLE::exists(const std::string& HEATID, const std::string& TREATID, const std::string& PLANT)
{
	cleanWhereStatement();

	m_Statement = "Select HEATID from " + m_TableName;

	addWhereClause(CHD_LADLE::HEATID,HEATID);
	addWhereClause(CHD_LADLE::TREATID,TREATID);
	addWhereClause(CHD_LADLE::PLANT,PLANT);
   
  std::string sWhereStatement = getWhereStatement();
  //to avoid the exception like 'Select HEATID from PP_HEAT AND ROWNUM = 1 '
  if(sWhereStatement.length() > 0 ) 
  {
    // do not use ROWNUM in "addWhereClause", ROWNUM is not a table column and where statement will be used for deletion at "deleteRows"
    m_Statement += sWhereStatement + " AND ROWNUM = 1 ;";
  }
  else
  {
    return false;
  }

	return CSMC_DBData::select();
}


