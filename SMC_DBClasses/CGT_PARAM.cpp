//## Copyright (C) 2010 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "cCBS_StdEventLogFrameController.h"

#include "CDataConversion.h"
#include "DEF_GC_PARAM_TYPE.h"
#include "CGC_PLANTGROUP.h"
#include "CGT_PARAM_MATRIX.h"
#include "CGT_PARAM.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGT_PARAM::UNITGROUPNO("UNITGROUPNO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGT_PARAM::PNAME("PNAME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGT_PARAM::PRACNO("PRACNO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGT_PARAM::TYPE("TYPE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGT_PARAM::UNIT("UNIT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGT_PARAM::VALUE("VALUE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGT_PARAM::INST_ACTV("INST_ACTV");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGT_PARAM::DIALOG_PARAM("DIALOG_PARAM");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGT_PARAM::CONV("CONV");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGT_PARAM::MIN_VALUE("MIN_VALUE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGT_PARAM::MAX_VALUE("MAX_VALUE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGT_PARAM::CREATIONDATE("CREATIONDATE");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGT_PARAM::PARAMDESCR("PARAMDESCR");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGT_PARAM::PARAMDESCR_C("PARAMDESCR_C");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGT_PARAM::PARAMGROUP("PARAMGROUP");

//##DBClassCodeUtility ! DO NOT EDIT !
CGT_PARAM::CGT_PARAM(cCBS_StdConnection* Connection)
:CSMC_DBData("GT_PARAM",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CGT_PARAM::CGT_PARAM(cCBS_Connection* Connection)
:CSMC_DBData("GT_PARAM",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CGT_PARAM::CGT_PARAM()
:CSMC_DBData("GT_PARAM")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CGT_PARAM::~CGT_PARAM()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Unit group number, see GC_PLANT_GROUP
long CGT_PARAM::getUNITGROUPNO(long Row)
{
  return getLong(CGT_PARAM::UNITGROUPNO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGT_PARAM::setUNITGROUPNO(long value)
{
  setLong(CGT_PARAM::UNITGROUPNO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Parameter name
std::string CGT_PARAM::getPNAME(long Row)
{
  return getString(CGT_PARAM::PNAME, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGT_PARAM::setPNAME(const std::string& value)
{
  setString(CGT_PARAM::PNAME, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Production Practice Number
long CGT_PARAM::getPRACNO(long Row)
{
  return getLong(CGT_PARAM::PRACNO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGT_PARAM::setPRACNO(long value)
{
  setLong(CGT_PARAM::PRACNO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Type indicator 1-9
long CGT_PARAM::getTYPE(long Row)
{
  return getLong(CGT_PARAM::TYPE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGT_PARAM::setTYPE(long value)
{
  setLong(CGT_PARAM::TYPE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Engineering unit
std::string CGT_PARAM::getUNIT(long Row)
{
  return getString(CGT_PARAM::UNIT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGT_PARAM::setUNIT(const std::string& value)
{
  setString(CGT_PARAM::UNIT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Value, used for unkeyed parameters only, see also
std::string CGT_PARAM::getVALUE(long Row)
{
  return getString(CGT_PARAM::VALUE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGT_PARAM::setVALUE(const std::string& value)
{
  setString(CGT_PARAM::VALUE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Immediately active flag
long CGT_PARAM::getINST_ACTV(long Row)
{
  return getLong(CGT_PARAM::INST_ACTV, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGT_PARAM::setINST_ACTV(long value)
{
  setLong(CGT_PARAM::INST_ACTV, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Can be modified via the dialogue system
long CGT_PARAM::getDIALOG_PARAM(long Row)
{
  return getLong(CGT_PARAM::DIALOG_PARAM, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGT_PARAM::setDIALOG_PARAM(long value)
{
  setLong(CGT_PARAM::DIALOG_PARAM, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Conversion factor
double CGT_PARAM::getCONV(long Row)
{
  return getDouble(CGT_PARAM::CONV, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGT_PARAM::setCONV(double value)
{
  setDouble(CGT_PARAM::CONV, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Minimum value
double CGT_PARAM::getMIN_VALUE(long Row)
{
  return getDouble(CGT_PARAM::MIN_VALUE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGT_PARAM::setMIN_VALUE(double value)
{
  setDouble(CGT_PARAM::MIN_VALUE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Maximum value
double CGT_PARAM::getMAX_VALUE(long Row)
{
  return getDouble(CGT_PARAM::MAX_VALUE, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGT_PARAM::setMAX_VALUE(double value)
{
  setDouble(CGT_PARAM::MAX_VALUE, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
CDateTime CGT_PARAM::getCREATIONDATE(long Row)
{
  CDateTime D;
  D.fromDBString(getString(CGT_PARAM::CREATIONDATE, Row));
  return D;
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGT_PARAM::setCREATIONDATE(const CDateTime& value)
{
 setString(CGT_PARAM::CREATIONDATE, value.toDBString());
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Description of Parameter
std::string CGT_PARAM::getPARAMDESCR(long Row)
{
  return getString(CGT_PARAM::PARAMDESCR, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGT_PARAM::setPARAMDESCR(const std::string& value)
{
  setString(CGT_PARAM::PARAMDESCR, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Parameter Description Customer
std::string CGT_PARAM::getPARAMDESCR_C(long Row)
{
  return getString(CGT_PARAM::PARAMDESCR_C, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGT_PARAM::setPARAMDESCR_C(const std::string& value)
{
  setString(CGT_PARAM::PARAMDESCR_C, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Parameter group
std::string CGT_PARAM::getPARAMGROUP(long Row)
{
  return getString(CGT_PARAM::PARAMGROUP, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGT_PARAM::setPARAMGROUP(const std::string& value)
{
  setString(CGT_PARAM::PARAMGROUP, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CGT_PARAM::select(long UNITGROUPNO, const std::string& PNAME, long PRACNO, long TYPE)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CGT_PARAM::UNITGROUPNO,UNITGROUPNO);
  addWhereClause(CGT_PARAM::PNAME,PNAME);
  addWhereClause(CGT_PARAM::PRACNO,PRACNO);
  addWhereClause(CGT_PARAM::TYPE,TYPE);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CGT_PARAM::selectByPlant(const std::string& PLANT, long PLANTNO, const std::string& PNAME, long PRACNO, long TYPE)
{
  bool RetValue = false;

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CGT_PARAM::PNAME,PNAME);
  addWhereClause(CGT_PARAM::PRACNO,PRACNO);
  addWhereClause(CGT_PARAM::TYPE,TYPE);

  // find unitgroup numbers for PLANT and PLANTNO
  std::vector<long> UnitGroupList = getUnitGroupList(PLANT,PLANTNO);
  addWhereClause(CGT_PARAM::UNITGROUPNO, UnitGroupList, "IN");

  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

bool CGT_PARAM::selectOrderByUnitGroupNo(const std::string& PNAME, long PRACNO, long TYPE)
{
	cleanWhereStatement();

	m_Statement = "Select * from " + m_TableName;

	addWhereClause(CGT_PARAM::PNAME,PNAME);
	addWhereClause(CGT_PARAM::PRACNO,PRACNO);
	addWhereClause(CGT_PARAM::TYPE,TYPE);

	m_Statement += getWhereStatement() + " order by UNITGROUPNO;";

	return CSMC_DBData::select();
}

std::vector<long> CGT_PARAM::getUnitGroupList(const std::string& Plant,long PlantNo)
{
  CGC_PLANTGROUP GC_PLANTGROUP(m_pCBS_StdConnection);

  return GC_PLANTGROUP.getUnitGroupList(Plant,PlantNo);
}

bool CGT_PARAM::getValue(const std::string& PLANT, long PLANTNO, const std::string& PNAME, long PRACNO, long TYPE, std::string& Value)
{
  bool RetValue = false;
  Value = CSMC_DBData::unspecString;

  if ( selectByPlant(PLANT, PLANTNO, PNAME, PRACNO, TYPE) )
  {
    if ( getLastRow() == 1 )
    {
      RetValue = true;
      Value    = getVALUE(1);
    }
  }

  return RetValue;
}

bool CGT_PARAM::getKeyedValue(const std::string& PLANT, long PLANTNO, const std::string& PNAME, long PRACNO, long TYPE, const std::string& KEY1, const std::string& KEY2, std::string& Value)
{
  bool RetValue = false;
  Value = CSMC_DBData::unspecString;

  CGT_PARAM_MATRIX GT_PARAM_MATRIX( m_pCBS_StdConnection );

  if ( GT_PARAM_MATRIX.selectByPlant(PLANT, PLANTNO, PNAME, PRACNO, TYPE, KEY1, KEY2 ) )
  {
    if ( GT_PARAM_MATRIX.getLastRow() == 1 )
    {
      RetValue = true;
      Value    = GT_PARAM_MATRIX.getVALUE(1);
    }
  }

  return RetValue;

}

bool CGT_PARAM::getKeyedValueList(const std::string& PLANT, long PLANTNO, const std::string& PNAME, long PRACNO, long TYPE, const std::string& KEY1, const std::string& KEY2, std::set<std::string>& ValueList)
{
  bool RetValue = false;
  //ValueList.erase(ValueList.begin(), ValueList.end());

  CGT_PARAM_MATRIX GT_PARAM_MATRIX( m_pCBS_StdConnection );

  if ( GT_PARAM_MATRIX.selectByPlant(PLANT, PLANTNO, PNAME, PRACNO, TYPE, KEY1, KEY2 ) )
  {
    RetValue = true;

    for ( long i = 1 ; i <= GT_PARAM_MATRIX.getLastRow(); ++i )
    {
      std::string Value = GT_PARAM_MATRIX.getVALUE(i);

      // retrun single entries only
      if ( ValueList.find(Value) == ValueList.end() )
      {
        ValueList.insert(Value);
      }
    }
  }

  return RetValue;

}


bool CGT_PARAM::setHeatCustSeqParam(long PlantNo, long pValue, bool Commit, cCBS_ODBC_DBError &Error)
{
	std::stringstream sql;

	sql << "update GT_PARAM set VALUE = TO_CHAR(TO_NUMBER(VALUE + " << pValue << "))"
			<< "  where PNAME = 'CustHeatIDSequence'"
			<< "  and UNITGROUPNO in"
			<< "     (select UNITGROUPNO from GC_PLANTGROUP"
			<< "      where PLANT = 'BOF' and PLANTNO = " << PlantNo << ")";
	
	bool result = executeSQL(sql.str());
	if (!result)
		Error = getLastError();

	if(Commit)
  {
		if (result)
			this->commit();
		else
			rollback();
  }

	return result;
}

bool CGT_PARAM::updateValue (const std::string& PLANT, long PLANTNO, const std::string& PNAME, long PRACNO, long TYPE, const std::string &Value)
{
  bool RetValue = false;      
  try
  {
    // get all possible unit groups and start to update from specialized
    // break if first update was successful
    std::vector<long> UnitGroupList = getUnitGroupList(PLANT, PLANTNO);
    std::vector<long>::iterator it;

    if( PNAME != CSMC_DBData::unspecString && PRACNO != CSMC_DBData::unspecLong && TYPE != CSMC_DBData::unspecLong)
    {
      for (it = UnitGroupList.begin(); it != UnitGroupList.end(); ++it)
      {
        cleanWhereStatement();

        addWhereClause    (CGT_PARAM::PNAME, PNAME);
        addWhereClause    (CGT_PARAM::UNITGROUPNO,*it);
        addWhereClause    (CGT_PARAM::PRACNO,PRACNO);
        addWhereClause    (CGT_PARAM::TYPE,  TYPE);

        setString         (CGT_PARAM::VALUE, Value);

        RetValue  =  update();

        if (RetValue)
        {
          break;
        }
      }
    }
  }
  catch (...)
  {
    std::stringstream Message;
    Message << "Parameter Update failed for Parameter <" << PNAME << "> for PLANT " << PLANT << " PLANTNO " << PLANTNO;

		cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
		sEventLogMessage sMessage = cCBS_StdEventLogFrame::initMessage(__FILE__,__LINE__);
    pEventLog->EL_DBWriteError(sMessage,"", m_TableName.c_str(), Message.str().c_str());

    RetValue = false;
  }

  return     RetValue;

}

// check plausibility for numeric parameter types MIN <= value <= MAX
bool CGT_PARAM::checkMinMaxRange(const std::string& PLANT, long PLANTNO, const std::string& PNAME, long PRACNO, long TYPE, const std::string &Value)
{
  bool RetValue = true;      

  if ( TYPE == DEF_GC_PARAM_TYPE::LParam ||
       TYPE == DEF_GC_PARAM_TYPE::DParam )
  {
    // get all possible unit groups and start to update from specialized
    // break if first update was successful
    std::vector<long> UnitGroupList = getUnitGroupList(PLANT, PLANTNO);
    std::vector<long>::iterator it;

    if( PNAME != CSMC_DBData::unspecString && PRACNO != CSMC_DBData::unspecLong && TYPE != CSMC_DBData::unspecLong)
    {
      for (it = UnitGroupList.begin(); it != UnitGroupList.end(); ++it)
      {
        long UNITGROUPNO = (*it);

        if ( select(UNITGROUPNO, PNAME, PRACNO, TYPE ) )
        {
          double MIN_VALUE = getMIN_VALUE(1);
          double MAX_VALUE = getMAX_VALUE(1);

          double ActValue = CDataConversion::StringToDouble(Value);

          if ( ActValue > MAX_VALUE || 
               ActValue < MIN_VALUE )
          {
            std::stringstream Message;
            Message << "Parameter check failed for Parameter <" << PNAME << "> for PLANT " << PLANT << " PLANTNO " << PLANTNO;
            Message << " - MIN/MAX violated with value :" << Value;

		        cCBS_StdEventLogFrame *pEventLog = cCBS_StdEventLogFrameController::getInstance()->getpEventLog();
		        sEventLogMessage sMessage = cCBS_StdEventLogFrame::initMessage(__FILE__,__LINE__);
            pEventLog->EL_DBReadError(sMessage,"", m_TableName.c_str(), Message.str().c_str());

            RetValue = false;

            break;
          }
        } // if ( select(UNITGROUPNO, PNAME, PRACNO, TYPE ) )
      } // for (it = UnitGroupList.begin(); it != UnitGroupList.end(); ++it)
    }
  }

  return RetValue;

}


bool CGT_PARAM::isParam(const std::string& PLANT, long PLANTNO, const std::string& PNAME, long PRACNO, long TYPE)
{
  bool RetValue = false;

  RetValue = selectByPlant(PLANT, PLANTNO, PNAME, PRACNO, TYPE);

  return RetValue;
}
