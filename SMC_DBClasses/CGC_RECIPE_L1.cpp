//## Copyright (C) 2009 SMS Siemag AG, Germany 
//## Version generated by DBClassCodeUtility BETA 0.6.3 
//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED 
//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - "YOUR-CODE" - 


#include "CGC_RECIPE_L1.h"


//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGC_RECIPE_L1::PLANT("PLANT");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGC_RECIPE_L1::RECIPENAME("RECIPENAME");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGC_RECIPE_L1::RECIPENO("RECIPENO");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGC_RECIPE_L1::RECIPE_NO_L1("RECIPE_NO_L1");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGC_RECIPE_L1::DESCRIPTION("DESCRIPTION");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGC_RECIPE_L1::DISPLAY_ORDER("DISPLAY_ORDER");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGC_RECIPE_L1::RECIPENAME_MODEL("RECIPENAME_MODEL");
//##DBClassCodeUtility ! DO NOT EDIT !
const std::string CGC_RECIPE_L1::RECIPENO_MODEL("RECIPENO_MODEL");

//##DBClassCodeUtility ! DO NOT EDIT !
CGC_RECIPE_L1::CGC_RECIPE_L1(cCBS_StdConnection* Connection)
:CSMC_DBData("GC_RECIPE_L1",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CGC_RECIPE_L1::CGC_RECIPE_L1(cCBS_Connection* Connection)
:CSMC_DBData("GC_RECIPE_L1",Connection)
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CGC_RECIPE_L1::CGC_RECIPE_L1()
:CSMC_DBData("GC_RECIPE_L1")
{
  //please implement virtual method, to initialize your members  
  doOnConstruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
CGC_RECIPE_L1::~CGC_RECIPE_L1()
{
  //please implement virtual method, to destruct your members
  doOnDestruct(); 
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Plant identifier
std::string CGC_RECIPE_L1::getPLANT(long Row)
{
  return getString(CGC_RECIPE_L1::PLANT, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGC_RECIPE_L1::setPLANT(const std::string& value)
{
  setString(CGC_RECIPE_L1::PLANT, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Name of recipe or recipe group
std::string CGC_RECIPE_L1::getRECIPENAME(long Row)
{
  return getString(CGC_RECIPE_L1::RECIPENAME, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGC_RECIPE_L1::setRECIPENAME(const std::string& value)
{
  setString(CGC_RECIPE_L1::RECIPENAME, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Running recipe counter with a pre-defined range(0-10/14 depending on the model). If a recipe is sent again the DM checks highest RECIPENO in PD_RECIPE and uses the next one as the new one.
long CGC_RECIPE_L1::getRECIPENO(long Row)
{
  return getLong(CGC_RECIPE_L1::RECIPENO, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGC_RECIPE_L1::setRECIPENO(long value)
{
  setLong(CGC_RECIPE_L1::RECIPENO, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##This is the mapping between the RECIPENAME and the possible incremented RECIPENO to a unique number used for L1 communication.
long CGC_RECIPE_L1::getRECIPE_NO_L1(long Row)
{
  return getLong(CGC_RECIPE_L1::RECIPE_NO_L1, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGC_RECIPE_L1::setRECIPE_NO_L1(long value)
{
  setLong(CGC_RECIPE_L1::RECIPE_NO_L1, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Description for what this recipe is used for. For special recipes like 'L2 Manual Addition' a separate number range should be defined to difference this addition from additions calculated by the model.
std::string CGC_RECIPE_L1::getDESCRIPTION(long Row)
{
  return getString(CGC_RECIPE_L1::DESCRIPTION, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGC_RECIPE_L1::setDESCRIPTION(const std::string& value)
{
  setString(CGC_RECIPE_L1::DESCRIPTION, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
//##Display order in HMI, chronological order during treatment
long CGC_RECIPE_L1::getDISPLAY_ORDER(long Row)
{
  return getLong(CGC_RECIPE_L1::DISPLAY_ORDER, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGC_RECIPE_L1::setDISPLAY_ORDER(long value)
{
  setLong(CGC_RECIPE_L1::DISPLAY_ORDER, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
std::string CGC_RECIPE_L1::getRECIPENAME_MODEL(long Row)
{
  return getString(CGC_RECIPE_L1::RECIPENAME_MODEL, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGC_RECIPE_L1::setRECIPENAME_MODEL(const std::string& value)
{
  setString(CGC_RECIPE_L1::RECIPENAME_MODEL, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
long CGC_RECIPE_L1::getRECIPENO_MODEL(long Row)
{
  return getLong(CGC_RECIPE_L1::RECIPENO_MODEL, Row);
}

//##DBClassCodeUtility ! DO NOT EDIT !
void CGC_RECIPE_L1::setRECIPENO_MODEL(long value)
{
  setLong(CGC_RECIPE_L1::RECIPENO_MODEL, value);
}

//##DBClassCodeUtility ! DO NOT EDIT !
bool CGC_RECIPE_L1::select(const std::string& PLANT, const std::string& RECIPENAME, long RECIPENO)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CGC_RECIPE_L1::PLANT,PLANT);
  addWhereClause(CGC_RECIPE_L1::RECIPENAME,RECIPENAME);
  addWhereClause(CGC_RECIPE_L1::RECIPENO,RECIPENO);
  m_Statement += getWhereStatement() + ";";

  return CSMC_DBData::select();
}

//## ------------------------------------END-GENERATED-CODE---------------------- 

//## ------------------------------------YOUR-CODE------------------------------- 

bool CGC_RECIPE_L1::selectOrdered(const std::string& PLANT, const std::string& RECIPENAME, long RECIPENO)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CGC_RECIPE_L1::PLANT,PLANT);
  addWhereClause(CGC_RECIPE_L1::RECIPENAME,RECIPENAME);
  addWhereClause(CGC_RECIPE_L1::RECIPENO,RECIPENO);

  m_Statement += getWhereStatement() + " ORDER BY RECIPENO ;";

  return CSMC_DBData::select();
}

bool CGC_RECIPE_L1::selectOrderedByModelData(const std::string& PLANT, const std::string& RECIPENAME_MODEL, long RECIPENO_MODEL)
{
  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CGC_RECIPE_L1::PLANT,PLANT);
  addWhereClause(CGC_RECIPE_L1::RECIPENAME_MODEL,RECIPENAME_MODEL);
  addWhereClause(CGC_RECIPE_L1::RECIPENO_MODEL,RECIPENO_MODEL);

  m_Statement += getWhereStatement() + " ORDER BY RECIPENO ;";

  return CSMC_DBData::select();
}

std::map<long, std::pair<std::string, long> > & CGC_RECIPE_L1::getL1RecipeNoList(const std::string& Plant)
{
  static std::map<long, std::pair<std::string, long> > RecipeList;

  this->select( Plant, CSMC_DBData::unspecString, CSMC_DBData::unspecLong );
  long lRowsGot = this->getLastRow();

  std::string RecipeName;
  long lRecipeNo, lL1RecipeNo;

  for (long i = 1; i <= lRowsGot; i++)
  {
    RecipeName  = getRECIPENAME(i);
    lRecipeNo   = getRECIPENO(i);
    lL1RecipeNo = getRECIPE_NO_L1(i);

    RecipeList.insert(std::pair <long,std::pair< std::string,long > > 
      ( lL1RecipeNo,std::pair< std::string, long >(RecipeName ,lRecipeNo )));
  }
  return RecipeList;
}

std::map<std::string, long> &  CGC_RECIPE_L1::getL2RecipeNameList(const std::string& Plant )
{
  static std::map<std::string, long> RecipeList;

  this->select( Plant, CSMC_DBData::unspecString, CSMC_DBData::unspecLong );
  long lRowsGot = this->getLastRow();
  std::ostringstream RecipeNo;
  std::string L2RecipeName;
  long lL1RecipeNo = 0;

  for (long i = 1; i <= lRowsGot; i++)
  {
    RecipeNo << getRECIPENAME(i);
    RecipeNo << "_";
    RecipeNo << getRECIPENO(i);
    L2RecipeName  = RecipeNo.str();
    lL1RecipeNo   = getRECIPE_NO_L1(i);

    RecipeList.insert(std::pair <std::string,long>(L2RecipeName, lL1RecipeNo));
    
    RecipeNo.str("");
  }
  return RecipeList;
}

long CGC_RECIPE_L1::getMaxRecipeNo(const std::string& PLANT, const std::string& RECIPENAME_MODEL, long RECIPENO_MODEL)
{
  long LastRecipeNo = 1;

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CGC_RECIPE_L1::PLANT,PLANT);
  addWhereClause(CGC_RECIPE_L1::RECIPENAME_MODEL,RECIPENAME_MODEL);
  addWhereClause(CGC_RECIPE_L1::RECIPENO_MODEL,RECIPENO_MODEL);

  m_Statement += getWhereStatement() + " ORDER BY RECIPENO DESC ;";

  if ( CSMC_DBData::select() )
  {
    LastRecipeNo = getRECIPENO(1);
  }

  return LastRecipeNo;

}

long CGC_RECIPE_L1::getMinRecipeNo(const std::string& PLANT, const std::string& RECIPENAME_MODEL, long RECIPENO_MODEL)
{
  long FirstRecipeNo = 1;

  cleanWhereStatement();

  m_Statement = "Select * from " + m_TableName;

  addWhereClause(CGC_RECIPE_L1::PLANT,PLANT);
  addWhereClause(CGC_RECIPE_L1::RECIPENAME_MODEL,RECIPENAME_MODEL);
  addWhereClause(CGC_RECIPE_L1::RECIPENO_MODEL,RECIPENO_MODEL);

  m_Statement += getWhereStatement() + " ORDER BY RECIPENO ;";

  if ( CSMC_DBData::select() )
  {
    FirstRecipeNo = getRECIPENO(1);
  }

  return FirstRecipeNo;

}

std::string CGC_RECIPE_L1::getRecipeNameByModelData(const std::string& PLANT, const std::string& RECIPENAME_MODEL, long RECIPENO_MODEL)
{
  std::string RecipeName = CSMC_DBData::unspecString;

  if ( selectOrderedByModelData(PLANT, RECIPENAME_MODEL, RECIPENO_MODEL) )
  {
    RecipeName = getRECIPENAME(1);
  }

  return RecipeName;
}


