// This file is generated by omniidl (C++ backend) - omniORB_4_2. Do not edit.

#include "IBas_s.h"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_2_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static const char* _0RL_enumMember_IBAS_mvalueKind[] = { "e_kindLong", "e_kindFloat", "e_kindString" };
static CORBA::TypeCode_ptr _0RL_tc_IBAS_mvalueKind = CORBA::TypeCode::PR_enum_tc("IDL:IBAS/valueKind:1.0", "valueKind", _0RL_enumMember_IBAS_mvalueKind, 3, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace IBAS { 
  const ::CORBA::TypeCode_ptr _tc_valueKind = _0RL_tc_IBAS_mvalueKind;
} 
#else
const ::CORBA::TypeCode_ptr IBAS::_tc_valueKind = _0RL_tc_IBAS_mvalueKind;
#endif

static CORBA::PR_unionMember _0RL_unionMember_IBAS_mu__Data[] = {
  {"LongVal", CORBA::TypeCode::PR_long_tc(), (CORBA::PR_unionDiscriminator)IBAS::e_kindLong},
  {"FloatVal", CORBA::TypeCode::PR_float_tc(), (CORBA::PR_unionDiscriminator)IBAS::e_kindFloat},
  {"StringVal", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), (CORBA::PR_unionDiscriminator)IBAS::e_kindString}
};
#ifdef _0RL_tc_IBAS_mu__Data
#  undef _0RL_tc_IBAS_mu__Data
#endif
static CORBA::TypeCode_ptr _0RL_tc_IBAS_mu__Data = CORBA::TypeCode::PR_union_tc("IDL:IBAS/u_Data:1.0", "u_Data", _0RL_tc_IBAS_mvalueKind, _0RL_unionMember_IBAS_mu__Data, 3, -1, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace IBAS { 
  const ::CORBA::TypeCode_ptr _tc_u_Data = _0RL_tc_IBAS_mu__Data;
} 
#else
const ::CORBA::TypeCode_ptr IBAS::_tc_u_Data = _0RL_tc_IBAS_mu__Data;
#endif


static CORBA::PR_structMember _0RL_structmember_IBAS_mNamedValue[] = {
  {"Tag", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"Data", _0RL_tc_IBAS_mu__Data}
};

#ifdef _0RL_tc_IBAS_mNamedValue
#  undef _0RL_tc_IBAS_mNamedValue
#endif
static CORBA::TypeCode_ptr _0RL_tc_IBAS_mNamedValue = CORBA::TypeCode::PR_struct_tc("IDL:IBAS/NamedValue:1.0", "NamedValue", _0RL_structmember_IBAS_mNamedValue, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace IBAS { 
  const ::CORBA::TypeCode_ptr _tc_NamedValue = _0RL_tc_IBAS_mNamedValue;
} 
#else
const ::CORBA::TypeCode_ptr IBAS::_tc_NamedValue = _0RL_tc_IBAS_mNamedValue;
#endif






static CORBA::TypeCode_ptr _0RL_tc_IBAS_mseqValues = CORBA::TypeCode::PR_alias_tc("IDL:IBAS/seqValues:1.0", "seqValues", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_IBAS_mNamedValue, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace IBAS { 
  const ::CORBA::TypeCode_ptr _tc_seqValues = _0RL_tc_IBAS_mseqValues;
} 
#else
const ::CORBA::TypeCode_ptr IBAS::_tc_seqValues = _0RL_tc_IBAS_mseqValues;
#endif

static CORBA::TypeCode_ptr _0RL_tc_IBAS_mseqLocks = CORBA::TypeCode::PR_alias_tc("IDL:IBAS/seqLocks:1.0", "seqLocks", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace IBAS { 
  const ::CORBA::TypeCode_ptr _tc_seqLocks = _0RL_tc_IBAS_mseqLocks;
} 
#else
const ::CORBA::TypeCode_ptr IBAS::_tc_seqLocks = _0RL_tc_IBAS_mseqLocks;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace IBAS { 
  const ::CORBA::TypeCode_ptr _tc_IBASIntrf = CORBA::TypeCode::PR_interface_tc("IDL:IBAS/IBASIntrf:1.0", "IBASIntrf", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr IBAS::_tc_IBASIntrf = CORBA::TypeCode::PR_interface_tc("IDL:IBAS/IBASIntrf:1.0", "IBASIntrf", &_0RL_tcTrack);
#endif

static void _0RL_IBAS_mvalueKind_marshal_fn(cdrStream& _s, void* _v)
{
  IBAS::valueKind* _p = (IBAS::valueKind*)_v;
  *_p >>= _s;
}
static void _0RL_IBAS_mvalueKind_unmarshal_fn(cdrStream& _s, void*& _v)
{
  IBAS::valueKind* _p = (IBAS::valueKind*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, IBAS::valueKind _s)
{
  _a.PR_insert(_0RL_tc_IBAS_mvalueKind,
               _0RL_IBAS_mvalueKind_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, IBAS::valueKind& _s)
{
  return _a.PR_extract(_0RL_tc_IBAS_mvalueKind,
                       _0RL_IBAS_mvalueKind_unmarshal_fn,
                       &_s);
}

static void _0RL_IBAS_mu__Data_marshal_fn(cdrStream& _s, void* _v)
{
  IBAS::u_Data* _p = (IBAS::u_Data*)_v;
  *_p >>= _s;
}
static void _0RL_IBAS_mu__Data_unmarshal_fn(cdrStream& _s, void*& _v)
{
  IBAS::u_Data* _p = new IBAS::u_Data;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_IBAS_mu__Data_destructor_fn(void* _v)
{
  IBAS::u_Data* _p = (IBAS::u_Data*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const IBAS::u_Data& _s)
{
  IBAS::u_Data* _p = new IBAS::u_Data(_s);
  _a.PR_insert(_0RL_tc_IBAS_mu__Data,
               _0RL_IBAS_mu__Data_marshal_fn,
               _0RL_IBAS_mu__Data_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, IBAS::u_Data* _sp)
{
  _a.PR_insert(_0RL_tc_IBAS_mu__Data,
               _0RL_IBAS_mu__Data_marshal_fn,
               _0RL_IBAS_mu__Data_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, IBAS::u_Data*& _sp)
{
  return _a >>= (const IBAS::u_Data*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const IBAS::u_Data*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_IBAS_mu__Data,
                    _0RL_IBAS_mu__Data_unmarshal_fn,
                    _0RL_IBAS_mu__Data_marshal_fn,
                    _0RL_IBAS_mu__Data_destructor_fn,
                    _v)) {
    _sp = (const IBAS::u_Data*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_IBAS_mNamedValue_marshal_fn(cdrStream& _s, void* _v)
{
  IBAS::NamedValue* _p = (IBAS::NamedValue*)_v;
  *_p >>= _s;
}
static void _0RL_IBAS_mNamedValue_unmarshal_fn(cdrStream& _s, void*& _v)
{
  IBAS::NamedValue* _p = new IBAS::NamedValue;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_IBAS_mNamedValue_destructor_fn(void* _v)
{
  IBAS::NamedValue* _p = (IBAS::NamedValue*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const IBAS::NamedValue& _s)
{
  IBAS::NamedValue* _p = new IBAS::NamedValue(_s);
  _a.PR_insert(_0RL_tc_IBAS_mNamedValue,
               _0RL_IBAS_mNamedValue_marshal_fn,
               _0RL_IBAS_mNamedValue_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, IBAS::NamedValue* _sp)
{
  _a.PR_insert(_0RL_tc_IBAS_mNamedValue,
               _0RL_IBAS_mNamedValue_marshal_fn,
               _0RL_IBAS_mNamedValue_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, IBAS::NamedValue*& _sp)
{
  return _a >>= (const IBAS::NamedValue*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const IBAS::NamedValue*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_IBAS_mNamedValue,
                    _0RL_IBAS_mNamedValue_unmarshal_fn,
                    _0RL_IBAS_mNamedValue_marshal_fn,
                    _0RL_IBAS_mNamedValue_destructor_fn,
                    _v)) {
    _sp = (const IBAS::NamedValue*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_IBAS_mseqValues_marshal_fn(cdrStream& _s, void* _v)
{
  IBAS::seqValues* _p = (IBAS::seqValues*)_v;
  *_p >>= _s;
}
static void _0RL_IBAS_mseqValues_unmarshal_fn(cdrStream& _s, void*& _v)
{
  IBAS::seqValues* _p = new IBAS::seqValues;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_IBAS_mseqValues_destructor_fn(void* _v)
{
  IBAS::seqValues* _p = (IBAS::seqValues*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const IBAS::seqValues& _s)
{
  IBAS::seqValues* _p = new IBAS::seqValues(_s);
  _a.PR_insert(_0RL_tc_IBAS_mseqValues,
               _0RL_IBAS_mseqValues_marshal_fn,
               _0RL_IBAS_mseqValues_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, IBAS::seqValues* _sp)
{
  _a.PR_insert(_0RL_tc_IBAS_mseqValues,
               _0RL_IBAS_mseqValues_marshal_fn,
               _0RL_IBAS_mseqValues_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, IBAS::seqValues*& _sp)
{
  return _a >>= (const IBAS::seqValues*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const IBAS::seqValues*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_IBAS_mseqValues,
                    _0RL_IBAS_mseqValues_unmarshal_fn,
                    _0RL_IBAS_mseqValues_marshal_fn,
                    _0RL_IBAS_mseqValues_destructor_fn,
                    _v)) {
    _sp = (const IBAS::seqValues*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_IBAS_mseqLocks_marshal_fn(cdrStream& _s, void* _v)
{
  IBAS::seqLocks* _p = (IBAS::seqLocks*)_v;
  *_p >>= _s;
}
static void _0RL_IBAS_mseqLocks_unmarshal_fn(cdrStream& _s, void*& _v)
{
  IBAS::seqLocks* _p = new IBAS::seqLocks;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_IBAS_mseqLocks_destructor_fn(void* _v)
{
  IBAS::seqLocks* _p = (IBAS::seqLocks*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const IBAS::seqLocks& _s)
{
  IBAS::seqLocks* _p = new IBAS::seqLocks(_s);
  _a.PR_insert(_0RL_tc_IBAS_mseqLocks,
               _0RL_IBAS_mseqLocks_marshal_fn,
               _0RL_IBAS_mseqLocks_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, IBAS::seqLocks* _sp)
{
  _a.PR_insert(_0RL_tc_IBAS_mseqLocks,
               _0RL_IBAS_mseqLocks_marshal_fn,
               _0RL_IBAS_mseqLocks_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, IBAS::seqLocks*& _sp)
{
  return _a >>= (const IBAS::seqLocks*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const IBAS::seqLocks*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_IBAS_mseqLocks,
                    _0RL_IBAS_mseqLocks_unmarshal_fn,
                    _0RL_IBAS_mseqLocks_marshal_fn,
                    _0RL_IBAS_mseqLocks_destructor_fn,
                    _v)) {
    _sp = (const IBAS::seqLocks*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_IBAS_mIBASIntrf_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_IBAS_mIBASIntrf_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(IBAS::IBASIntrf::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_IBAS_mIBASIntrf_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, IBAS::IBASIntrf_ptr _o)
{
  IBAS::IBASIntrf_ptr _no = IBAS::IBASIntrf::_duplicate(_o);
  _a.PR_insert(IBAS::_tc_IBASIntrf,
               _0RL_IBAS_mIBASIntrf_marshal_fn,
               _0RL_IBAS_mIBASIntrf_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, IBAS::IBASIntrf_ptr* _op)
{
  _a.PR_insert(IBAS::_tc_IBASIntrf,
               _0RL_IBAS_mIBASIntrf_marshal_fn,
               _0RL_IBAS_mIBASIntrf_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = IBAS::IBASIntrf::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, IBAS::IBASIntrf_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(IBAS::_tc_IBASIntrf,
                    _0RL_IBAS_mIBASIntrf_unmarshal_fn,
                    _0RL_IBAS_mIBASIntrf_marshal_fn,
                    _0RL_IBAS_mIBASIntrf_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (IBAS::IBASIntrf_ptr)_r->_ptrToObjRef(IBAS::IBASIntrf::_PD_repoId);
    else
      _o = IBAS::IBASIntrf::_nil();
    return 1;
  }
  return 0;
}

