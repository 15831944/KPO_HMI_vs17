using System;
using System.IO;
using System.Data;
using System.Xml;
using System.Xml.XPath;
using System.Collections;
using System.Windows.Forms;
 

namespace DBClassCodeUtility
{
  /// <summary>
  /// CCodePreprocessor erzeugt Beschreibung einer Klasse in Form von xml.
  /// </summary>

  struct sActFileInfo
  {
    public bool Exists;
    public DateTime CreationTime;
  };
    
  public class CCodePreprocessor
  {
    private int CountGet;
    private int CountSet;
    private string methodSummary = null;
    private string m_GeneratedComment = "//##DBClassCodeUtility ! DO NOT EDIT !";
    private int    m_OrderNr          = 0; // order number

    //DialogResult result = new DialogResult();

    private XmlDocument newDoc;
    private XmlNode newMethod;

    private ArrayList m_CurrentLineArray = new ArrayList();

    private sActFileInfo sActFile;
    private bool ExistMethodName = false;
    private bool IsMethodSignatureComplete = false;

    public CCodePreprocessor()
    {
      //Constructor      
    }

    public CCodePreprocessor(DataTable Desc_Table, int detailIndex, int dataIndex)
    {
      createDefClass(Desc_Table, detailIndex, dataIndex);   
    }
    
    public CCodePreprocessor(DataTable Desc_Table, string Filename, bool IsDBTable, string sTableComment)
    {
      try
      {
        // reset parameter
        m_OrderNr = 0; // order number
        CData.Instance.setNewSummary(null);

        if (File.Exists(Filename + ".h") && File.Exists(Filename + ".cpp"))
        {
          sActFile.Exists       = true;
          sActFile.CreationTime = File.GetCreationTime(Filename + ".h");

          createNewXMLFile(Desc_Table, IsDBTable, sTableComment); // create XML to describe renew class

          parsingOfExistingFile(Desc_Table, Filename, IsDBTable);// create XML to describe exist class 
        }
        else
        {
          sActFile.Exists       = false;
          sActFile.CreationTime = DateTime.Now;

          createNewXMLFile(Desc_Table, IsDBTable, sTableComment); // create XML to describe new class
        }// File exist  
      }
      catch (Exception ex)
      {
        MessageBox.Show(ex.StackTrace + " : \r\n\r\n"
          + ex.Message,
          "Error: " + ex.ToString(), MessageBoxButtons.OK, MessageBoxIcon.Error);
      }     
    }// End of Constructor
      
    public bool getFileExists()
    {
      if (sActFile.Exists == true) 
        return true;

      return false;
    }// End of checkFileExists

    // create XML to describe new class   
    public XmlDocument createNewXMLFile(DataTable Desc_Table, bool IsDBTable, string sTableComment)
    {
      XmlDocument DBDoc = new XmlDocument();// XML-Document that contains the class description
      XmlNode static_member, get_method, set_method, select_method = null, arg, root;
      XmlAttribute newAttr; 
    
      string className = "C" + Desc_Table.TableName.ToString();

      string colType;
      string colName;
      string colComment;

      bool isStatic = false;
      string StaticMembers = CData.Instance.ReadSetting("UserSettings", "StaticMembers");
      if (StaticMembers == "yes")
      {
        isStatic = true;
      }
 
      bool select_created = false; // select methode nur 1 mal generieren
      DBDoc.LoadXml("<class> </class>");
      root = DBDoc.FirstChild; // main node of XML-document

      #region root Attributes
      newAttr = DBDoc.CreateAttribute("CLASS");
      newAttr.InnerText = "C" + Desc_Table.TableName.ToString(); // Class name
      root.Attributes.Append(newAttr);

      string sCopyrightYear = sActFile.CreationTime.Year.ToString();

      newAttr = DBDoc.CreateAttribute("SMS_COPYRIGHT");
      newAttr.InnerText = "//## Copyright (C) " + sCopyrightYear + " SMS Siemag AG, Germany \r\n";
      root.Attributes.Append(newAttr);

      if (IsDBTable)
      {
        newAttr = DBDoc.CreateAttribute("TABLE_COMMENT");
        newAttr.InnerText = sTableComment;
        root.Attributes.Append(newAttr);
      }

      newAttr = DBDoc.CreateAttribute("HEADER_COMMENT");
      if (IsDBTable)
      {
        newAttr.InnerText = "//## Version generated by " + CData.Instance.getVersionOfDBClassCodeUtility() + " \r\n" +
          "//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED \r\n" +
          "//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - \"YOUR-CODE\" - \r\n\r\n";
      }
      else 
      {
        newAttr.InnerText = "//## Version generated by " + CData.Instance.getVersionOfClassCodeUtility() + " \r\n\r\n";
      }
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("HEADER_MACRO");
      newAttr.InnerText = "#if defined (_MSC_VER) && (_MSC_VER >= 1000)\r\n" +
          "#pragma once\r\n" +
          "#endif\r\n" +
          "#ifndef _INC_C" + Desc_Table.TableName.ToString() + "_INCLUDED\r\n" +
          "#define _INC_C" + Desc_Table.TableName.ToString() + "_INCLUDED\r\n";
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("HEADER_INCLUDE");
      if (IsDBTable)
      {
        newAttr.InnerText = "#include \"CSMC_DBData.h\"\r\n\r\n";
      }
      else
      {
        newAttr.InnerText = "\r\n";
      }
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("HEADER_INCLUDE_MANUAL");
      newAttr.InnerText = "";
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("HEADER_INNER_UNDETECTEDCODE");
      newAttr.InnerText = "";
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("HEADER_OUTER_UNDETECTEDCODE");
      newAttr.InnerText = "";
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("HEADER_CLASS_MANUAL");
      newAttr.InnerText = "";
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("HEADER_CLASS");
      newAttr.InnerText = "class C" + Desc_Table.TableName.ToString() + "\r\n" + ": public CSMC_DBData\r\n";
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("HEADER_MEMBER");
      newAttr.InnerText = "";
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("HEADER_BODY");
      newAttr.InnerText = "{\r\n"; 
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("CPP_COMMENT");
      if (IsDBTable)
      {
        newAttr.InnerText = "//## Version generated by " + CData.Instance.getVersionOfDBClassCodeUtility() + " \r\n" +
          "//## ALL METHODS MARKED AS - //##DBClassCodeUtility - WILL BE OVERWRITTEN, IF DB CLASS RE-GENERATED \r\n" +
          "//## MANUALLY IMPLEMENTED METHODS MUST BE LOCATED BELOW THE MARK - \"YOUR-CODE\" - \r\n";
      }
      else
      {
        newAttr.InnerText = "//## Version generated by " + CData.Instance.getVersionOfClassCodeUtility() + " \r\n";
      }
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("GENERATED_COMMENT");
      newAttr.InnerText = m_GeneratedComment; 
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("CPP_INCLUDE");
      newAttr.InnerText = "#include \"C" + Desc_Table.TableName.ToString() + ".h\"\r\n\r\n";
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("CPP_INCLUDE_MANUAL");
      newAttr.InnerText = "";
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("ENDBODY");
      newAttr.InnerText = "};\r\n\r\n" +
        "#endif /* _INC_C" + Desc_Table.TableName.ToString() + "_INCLUDED */";
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("GENERATEDBY");
      newAttr.InnerText = "DBClassCodeUtility"; // mark as generated
      root.Attributes.Append(newAttr);

      newAttr = DBDoc.CreateAttribute("GENERATE");
      newAttr.InnerText = "YES"; // generate method
      root.Attributes.Append(newAttr);
      #endregion

      if (IsDBTable)
      {
        #region generate XML-Node for Constructor

        string ConstructorArgumentType = CData.Instance.ReadSetting("UserSettings", "ConstructorArgumentType");

        if (ConstructorArgumentType == "")
        {
          ConstructorArgumentType = "cCBS_StdConnection";
          CData.Instance.WriteSetting("UserSettings", "ConstructorArgumentType", ConstructorArgumentType);
          //ConstructorArgumentType += ",";
        }

        string DefaultConstructor = CData.Instance.ReadSetting("UserSettings", "DefaultConstructor");

        if (DefaultConstructor == "yes")
        {
          ConstructorArgumentType += ",DefaultConstructor";
        }

        string[] parts = ConstructorArgumentType.Split(',');

        foreach (string ConstructorArgumentTypePart in parts)
        {
          //use temporary XML-node for select-method
          select_method = DBDoc.CreateNode(XmlNodeType.Element, "METHOD", "");
          newAttr = DBDoc.CreateAttribute("NAME");
          newAttr.InnerText = "C" + Desc_Table.TableName; // constructor name
          select_method.Attributes.Append(newAttr);

          newAttr = DBDoc.CreateAttribute("CLASS");
          newAttr.InnerText = "C" + Desc_Table.TableName.ToString(); // Class name
          select_method.Attributes.Append(newAttr);

          newAttr = DBDoc.CreateAttribute("RET_TYPE");
          newAttr.InnerText = ""; // constructor returntype
          select_method.Attributes.Append(newAttr);

          newAttr = DBDoc.CreateAttribute("ACCESSIBILITY");
          newAttr.InnerText = "public:\r\n"; // public-key ACCESSIBILITY
          select_method.Attributes.Append(newAttr);

          newAttr = DBDoc.CreateAttribute("BODY");//constructor body
          if (ConstructorArgumentTypePart != "DefaultConstructor")
          {
            newAttr.InnerText = ":CSMC_DBData(\"" + Desc_Table.TableName + "\",Connection)\r\n";
          }
          else
          {
            newAttr.InnerText = ":CSMC_DBData(\"" + Desc_Table.TableName + "\")\r\n";
          }
          newAttr.InnerText += "{\r\n  //please implement virtual method, to initialize your members  \r\n  doOnConstruct(); \r\n}\r\n\r\n";
          select_method.Attributes.Append(newAttr);

          newAttr = DBDoc.CreateAttribute("BODYIDENTICAL");
          newAttr.InnerText = "YES"; // exist in table
          select_method.Attributes.Append(newAttr);

          newAttr = DBDoc.CreateAttribute("COLUMNEXISTS");
          newAttr.InnerText = "YES"; // exist in table
          select_method.Attributes.Append(newAttr);

          newAttr = DBDoc.CreateAttribute("FROM");
          newAttr.InnerText = "DB_constructor"; // generated from DB
          select_method.Attributes.Append(newAttr);

          newAttr = DBDoc.CreateAttribute("GENERATEDBY");
          newAttr.InnerText = "DBClassCodeUtility"; // mark as generated
          select_method.Attributes.Append(newAttr);

          newAttr = DBDoc.CreateAttribute("GENERATE");
          newAttr.InnerText = "YES"; // generate method
          select_method.Attributes.Append(newAttr);

          m_OrderNr++; // order number

          newAttr = DBDoc.CreateAttribute("ORDERNR");
          newAttr.InnerText = m_OrderNr.ToString(); // order number
          select_method.Attributes.Append(newAttr);

          arg = DBDoc.CreateNode(XmlNodeType.Element, "ARGUMENT", "");
          newAttr = DBDoc.CreateAttribute("ARG_TYPE");

          if (ConstructorArgumentTypePart != "DefaultConstructor")
          {
            newAttr.InnerText = ConstructorArgumentTypePart.Trim() + "*"; // argumenttype
            arg.Attributes.Append(newAttr);
            newAttr = DBDoc.CreateAttribute("NAME");
            newAttr.InnerText = "Connection"; // argumentname
            arg.Attributes.Append(newAttr);
            select_method.AppendChild(arg);
          }

          root.AppendChild(select_method);
        }

        #endregion

        #region generate XML-Node for Destructor

        //use temporary XML-node for select-method
        select_method = DBDoc.CreateNode(XmlNodeType.Element, "METHOD", "");
        newAttr = DBDoc.CreateAttribute("NAME");
        newAttr.InnerText = "~C" + Desc_Table.TableName; // destructor name
        select_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("CLASS");
        newAttr.InnerText = "C" + Desc_Table.TableName.ToString(); // Class name
        select_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("RET_TYPE");
        newAttr.InnerText = ""; // destructor returntype
        select_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("ACCESSIBILITY");
        newAttr.InnerText = "public:\r\n"; // public-key ACCESSIBILITY
        select_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("BODY");//destructor body
        newAttr.InnerText = "{\r\n  //please implement virtual method, to destruct your members\r\n  doOnDestruct(); \r\n}\r\n\r\n";
        select_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("BODYIDENTICAL");
        newAttr.InnerText = "YES"; // exist in table
        select_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("COLUMNEXISTS");
        newAttr.InnerText = "YES"; // exist in table
        select_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("FROM");
        newAttr.InnerText = "DB_destructor"; // generated from DB
        select_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("GENERATEDBY");
        newAttr.InnerText = "DBClassCodeUtility"; // mark as generated
        select_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("GENERATE");
        newAttr.InnerText = "YES"; // generate method
        select_method.Attributes.Append(newAttr);

        m_OrderNr++; // order number

        newAttr = DBDoc.CreateAttribute("ORDERNR");
        newAttr.InnerText = m_OrderNr.ToString(); // order number
        select_method.Attributes.Append(newAttr);

        root.AppendChild(select_method);

        #endregion
      }
      //string test = Desc_Table.Rows[0]["DATA_TYPE"].ToString();
      //string test1 = Desc_Table.Rows[0]["DATA_LENGTH"].ToString();
      //string test2 = Desc_Table.Rows[0]["DATA_SCALE"].ToString();
      
      for (int i = 0 ; i < Desc_Table.Rows.Count ; i++)
      {
        static_member = DBDoc.CreateNode(XmlNodeType.Element, "MEMBER", ""); // XML-node for static member
        get_method = DBDoc.CreateNode(XmlNodeType.Element, "METHOD", ""); // XML-node for get-method
        set_method = DBDoc.CreateNode(XmlNodeType.Element, "METHOD", ""); // XML-node for set-method
        colType = getColType(Desc_Table.Rows[i]["DATA_TYPE"].ToString(), Desc_Table.Rows[i]["DATA_LENGTH"].ToString(),
          Desc_Table.Rows[i]["DATA_SCALE"].ToString()); // type of column
        colName = Desc_Table.Rows[i]["COLUMN_NAME"].ToString(); // name of method/column
        colComment = Desc_Table.Rows[i]["COLUMN_COMMENT"].ToString(); // name of method/column

        if (isStatic)
        {
          #region generate XML-Node for static constant string member
          newAttr = DBDoc.CreateAttribute("HEADER_STATIC_MEMBER");
          newAttr.InnerText = "static const std::string " + colName + ";";
          static_member.Attributes.Append(newAttr);

          newAttr = DBDoc.CreateAttribute("CPP_STATIC_MEMBER");
          newAttr.InnerText = "const std::string " + className + "::" + colName + "(\"" + colName + "\");";
          static_member.Attributes.Append(newAttr);
          #endregion
        }

        #region generate XML-Node for getMethods
        newAttr = DBDoc.CreateAttribute("NAME");
        newAttr.InnerText = "get" + colName; // method name
        get_method.Attributes.Append(newAttr);

        
        newAttr = DBDoc.CreateAttribute("CLASS");
        newAttr.InnerText = "C" + Desc_Table.TableName.ToString(); // Class name
        get_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("RET_TYPE");
        if(colType.Equals("string"))
        {
          newAttr.InnerText = "std::" + colType; // get_method returntype
        }
        else
        {
          newAttr.InnerText = colType; // get_method returntype
        }
        get_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("ACCESSIBILITY");
        newAttr.InnerText = "public:\r\n"; // public-key ACCESSIBILITY
        get_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("COLUMN_COMMENT");
        newAttr.InnerText = colComment.Trim(); // COLUMN COMMENT from user table
        get_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("BODY");
        newAttr.InnerText = makeGetBody(colType,colName,className, isStatic); // get method body
        get_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("BODYIDENTICAL");
        newAttr.InnerText = "NO"; // check body
        get_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("COLUMNEXISTS");
        newAttr.InnerText = "NO"; // check table column in File (signature)
        get_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("FROM");
        newAttr.InnerText = "DB"; // generated from DB
        get_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("GENERATEDBY");
        newAttr.InnerText = "DBClassCodeUtility"; // mark as generated
        get_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("GENERATE");
        newAttr.InnerText = "YES"; // generate method
        get_method.Attributes.Append(newAttr);

        m_OrderNr++; // order number

        newAttr = DBDoc.CreateAttribute("ORDERNR");
        newAttr.InnerText = m_OrderNr.ToString(); // order number
        get_method.Attributes.Append(newAttr);

        arg = DBDoc.CreateNode(XmlNodeType.Element, "ARGUMENT", "");
        newAttr = DBDoc.CreateAttribute("ARG_TYPE");
        newAttr.InnerText = "long"; // argumenttype
        arg.Attributes.Append(newAttr);
        newAttr = DBDoc.CreateAttribute("NAME");
        newAttr.InnerText = "Row"; // argumentname
        arg.Attributes.Append(newAttr);
        get_method.AppendChild(arg);
        #endregion

        #region generate XML-Node for setMethods
        newAttr = DBDoc.CreateAttribute("NAME");
        newAttr.InnerText = "set" + colName;// method name
        set_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("CLASS");
        newAttr.InnerText = "C" + Desc_Table.TableName.ToString(); // Class name
        set_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("RET_TYPE");
        newAttr.InnerText = "void"; // set_method returntype
        set_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("ACCESSIBILITY");
        newAttr.InnerText = "public:\r\n"; // public-key ACCESSIBILITY
        set_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("COLUMN_COMMENT");
        colComment = colComment.Replace("\r", "");
        colComment = colComment.Replace("\n", ", ");
        colComment = colComment.Replace("\t", " ");
        newAttr.InnerText = colComment; // COLUMN COMMENT from user table
        get_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("BODY");
        newAttr.InnerText = makeSetBody(colType,colName,className,isStatic); // set method body
        set_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("BODYIDENTICAL");
        newAttr.InnerText = "NO"; // check body
        set_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("COLUMNEXISTS");
        newAttr.InnerText = "NO"; // check table column in File (signature)
        set_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("FROM");
        newAttr.InnerText = "DB"; // generated from DB
        set_method.Attributes.Append(newAttr);       

        newAttr = DBDoc.CreateAttribute("GENERATEDBY");
        newAttr.InnerText = "DBClassCodeUtility"; // mark as generated
        set_method.Attributes.Append(newAttr);

        newAttr = DBDoc.CreateAttribute("GENERATE");
        newAttr.InnerText = "YES"; // generate method
        set_method.Attributes.Append(newAttr);

        m_OrderNr++; // order number

        newAttr = DBDoc.CreateAttribute("ORDERNR");
        newAttr.InnerText = m_OrderNr.ToString(); // order number
        set_method.Attributes.Append(newAttr);

        arg = DBDoc.CreateNode(XmlNodeType.Element, "ARGUMENT", "");
        newAttr = DBDoc.CreateAttribute("ARG_TYPE");
        if(colType == "CDateTime")
          newAttr.InnerText = "const " + colType + "&"; // argumenttype
        else if(colType == "string")
          newAttr.InnerText = "const std::" + colType + "&"; // argumenttype
        else
          newAttr.InnerText = colType; // argumenttype
        arg.Attributes.Append(newAttr);
        newAttr = DBDoc.CreateAttribute("NAME");
        newAttr.InnerText = "value"; // argumentname
        arg.Attributes.Append(newAttr);
        set_method.AppendChild(arg);
        #endregion

        root.AppendChild(static_member);
        root.AppendChild(get_method);
        root.AppendChild(set_method);

        #region append attributes to default select-methode-node
        if(Desc_Table.Rows[i]["PK"].ToString() != "")// do for primary key only
        {
          if(!select_created)// do once only
          {
            select_method = DBDoc.CreateNode(XmlNodeType.Element, "METHOD", "");

            newAttr = DBDoc.CreateAttribute("NAME");
            newAttr.InnerText = "select"; // method name
            select_method.Attributes.Append(newAttr);

            newAttr = DBDoc.CreateAttribute("CLASS");
            newAttr.InnerText = "C" + Desc_Table.TableName.ToString(); // Class name
            select_method.Attributes.Append(newAttr);

            newAttr = DBDoc.CreateAttribute("RET_TYPE");
            newAttr.InnerText = "bool"; // select_method returntype
            select_method.Attributes.Append(newAttr);

            newAttr = DBDoc.CreateAttribute("ACCESSIBILITY");
            newAttr.InnerText = "public:\r\n"; // public-key ACCESSIBILITY
            select_method.Attributes.Append(newAttr);

            newAttr = DBDoc.CreateAttribute("BODY");//select_method body
            newAttr.InnerText = "{\r\n"; 
            newAttr.InnerText += "  cleanWhereStatement();\r\n\n"; 
            newAttr.InnerText += "  m_Statement = \"Select * from \" + m_TableName;\r\n\n"; 
            select_method.Attributes.Append(newAttr);
            select_created = true;

            newAttr = DBDoc.CreateAttribute("BODYIDENTICAL");
            newAttr.InnerText = "NO"; // check body
            select_method.Attributes.Append(newAttr);

            newAttr = DBDoc.CreateAttribute("COLUMNEXISTS");
            newAttr.InnerText = "NO"; // check table column in File (signature)
            select_method.Attributes.Append(newAttr);

            newAttr = DBDoc.CreateAttribute("GENERATEDBY");
            newAttr.InnerText = "DBClassCodeUtility"; // mark as generated
            select_method.Attributes.Append(newAttr);

            newAttr = DBDoc.CreateAttribute("GENERATE");
            newAttr.InnerText = "YES"; // generate method
            select_method.Attributes.Append(newAttr);
          }

          arg = DBDoc.CreateNode(XmlNodeType.Element, "ARGUMENT", "");
          newAttr = DBDoc.CreateAttribute("ARG_TYPE");
          if(colType == "CDateTime")
            newAttr.InnerText = "const " + colType + "&"; // argumenttype
          else if(colType == "string")
            newAttr.InnerText = "const std::" + colType + "&"; // argumenttype
          else
            newAttr.InnerText = colType; // argumenttype
          arg.Attributes.Append(newAttr);
          newAttr = DBDoc.CreateAttribute("NAME");
          newAttr.InnerText = colName; // argumentname
          arg.Attributes.Append(newAttr);
          select_method.AppendChild(arg);
          // There is an overloaded method in CSMC_DBData that CDateTime act. With this state it daoes not work with CSMC_DBData::unspecDate
          // if(colType == "CDateTime") // to convert CDateTime-type to DBString
          if (isStatic)
          {
            select_method.Attributes["BODY"].InnerText += "  addWhereClause(" + className + "::" + colName + "," + colName + ");\r\n";
          }
          else
          {
            select_method.Attributes["BODY"].InnerText += "  addWhereClause(\"" + colName + "\"," + colName + ");\r\n";
          }
        }
        #endregion

      }// loop for each row in Desc_Table

      if(select_created) // if select-method created
      {
        select_method.Attributes["BODY"].InnerText += "  m_Statement += getWhereStatement() + \";\";\r\n\n";
        select_method.Attributes["BODY"].InnerText += "  return CSMC_DBData::select();\r\n}\r\n\r\n";
        
        m_OrderNr++; // order number

        newAttr = DBDoc.CreateAttribute("ORDERNR");
        newAttr.InnerText = m_OrderNr.ToString(); // order number
        select_method.Attributes.Append(newAttr);

        root.AppendChild(select_method);
      }

      CData.Instance.setXmlDocument(DBDoc);
      return DBDoc;
    }// End of createNewClass

    // create XML to describe new class
    
    public XmlDocument createDefClass(DataTable Desc_Table, int detailIndex, int dataIndex)
    {
      XmlDocument m_DefDoc = new XmlDocument(); // XML-Document that contains the class description;
  
      XmlNode def_node, arg, root;
      XmlAttribute newAttr;
      string colType;
      string colName;
      string colValue;

      m_DefDoc.LoadXml("<CLASS> </CLASS>");
      root = m_DefDoc.FirstChild; // main node of XML-document

      #region root Attributes
      newAttr = m_DefDoc.CreateAttribute("CLASS");
      newAttr.InnerText = "C" + Desc_Table.TableName.ToString(); // Class name
      root.Attributes.Append(newAttr);

      newAttr = m_DefDoc.CreateAttribute("BODY_HEADER");
      newAttr.InnerText = "//## Copyright (C) " + DateTime.Now.Year.ToString() + " SMS Siemag AG, Germany\r\n" +
        "//## Version generated by " + CData.Instance.getVersionOfDBClassCodeUtility() + " \r\n\r\n" +
        "#if defined (_MSC_VER) && (_MSC_VER >= 1000)\r\n" +
        "#pragma once\r\n" +
        "#endif\r\n" +
        "#ifndef _INC_CDEF_" + Desc_Table.TableName.ToString() + "_INCLUDED\r\n" +
        "#define _INC_CDEF_" + Desc_Table.TableName.ToString() + "_INCLUDED\r\n\r\n" +
        "#include <string> \r\n\r\n" +
        "namespace DEF_" + Desc_Table.TableName.ToString() + "\r\n" +
        "{\r\n"; 
      root.Attributes.Append(newAttr);
      #endregion

      def_node = m_DefDoc.CreateNode(XmlNodeType.Element, "DEF", ""); // XML-node for get-method
      colType = getColType(Desc_Table.Rows[dataIndex]["DATA_TYPE"].ToString(), Desc_Table.Rows[dataIndex]["DATA_LENGTH"].ToString(),
        Desc_Table.Rows[dataIndex]["DATA_SCALE"].ToString()); // type of column
      colName = Desc_Table.Rows[detailIndex]["COLUMN_NAME"].ToString(); // name of method/column
      colValue = Desc_Table.Rows[dataIndex]["COLUMN_NAME"].ToString(); // name of method/column

      #region generate XML-Node for def_node      
      newAttr = m_DefDoc.CreateAttribute("NAME");
      newAttr.InnerText = colName; //name
      def_node.Attributes.Append(newAttr);

      newAttr = m_DefDoc.CreateAttribute("DEF_COMMENT");
      ArrayList comments = new ArrayList();
      comments = CData.Instance.getComments();
      int index=0;
      if((index=comments.IndexOf(colName)) == 0)
        newAttr.InnerText = comments[index+1].ToString(); //comment;
      else newAttr.InnerText = "";
      def_node.Attributes.Append(newAttr);

      newAttr = m_DefDoc.CreateAttribute("TYPE");
      newAttr.InnerText = colType; // type
      def_node.Attributes.Append(newAttr);

      newAttr = m_DefDoc.CreateAttribute("ACCESSIBILITY");
      newAttr.InnerText = "public:\r\n"; // public-key ACCESSIBILITY
      def_node.Attributes.Append(newAttr);

      newAttr = m_DefDoc.CreateAttribute("ROWNUMBER");
      newAttr.InnerText = detailIndex.ToString(); // index
      def_node.Attributes.Append(newAttr);
      ArrayList tableDataName = new ArrayList();
      ArrayList tableDataValue = new ArrayList();

      //sorted by ColumnName
      DataRow[] foundRows = CData.Instance.getTableData().Select(null,CData.Instance.getTableData().Columns[detailIndex].ColumnName); // Sort with Column name 

      for (int i = 0 ; i < CData.Instance.getTableData().Rows.Count; i++)
      {     
        tableDataName.Add(foundRows[i][colName].ToString()); // Name
        tableDataValue.Add(foundRows[i][colValue].ToString()); // Value
      }
     
      for (int i = 0 ; i < tableDataName.Count; i++)
      {
        arg = m_DefDoc.CreateNode(XmlNodeType.Element, "DATA", "");
        newAttr = m_DefDoc.CreateAttribute("DEFNAME");
        newAttr.InnerText = tableDataName[i].ToString(); // Name
        arg.Attributes.Append(newAttr);
     
        newAttr = m_DefDoc.CreateAttribute("DEFVALUE");
        newAttr.InnerText = tableDataValue[i].ToString(); // Value
        arg.Attributes.Append(newAttr);
     
        def_node.AppendChild(arg);
      }
      #endregion

      root.AppendChild(def_node);
      
      #region DefFromDatabase
      StreamWriter xr =  File.CreateText("DEF_NEW.xml");
      xr.WriteLine(m_DefDoc.InnerXml);
      xr.Close();
      #endregion

      return m_DefDoc;
    }// End of createDEF_Class

    // return column type
    private string getColType(string dbType, string dbLength, string dbScale)
    {
      if(dbType == "VARCHAR2")
      {
        if(dbLength == "23") return "CDateTime";
        else return "string";
      }
      else if(dbType == "NUMBER")
      {
        if(dbScale == "0") return "long";
        else return "double";
      }
      else if(dbType != "")
        return dbType;
      else return "unknown";
    }// End of getColType

    // return constructed body for get-method depended on column type
    
    private string makeGetBody(string colType, string colName, string className, bool IsStatic)
    {
      string body = "";
      body = "{\r\n"; // methodbody for cpp-file

      if ( IsStatic )
      {
        if (colType == "CDateTime")
        {
          body += "  CDateTime D;\r\n";
          body += "  D.fromDBString(getString(" + className + "::" + colName + ", Row));\r\n  return D;\r\n";
        }
        else if (colType == "string")
        {
          body += "  return getString(" + className + "::" + colName + ", Row);\r\n";
        }
        else if (colType == "long")
        {
          body += "  return getLong(" + className + "::" + colName + ", Row);\r\n";
        }
        else if (colType == "double")
        {
          body += "  return getDouble(" + className + "::" + colName + ", Row);\r\n";
        }
        else
        {
          body += "  return get" + colType + "(" + className + "::" + colName + ", Row);\r\n";
        }
      }
      else
      {
        if (colType == "CDateTime")
        {
          body += "  CDateTime D;\r\n";
          body += "  D.fromDBString(getString(\"" + colName + "\", Row));\r\n  return D;\r\n";
        }
        else if (colType == "string")
        {
          body += "  return getString(\"" + colName + "\", Row);\r\n";
        }
        else if (colType == "long")
        {
          body += "  return getLong(\"" + colName + "\", Row);\r\n";
        }
        else if (colType == "double")
        {
          body += "  return getDouble(\"" + colName + "\", Row);\r\n";
        }
        else
        {
          body += "  return get" + colType + "(\"" + colName + "\", Row);\r\n";
        }
      }

      body += "}\r\n\r\n";
      return body;
    }// End of makeGetBody

    // return constructed body for set-method depended on column type

    private string makeSetBody(string colType, string colName, string className, bool IsStatic)
    {
      string body = "";
      body = "{\r\n"; // methodbody for cpp

      if (IsStatic)
      {
        if (colType == "CDateTime")
        {
          body += " setString(" + className + "::" + colName + ", value.toDBString());\r\n";
        }
        else if (colType == "string")
        {
          body += "  setString(" + className + "::" + colName + ", value);\r\n";
        }
        else if (colType == "long")
        {
          body += "  setLong(" + className + "::" + colName + ", value);\r\n";
        }
        else if (colType == "double")
        {
          body += "  setDouble(" + className + "::" + colName + ", value);\r\n";
        }
        else
        {
          body += "  set" + colType + "(" + className + "::" + colName + ", value);\r\n";
        }
      }
      else
      {
        if (colType == "CDateTime")
        {
          body += " setString(\"" + colName + "\", value.toDBString());\r\n";
        }
        else if (colType == "string")
        {
          body += "  setString(\"" + colName + "\", value);\r\n";
        }
        else if (colType == "long")
        {
          body += "  setLong(\"" + colName + "\", value);\r\n";
        }
        else if (colType == "double")
        {
          body += "  setDouble(\"" + colName + "\", value);\r\n";
        }
        else
        {
          body += "  set" + colType + "(\"" + colName + "\", value);\r\n";
        }
      }
      body += "}\r\n\r\n";
      return body;
    }// End of makeSetBody
  
    // find generated methods
    bool findRightMethodInXmL(XmlDocument doc)
    {
      int count = 0;
      string infoAboutAllMethod = null;
      string Name = "";
      ExistMethodName = false;
      int LineIndex = 0;

      //read XMLData from Stack and saved it in nlist
      //XmlNodeList nlist = doc.GetElementsByTagName("METHOD");
      XmlNodeList nlist = doc.SelectNodes("/class/METHOD[@GENERATEDBY='DBClassCodeUtility']");

      for (int index = 0; index <= m_CurrentLineArray.Count - 1; index++)
      {
        m_CurrentLineArray[index] = m_CurrentLineArray[index].ToString().Trim();
      }
      
      //Search in the XmlDocument
      foreach (XmlNode method in nlist)
      {
        if (m_CurrentLineArray[LineIndex].Equals("string"))
        {
          m_CurrentLineArray[LineIndex] = "std::" + m_CurrentLineArray[LineIndex]; // method returntype
        }

        //In METHOD
        if (m_CurrentLineArray[LineIndex].Equals(method.Attributes.GetNamedItem("RET_TYPE").InnerText))
        {
          LineIndex = 3;
          infoAboutAllMethod = method.Attributes.GetNamedItem("ACCESSIBILITY").InnerText; 
          infoAboutAllMethod += " " + method.Attributes.GetNamedItem("RET_TYPE").InnerText;
          Name = m_CurrentLineArray[LineIndex].ToString();
        }
        else if (m_CurrentLineArray[0].ToString().Equals(m_CurrentLineArray[2].ToString()) &&
                 m_CurrentLineArray[2].ToString().ToUpper().Equals(method.Attributes.GetNamedItem("NAME").InnerText.ToUpper()) ) // construtor
        {
          LineIndex = 2;
          infoAboutAllMethod = method.Attributes.GetNamedItem("ACCESSIBILITY").InnerText;
          infoAboutAllMethod += " " + method.Attributes.GetNamedItem("RET_TYPE").InnerText;
          Name = m_CurrentLineArray[LineIndex].ToString();
        }
        else if (m_CurrentLineArray[2].ToString().Equals("~") &&
                (m_CurrentLineArray[2].ToString() + m_CurrentLineArray[3].ToString()).ToUpper().Equals(method.Attributes.GetNamedItem("NAME").InnerText.ToUpper()) ) // deconstrutor
        {
          LineIndex = 3;
          infoAboutAllMethod = method.Attributes.GetNamedItem("ACCESSIBILITY").InnerText;
          infoAboutAllMethod += " " + method.Attributes.GetNamedItem("RET_TYPE").InnerText;
          Name = (m_CurrentLineArray[LineIndex - 1].ToString() + m_CurrentLineArray[LineIndex].ToString());
        }
        else 
        {
          LineIndex = 0;
          continue;
        }
        
        count++;

        if (Name.ToUpper().Equals(method.Attributes.GetNamedItem("NAME").InnerText.ToUpper()))
        {
          ExistMethodName = true;
          int refIndex = 0;
          //review Select
          if (m_CurrentLineArray[LineIndex].Equals("select"))
          {
            string refSelectArg = null;  
            foreach (XmlNode methodData in method.ChildNodes)
            {
              if((refIndex=m_CurrentLineArray.IndexOf("&",refIndex+1)) !=-1 )
              {
                if(m_CurrentLineArray.IndexOf("std",refIndex-3) !=-1)
                {
                  refSelectArg += m_CurrentLineArray[refIndex-4];
                  refSelectArg += " " + m_CurrentLineArray[refIndex-3];
                  refSelectArg += m_CurrentLineArray[refIndex-2];
                  refSelectArg += m_CurrentLineArray[refIndex-1];
                  refSelectArg += m_CurrentLineArray[refIndex];
                  //refIndex=refIndex;
                }
                else
                {
                  refSelectArg += m_CurrentLineArray[refIndex-2];
                  refSelectArg += " " + m_CurrentLineArray[refIndex-1];
                  refSelectArg += m_CurrentLineArray[refIndex];
                  //refIndex=refIndex;
                }
              }
             
              //Argumentenüberpfrüfung implementiert für select!
              if(refSelectArg != null)
                if(m_CurrentLineArray.Contains(methodData.Attributes.GetNamedItem("ARG_TYPE").InnerText) 
                  || refSelectArg.Equals(methodData.Attributes.GetNamedItem("ARG_TYPE").InnerText))
                {    
                  infoAboutAllMethod += "\n " + methodData.Attributes.GetNamedItem("ARG_TYPE").InnerText + " \n";
                  refSelectArg = null; 
                  if(m_CurrentLineArray.Contains(methodData.Attributes.GetNamedItem("NAME").InnerText))
                  {
                    infoAboutAllMethod += "\n " + methodData.Attributes.GetNamedItem("NAME").InnerText + " \n";
                    infoAboutAllMethod += "\r\n\r\n In the database are absolutely identical arguments \r\n\r\n";
                  }// if(m_CurrentLineArray[6].ToString().Trim().Equals(methodData.Attributes.GetNamedItem("NAME").InnerText))
                  else 
                  {
                    infoAboutAllMethod += " From the database is only the arguments identical ARG_TYP \r\n\r\n";
                    ExistMethodName = false;
                    return false; 
                  }
                }// if(m_CurrentLineArray[5].Equals(methodData.Attributes.GetNamedItem("ARG_TYPE").InnerText))
                else
                {
                  infoAboutAllMethod += " In the database are not the same arguments \r\n\r\n";
                  ExistMethodName = false;
                  return false; 
                }
            }
          }//if(m_CurrentLineArray[3].Equals("select"))
          else
          {
            string refArg = null;
            // Childnodes überprüfen im Argument!
            if (method.ChildNodes.Count > 0)
            {
              foreach (XmlNode methodData in method.ChildNodes)
              {
                if ((refIndex = m_CurrentLineArray.IndexOf("&", refIndex + 1)) != -1)
                {
                  if (m_CurrentLineArray.IndexOf("std", refIndex - 3) != -1)
                  {
                    refArg += m_CurrentLineArray[refIndex - 4];
                    refArg += " " + m_CurrentLineArray[refIndex - 3];
                    refArg += m_CurrentLineArray[refIndex - 2];
                    refArg += m_CurrentLineArray[refIndex - 1];
                    refArg += m_CurrentLineArray[refIndex];
                    //refIndex=refIndex;
                  }
                  else
                  {
                    refArg += m_CurrentLineArray[refIndex - 2];
                    refArg += " " + m_CurrentLineArray[refIndex - 1];
                    refArg += m_CurrentLineArray[refIndex];
                    //refIndex=refIndex;
                  }
                }
                else
                {
                  refArg = methodData.Attributes.GetNamedItem("ARG_TYPE").InnerText;
                }

                //Argumentenüberpfrüfung implementiert get und set!
                if (refArg != null)
                  if (m_CurrentLineArray.Contains(methodData.Attributes.GetNamedItem("ARG_TYPE").InnerText)
                    || refArg.Equals(methodData.Attributes.GetNamedItem("ARG_TYPE").InnerText))
                  {
                    refArg = null;
                    infoAboutAllMethod += "\n " + methodData.Attributes.GetNamedItem("ARG_TYPE").InnerText + " \n";

                    if (m_CurrentLineArray.Contains(methodData.Attributes.GetNamedItem("NAME").InnerText))
                    {
                      infoAboutAllMethod += "\n " + methodData.Attributes.GetNamedItem("NAME").InnerText + " \n";
                      infoAboutAllMethod += "\r\n\r\n In the database are absolutely identical arguments\r\n\r\n";
                    }// if(m_CurrentLineArray[6].ToString().Trim().Equals(methodData.Attributes.GetNamedItem("NAME").InnerText))
                    else
                    {
                      infoAboutAllMethod += " From the database is only the arguments identical ARG_TYP \r\n\r\n";
                      ExistMethodName = false;
                      return false;
                    }
                  }// if(m_CurrentLineArray[5].Equals(methodData.Attributes.GetNamedItem("ARG_TYPE").InnerText))
                  else
                  {
                    infoAboutAllMethod += "  In the database are not the same arguments \r\n\r\n";
                    ExistMethodName = false;
                    return false;
                  }
              }
            }//if (method.ChildNodes.Count >= 0)
            else
            {
              int diff = 0;
              int startIndex = -1;
              int endIndex = -1;

              if ((startIndex = m_CurrentLineArray.IndexOf("(")) != -1 && (endIndex = m_CurrentLineArray.IndexOf(")")) != -1)
              {
                diff = endIndex - startIndex;
              }

              if (diff != 1)
              {
                ExistMethodName = false;
                infoAboutAllMethod += "  method with no generated arguments \r\n\r\n";
                return false;
              }
            }
          }
          infoAboutAllMethod += " This Method is in the DataBase \r\n\r\n";
          infoAboutAllMethod += " " + method.Attributes.GetNamedItem("NAME").InnerText;
          infoAboutAllMethod += " " + method.Attributes.GetNamedItem("BODY").InnerText;
               
          methodSummary += "Methode " + infoAboutAllMethod + " are found \r\n\r\n";
          methodSummary += "\n" + "-------------------" + " \r\n\r\n";
          return true;
        } // if(m_CurrentLineArray[3].Equals(method.Attributes.GetNamedItem("NAME").InnerText))
        else 
        {
          if( count!=nlist.Count ) continue;

          infoAboutAllMethod = "Missing  GetSet method: "+ m_CurrentLineArray[3].ToString() + 
            " does not correspond to the XML node " + method.Attributes.GetNamedItem("NAME").InnerText + " \r\n\r\n";
          methodSummary += infoAboutAllMethod + " \n";
          methodSummary += "\n" + "--------Please control------" + " \r\n\r\n";
          ExistMethodName = false;
          return false;  
        }
      }
      ExistMethodName = false;
      return false; 
    }

    
    bool findGetMethod(ArrayList TokenKindArray, XmlDocument doc)
    {
      //Struktur einer Methode
      if ( IsMethod(TokenKindArray) )
      { 
        if ((int)TokenKindArray[0]==54 && m_CurrentLineArray[3].ToString().Equals("select"))  // TTokenType.TOK_BOOL  
        {
          return true;
        }// if ((int)TokenKindArray[0]==54)  // TTokenType.TOK_BOOL  

        // TTokenType.TOK_ID || TTokenType.TOK_LONG || TTokenType.TOK_DOUBLE || // TTokenType.TOK_BOOL 
        if ((int)TokenKindArray[0]==136 || (int)TokenKindArray[0]==94 || (int)TokenKindArray[0]==71 || (int)TokenKindArray[0]==54)     
          if ((int)TokenKindArray[1]==136)                           // TTokenType.TOK_ID 
            if ((int)TokenKindArray[2]==42)                          // TTokenType.TOK_SCOPE 
              if ((int)TokenKindArray[3]==136)                       // TTokenType.TOK_ID
                if ((int)TokenKindArray[4]==23)                      // TTokenType.TOK_LPAREN 
                  if ((int)TokenKindArray[TokenKindArray.Count-2]==40)  // TTokenType.TOK_RPAREN
                  {
                    CountGet++;
                    return true;
                  } 
        return false;
      }
      return false;
    }

    string GetVisibility(ArrayList TokenKindArray)
    {
      //Struktur der Sichtbarkeit
      //if ((TokenKindArray.Contains(105) || TokenKindArray.Contains(104) || TokenKindArray.Contains(102)) && TokenKindArray.Contains(11))

      //private: TOK_PRIVATE,// 102
      if ((TokenKindArray.Contains(102)) && TokenKindArray.Contains(11))
      {
        return "private:";
      }
      //protected: TOK_PROTECTED, // 104
      else if ((TokenKindArray.Contains(104)) && TokenKindArray.Contains(11))
      {
        return "protected:";
      }
      //publíc: TTOK_PUBLIC,// 105
      else if ((TokenKindArray.Contains(105)) && TokenKindArray.Contains(11))
      {
        return "public:";
      }
      else
      {
        return "";
      }
    } 
    
    bool findSetMethod(ArrayList TokenKindArray)
    {
      if (IsMethod(TokenKindArray) )
      {
        if ((int)TokenKindArray[0]==(int)TTokenType.TOK_VOID)        // TTokenType.TOK_VOID  
          if ((int)TokenKindArray[1]==136)                           // TTokenType.TOK_ID 
            if ((int)TokenKindArray[2]==42)                          // TTokenType.TOK_SCOPE 
              if ((int)TokenKindArray[3]==136)                       // TTokenType.TOK_ID
                if ((int)TokenKindArray[4]==23)                      // TTokenType.TOK_LPAREN 
                  if ((int)TokenKindArray[TokenKindArray.Count-2]==40)  // TTokenType.TOK_RPAREN
                  {
                    CountSet++;
                    return true;
                  }             
      }
      return false;
    }

    bool IsMethod(ArrayList TokenKindArray)
    {
      //Struktur einer Methode
      if (TokenKindArray.Contains(136) && TokenKindArray.Contains(42) && TokenKindArray.Contains(23) /*&& TokenKindArray.Contains(40)*/ )
      {
        if ( TokenKindArray.Contains(40) )
        {
          IsMethodSignatureComplete = true;
        }
        else
        {
          IsMethodSignatureComplete = false;
        }
        return true;
      } 
      return false;
    }

    bool IsHeaderMethod(ArrayList TokenKindArray)
    {
      //Struktur einer Methode
      if (TokenKindArray.Contains(136) && TokenKindArray.Contains(23) /*&& TokenKindArray.Contains(40)*/ )
      {
        if (TokenKindArray.Contains(40) && TokenKindArray.Contains(43) )
        {
          IsMethodSignatureComplete = true;
        }
        else
        {
          IsMethodSignatureComplete = false;
        }
        return true;
      }
      return false;
    }

    // create a new attribute for XMLDocument
    public XmlAttribute NewAttribute(XmlDocument doc, string AttributeName, string Value)
    {
      XmlAttribute newAttr;
      newAttr = doc.CreateAttribute(AttributeName);
      newAttr.InnerText = Value; // method name
      return newAttr;  
    }
    
    // create XML-Document that describes class from existing file
    public XmlDocument parsingOfExistingFile(DataTable Desc_Table, string Filename, bool IsDBTable)
    {  
      bool IsMethodDetected   = false;
      bool IsGenerated        = false;
      bool controlBodyContent = false;
      bool IsOk               = false;
      string Body             = null;
      string Method           = null;
      int strIndex            = 0;
      int tokBracket          = 0;
      int fileBracket         = 0;
      
      int runner              = 0; // runner for TokenArray

      // copy generated code into the new xml file
      CData.Instance.setNewXmlDocument(CData.Instance.getXmlDocument());

      XmlDocument doc = CData.Instance.getXmlDocument();
      // make a local copy   
      newDoc = doc;

      Wrapper.Token tok = new Wrapper.Token();//object that describe on Token
      Wrapper.CWrapperScanner myScanner = new Wrapper.CWrapperScanner();// class to scan the file
      
      ArrayList TokenArray     = new ArrayList();//container for Tokens
      ArrayList TokenKindArray = new ArrayList();//container for kind of Tokens);

      string Comment      = null;
      string UnDetectedCode = null;
      string Macro = null;

      methodSummary += "\n" + "-------------------" + " \r\n\r\n";

      ////Nimmt das XML und speichert es zur Veranschaulichung!!
      //#region fromDatabase
      //StreamWriter sw =  File.CreateText("DB_TABLE.xml");
      ////sw.WriteLine(doc.FirstChild.Attributes["BODY_HEADER"].InnerText);
      //sw.WriteLine(doc.InnerXml);
      //sw.Close();
      //#endregion

      // MakeNewXmlFile
      XmlNode root = newDoc.LastChild;
      
      if(File.Exists((Filename + ".h")))
      {
        myScanner.setInFile(Filename + ".cpp");
        IsOk = myScanner.scan();
        //myScanner.getTokenTable(TokenArray);
        TokenArray = myScanner.getTokenTable();

        if(TokenArray.Count != 0)
        {
          StreamReader sr = new StreamReader((Filename + ".cpp"));
          
          XmlNode first;
          first = newDoc.FirstChild;

          tok = (Wrapper.Token)TokenArray[0];
          TokenKindArray.Add(tok.m_kind);
          runner++;
          
          while(runner < TokenArray.Count)
          {
            if(tok.m_kind == (int)TTokenType.TOK_CLASS && ((Wrapper.Token)TokenArray[runner+2]).m_kind != (int)TTokenType.TOK_SEMICOLON)
              if(((Wrapper.Token)TokenArray[runner+3]).m_kind != (int)TTokenType.TOK_SEMICOLON)// falls semikolon nach newline steht
              {
                runner++;
                tok = (Wrapper.Token)TokenArray[runner];
                doc.FirstChild.Attributes["NAME"].InnerText = tok.m_text;
                while(tok.m_kind != (int)TTokenType.TOK_LCURLY)
                {
                  if (tok.m_kind == (int)TTokenType.TOK_NEWLINE)
                  {
                    sr.ReadLine();
                  }
                  runner++;
                  tok = (Wrapper.Token)TokenArray[runner];
                }
                break;
              }

            TokenKindArray.Add(tok.m_kind);
            m_CurrentLineArray.Add(tok.m_text.ToString().Trim()); 
       
            // tokBracket counter
            if(tok.m_text.IndexOf("{") != -1)
              tokBracket++; // 20
            if(tok.m_text.IndexOf("}") != -1)
              tokBracket--; // 39

            //Wenn TOK_NEWLINE gefunden wurde dann wird die aktuelle Zeile eingelesen
            if(tok.m_kind == (int)TTokenType.TOK_NEWLINE)
            {
              string currentLine = sr.ReadLine();

              // fileBracket counter
              if (currentLine.IndexOf("{") != -1)
                fileBracket++; 
              if (currentLine.IndexOf("}") != -1)
                fileBracket--;

              if (runner == 1 && currentLine.IndexOf("Copyright (C)") != -1)
              {
                first.Attributes.GetNamedItem("SMS_COPYRIGHT").InnerText = currentLine + "\r\n";
              }

              if (runner >= 2)
              {
                // important dectect sync error in sec round ( -2="}", -1="/n" (Actual))
                if (tokBracket == 0 && ((Wrapper.Token)TokenArray[runner - 2]).m_text.Equals("}"))
                {
                  while ( fileBracket > 0 )
                  {
                    if ( newMethod != null && newMethod.Attributes["BODY"] != null)
                    {
                      string body = newMethod.Attributes["BODY"].InnerText.ToString();

                      newMethod.Attributes.GetNamedItem("BODY").InnerText = body.Insert(body.Length - 5, currentLine + "\n");
                    }

                    //korrigiert fehlendes /n in Datei
                    currentLine = sr.ReadLine();

                    // fileBracket counter
                    if (currentLine.IndexOf("{") != -1)
                      fileBracket++; 
                    if (currentLine.IndexOf("}") != -1)
                      fileBracket--;                   
                  }
                }// if (tokBracket == 0 && ((Wrapper.Token)TokenArray[runner - 2]).m_text.Equals("}"))
              }

              //Control the line for DB Comment
              if (currentLine.IndexOf(m_GeneratedComment) != -1)
              {
                IsGenerated = true;
              }
              else if (currentLine.IndexOf("//") != -1 && tokBracket == 0 && currentLine.IndexOf("//##") == -1
                && currentLine.IndexOf("Copyright (C)") == -1
                && currentLine.IndexOf("// ----------------") == -1 /*dont save generated code, for older versions (<=0.5.6)*/)
              {
                //save personal comments
                Comment += currentLine + "\r\n";
              }

              if (TokenKindArray.Contains((int)TTokenType.TOK_PNDINCLUDE) &&
                  currentLine.ToUpper().IndexOf(first.Attributes.GetNamedItem("CPP_INCLUDE").InnerText.TrimEnd().ToUpper()) == -1)
              {
                // own includes and exclude file e.g. #include "CGC_CHEM.h" 
                string include = first.Attributes["CPP_INCLUDE_MANUAL"].InnerText + "\r\n";
                if (Comment != null)
                {
                  first.Attributes.GetNamedItem("CPP_INCLUDE_MANUAL").InnerText = include + "\r\n" + Comment + currentLine.ToString(); 
                  Comment = null;
                }
                else
                {
                  first.Attributes.GetNamedItem("CPP_INCLUDE_MANUAL").InnerText = include + currentLine.ToString();
                }
              }

              //save only personal body method
              if (IsMethodDetected == true)
                Body += currentLine + "\n";

              if (m_CurrentLineArray[0].Equals("std") && m_CurrentLineArray[1].Equals("::"))
              {
                m_CurrentLineArray.RemoveRange(0, 2);
                TokenKindArray.RemoveRange(0, 2);
                m_CurrentLineArray.TrimToSize();
                TokenKindArray.TrimToSize();

                // need for visual studio 2005
                m_CurrentLineArray[0] = "std::" + m_CurrentLineArray[0].ToString();
              }

              if (IsGenerated && findGetMethod(TokenKindArray, doc))
              {
                methodSummary += currentLine + " \r\n\r\n";

                newMethod = newDoc.CreateNode(XmlNodeType.Element, "METHOD", "");

                if (findRightMethodInXmL(doc))
                {
                  IsMethodDetected = true;
                  controlBodyContent = true;
                }
                else
                {
                  // save to XML 
                  SaveNotFoundMethod();

                  newMethod.Attributes.Append(NewAttribute(newDoc, "SIGNATURE", currentLine));
                  newMethod.Attributes.Append(NewAttribute(newDoc, "INDEX", ""));

                  IsMethodDetected = true;
                  //flag für Methode die Behalten werden soll
                  controlBodyContent = false;
                }
              }
              else if (IsGenerated && findSetMethod(TokenKindArray))
              {
                methodSummary += currentLine + " \r\n\r\n";

                newMethod = newDoc.CreateNode(XmlNodeType.Element, "METHOD", "");

                if (findRightMethodInXmL(doc))
                {
                  IsMethodDetected = true;
                  controlBodyContent = true;
                }
                else
                {
                  SaveNotFoundMethod();

                  newMethod.Attributes.Append(NewAttribute(newDoc, "SIGNATURE", currentLine));
                  newMethod.Attributes.Append(NewAttribute(newDoc, "INDEX", ""));

                  IsMethodDetected = true;
                  //flag für Methode die Behalten werden soll
                  controlBodyContent = false;
                }
              }
              else if (IsGenerated && IsMethod(TokenKindArray))
              {
                // if no get set method is found !! 
                string className = first.Attributes["CLASS"].InnerText.ToString();
                int index = 0;

                if (!findRightMethodInXmL(doc) && (index = m_CurrentLineArray.IndexOf(className)) != -1)
                  if (!m_CurrentLineArray[index + 2].ToString().Equals(className))// exclude construtor
                    if (!m_CurrentLineArray[index + 3].ToString().Equals(className))// exclude deconstrutor
                    {
                      XmlNodeList DBClassCodeMethod;
                      DBClassCodeMethod = first.SelectNodes("/class/METHOD[@NAME='" + m_CurrentLineArray[index + 2] + "']");
                      if (DBClassCodeMethod.Count.Equals((int)1))
                      {
                        // if not found it must be generated
                        DBClassCodeMethod[0].Attributes["COLUMNEXISTS"].InnerText = "NO";
                      }
                    }
              }
              else if ( (IsGenerated == false && IsMethod(TokenKindArray) && IsMethodDetected == false) )
              {
                methodSummary += currentLine + " \r\n\r\n";
                Method += currentLine;

                int endOfMethod = Method.IndexOf(")");
                if (IsMethodSignatureComplete)
                {
                  Method = Method.Substring(0, endOfMethod + 1);
                }
                else
                {
                  Method += "\r\n";
                  tok = (Wrapper.Token)TokenArray[runner];
                  runner++;
                  continue;
                }

                if ( IsDBTable && (findGetMethod(TokenKindArray, doc) || findSetMethod(TokenKindArray) || IsMethod(TokenKindArray)) )
                {
                  methodSummary += currentLine + " \r\n\r\n";

                  newMethod = newDoc.CreateNode(XmlNodeType.Element, "METHOD", "");

                  if (findRightMethodInXmL(doc))
                  {
                    IsMethodDetected = true;
                    controlBodyContent = true;
                  }
                }// if (findGetMethod(TokenKindArray, doc) || findSetMethod(TokenKindArray) || IsMethod(TokenKindArray))

                string className = first.Attributes["CLASS"].InnerText.ToString();
                int index = m_CurrentLineArray.IndexOf(className);

                if (index == -1)
                {
                  index = m_CurrentLineArray.IndexOf("::");
                  while (className.ToUpper() != m_CurrentLineArray[index - 1].ToString().ToUpper())
                  {
                    index = m_CurrentLineArray.IndexOf("::", index+1);
                    if (index == -1)
                    {
                      break;
                    }
                  }
                  className = m_CurrentLineArray[index - 1].ToString();
                  index--;
                }

                if (!IsMethodDetected && index != -1)
                {
                  newMethod = newDoc.CreateNode(XmlNodeType.Element, "METHOD", "");

                  string sFrom = "FILE";
                  string sName = m_CurrentLineArray[index + 2].ToString().Trim();
                  string sClass = m_CurrentLineArray[index].ToString().Trim();
                  string sOrder = "YES";

                  // 49 == "~"
                  if (TokenKindArray.Contains(49))
                  {
                    sName = m_CurrentLineArray[index + 2].ToString().Trim() + m_CurrentLineArray[index + 3].ToString().Trim();
                    sOrder = "NO";
                    sFrom = "destructor";
                  }
                  else if (sName.ToUpper() == sClass.ToUpper())
                  {
                    sOrder = "NO";
                    sFrom = "constructor";
                  }

                  newMethod.Attributes.Append(NewAttribute(newDoc, "NAME", sName));
                  newMethod.Attributes.Append(NewAttribute(newDoc, "CLASS", sClass));

                  string sRetType = m_CurrentLineArray[0].ToString().Trim();
                  if (sRetType.Equals("string"))
                  {
                    sRetType = "std::" + sRetType; // method returntype
                    Method = "std::" + Method;   // method returntype
                  }

                  newMethod.Attributes.Append(NewAttribute(newDoc, "ACCESSIBILITY", "public:\r\n"));

                  newMethod.Attributes.Append(NewAttribute(newDoc, "RET_TYPE", sRetType));
                  newMethod.Attributes.Append(NewAttribute(newDoc, "CPP_COMMENT", Comment));
                  newMethod.Attributes.Append(NewAttribute(newDoc, "SIGNATURE", Method));
                  newMethod.Attributes.Append(NewAttribute(newDoc, "FROM", sFrom));

                  newMethod.Attributes.Append(NewAttribute(newDoc, "ORDER", sOrder));

                  newMethod.Attributes.Append(NewAttribute(newDoc, "HEADER_RET_TYPE", ""));
                  newMethod.Attributes.Append(NewAttribute(newDoc, "HEADER_COMMENT", ""));
                  newMethod.Attributes.Append(NewAttribute(newDoc, "HEADER_SIGNATURE", ""));

                  newMethod.Attributes.Append(NewAttribute(newDoc, "INDEX", ""));
                  newMethod.Attributes.Append(NewAttribute(newDoc, "LINESAVE", "YES"));

                  //SaveNotFoundMethod(saveMethod);
                  IsMethodDetected = true;
                  //flag für Methode die Behalten werden soll
                  controlBodyContent = false;

                }
              }

              Method = null;

              TokenKindArray.Clear();
              //Falls es der Body der Methode ist wird weitergelesen, ansonsten wird verworfen
              if (!IsMethodDetected) m_CurrentLineArray.Clear();
            }// if(tok.m_kind == (int)TTokenType.TOK_NEWLINE)

            //Wenn } und eigene CPP Methode gefunden wurde dann wird Methode in XML geschrieben
            if(tok.m_kind== (int)TTokenType.TOK_RCURLY  && IsMethodDetected && tokBracket == 0 ) // TTokenTypeTOK_RCURLY == }
            {  
              //Hinzufügen des Body's
              int count = 0;
              int index = m_CurrentLineArray.Count;
              foreach(string sobj in m_CurrentLineArray)
              {
                //Anfang vom Body Suchen und in String speichern
                if(sobj.Equals("{")) 
                {
                  index = count;
                  break;
                }
                count++;
              }
              //Damit beim speichern für  SaveNotFoundMethod() nicht der Body dabei ist
              m_CurrentLineArray.RemoveRange(index-1, (m_CurrentLineArray.Count-1)-(index-2));
              m_CurrentLineArray.TrimToSize();
              
              Body += "}\r\n\r\n";
              
              if(controlBodyContent == false)
              {
                if (ExistMethodName == true)
                {
                  // error in argument list
                  string className =  first.Attributes["CLASS"].InnerText.ToString();
                  int classNameIndex = 0;
                  
                  if ( (classNameIndex=m_CurrentLineArray.IndexOf(className)) != -1 )             
                  {
                    XmlNodeList DBClassCodeMethod;
                    DBClassCodeMethod = first.SelectNodes("/class/METHOD[@NAME='" + m_CurrentLineArray[classNameIndex+2] + "' and @GENERATEDBY='DBClassCodeUtility']");
                    if (DBClassCodeMethod.Count.Equals((int)1))
                    {
                      DBClassCodeMethod[0].Attributes["COLUMNEXISTS"].InnerText = "YES";
                    }
                  }
                }
                else if (ExistMethodName == false)
                {
                  m_OrderNr++; // order number
                  if ( IsGenerated )
                  {
                    // an old generated method so it must be delete (only for visualization)  
                    newMethod.Attributes.Append( NewAttribute(newDoc, "BODY", Body ));
                    newMethod.Attributes.Append( NewAttribute(newDoc, "BODYIDENTICAL", "NO") );
                    newMethod.Attributes.Append( NewAttribute(newDoc, "COLUMNEXISTS", "NO") );
                    newMethod.Attributes.Append( NewAttribute(newDoc, "GENERATEDBY", "DBClassCodeUtility") );
                    // user information
                    newMethod.Attributes.Append( NewAttribute(newDoc, "GENERATE", "NO") );
                    newMethod.Attributes.Append(NewAttribute(newDoc, "ORDERNR", m_OrderNr.ToString()));
                  }
                  else
                  {
                    // personal method (user information) 
                    newMethod.Attributes.Append( NewAttribute(newDoc, "BODY", Body ));
                    newMethod.Attributes.Append( NewAttribute(newDoc, "BODYIDENTICAL", "NO") );
                    newMethod.Attributes.Append( NewAttribute(newDoc, "COLUMNEXISTS", "NO") );
                    //flache Kopie der CPP Methode  
                    newMethod.Attributes.Append( NewAttribute(newDoc, "GENERATEDBY", "MANUAL") );
                    // user information
                    newMethod.Attributes.Append( NewAttribute(newDoc, "GENERATE", "NO") );
                    newMethod.Attributes.Append(NewAttribute(newDoc, "ORDERNR", m_OrderNr.ToString()));
                  }
                  root.AppendChild(newMethod);
                }

                // für den Texteditor
                Body = Body.Replace("\n","\r\n");
                methodSummary += Body + " \r\n\r\n";
                methodSummary += " Is not the same but can be wrapped" + " \r\n\r\n";
                methodSummary += "\n" + "-------------------" + " \r\n\r\n";
              }// if(controlBodyContent == false)
              else 
              { 
                // control generated methods
                //Filter XML Body in summary
                string bodyXML= null;
                string bodyCPP= null;

                strIndex=methodSummary.IndexOf(m_CurrentLineArray[3].ToString(), strIndex);
                strIndex=methodSummary.IndexOf("{", strIndex+10);
                if(strIndex!=-1)
                {
                  //length of Body string
                  int diflength = methodSummary.IndexOf("}", strIndex) - strIndex;
                  bodyXML = methodSummary.Substring(strIndex,diflength+1);
                  bodyXML= bodyXML.Replace("\r", "");
                  bodyXML= bodyXML.Replace("\n", "");
                  bodyXML= bodyXML.Replace("\t", "");
                  bodyXML= bodyXML.Replace(" ", "");
                  bodyCPP= Body.Replace("\n", "");
                  bodyCPP= bodyCPP.Replace("\t", "");
                  bodyCPP= bodyCPP.Replace("\r", "");
                  bodyCPP= bodyCPP.Replace(" ", "");
                  
                  //Wenn Body's ungleich sind wird es in checker.txt vermerkt und zum generieren angeboten
                  if(!bodyCPP.Equals(bodyXML))
                  {
                    SaveNotFoundMethod();

                    m_OrderNr++; // order number

                    // diff body must replaced (only for visualization in XML File which method is affected) 
                    newMethod.Attributes.Append( NewAttribute(newDoc, "BODY", Body ));                  
                    newMethod.Attributes.Append( NewAttribute(newDoc, "BODYIDENTICAL", "NO" ));
                    newMethod.Attributes.Append( NewAttribute(newDoc, "COLUMNEXISTS", "YES") );
                    newMethod.Attributes.Append( NewAttribute(newDoc, "FROM", "FILE") );
                    newMethod.Attributes.Append( NewAttribute(newDoc, "GENERATEDBY", "DBClassCodeUtility") );
                    newMethod.Attributes.Append( NewAttribute(newDoc, "GENERATE", "NO" ) );
                    newMethod.Attributes.Append(NewAttribute(newDoc, "ORDERNR", m_OrderNr.ToString()));
                
                    strIndex=methodSummary.IndexOf("are found", strIndex);
                    //Paste Body from CPP File in summary
                    if(strIndex!=-1)
                    {
                      methodSummary = methodSummary.Insert(strIndex, " This method is from your CPP-File " + " \r\n\r\n");
                      strIndex=methodSummary.IndexOf("CPP-File", strIndex);
                      for(int i=Body.IndexOf(";"); i >= 0; i=Body.IndexOf(";", i+1 ))
                      {
                        Body = Body.Insert(i+1, "\r\n");
                      }
                      methodSummary = methodSummary.Insert(strIndex+10, "\r\n\r\n " + Body.Trim());
                    }//if(strIndex!=-1)

                    root.AppendChild(newMethod);
                  }//if(!bodyCPP.Equals(bodyXML))
                  else
                  {
                    string className =  first.Attributes["CLASS"].InnerText.ToString();
                    int classNameIndex = 0;
                  
                    if ( (classNameIndex=m_CurrentLineArray.IndexOf(className)) != -1 )             
                    {
                      XmlNodeList DBClassCodeMethod;
                      DBClassCodeMethod = first.SelectNodes("/class/METHOD[@NAME='" + m_CurrentLineArray[classNameIndex+2] + "']");
                      if ( DBClassCodeMethod.Count.Equals((int)1) )
                      {
                        DBClassCodeMethod[0].Attributes["COLUMNEXISTS"].InnerText = "YES";
                        DBClassCodeMethod[0].Attributes["BODYIDENTICAL"].InnerText = "YES";
                      }
                    }            
                  }
                }//if(strIndex!=-1)
              }//if(controlBodyContent==true)
              
              //reset for next method
              controlBodyContent = false;
              IsMethodDetected           = false;
              IsGenerated        = false;
              ExistMethodName    = false;
              Body               = null;
              Comment            = null;
              m_CurrentLineArray.Clear();   
            }//if(tok.m_kind== (int)TTokenType.TOK_RCURLY && IsMethodDetected)
            else if(tok.m_kind== (int)TTokenType.TOK_RCURLY && tokBracket == 0 ) // TTokenTypeTOK_RCURLY == }
            {
              IsGenerated = false;       
            }
            //          end:

            tok = (Wrapper.Token)TokenArray[runner];
            runner++;               
          }
          sr.Close();
        }

        TokenArray.Clear();
        TokenKindArray.Clear();
        m_CurrentLineArray.Clear();

        //reset for header
        IsMethodDetected   = false;
        IsGenerated        = false;
        Comment            = null;
        UnDetectedCode     = null;

        #region ShowNewXmlFile
        StreamWriter sw = File.CreateText("DB_TABLE.xml");
        sw.WriteLine(newDoc.InnerXml);
        sw.Close();
        #endregion

        // -- HEADERFILE ---
        myScanner.setInFile(Filename + ".h");
        myScanner.scan();
        TokenArray = myScanner.getTokenTable(); 

        if(TokenArray.Count != 0)
        {
          bool IsBodyOfHeaderClass = false;
          bool IsHeaderClass = false;
          string Visibility = "public:";
          bool IsVisibilityChanged = false;
          // get class name
          XmlNode first = newDoc.FirstChild;
          string ClassName = first.Attributes["CLASS"].InnerText.ToString();

          StreamReader sr = new StreamReader((Filename + ".h"));
          tok = (Wrapper.Token)TokenArray[runner];
          TokenKindArray.Add(tok.m_kind);
          runner++;

          while (runner < TokenArray.Count)
          {
            TokenKindArray.Add(tok.m_kind);
            m_CurrentLineArray.Add(tok.m_text.ToString().Trim());

            // tokBracket counter
            if (tok.m_text.IndexOf("{") != -1)
              tokBracket++; // 20
            if (tok.m_text.IndexOf("}") != -1)
              tokBracket--; // 39

            //Wenn TOK_NEWLINE gefunden wurde dann wird die aktuelle Zeile eingelesen
            if (tok.m_kind == (int)TTokenType.TOK_NEWLINE)
            {
              string currentLine = sr.ReadLine();
              //Control the line for DB Comment

              int IndexComment = -1;
              if (currentLine.IndexOf(m_GeneratedComment) != -1)
              {
                IsGenerated = true;
              }
              else if ( (IndexComment=currentLine.IndexOf("//")) != -1 
                && currentLine.IndexOf("//##") == -1
                && currentLine.IndexOf("Copyright (C)") == -1
                /*dont save generated code, for older versions (<=0.5.6)*/
                && currentLine.IndexOf("// ----------------") == -1 
                )
              {
                // bool select();   // make problem: comment at end of method
                //currentLine.Remove(0, IndexComment);
                //save personal comments
                Comment += currentLine + "\r\n";
              }

              if (TokenKindArray.Contains((int)TTokenType.TOK_CLASS) && TokenKindArray.Contains((int)TTokenType.TOK_SEMICOLON))
              {
                // save class declaration
                first.Attributes["HEADER_CLASS_MANUAL"].InnerText = first.Attributes["HEADER_CLASS_MANUAL"].InnerText + currentLine.ToString() + "\r\n";
              } 
              // class Foo
              else if (TokenKindArray.Contains(60) && TokenKindArray.Contains(136) && m_CurrentLineArray[1].ToString().ToUpper().Equals(ClassName.ToUpper()))
              {
                IsHeaderClass = true;
                first.Attributes["HEADER_OUTER_UNDETECTEDCODE"].InnerText = UnDetectedCode;
                UnDetectedCode = null;

                // save own class
                first.Attributes["HEADER_CLASS"].InnerText = currentLine.ToString();
              }
              else if (IsHeaderClass && !IsBodyOfHeaderClass && tokBracket == 1)
              {
                IsBodyOfHeaderClass = true;
                Comment = null;
              }
              // first save all inherit infornation. second class end is reached (IsBodyOfHeaderClass = false)
              else if (IsHeaderClass && tokBracket == 0)
              {
                //save all inherit information.
                if (!IsBodyOfHeaderClass)
                {
                  first.Attributes["HEADER_CLASS"].InnerText = first.Attributes["HEADER_CLASS"].InnerText + "\r\n"  + currentLine.ToString();
                }
                else
                {
                  // important dectect sync error in sec round ( -2="}", -1="/n" (Actual))
                  if (((Wrapper.Token)TokenArray[runner - 2]).m_text.Equals("}"))
                  {
                    IsBodyOfHeaderClass = false;
                    IsHeaderClass = false;
                  }// if (tokBracket == 0 && ((Wrapper.Token)TokenArray[runner - 2]).m_text.Equals("}"))
                }
              }     
              //save manual include
              else if (TokenKindArray.Contains((int)TTokenType.TOK_PNDINCLUDE))
              {
                if (IsDBTable)
                {
                  if (currentLine.IndexOf("#include \"CSMC_DBData.h\"") == -1)
                  {
                    // own includes and exclude file e.g. #include "CGC_CHEM.h" 
                    string include = first.Attributes["HEADER_INCLUDE_MANUAL"].InnerText + "\r\n";
                    if (Comment != null)
                    {
                      first.Attributes.GetNamedItem("HEADER_INCLUDE_MANUAL").InnerText = include + "\r\n" + Comment + currentLine.ToString();
                      Comment = null;
                    }
                    else
                    {
                      first.Attributes.GetNamedItem("HEADER_INCLUDE_MANUAL").InnerText = include + currentLine.ToString();
                    }
                  }
                }// if (IsDBTable)
                else
                {
                  // own includes and exclude file e.g. #include "CGC_CHEM.h" 
                  string include = first.Attributes["HEADER_INCLUDE_MANUAL"].InnerText + "\r\n";
                  if (Comment != null)
                  {
                    first.Attributes.GetNamedItem("HEADER_INCLUDE_MANUAL").InnerText = include + "\r\n" + Comment + currentLine.ToString();
                    Comment = null;
                  }
                  else
                  {
                    first.Attributes.GetNamedItem("HEADER_INCLUDE_MANUAL").InnerText = include + currentLine.ToString();
                  }
                }
              }// else if (TokenKindArray.Contains((int)TTokenType.TOK_PNDINCLUDE))
              else if (IsBodyOfHeaderClass && !IsMethodDetected && tokBracket == 1 && IsHeaderMethod(TokenKindArray))
              /* check method code*/
              {
                Method += currentLine;

                int endOfMethod = Method.IndexOf(";");
                if (IsMethodSignatureComplete)
                {
                  Method = Method.Substring(0, endOfMethod + 1);
                }
                else
                {
                  Method += "\r\n";
                  tok = (Wrapper.Token)TokenArray[runner];
                  runner++;
                  continue;
                }

                Method = Method.Trim();

                if (!IsGenerated)
                {
                  /* save manual method code*/
                  int index = 0;

                  if ((index = m_CurrentLineArray.IndexOf("(")) != -1)
                  {
                    string sMethodName = m_CurrentLineArray[index - 1].ToString().Trim();
                    string sRetType    = m_CurrentLineArray[0].ToString().Trim();

                    // 49 == "~"
                    if (TokenKindArray.Contains(49))
                    {
                      sMethodName = m_CurrentLineArray[index - 2].ToString().Trim() + m_CurrentLineArray[index - 1].ToString().Trim();
                    }

                    XmlNodeList ManualClassCodeMethodList = first.SelectNodes("/class/METHOD[@NAME='" + sMethodName + "' and @GENERATEDBY='MANUAL']");
                    
                    if (ManualClassCodeMethodList.Count == 1)
                    {
                      foreach (XmlNode methods in ManualClassCodeMethodList)
                      {
                        methods.Attributes.GetNamedItem("ACCESSIBILITY").InnerText = Visibility + "\r\n";
                        methods.Attributes.GetNamedItem("HEADER_RET_TYPE").InnerText = sRetType;
                        methods.Attributes.GetNamedItem("HEADER_COMMENT").InnerText = Comment;
                        methods.Attributes.GetNamedItem("HEADER_SIGNATURE").InnerText = Method;
                      }                      
                    }
                    else 
                    {
                      // overladed mothod
                      foreach (XmlNode methods in ManualClassCodeMethodList)
                      {
                        string cppsignature = methods.Attributes.GetNamedItem("SIGNATURE").InnerText;
                        string hsignature = Method;
                        cppsignature = cppsignature.Replace(ClassName + "::", "");
                        cppsignature = cppsignature + ";";
                        
                        while((index = hsignature.IndexOf("=")) != -1)
                        {
                          int endIndex = 0;
                          if ((endIndex = hsignature.IndexOf(",", index)) != -1 || (endIndex = hsignature.IndexOf(")", index)) != -1)
                          {
                            hsignature = hsignature.Remove(index, endIndex - index);
                          }
                        }// while((index = hsignature.IndexOf("=")) != -1)

                        cppsignature = cppsignature.ToLower().Trim().Replace(" ", "");
                        hsignature = hsignature.ToLower().Trim().Replace(" ", "");
                        if (cppsignature == hsignature)
                        {
                          methods.Attributes.GetNamedItem("ACCESSIBILITY").InnerText = Visibility + "\r\n";
                          methods.Attributes.Append(NewAttribute(newDoc, "HEADER_RET_TYPE", sRetType));
                          methods.Attributes.Append(NewAttribute(newDoc, "HEADER_COMMENT", Comment));
                          methods.Attributes.Append(NewAttribute(newDoc, "HEADER_SIGNATURE", Method));
                        }
                      }//  foreach (XmlNode methods in DBClassCodeMethodList) 
                    }
                  }// if ((index = m_CurrentLineArray.IndexOf("(")) != -1)
                }

                IsMethodDetected = true;
              }
              // memebers
              else if (TokenKindArray.Contains((int)TTokenType.TOK_SEMICOLON) && currentLine.IndexOf("m_") != -1)
              {
                string sMember = first.Attributes["HEADER_MEMBER"].InnerText;

                if (sMember != "")
                {
                  sMember = sMember + "\r\n";
                }

                if (Comment != null)
                {
                  if (IsVisibilityChanged)
                  {
                    first.Attributes.GetNamedItem("HEADER_MEMBER").InnerText = sMember + "\r\n" + Visibility + "\r\n" + Comment + currentLine.ToString();
                    IsVisibilityChanged = false;
                  }
                  else
                  {
                    first.Attributes.GetNamedItem("HEADER_MEMBER").InnerText = sMember + "\r\n" + Comment + currentLine.ToString();
                  }
                  Comment = null;
                }
                else
                {
                  if (IsVisibilityChanged)
                  {
                    first.Attributes.GetNamedItem("HEADER_MEMBER").InnerText = sMember + "\r\n" + Visibility + "\r\n" + currentLine.ToString();
                    IsVisibilityChanged = false;
                  }
                  else
                  {
                    first.Attributes.GetNamedItem("HEADER_MEMBER").InnerText = sMember + currentLine.ToString();
                  }
                }
              }// else if (TokenKindArray.Contains((int)TTokenType.TOK_SEMICOLON) && currentLine.IndexOf("m_") != -1)
              else
              {
                if (!IsGenerated && currentLine.Trim().Length >= 1 && currentLine.IndexOf("//##") == -1 && currentLine.IndexOf("Copyright (C)") == -1 )
                {
                  if (IsBodyOfHeaderClass)
                  {
                    string CheckVisibility = GetVisibility(TokenKindArray);

                    if (currentLine.IndexOf("//") == -1)
                    {
                      if (CheckVisibility == "")
                      {
                        UnDetectedCode += currentLine + " \r\n";
                        IsVisibilityChanged = false;
                      }
                      else
                      {
                        if (CheckVisibility == Visibility)
                        {
                          IsVisibilityChanged = false;
                        }
                        else
                        {
                          IsVisibilityChanged = true;
                        }

                        Visibility = CheckVisibility;
                      }
                    }
                  }//if (IsBodyOfHeaderClass)
                  else
                  {
                    if (TokenKindArray.Contains(145) || TokenKindArray.Contains(146) || TokenKindArray.Contains(148) || TokenKindArray.Contains(151) || TokenKindArray.Contains(154))
                    {
                      Macro = Macro + currentLine.ToString() + "\r\n";
                    }
                    else
                    {
                      UnDetectedCode += currentLine + "\r\n";
                    }
                  }
                }// if (!IsGenerated && currentLine.Trim().Length >= 1 && currentLine.IndexOf("//##") == -1)
                else if (IsBodyOfHeaderClass)
                {
                  string CheckVisibility = GetVisibility(TokenKindArray);

                  if (currentLine.IndexOf("//") == -1)
                  {
                    if (CheckVisibility == "")
                    {
                      IsVisibilityChanged = false;
                    }
                    else
                    {
                      if (CheckVisibility == Visibility)
                      {
                        IsVisibilityChanged = false;
                      }
                      else
                      {
                        IsVisibilityChanged = true;
                      }

                      Visibility = CheckVisibility;
                    }
                  }//if (currentLine.IndexOf("//") == -1)
                }//else if (IsBodyOfHeaderClass)
              }

              if (IsBodyOfHeaderClass && IsMethodDetected)
              {
                //reset for next method
                IsMethodDetected = false;
                IsGenerated = false;
                ExistMethodName = false;
                Comment = null;
                Method = null;
              }

              TokenKindArray.Clear();
              m_CurrentLineArray.Clear();
            }// if( tok.m_kind == (int)TTokenType.TOK_NEWLINE )

            tok = (Wrapper.Token)TokenArray[runner];
            runner++;
          }
          sr.Close();

          if (Macro != null)
          {
            first.Attributes["HEADER_MACRO"].InnerText = Macro;
          }

          first.Attributes["HEADER_INNER_UNDETECTEDCODE"].InnerText = UnDetectedCode;
        }
      }

      //#region ShowNewXmlFile
      //StreamWriter xr = File.CreateText("DB_TABLE.xml");
      //xr.WriteLine(newDoc.InnerXml);
      //xr.Close();
      //#endregion

      if (CData.Instance.ReadSetting("UserSettings", "ManualMethodSort") == "yes")
      {
        #region SortNewXmlFile
        // In the following elements in the newDoc xml are sorted by name

        XPathNavigator navigator = newDoc.CreateNavigator(); 
        XPathExpression expression = navigator.Compile(("/class/METHOD[@GENERATEDBY='MANUAL' and @ORDER='YES']"));
        expression.AddSort("@NAME", new MethodComparer());
        XPathNodeIterator nodes = navigator.Select(expression);

        IsOk = navigator.MoveToChild("class", "");
        IsOk = navigator.MoveToChild("METHOD", "");

        //while (navigator.MoveToNext())
        //{
        //  if ("MANUAL" == navigator.GetAttribute("GENERATEDBY", ""))
        //  {
        //    break;
        //  }
        //}

        while (nodes.MoveNext())
        {
          XPathNavigator node = nodes.Current;

          if (node.IsNode)
          {
            //testx.AppendChild(((System.Xml.IHasXmlNode)node).GetNode());
            //testx.AppendChild(((XmlNode)node.UnderlyingObject));

            //node.MoveToAttribute("id", "");
            //node.SetValue("5");

            //string sCurrentNode = node.OuterXml;

            //string poNum = node.GetAttribute("NAME", "");
            //string piNum = navigator.GetAttribute("NAME", "");

            while (!("MANUAL" == navigator.GetAttribute("GENERATEDBY", "") && "YES" == navigator.GetAttribute("ORDER", "")) )
            {
              IsOk = navigator.MoveToNext();
            }

            navigator.ReplaceSelf(node);

            IsOk = navigator.MoveToNext();
          }

          //string poNum = node.GetAttribute("NAME", "");
          //XPathNodeIterator children = node.SelectChildren(XPathNodeType.All);
          //while (children.MoveNext())
          //{
          //  XPathNavigator child = children.Current;
          //  //string lineNumber = child.GetAttribute("line", "");
          //  //string id = child.GetAttribute("id", "");
          //}
        }// while (nodes.MoveNext())
        #endregion

        //#region ShowNewXmlFile
        //xr = File.CreateText("DB_TABLE.xml");
        //xr.WriteLine(newDoc.InnerXml);
        //xr.Close();
        //#endregion
      }

      #region ShowNewXmlFile
      StreamWriter xr = File.CreateText("DB_TABLE.xml");
      xr.WriteLine(newDoc.InnerXml);
      xr.Close();
      #endregion

      // copy code into the xml file
      CData.Instance.setNewXmlDocument(newDoc);

      CData.Instance.setNewSummary(methodSummary);   

      return doc;
    }
    
    // to new XML file
    void SaveNotFoundMethod()
    {     
      // Is not identical to the database! and must be ordered for xml file
      newMethod.Attributes.Append( NewAttribute(newDoc, "NAME", m_CurrentLineArray[3].ToString().Trim()) );
      newMethod.Attributes.Append( NewAttribute(newDoc, "CLASS", m_CurrentLineArray[1].ToString().Trim()) );

      string sRetType = m_CurrentLineArray[0].ToString().Trim();
      if (sRetType.Equals("string"))
      {
        sRetType = "std::" + sRetType; // method returntype
      }

      newMethod.Attributes.Append(NewAttribute(newDoc, "RET_TYPE", sRetType)); 
      newMethod.Attributes.Append( NewAttribute(newDoc, "ACCESSIBILITY", "public:\r\n") ); 
      
      XmlNode newArg;
      
      int ArgLength= m_CurrentLineArray.Count;
      int myIndex = 0;
      int stdIndex = 0;

      //Save arguments in an array
      for(int index=5; index<= m_CurrentLineArray.Count-3; index = index + 2)
      {
        //Für den zweiten Schleifendurchgang
        if((myIndex=m_CurrentLineArray.IndexOf(",",index,2)) !=-1 ) 
          index=myIndex+1;

        // search for the next comma
        if( (myIndex=m_CurrentLineArray.IndexOf(",",index)) != -1 ) 
          ArgLength = myIndex+1;
        else ArgLength =  m_CurrentLineArray.Count;

        // Remove std
        if(m_CurrentLineArray.Count-6 > 2) 
        {
          if((stdIndex=m_CurrentLineArray.IndexOf("std",index,(ArgLength-index))) !=-1)
            index = stdIndex;
        }
        else
        {
          if((stdIndex=m_CurrentLineArray.IndexOf("std",index)) !=-1)
            index = index + 2;
        }

        //Filter Arguments
        string refArg = null;     
        if( (myIndex=m_CurrentLineArray.IndexOf("&",index,(ArgLength-index)) ) !=-1 )
        {
          if(m_CurrentLineArray.IndexOf("std",index-3) !=-1)
          {
            refArg += m_CurrentLineArray[myIndex-4]; // const
            refArg += " " + m_CurrentLineArray[myIndex-3]; // std
            refArg += m_CurrentLineArray[myIndex-2];  // ::
            refArg += m_CurrentLineArray[myIndex-1];  //ARG_TYPE
            refArg += m_CurrentLineArray[myIndex]; // &

            newArg = newDoc.CreateNode(XmlNodeType.Element, "ARGUMENT", "");
            newArg.Attributes.Append( NewAttribute(newDoc, "ARG_TYPE", refArg) );
            newArg.Attributes.Append( NewAttribute(newDoc, "NAME", m_CurrentLineArray[myIndex+1].ToString()) );
            index=myIndex+1;
          }
          else
          {
            refArg += m_CurrentLineArray[myIndex-2]; // const
            refArg += " " + m_CurrentLineArray[myIndex-1]; // ARG_TYPE
            refArg += m_CurrentLineArray[myIndex]; //&
            
            newArg = newDoc.CreateNode(XmlNodeType.Element, "ARGUMENT", "");
            newArg.Attributes.Append( NewAttribute(newDoc, "ARG_TYPE", refArg) );
            newArg.Attributes.Append( NewAttribute(newDoc, "NAME", m_CurrentLineArray[myIndex+1].ToString().Trim()) );
            //geht eins weiter im Index, da ein Komma kommt
            index=myIndex+1;
          }     
        }
        else
        { 
          // -1 std nicht gefunden also else zweig
          if(stdIndex != -1)
          {
            refArg += m_CurrentLineArray[stdIndex-1]; // const
            refArg += " " +m_CurrentLineArray[stdIndex]; // std
            refArg += m_CurrentLineArray[stdIndex+1]; // ::
            refArg += m_CurrentLineArray[stdIndex+2]; // arg type
            
            newArg = newDoc.CreateNode(XmlNodeType.Element, "ARGUMENT", "");
            newArg.Attributes.Append( NewAttribute(newDoc, "ARG_TYPE", refArg) );
            newArg.Attributes.Append( NewAttribute(newDoc, "NAME", m_CurrentLineArray[stdIndex+3].ToString().Trim()) );
            index= stdIndex + 4;
          }
          else
          {
            //if(m_CurrentLineArray.IndexOf("const",0) != -1) MessageBox.Show("CONST!!!");
            newArg = newDoc.CreateNode(XmlNodeType.Element, "ARGUMENT", "");
            newArg.Attributes.Append( NewAttribute(newDoc, "ARG_TYPE", m_CurrentLineArray[index].ToString().Trim()) );
            newArg.Attributes.Append( NewAttribute(newDoc, "NAME", m_CurrentLineArray[index+1].ToString().Trim()) );
          }
        }

        if( newArg != null)
        {
          newMethod.AppendChild(newArg);
        }
      }//Save arguments in XML  
    }
   
    
    enum TTokenType 
    {
      TOK_EMPTY,
      TOK_EOF,
      TOK_AMPERSAND,
      TOK_AND,
      TOK_ASSIGNEQUAL,
      TOK_BITWISEANDEQUAL,
      TOK_BITWISEOR,
      TOK_BITWISEOREQUAL,
      TOK_BITWISEXOR,
      TOK_BITWISEXOREQUAL,
      TOK_COMMA, // 10
      TOK_COLON,
      TOK_DIVIDE,
      TOK_DIVIDEEQUAL,
      TOK_DOT,
      TOK_DOTMBR,
      TOK_ELLIPSIS,
      TOK_EQUAL,
      TOK_GREATERTHAN,
      TOK_GREATERTHANOREQUALTO,
      TOK_LCURLY, // 20
      TOK_LESSTHAN,
      TOK_LESSTHANOREQUALTO,
      TOK_LPAREN,
      TOK_LSQUARE,
      TOK_MINUS,
      TOK_MINUSEQUAL,
      TOK_MINUSMINUS,
      TOK_MOD,
      TOK_MODEQUAL,
      TOK_NOT, // 30
      TOK_NOTEQUAL,
      TOK_OR,
      TOK_PLUS,
      TOK_PLUSEQUAL,
      TOK_PLUSPLUS,
      TOK_POINTERTO,
      TOK_POINTERTOMBR,
      TOK_QUESTIONMARK,
      TOK_RCURLY,
      TOK_RPAREN, // 40
      TOK_RSQUARE,
      TOK_SCOPE,
      TOK_SEMICOLON, // 43
      TOK_SHIFTLEFT,
      TOK_SHIFTLEFTEQUAL,
      TOK_SHIFTRIGHT,
      TOK_SHIFTRIGHTEQUAL,
      TOK_STAR, // 48
      TOK_TILDE,
      TOK_TIMESEQUAL, // 50

      TOK_ASM,
      TOK_AUTO,
      TOK_AUTOMATED,
      TOK_BOOL,
      TOK_BREAK,
      TOK_CASE,
      TOK_CATCH,
      TOK_CDECL,
      TOK_CHAR,
      TOK_CLASS, // 60
      TOK_CLASSID,
      TOK_CLOSURE,
      TOK_CONST,
      TOK_CONST_CAST,
      TOK_CONTINUE,
      TOK_DECLSPEC,
      TOK_DEFAULT,
      TOK_DELETE,
      TOK_DISPID,
      TOK_DO, // 70
      TOK_DOUBLE,
      TOK_DYNAMIC_CAST,
      TOK_ELSE,
      TOK_ENUM,
      TOK_EXCEPT,
      TOK_EXPLICIT,
      TOK_EXPORT,
      TOK_EXTERN,
      TOK_FALSE,
      TOK_FASTCALL, // 80
      TOK_FINALLY,
      TOK_FLOAT,
      TOK_FOR,
      TOK_FRIEND,
      TOK_GOTO,
      TOK_IF,
      TOK_IMPORT,
      TOK_INLINE,
      TOK_INT,
      TOK_INT8, // 90
      TOK_INT16,
      TOK_INT32,
      TOK_INT64,
      TOK_LONG,
      TOK_MSFASTCALL,
      TOK_MSRETURN,
      TOK_MUTABLE,
      TOK_NAMESPACE,
      TOK_NEW,
      TOK_OPERATOR, // 100
      TOK_PASCAL,
      TOK_PRIVATE,// 102
      TOK_PROPERTY,
      TOK_PROTECTED, // 104
      TOK_PUBLIC,// 105
      TOK_PUBLISHED,
      TOK_REGISTER,
      TOK_REINTERPRET_CAST,
      TOK_RETURN,
      TOK_RTTI, // 110
      TOK_SHORT,
      TOK_SIGNED,
      TOK_SIZEOF,
      TOK_STATIC,
      TOK_STATIC_CAST,
      TOK_STDCALL,
      TOK_STRUCT,
      TOK_SWITCH,
      TOK_TEMPLATE,
      TOK_THIS,  // 120
      TOK_THREAD,
      TOK_THROW,
      TOK_TRUE,
      TOK_TRY,
      TOK_TYPEDEF,
      TOK_TYPEID,
      TOK_TYPENAME,
      TOK_UNION,
      TOK_UNSIGNED,
      TOK_USING, // 130
      TOK_VIRTUAL, 
      TOK_VOID,
      TOK_VOLATILE,
      TOK_WCHAR_T,
      TOK_WHILE,

      TOK_ID, // 136
      TOK_OCTALINT,
      TOK_DECIMALINT,
      TOK_HEXADECIMALINT,
      TOK_FLOATONE, // 140
      TOK_FLOATTWO,
      TOK_PNDPND,
      TOK_PND,
      TOK_PP_NUMBER,
      TOK_PNDDEFINE,
      TOK_PNDIF,
      TOK_PNDIFDEF,
      TOK_PNDIFNDEF,
      TOK_PNDELIF,
      TOK_PNDELSE, // 150
      TOK_PNDENDIF,
      TOK_PNDINCLUDE,
      TOK_PNDLINE,
      TOK_PNDPRAGMA,
      TOK_PNDUNDEF,
      TOK_PNDIMPORT,
      TOK_FUNCID,
      TOK_STRING,
      TOK_CHARACTER,
      TOK_FILENAME, //160
      TOK_ASMSTAT, 

      TOK_PRGALIGNMENT,
      TOK_PRGANON_STRUCT,
      TOK_PRGARGSUSED,
      TOK_PRGCHECKOPTION,
      TOK_PRGDEFOPTION,
      TOK_PRGUNDEFOPTION,
      TOK_PRGINLINE,
      TOK_PRGMESSAGE,
      TOK_PRGNOPUSHOPTWARN, // 170
      TOK_PRGOBSOLETE, 
      TOK_PRGOPTION,
      TOK_PRGWARN,
      TOK_PRGOPTSTR,
      TOK_PRGPUSH,
      TOK_PRGPOP,

      TOK_NEWLINE}; //177

  } //class CCodePreprocessor
}//namespace DBClassCodeUtility
