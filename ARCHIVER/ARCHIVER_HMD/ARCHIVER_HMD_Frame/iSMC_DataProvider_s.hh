// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __iSMC__DataProvider_hh__
#define __iSMC__DataProvider_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_iSMC__DataProvider
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_iSMC__DataProvider
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_iSMC__DataProvider
#endif



#ifndef __iData__Provider_hh_EXTERNAL_GUARD__
#define __iData__Provider_hh_EXTERNAL_GUARD__
#include <iData_Provider_s.hh>
#endif
#ifndef __CBS__Common_hh_EXTERNAL_GUARD__
#define __CBS__Common_hh_EXTERNAL_GUARD__
#include <CBS_Common_s.hh>
#endif
#ifndef __CBS_hh_EXTERNAL_GUARD__
#define __CBS_hh_EXTERNAL_GUARD__
#include <CBS_s.hh>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





struct sTlgRecordElem {
  typedef _CORBA_ConstrType_Variable_Var<sTlgRecordElem> _var_type;

  
  ::CORBA::String_member Name;

  ::CORBA::Long Type;

  ::CORBA::Any Value;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sTlgRecordElem::_var_type sTlgRecordElem_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sTlgRecordElem,sTlgRecordElem_var > sTlgRecordElem_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sTlgRecordElem;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqTlgRecordElem;

class seqTlgRecordElem_var;

class seqTlgRecordElem : public _CORBA_Unbounded_Sequence< sTlgRecordElem >  {
public:
  typedef seqTlgRecordElem_var _var_type;
  inline seqTlgRecordElem() {}
  inline seqTlgRecordElem(const seqTlgRecordElem& _s)
    : _CORBA_Unbounded_Sequence< sTlgRecordElem > (_s) {}

  inline seqTlgRecordElem(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sTlgRecordElem > (_max) {}
  inline seqTlgRecordElem(_CORBA_ULong _max, _CORBA_ULong _len, sTlgRecordElem* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sTlgRecordElem > (_max, _len, _val, _rel) {}



  inline seqTlgRecordElem& operator = (const seqTlgRecordElem& _s) {
    _CORBA_Unbounded_Sequence< sTlgRecordElem > ::operator=(_s);
    return *this;
  }
};

class seqTlgRecordElem_out;

class seqTlgRecordElem_var {
public:
  inline seqTlgRecordElem_var() : _pd_seq(0) {}
  inline seqTlgRecordElem_var(seqTlgRecordElem* _s) : _pd_seq(_s) {}
  inline seqTlgRecordElem_var(const seqTlgRecordElem_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqTlgRecordElem(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqTlgRecordElem_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqTlgRecordElem_var& operator = (seqTlgRecordElem* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqTlgRecordElem_var& operator = (const seqTlgRecordElem_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqTlgRecordElem;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sTlgRecordElem& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqTlgRecordElem* operator -> () { return _pd_seq; }
  inline const seqTlgRecordElem* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqTlgRecordElem& () const { return *_pd_seq; }
#else
  inline operator const seqTlgRecordElem& () const { return *_pd_seq; }
  inline operator seqTlgRecordElem& () { return *_pd_seq; }
#endif
    
  inline const seqTlgRecordElem& in() const { return *_pd_seq; }
  inline seqTlgRecordElem&       inout()    { return *_pd_seq; }
  inline seqTlgRecordElem*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqTlgRecordElem* _retn() { seqTlgRecordElem* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqTlgRecordElem_out;
  
private:
  seqTlgRecordElem* _pd_seq;
};

class seqTlgRecordElem_out {
public:
  inline seqTlgRecordElem_out(seqTlgRecordElem*& _s) : _data(_s) { _data = 0; }
  inline seqTlgRecordElem_out(seqTlgRecordElem_var& _s)
    : _data(_s._pd_seq) { _s = (seqTlgRecordElem*) 0; }
  inline seqTlgRecordElem_out(const seqTlgRecordElem_out& _s) : _data(_s._data) {}
  inline seqTlgRecordElem_out& operator = (const seqTlgRecordElem_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqTlgRecordElem_out& operator = (seqTlgRecordElem* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqTlgRecordElem*&()  { return _data; }
  inline seqTlgRecordElem*& ptr()       { return _data; }
  inline seqTlgRecordElem* operator->() { return _data; }

  inline sTlgRecordElem& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqTlgRecordElem*& _data;

private:
  seqTlgRecordElem_out();
  seqTlgRecordElem_out& operator=(const seqTlgRecordElem_var&);
};

struct sTlgRecord {
  typedef _CORBA_ConstrType_Variable_Var<sTlgRecord> _var_type;

  
  ::CORBA::String_member Name;

  seqTlgRecordElem TlgRecordElem;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sTlgRecord::_var_type sTlgRecord_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sTlgRecord,sTlgRecord_var > sTlgRecord_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sTlgRecord;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqTlgRecord;

class seqTlgRecord_var;

class seqTlgRecord : public _CORBA_Unbounded_Sequence< sTlgRecord >  {
public:
  typedef seqTlgRecord_var _var_type;
  inline seqTlgRecord() {}
  inline seqTlgRecord(const seqTlgRecord& _s)
    : _CORBA_Unbounded_Sequence< sTlgRecord > (_s) {}

  inline seqTlgRecord(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sTlgRecord > (_max) {}
  inline seqTlgRecord(_CORBA_ULong _max, _CORBA_ULong _len, sTlgRecord* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sTlgRecord > (_max, _len, _val, _rel) {}



  inline seqTlgRecord& operator = (const seqTlgRecord& _s) {
    _CORBA_Unbounded_Sequence< sTlgRecord > ::operator=(_s);
    return *this;
  }
};

class seqTlgRecord_out;

class seqTlgRecord_var {
public:
  inline seqTlgRecord_var() : _pd_seq(0) {}
  inline seqTlgRecord_var(seqTlgRecord* _s) : _pd_seq(_s) {}
  inline seqTlgRecord_var(const seqTlgRecord_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqTlgRecord(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqTlgRecord_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqTlgRecord_var& operator = (seqTlgRecord* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqTlgRecord_var& operator = (const seqTlgRecord_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqTlgRecord;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sTlgRecord& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqTlgRecord* operator -> () { return _pd_seq; }
  inline const seqTlgRecord* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqTlgRecord& () const { return *_pd_seq; }
#else
  inline operator const seqTlgRecord& () const { return *_pd_seq; }
  inline operator seqTlgRecord& () { return *_pd_seq; }
#endif
    
  inline const seqTlgRecord& in() const { return *_pd_seq; }
  inline seqTlgRecord&       inout()    { return *_pd_seq; }
  inline seqTlgRecord*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqTlgRecord* _retn() { seqTlgRecord* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqTlgRecord_out;
  
private:
  seqTlgRecord* _pd_seq;
};

class seqTlgRecord_out {
public:
  inline seqTlgRecord_out(seqTlgRecord*& _s) : _data(_s) { _data = 0; }
  inline seqTlgRecord_out(seqTlgRecord_var& _s)
    : _data(_s._pd_seq) { _s = (seqTlgRecord*) 0; }
  inline seqTlgRecord_out(const seqTlgRecord_out& _s) : _data(_s._data) {}
  inline seqTlgRecord_out& operator = (const seqTlgRecord_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqTlgRecord_out& operator = (seqTlgRecord* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqTlgRecord*&()  { return _data; }
  inline seqTlgRecord*& ptr()       { return _data; }
  inline seqTlgRecord* operator->() { return _data; }

  inline sTlgRecord& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqTlgRecord*& _data;

private:
  seqTlgRecord_out();
  seqTlgRecord_out& operator=(const seqTlgRecord_var&);
};

struct sAnalysisString {
  typedef _CORBA_ConstrType_Variable_Var<sAnalysisString> _var_type;

  
  ::CORBA::String_member Element;

  ::CORBA::String_member Concentration;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sAnalysisString::_var_type sAnalysisString_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sAnalysisString,sAnalysisString_var > sAnalysisString_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sAnalysisString;

struct sAnalysis {
  typedef _CORBA_ConstrType_Variable_Var<sAnalysis> _var_type;

  
  ::CORBA::String_member Element;

  ::CORBA::Double Concentration;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sAnalysis::_var_type sAnalysis_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sAnalysis,sAnalysis_var > sAnalysis_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sAnalysis;

struct sBatch {
  typedef _CORBA_ConstrType_Variable_Var<sBatch> _var_type;

  
  ::CORBA::String_member MatCode;

  ::CORBA::Double Mass;

  ::CORBA::Double MatFeedSpeed;

  ::CORBA::Long Source;

  ::CORBA::Double FeedingRateRel2Energy;

  ::CORBA::Long MatLoadingSequence;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sBatch::_var_type sBatch_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sBatch,sBatch_var > sBatch_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sBatch;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sDate;

typedef MCBS::CBS_LocalTime sDate;
typedef MCBS::CBS_LocalTime_var sDate_var;
typedef MCBS::CBS_LocalTime_out sDate_out;

struct sEAFBurnerPredRes {
  typedef _CORBA_ConstrType_Variable_Var<sEAFBurnerPredRes> _var_type;

  
  ::CORBA::String_member Phase;

  ::CORBA::Long PhaseNo;

  ::CORBA::Long Step;

  ::CORBA::String_member BurnerName;

  ::CORBA::Double BaseMass;

  ::CORBA::Double DurStep;

  ::CORBA::Double SpecEgy;

  ::CORBA::Double ElecEgy;

  ::CORBA::String_member Gastype;

  ::CORBA::Double GasFlow;

  ::CORBA::Double O2Flow;

  ::CORBA::Double ElecEgyStep;

  ::CORBA::Double DurUntilEndOfStep;

  ::CORBA::Double DurUntilStartOfStep;

  ::CORBA::Double SpecEgyStep;

  ::CORBA::Long FlameProfile_Burner;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sEAFBurnerPredRes::_var_type sEAFBurnerPredRes_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sEAFBurnerPredRes,sEAFBurnerPredRes_var > sEAFBurnerPredRes_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sEAFBurnerPredRes;

struct sEAFProcessPredRes {
  typedef _CORBA_ConstrType_Variable_Var<sEAFProcessPredRes> _var_type;

  
  ::CORBA::String_member Phase;

  ::CORBA::Long PhaseNo;

  ::CORBA::Long DeviceNo;

  ::CORBA::Long Step;

  ::CORBA::Long VoltTap;

  ::CORBA::Long ImpCurve;

  ::CORBA::Long ReactorTap;

  ::CORBA::Double DurStep;

  ::CORBA::Double Temp;

  ::CORBA::Double DurUntilEndOfStep;

  ::CORBA::Double DurUntilStartOfStep;

  ::CORBA::Double SpecEgyStep;

  ::CORBA::Double SpecEgy;

  ::CORBA::Double ElecEgyStep;

  ::CORBA::Double ElecEgy;

  ::CORBA::Double O2Flow;

  ::CORBA::Double O2Amount;

  ::CORBA::Double BaseMass;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sEAFProcessPredRes::_var_type sEAFProcessPredRes_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sEAFProcessPredRes,sEAFProcessPredRes_var > sEAFProcessPredRes_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sEAFProcessPredRes;

struct sLFElecPredRes {
  typedef _CORBA_ConstrType_Variable_Var<sLFElecPredRes> _var_type;

  
  ::CORBA::Long Step;

  ::CORBA::Long VoltTap;

  ::CORBA::Long ImpCurve;

  ::CORBA::Double ElecEgy;

  ::CORBA::Double SpecEgy;

  ::CORBA::Long StirrIntensity;

  ::CORBA::Double StirrFlow;

  ::CORBA::String_member GasType;

  ::CORBA::Long Priority;

  ::CORBA::Double DurStep;

  ::CORBA::Long Enable;

  ::CORBA::Long Order;

  sDate RevDate;

  ::CORBA::String_member StirrIntensityCode;

  ::CORBA::String_member ElecPhase;

  ::CORBA::Double ElecEgyStep;

  ::CORBA::Double DurUntilEndOfStep;

  ::CORBA::Double DurUntilStartOfStep;

  ::CORBA::Double BaseMass;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sLFElecPredRes::_var_type sLFElecPredRes_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sLFElecPredRes,sLFElecPredRes_var > sLFElecPredRes_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sLFElecPredRes;

struct sLFStirrPredRes {
  typedef _CORBA_ConstrType_Variable_Var<sLFStirrPredRes> _var_type;

  
  ::CORBA::String_member StirrPhase;

  ::CORBA::Long StirrIntensity;

  ::CORBA::Double StirrFlow;

  ::CORBA::String_member GasType;

  ::CORBA::Long Priority;

  ::CORBA::Double DurStep;

  ::CORBA::String_member StirrIntensityCode;

  ::CORBA::Long Enable;

  ::CORBA::Long Order;

  ::CORBA::Long isPatternOrActivity;

  ::CORBA::Double DurUntilEndOfStep;

  ::CORBA::Double DurUntilStartOfStep;

  ::CORBA::Long VoltTap;

  ::CORBA::Long ImpCurve;

  ::CORBA::Double ElecEgy;

  ::CORBA::Double SteelMass;

  ::CORBA::Double SlagMass;

  ::CORBA::Double Temp;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sLFStirrPredRes::_var_type sLFStirrPredRes_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sLFStirrPredRes,sLFStirrPredRes_var > sLFStirrPredRes_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sLFStirrPredRes;

struct sMetTimeStamp {
  typedef _CORBA_ConstrType_Fix_Var<sMetTimeStamp> _var_type;

  
  ::CORBA::Double O2_Moment;

  ::CORBA::Double Ar_Moment;

  ::CORBA::Double N2_Moment;

  ::CORBA::Double Elec_Moment;

  ::CORBA::Double DurSinceHeatAnnouncement;

  ::CORBA::Double DurSinceStartOfHeat;

  sDate RevDate;

  sDate ActionDate;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sMetTimeStamp::_var_type sMetTimeStamp_var;

typedef sMetTimeStamp& sMetTimeStamp_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sMetTimeStamp;

struct sRecipeProperties {
  typedef _CORBA_ConstrType_Fix_Var<sRecipeProperties> _var_type;

  
  ::CORBA::Long RecipeStatus;

  ::CORBA::Double HomogDuration;

  ::CORBA::Double TotalMass;

  ::CORBA::Double BulkVolume;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sRecipeProperties::_var_type sRecipeProperties_var;

typedef sRecipeProperties& sRecipeProperties_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sRecipeProperties;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqAnalysis;

class seqAnalysis_var;

class seqAnalysis : public _CORBA_Unbounded_Sequence< sAnalysis >  {
public:
  typedef seqAnalysis_var _var_type;
  inline seqAnalysis() {}
  inline seqAnalysis(const seqAnalysis& _s)
    : _CORBA_Unbounded_Sequence< sAnalysis > (_s) {}

  inline seqAnalysis(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sAnalysis > (_max) {}
  inline seqAnalysis(_CORBA_ULong _max, _CORBA_ULong _len, sAnalysis* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sAnalysis > (_max, _len, _val, _rel) {}



  inline seqAnalysis& operator = (const seqAnalysis& _s) {
    _CORBA_Unbounded_Sequence< sAnalysis > ::operator=(_s);
    return *this;
  }
};

class seqAnalysis_out;

class seqAnalysis_var {
public:
  inline seqAnalysis_var() : _pd_seq(0) {}
  inline seqAnalysis_var(seqAnalysis* _s) : _pd_seq(_s) {}
  inline seqAnalysis_var(const seqAnalysis_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqAnalysis(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqAnalysis_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqAnalysis_var& operator = (seqAnalysis* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqAnalysis_var& operator = (const seqAnalysis_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqAnalysis;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sAnalysis& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqAnalysis* operator -> () { return _pd_seq; }
  inline const seqAnalysis* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqAnalysis& () const { return *_pd_seq; }
#else
  inline operator const seqAnalysis& () const { return *_pd_seq; }
  inline operator seqAnalysis& () { return *_pd_seq; }
#endif
    
  inline const seqAnalysis& in() const { return *_pd_seq; }
  inline seqAnalysis&       inout()    { return *_pd_seq; }
  inline seqAnalysis*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqAnalysis* _retn() { seqAnalysis* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqAnalysis_out;
  
private:
  seqAnalysis* _pd_seq;
};

class seqAnalysis_out {
public:
  inline seqAnalysis_out(seqAnalysis*& _s) : _data(_s) { _data = 0; }
  inline seqAnalysis_out(seqAnalysis_var& _s)
    : _data(_s._pd_seq) { _s = (seqAnalysis*) 0; }
  inline seqAnalysis_out(const seqAnalysis_out& _s) : _data(_s._data) {}
  inline seqAnalysis_out& operator = (const seqAnalysis_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqAnalysis_out& operator = (seqAnalysis* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqAnalysis*&()  { return _data; }
  inline seqAnalysis*& ptr()       { return _data; }
  inline seqAnalysis* operator->() { return _data; }

  inline sAnalysis& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqAnalysis*& _data;

private:
  seqAnalysis_out();
  seqAnalysis_out& operator=(const seqAnalysis_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqBatch;

class seqBatch_var;

class seqBatch : public _CORBA_Unbounded_Sequence< sBatch >  {
public:
  typedef seqBatch_var _var_type;
  inline seqBatch() {}
  inline seqBatch(const seqBatch& _s)
    : _CORBA_Unbounded_Sequence< sBatch > (_s) {}

  inline seqBatch(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sBatch > (_max) {}
  inline seqBatch(_CORBA_ULong _max, _CORBA_ULong _len, sBatch* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sBatch > (_max, _len, _val, _rel) {}



  inline seqBatch& operator = (const seqBatch& _s) {
    _CORBA_Unbounded_Sequence< sBatch > ::operator=(_s);
    return *this;
  }
};

class seqBatch_out;

class seqBatch_var {
public:
  inline seqBatch_var() : _pd_seq(0) {}
  inline seqBatch_var(seqBatch* _s) : _pd_seq(_s) {}
  inline seqBatch_var(const seqBatch_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqBatch(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqBatch_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqBatch_var& operator = (seqBatch* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqBatch_var& operator = (const seqBatch_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqBatch;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sBatch& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqBatch* operator -> () { return _pd_seq; }
  inline const seqBatch* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqBatch& () const { return *_pd_seq; }
#else
  inline operator const seqBatch& () const { return *_pd_seq; }
  inline operator seqBatch& () { return *_pd_seq; }
#endif
    
  inline const seqBatch& in() const { return *_pd_seq; }
  inline seqBatch&       inout()    { return *_pd_seq; }
  inline seqBatch*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqBatch* _retn() { seqBatch* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqBatch_out;
  
private:
  seqBatch* _pd_seq;
};

class seqBatch_out {
public:
  inline seqBatch_out(seqBatch*& _s) : _data(_s) { _data = 0; }
  inline seqBatch_out(seqBatch_var& _s)
    : _data(_s._pd_seq) { _s = (seqBatch*) 0; }
  inline seqBatch_out(const seqBatch_out& _s) : _data(_s._data) {}
  inline seqBatch_out& operator = (const seqBatch_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqBatch_out& operator = (seqBatch* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqBatch*&()  { return _data; }
  inline seqBatch*& ptr()       { return _data; }
  inline seqBatch* operator->() { return _data; }

  inline sBatch& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqBatch*& _data;

private:
  seqBatch_out();
  seqBatch_out& operator=(const seqBatch_var&);
};

struct sEAFMatFeed {
  typedef _CORBA_ConstrType_Variable_Var<sEAFMatFeed> _var_type;

  
  ::CORBA::String_member Phase;

  ::CORBA::Long PhaseNo;

  ::CORBA::Long Step;

  ::CORBA::Double DurStep;

  ::CORBA::Double SpecEgy;

  seqBatch MatFeed;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sEAFMatFeed::_var_type sEAFMatFeed_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sEAFMatFeed,sEAFMatFeed_var > sEAFMatFeed_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sEAFMatFeed;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqEAFBurnerPredRes;

class seqEAFBurnerPredRes_var;

class seqEAFBurnerPredRes : public _CORBA_Unbounded_Sequence< sEAFBurnerPredRes >  {
public:
  typedef seqEAFBurnerPredRes_var _var_type;
  inline seqEAFBurnerPredRes() {}
  inline seqEAFBurnerPredRes(const seqEAFBurnerPredRes& _s)
    : _CORBA_Unbounded_Sequence< sEAFBurnerPredRes > (_s) {}

  inline seqEAFBurnerPredRes(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sEAFBurnerPredRes > (_max) {}
  inline seqEAFBurnerPredRes(_CORBA_ULong _max, _CORBA_ULong _len, sEAFBurnerPredRes* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sEAFBurnerPredRes > (_max, _len, _val, _rel) {}



  inline seqEAFBurnerPredRes& operator = (const seqEAFBurnerPredRes& _s) {
    _CORBA_Unbounded_Sequence< sEAFBurnerPredRes > ::operator=(_s);
    return *this;
  }
};

class seqEAFBurnerPredRes_out;

class seqEAFBurnerPredRes_var {
public:
  inline seqEAFBurnerPredRes_var() : _pd_seq(0) {}
  inline seqEAFBurnerPredRes_var(seqEAFBurnerPredRes* _s) : _pd_seq(_s) {}
  inline seqEAFBurnerPredRes_var(const seqEAFBurnerPredRes_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqEAFBurnerPredRes(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqEAFBurnerPredRes_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqEAFBurnerPredRes_var& operator = (seqEAFBurnerPredRes* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqEAFBurnerPredRes_var& operator = (const seqEAFBurnerPredRes_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqEAFBurnerPredRes;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sEAFBurnerPredRes& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqEAFBurnerPredRes* operator -> () { return _pd_seq; }
  inline const seqEAFBurnerPredRes* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqEAFBurnerPredRes& () const { return *_pd_seq; }
#else
  inline operator const seqEAFBurnerPredRes& () const { return *_pd_seq; }
  inline operator seqEAFBurnerPredRes& () { return *_pd_seq; }
#endif
    
  inline const seqEAFBurnerPredRes& in() const { return *_pd_seq; }
  inline seqEAFBurnerPredRes&       inout()    { return *_pd_seq; }
  inline seqEAFBurnerPredRes*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqEAFBurnerPredRes* _retn() { seqEAFBurnerPredRes* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqEAFBurnerPredRes_out;
  
private:
  seqEAFBurnerPredRes* _pd_seq;
};

class seqEAFBurnerPredRes_out {
public:
  inline seqEAFBurnerPredRes_out(seqEAFBurnerPredRes*& _s) : _data(_s) { _data = 0; }
  inline seqEAFBurnerPredRes_out(seqEAFBurnerPredRes_var& _s)
    : _data(_s._pd_seq) { _s = (seqEAFBurnerPredRes*) 0; }
  inline seqEAFBurnerPredRes_out(const seqEAFBurnerPredRes_out& _s) : _data(_s._data) {}
  inline seqEAFBurnerPredRes_out& operator = (const seqEAFBurnerPredRes_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqEAFBurnerPredRes_out& operator = (seqEAFBurnerPredRes* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqEAFBurnerPredRes*&()  { return _data; }
  inline seqEAFBurnerPredRes*& ptr()       { return _data; }
  inline seqEAFBurnerPredRes* operator->() { return _data; }

  inline sEAFBurnerPredRes& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqEAFBurnerPredRes*& _data;

private:
  seqEAFBurnerPredRes_out();
  seqEAFBurnerPredRes_out& operator=(const seqEAFBurnerPredRes_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqEAFProcessPredRes;

class seqEAFProcessPredRes_var;

class seqEAFProcessPredRes : public _CORBA_Unbounded_Sequence< sEAFProcessPredRes >  {
public:
  typedef seqEAFProcessPredRes_var _var_type;
  inline seqEAFProcessPredRes() {}
  inline seqEAFProcessPredRes(const seqEAFProcessPredRes& _s)
    : _CORBA_Unbounded_Sequence< sEAFProcessPredRes > (_s) {}

  inline seqEAFProcessPredRes(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sEAFProcessPredRes > (_max) {}
  inline seqEAFProcessPredRes(_CORBA_ULong _max, _CORBA_ULong _len, sEAFProcessPredRes* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sEAFProcessPredRes > (_max, _len, _val, _rel) {}



  inline seqEAFProcessPredRes& operator = (const seqEAFProcessPredRes& _s) {
    _CORBA_Unbounded_Sequence< sEAFProcessPredRes > ::operator=(_s);
    return *this;
  }
};

class seqEAFProcessPredRes_out;

class seqEAFProcessPredRes_var {
public:
  inline seqEAFProcessPredRes_var() : _pd_seq(0) {}
  inline seqEAFProcessPredRes_var(seqEAFProcessPredRes* _s) : _pd_seq(_s) {}
  inline seqEAFProcessPredRes_var(const seqEAFProcessPredRes_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqEAFProcessPredRes(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqEAFProcessPredRes_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqEAFProcessPredRes_var& operator = (seqEAFProcessPredRes* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqEAFProcessPredRes_var& operator = (const seqEAFProcessPredRes_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqEAFProcessPredRes;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sEAFProcessPredRes& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqEAFProcessPredRes* operator -> () { return _pd_seq; }
  inline const seqEAFProcessPredRes* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqEAFProcessPredRes& () const { return *_pd_seq; }
#else
  inline operator const seqEAFProcessPredRes& () const { return *_pd_seq; }
  inline operator seqEAFProcessPredRes& () { return *_pd_seq; }
#endif
    
  inline const seqEAFProcessPredRes& in() const { return *_pd_seq; }
  inline seqEAFProcessPredRes&       inout()    { return *_pd_seq; }
  inline seqEAFProcessPredRes*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqEAFProcessPredRes* _retn() { seqEAFProcessPredRes* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqEAFProcessPredRes_out;
  
private:
  seqEAFProcessPredRes* _pd_seq;
};

class seqEAFProcessPredRes_out {
public:
  inline seqEAFProcessPredRes_out(seqEAFProcessPredRes*& _s) : _data(_s) { _data = 0; }
  inline seqEAFProcessPredRes_out(seqEAFProcessPredRes_var& _s)
    : _data(_s._pd_seq) { _s = (seqEAFProcessPredRes*) 0; }
  inline seqEAFProcessPredRes_out(const seqEAFProcessPredRes_out& _s) : _data(_s._data) {}
  inline seqEAFProcessPredRes_out& operator = (const seqEAFProcessPredRes_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqEAFProcessPredRes_out& operator = (seqEAFProcessPredRes* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqEAFProcessPredRes*&()  { return _data; }
  inline seqEAFProcessPredRes*& ptr()       { return _data; }
  inline seqEAFProcessPredRes* operator->() { return _data; }

  inline sEAFProcessPredRes& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqEAFProcessPredRes*& _data;

private:
  seqEAFProcessPredRes_out();
  seqEAFProcessPredRes_out& operator=(const seqEAFProcessPredRes_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqEAFMatFeed;

class seqEAFMatFeed_var;

class seqEAFMatFeed : public _CORBA_Unbounded_Sequence< sEAFMatFeed >  {
public:
  typedef seqEAFMatFeed_var _var_type;
  inline seqEAFMatFeed() {}
  inline seqEAFMatFeed(const seqEAFMatFeed& _s)
    : _CORBA_Unbounded_Sequence< sEAFMatFeed > (_s) {}

  inline seqEAFMatFeed(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sEAFMatFeed > (_max) {}
  inline seqEAFMatFeed(_CORBA_ULong _max, _CORBA_ULong _len, sEAFMatFeed* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sEAFMatFeed > (_max, _len, _val, _rel) {}



  inline seqEAFMatFeed& operator = (const seqEAFMatFeed& _s) {
    _CORBA_Unbounded_Sequence< sEAFMatFeed > ::operator=(_s);
    return *this;
  }
};

class seqEAFMatFeed_out;

class seqEAFMatFeed_var {
public:
  inline seqEAFMatFeed_var() : _pd_seq(0) {}
  inline seqEAFMatFeed_var(seqEAFMatFeed* _s) : _pd_seq(_s) {}
  inline seqEAFMatFeed_var(const seqEAFMatFeed_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqEAFMatFeed(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqEAFMatFeed_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqEAFMatFeed_var& operator = (seqEAFMatFeed* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqEAFMatFeed_var& operator = (const seqEAFMatFeed_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqEAFMatFeed;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sEAFMatFeed& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqEAFMatFeed* operator -> () { return _pd_seq; }
  inline const seqEAFMatFeed* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqEAFMatFeed& () const { return *_pd_seq; }
#else
  inline operator const seqEAFMatFeed& () const { return *_pd_seq; }
  inline operator seqEAFMatFeed& () { return *_pd_seq; }
#endif
    
  inline const seqEAFMatFeed& in() const { return *_pd_seq; }
  inline seqEAFMatFeed&       inout()    { return *_pd_seq; }
  inline seqEAFMatFeed*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqEAFMatFeed* _retn() { seqEAFMatFeed* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqEAFMatFeed_out;
  
private:
  seqEAFMatFeed* _pd_seq;
};

class seqEAFMatFeed_out {
public:
  inline seqEAFMatFeed_out(seqEAFMatFeed*& _s) : _data(_s) { _data = 0; }
  inline seqEAFMatFeed_out(seqEAFMatFeed_var& _s)
    : _data(_s._pd_seq) { _s = (seqEAFMatFeed*) 0; }
  inline seqEAFMatFeed_out(const seqEAFMatFeed_out& _s) : _data(_s._data) {}
  inline seqEAFMatFeed_out& operator = (const seqEAFMatFeed_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqEAFMatFeed_out& operator = (seqEAFMatFeed* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqEAFMatFeed*&()  { return _data; }
  inline seqEAFMatFeed*& ptr()       { return _data; }
  inline seqEAFMatFeed* operator->() { return _data; }

  inline sEAFMatFeed& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqEAFMatFeed*& _data;

private:
  seqEAFMatFeed_out();
  seqEAFMatFeed_out& operator=(const seqEAFMatFeed_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqLFElecPredRes;

class seqLFElecPredRes_var;

class seqLFElecPredRes : public _CORBA_Unbounded_Sequence< sLFElecPredRes >  {
public:
  typedef seqLFElecPredRes_var _var_type;
  inline seqLFElecPredRes() {}
  inline seqLFElecPredRes(const seqLFElecPredRes& _s)
    : _CORBA_Unbounded_Sequence< sLFElecPredRes > (_s) {}

  inline seqLFElecPredRes(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sLFElecPredRes > (_max) {}
  inline seqLFElecPredRes(_CORBA_ULong _max, _CORBA_ULong _len, sLFElecPredRes* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sLFElecPredRes > (_max, _len, _val, _rel) {}



  inline seqLFElecPredRes& operator = (const seqLFElecPredRes& _s) {
    _CORBA_Unbounded_Sequence< sLFElecPredRes > ::operator=(_s);
    return *this;
  }
};

class seqLFElecPredRes_out;

class seqLFElecPredRes_var {
public:
  inline seqLFElecPredRes_var() : _pd_seq(0) {}
  inline seqLFElecPredRes_var(seqLFElecPredRes* _s) : _pd_seq(_s) {}
  inline seqLFElecPredRes_var(const seqLFElecPredRes_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqLFElecPredRes(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqLFElecPredRes_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqLFElecPredRes_var& operator = (seqLFElecPredRes* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqLFElecPredRes_var& operator = (const seqLFElecPredRes_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqLFElecPredRes;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sLFElecPredRes& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqLFElecPredRes* operator -> () { return _pd_seq; }
  inline const seqLFElecPredRes* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqLFElecPredRes& () const { return *_pd_seq; }
#else
  inline operator const seqLFElecPredRes& () const { return *_pd_seq; }
  inline operator seqLFElecPredRes& () { return *_pd_seq; }
#endif
    
  inline const seqLFElecPredRes& in() const { return *_pd_seq; }
  inline seqLFElecPredRes&       inout()    { return *_pd_seq; }
  inline seqLFElecPredRes*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqLFElecPredRes* _retn() { seqLFElecPredRes* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqLFElecPredRes_out;
  
private:
  seqLFElecPredRes* _pd_seq;
};

class seqLFElecPredRes_out {
public:
  inline seqLFElecPredRes_out(seqLFElecPredRes*& _s) : _data(_s) { _data = 0; }
  inline seqLFElecPredRes_out(seqLFElecPredRes_var& _s)
    : _data(_s._pd_seq) { _s = (seqLFElecPredRes*) 0; }
  inline seqLFElecPredRes_out(const seqLFElecPredRes_out& _s) : _data(_s._data) {}
  inline seqLFElecPredRes_out& operator = (const seqLFElecPredRes_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqLFElecPredRes_out& operator = (seqLFElecPredRes* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqLFElecPredRes*&()  { return _data; }
  inline seqLFElecPredRes*& ptr()       { return _data; }
  inline seqLFElecPredRes* operator->() { return _data; }

  inline sLFElecPredRes& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqLFElecPredRes*& _data;

private:
  seqLFElecPredRes_out();
  seqLFElecPredRes_out& operator=(const seqLFElecPredRes_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqLFStirrPredRes;

class seqLFStirrPredRes_var;

class seqLFStirrPredRes : public _CORBA_Unbounded_Sequence< sLFStirrPredRes >  {
public:
  typedef seqLFStirrPredRes_var _var_type;
  inline seqLFStirrPredRes() {}
  inline seqLFStirrPredRes(const seqLFStirrPredRes& _s)
    : _CORBA_Unbounded_Sequence< sLFStirrPredRes > (_s) {}

  inline seqLFStirrPredRes(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sLFStirrPredRes > (_max) {}
  inline seqLFStirrPredRes(_CORBA_ULong _max, _CORBA_ULong _len, sLFStirrPredRes* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sLFStirrPredRes > (_max, _len, _val, _rel) {}



  inline seqLFStirrPredRes& operator = (const seqLFStirrPredRes& _s) {
    _CORBA_Unbounded_Sequence< sLFStirrPredRes > ::operator=(_s);
    return *this;
  }
};

class seqLFStirrPredRes_out;

class seqLFStirrPredRes_var {
public:
  inline seqLFStirrPredRes_var() : _pd_seq(0) {}
  inline seqLFStirrPredRes_var(seqLFStirrPredRes* _s) : _pd_seq(_s) {}
  inline seqLFStirrPredRes_var(const seqLFStirrPredRes_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqLFStirrPredRes(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqLFStirrPredRes_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqLFStirrPredRes_var& operator = (seqLFStirrPredRes* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqLFStirrPredRes_var& operator = (const seqLFStirrPredRes_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqLFStirrPredRes;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sLFStirrPredRes& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqLFStirrPredRes* operator -> () { return _pd_seq; }
  inline const seqLFStirrPredRes* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqLFStirrPredRes& () const { return *_pd_seq; }
#else
  inline operator const seqLFStirrPredRes& () const { return *_pd_seq; }
  inline operator seqLFStirrPredRes& () { return *_pd_seq; }
#endif
    
  inline const seqLFStirrPredRes& in() const { return *_pd_seq; }
  inline seqLFStirrPredRes&       inout()    { return *_pd_seq; }
  inline seqLFStirrPredRes*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqLFStirrPredRes* _retn() { seqLFStirrPredRes* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqLFStirrPredRes_out;
  
private:
  seqLFStirrPredRes* _pd_seq;
};

class seqLFStirrPredRes_out {
public:
  inline seqLFStirrPredRes_out(seqLFStirrPredRes*& _s) : _data(_s) { _data = 0; }
  inline seqLFStirrPredRes_out(seqLFStirrPredRes_var& _s)
    : _data(_s._pd_seq) { _s = (seqLFStirrPredRes*) 0; }
  inline seqLFStirrPredRes_out(const seqLFStirrPredRes_out& _s) : _data(_s._data) {}
  inline seqLFStirrPredRes_out& operator = (const seqLFStirrPredRes_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqLFStirrPredRes_out& operator = (seqLFStirrPredRes* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqLFStirrPredRes*&()  { return _data; }
  inline seqLFStirrPredRes*& ptr()       { return _data; }
  inline seqLFStirrPredRes* operator->() { return _data; }

  inline sLFStirrPredRes& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqLFStirrPredRes*& _data;

private:
  seqLFStirrPredRes_out();
  seqLFStirrPredRes_out& operator=(const seqLFStirrPredRes_var&);
};

struct sAODGlobalSetpoints {
  typedef _CORBA_ConstrType_Fix_Var<sAODGlobalSetpoints> _var_type;

  
  ::CORBA::Double O2VolStartMatAddn;

  ::CORBA::Double O2VolStartScrapChute;

  ::CORBA::Double O2VolSubLance;

  ::CORBA::Double O2VolTotal;

  ::CORBA::Double O2VolTotalLance;

  ::CORBA::Double N2VolTotal;

  ::CORBA::Double MatFeedRate;

  ::CORBA::Double MatDynFeedRate;

  ::CORBA::Double O2VolStartMatDynAddn;

  ::CORBA::Double AimTapWeightCalc;

  ::CORBA::Double DurStartMatAddn;

  ::CORBA::Double DurStartMatDynAddn;

  ::CORBA::Double DurStartScrapChute;

  ::CORBA::Double DurSubLance;

  ::CORBA::Double O2VolStartMat2ndAddn;

  ::CORBA::Double DurStartMat2ndAddn;

  ::CORBA::Double MatFeedRate2ndAdd;

  ::CORBA::Double O2VolSwN2toAr;

  ::CORBA::Double DurUntilN2ToAr;

  ::CORBA::Double N2VolSwN2toAr;

  ::CORBA::Double AimSteelMassCalc;

  ::CORBA::Double Duration;

  ::CORBA::Double LanceO2Flow;

  ::CORBA::Double LanceN2Flow;

  ::CORBA::Double LanceArFlow;

  ::CORBA::Double TuyereO2Flow;

  ::CORBA::Double TuyereN2Flow;

  ::CORBA::Double TuyereArFlow;

  ::CORBA::Double LanceDepth;

  ::CORBA::Double CalcSteelWeight;

  ::CORBA::Double CalcSlagWeight;

  ::CORBA::Double CalcTemp;

  ::CORBA::Double DecarbDelta;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sAODGlobalSetpoints::_var_type sAODGlobalSetpoints_var;

typedef sAODGlobalSetpoints& sAODGlobalSetpoints_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sAODGlobalSetpoints;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqAODGlobalSetpoints;

class seqAODGlobalSetpoints_var;

class seqAODGlobalSetpoints : public _CORBA_Unbounded_Sequence< sAODGlobalSetpoints >  {
public:
  typedef seqAODGlobalSetpoints_var _var_type;
  inline seqAODGlobalSetpoints() {}
  inline seqAODGlobalSetpoints(const seqAODGlobalSetpoints& _s)
    : _CORBA_Unbounded_Sequence< sAODGlobalSetpoints > (_s) {}

  inline seqAODGlobalSetpoints(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sAODGlobalSetpoints > (_max) {}
  inline seqAODGlobalSetpoints(_CORBA_ULong _max, _CORBA_ULong _len, sAODGlobalSetpoints* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sAODGlobalSetpoints > (_max, _len, _val, _rel) {}



  inline seqAODGlobalSetpoints& operator = (const seqAODGlobalSetpoints& _s) {
    _CORBA_Unbounded_Sequence< sAODGlobalSetpoints > ::operator=(_s);
    return *this;
  }
};

class seqAODGlobalSetpoints_out;

class seqAODGlobalSetpoints_var {
public:
  inline seqAODGlobalSetpoints_var() : _pd_seq(0) {}
  inline seqAODGlobalSetpoints_var(seqAODGlobalSetpoints* _s) : _pd_seq(_s) {}
  inline seqAODGlobalSetpoints_var(const seqAODGlobalSetpoints_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqAODGlobalSetpoints(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqAODGlobalSetpoints_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqAODGlobalSetpoints_var& operator = (seqAODGlobalSetpoints* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqAODGlobalSetpoints_var& operator = (const seqAODGlobalSetpoints_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqAODGlobalSetpoints;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sAODGlobalSetpoints& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqAODGlobalSetpoints* operator -> () { return _pd_seq; }
  inline const seqAODGlobalSetpoints* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqAODGlobalSetpoints& () const { return *_pd_seq; }
#else
  inline operator const seqAODGlobalSetpoints& () const { return *_pd_seq; }
  inline operator seqAODGlobalSetpoints& () { return *_pd_seq; }
#endif
    
  inline const seqAODGlobalSetpoints& in() const { return *_pd_seq; }
  inline seqAODGlobalSetpoints&       inout()    { return *_pd_seq; }
  inline seqAODGlobalSetpoints*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqAODGlobalSetpoints* _retn() { seqAODGlobalSetpoints* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqAODGlobalSetpoints_out;
  
private:
  seqAODGlobalSetpoints* _pd_seq;
};

class seqAODGlobalSetpoints_out {
public:
  inline seqAODGlobalSetpoints_out(seqAODGlobalSetpoints*& _s) : _data(_s) { _data = 0; }
  inline seqAODGlobalSetpoints_out(seqAODGlobalSetpoints_var& _s)
    : _data(_s._pd_seq) { _s = (seqAODGlobalSetpoints*) 0; }
  inline seqAODGlobalSetpoints_out(const seqAODGlobalSetpoints_out& _s) : _data(_s._data) {}
  inline seqAODGlobalSetpoints_out& operator = (const seqAODGlobalSetpoints_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqAODGlobalSetpoints_out& operator = (seqAODGlobalSetpoints* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqAODGlobalSetpoints*&()  { return _data; }
  inline seqAODGlobalSetpoints*& ptr()       { return _data; }
  inline seqAODGlobalSetpoints* operator->() { return _data; }

  inline sAODGlobalSetpoints& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqAODGlobalSetpoints*& _data;

private:
  seqAODGlobalSetpoints_out();
  seqAODGlobalSetpoints_out& operator=(const seqAODGlobalSetpoints_var&);
};

struct sGenRes {
  typedef _CORBA_ConstrType_Variable_Var<sGenRes> _var_type;

  
  seqAnalysis Analysis;

  ::CORBA::Double SteelWeight;

  ::CORBA::Double SlagWeight;

  ::CORBA::Double Temp;

  ::CORBA::Double DurPhase;

  sMetTimeStamp MetTimeStamp;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sGenRes::_var_type sGenRes_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sGenRes,sGenRes_var > sGenRes_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sGenRes;

struct sAODPredBlowRes {
  typedef _CORBA_ConstrType_Variable_Var<sAODPredBlowRes> _var_type;

  
  ::CORBA::String_member Phase;

  ::CORBA::Long PhaseNo;

  ::CORBA::Double O2Vol;

  ::CORBA::Double TopLanceO2Flow;

  ::CORBA::Double TopLanceN2Flow;

  ::CORBA::Double TopLanceArFlow;

  ::CORBA::Double TopLanceO2Cons;

  ::CORBA::Double TopLanceArCons;

  ::CORBA::Double TopLanceN2Cons;

  ::CORBA::Double TuyerO2Flow;

  ::CORBA::Double TuyerN2Flow;

  ::CORBA::Double TuyerArFlow;

  ::CORBA::Double TuyerO2Cons;

  ::CORBA::Double TuyerArCons;

  ::CORBA::Double TuyerN2Cons;

  ::CORBA::Double DecarbRate;

  ::CORBA::Double ChromDeslagRate;

  ::CORBA::Double TopLanceHeight;

  ::CORBA::Long PhaseActive;

  sGenRes GenRes;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sAODPredBlowRes::_var_type sAODPredBlowRes_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sAODPredBlowRes,sAODPredBlowRes_var > sAODPredBlowRes_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sAODPredBlowRes;

struct sPredRes {
  typedef _CORBA_ConstrType_Variable_Var<sPredRes> _var_type;

  
  ::CORBA::String_member Phase;

  ::CORBA::Long PhaseNo;

  sGenRes GenRes;

  ::CORBA::Long PhaseActive;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sPredRes::_var_type sPredRes_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sPredRes,sPredRes_var > sPredRes_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sPredRes;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqAODBlowPredRes;

class seqAODBlowPredRes_var;

class seqAODBlowPredRes : public _CORBA_Unbounded_Sequence< sAODPredBlowRes >  {
public:
  typedef seqAODBlowPredRes_var _var_type;
  inline seqAODBlowPredRes() {}
  inline seqAODBlowPredRes(const seqAODBlowPredRes& _s)
    : _CORBA_Unbounded_Sequence< sAODPredBlowRes > (_s) {}

  inline seqAODBlowPredRes(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sAODPredBlowRes > (_max) {}
  inline seqAODBlowPredRes(_CORBA_ULong _max, _CORBA_ULong _len, sAODPredBlowRes* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sAODPredBlowRes > (_max, _len, _val, _rel) {}



  inline seqAODBlowPredRes& operator = (const seqAODBlowPredRes& _s) {
    _CORBA_Unbounded_Sequence< sAODPredBlowRes > ::operator=(_s);
    return *this;
  }
};

class seqAODBlowPredRes_out;

class seqAODBlowPredRes_var {
public:
  inline seqAODBlowPredRes_var() : _pd_seq(0) {}
  inline seqAODBlowPredRes_var(seqAODBlowPredRes* _s) : _pd_seq(_s) {}
  inline seqAODBlowPredRes_var(const seqAODBlowPredRes_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqAODBlowPredRes(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqAODBlowPredRes_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqAODBlowPredRes_var& operator = (seqAODBlowPredRes* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqAODBlowPredRes_var& operator = (const seqAODBlowPredRes_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqAODBlowPredRes;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sAODPredBlowRes& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqAODBlowPredRes* operator -> () { return _pd_seq; }
  inline const seqAODBlowPredRes* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqAODBlowPredRes& () const { return *_pd_seq; }
#else
  inline operator const seqAODBlowPredRes& () const { return *_pd_seq; }
  inline operator seqAODBlowPredRes& () { return *_pd_seq; }
#endif
    
  inline const seqAODBlowPredRes& in() const { return *_pd_seq; }
  inline seqAODBlowPredRes&       inout()    { return *_pd_seq; }
  inline seqAODBlowPredRes*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqAODBlowPredRes* _retn() { seqAODBlowPredRes* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqAODBlowPredRes_out;
  
private:
  seqAODBlowPredRes* _pd_seq;
};

class seqAODBlowPredRes_out {
public:
  inline seqAODBlowPredRes_out(seqAODBlowPredRes*& _s) : _data(_s) { _data = 0; }
  inline seqAODBlowPredRes_out(seqAODBlowPredRes_var& _s)
    : _data(_s._pd_seq) { _s = (seqAODBlowPredRes*) 0; }
  inline seqAODBlowPredRes_out(const seqAODBlowPredRes_out& _s) : _data(_s._data) {}
  inline seqAODBlowPredRes_out& operator = (const seqAODBlowPredRes_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqAODBlowPredRes_out& operator = (seqAODBlowPredRes* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqAODBlowPredRes*&()  { return _data; }
  inline seqAODBlowPredRes*& ptr()       { return _data; }
  inline seqAODBlowPredRes* operator->() { return _data; }

  inline sAODPredBlowRes& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqAODBlowPredRes*& _data;

private:
  seqAODBlowPredRes_out();
  seqAODBlowPredRes_out& operator=(const seqAODBlowPredRes_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqPredRes;

class seqPredRes_var;

class seqPredRes : public _CORBA_Unbounded_Sequence< sPredRes >  {
public:
  typedef seqPredRes_var _var_type;
  inline seqPredRes() {}
  inline seqPredRes(const seqPredRes& _s)
    : _CORBA_Unbounded_Sequence< sPredRes > (_s) {}

  inline seqPredRes(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sPredRes > (_max) {}
  inline seqPredRes(_CORBA_ULong _max, _CORBA_ULong _len, sPredRes* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sPredRes > (_max, _len, _val, _rel) {}



  inline seqPredRes& operator = (const seqPredRes& _s) {
    _CORBA_Unbounded_Sequence< sPredRes > ::operator=(_s);
    return *this;
  }
};

class seqPredRes_out;

class seqPredRes_var {
public:
  inline seqPredRes_var() : _pd_seq(0) {}
  inline seqPredRes_var(seqPredRes* _s) : _pd_seq(_s) {}
  inline seqPredRes_var(const seqPredRes_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqPredRes(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqPredRes_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqPredRes_var& operator = (seqPredRes* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqPredRes_var& operator = (const seqPredRes_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqPredRes;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sPredRes& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqPredRes* operator -> () { return _pd_seq; }
  inline const seqPredRes* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqPredRes& () const { return *_pd_seq; }
#else
  inline operator const seqPredRes& () const { return *_pd_seq; }
  inline operator seqPredRes& () { return *_pd_seq; }
#endif
    
  inline const seqPredRes& in() const { return *_pd_seq; }
  inline seqPredRes&       inout()    { return *_pd_seq; }
  inline seqPredRes*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqPredRes* _retn() { seqPredRes* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqPredRes_out;
  
private:
  seqPredRes* _pd_seq;
};

class seqPredRes_out {
public:
  inline seqPredRes_out(seqPredRes*& _s) : _data(_s) { _data = 0; }
  inline seqPredRes_out(seqPredRes_var& _s)
    : _data(_s._pd_seq) { _s = (seqPredRes*) 0; }
  inline seqPredRes_out(const seqPredRes_out& _s) : _data(_s._data) {}
  inline seqPredRes_out& operator = (const seqPredRes_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqPredRes_out& operator = (seqPredRes* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqPredRes*&()  { return _data; }
  inline seqPredRes*& ptr()       { return _data; }
  inline seqPredRes* operator->() { return _data; }

  inline sPredRes& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqPredRes*& _data;

private:
  seqPredRes_out();
  seqPredRes_out& operator=(const seqPredRes_var&);
};

struct sCoolWater {
  typedef _CORBA_ConstrType_Variable_Var<sCoolWater> _var_type;

  
  ::CORBA::String_member CircuitName;

  ::CORBA::Double WaterFlow;

  ::CORBA::Double OutletTemp;

  ::CORBA::Double InletTemp;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sCoolWater::_var_type sCoolWater_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sCoolWater,sCoolWater_var > sCoolWater_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sCoolWater;

struct sComputerMode {
  typedef _CORBA_ConstrType_Variable_Var<sComputerMode> _var_type;

  
  ::CORBA::String_member Device;

  ::CORBA::Long Status;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sComputerMode::_var_type sComputerMode_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sComputerMode,sComputerMode_var > sComputerMode_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sComputerMode;

struct sCoolWaterDevice {
  typedef _CORBA_ConstrType_Variable_Var<sCoolWaterDevice> _var_type;

  
  ::CORBA::Long CoolWaterDeviceNo;

  ::CORBA::String_member CoolWaterDevice;

  sCoolWater CoolWaterData;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sCoolWaterDevice::_var_type sCoolWaterDevice_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sCoolWaterDevice,sCoolWaterDevice_var > sCoolWaterDevice_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sCoolWaterDevice;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqCoolWaterData;

class seqCoolWaterData_var;

class seqCoolWaterData : public _CORBA_Unbounded_Sequence< sCoolWaterDevice >  {
public:
  typedef seqCoolWaterData_var _var_type;
  inline seqCoolWaterData() {}
  inline seqCoolWaterData(const seqCoolWaterData& _s)
    : _CORBA_Unbounded_Sequence< sCoolWaterDevice > (_s) {}

  inline seqCoolWaterData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sCoolWaterDevice > (_max) {}
  inline seqCoolWaterData(_CORBA_ULong _max, _CORBA_ULong _len, sCoolWaterDevice* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sCoolWaterDevice > (_max, _len, _val, _rel) {}



  inline seqCoolWaterData& operator = (const seqCoolWaterData& _s) {
    _CORBA_Unbounded_Sequence< sCoolWaterDevice > ::operator=(_s);
    return *this;
  }
};

class seqCoolWaterData_out;

class seqCoolWaterData_var {
public:
  inline seqCoolWaterData_var() : _pd_seq(0) {}
  inline seqCoolWaterData_var(seqCoolWaterData* _s) : _pd_seq(_s) {}
  inline seqCoolWaterData_var(const seqCoolWaterData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqCoolWaterData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqCoolWaterData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqCoolWaterData_var& operator = (seqCoolWaterData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqCoolWaterData_var& operator = (const seqCoolWaterData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqCoolWaterData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sCoolWaterDevice& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqCoolWaterData* operator -> () { return _pd_seq; }
  inline const seqCoolWaterData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqCoolWaterData& () const { return *_pd_seq; }
#else
  inline operator const seqCoolWaterData& () const { return *_pd_seq; }
  inline operator seqCoolWaterData& () { return *_pd_seq; }
#endif
    
  inline const seqCoolWaterData& in() const { return *_pd_seq; }
  inline seqCoolWaterData&       inout()    { return *_pd_seq; }
  inline seqCoolWaterData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqCoolWaterData* _retn() { seqCoolWaterData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqCoolWaterData_out;
  
private:
  seqCoolWaterData* _pd_seq;
};

class seqCoolWaterData_out {
public:
  inline seqCoolWaterData_out(seqCoolWaterData*& _s) : _data(_s) { _data = 0; }
  inline seqCoolWaterData_out(seqCoolWaterData_var& _s)
    : _data(_s._pd_seq) { _s = (seqCoolWaterData*) 0; }
  inline seqCoolWaterData_out(const seqCoolWaterData_out& _s) : _data(_s._data) {}
  inline seqCoolWaterData_out& operator = (const seqCoolWaterData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqCoolWaterData_out& operator = (seqCoolWaterData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqCoolWaterData*&()  { return _data; }
  inline seqCoolWaterData*& ptr()       { return _data; }
  inline seqCoolWaterData* operator->() { return _data; }

  inline sCoolWaterDevice& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqCoolWaterData*& _data;

private:
  seqCoolWaterData_out();
  seqCoolWaterData_out& operator=(const seqCoolWaterData_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqComputerModes;

class seqComputerModes_var;

class seqComputerModes : public _CORBA_Unbounded_Sequence< sComputerMode >  {
public:
  typedef seqComputerModes_var _var_type;
  inline seqComputerModes() {}
  inline seqComputerModes(const seqComputerModes& _s)
    : _CORBA_Unbounded_Sequence< sComputerMode > (_s) {}

  inline seqComputerModes(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sComputerMode > (_max) {}
  inline seqComputerModes(_CORBA_ULong _max, _CORBA_ULong _len, sComputerMode* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sComputerMode > (_max, _len, _val, _rel) {}



  inline seqComputerModes& operator = (const seqComputerModes& _s) {
    _CORBA_Unbounded_Sequence< sComputerMode > ::operator=(_s);
    return *this;
  }
};

class seqComputerModes_out;

class seqComputerModes_var {
public:
  inline seqComputerModes_var() : _pd_seq(0) {}
  inline seqComputerModes_var(seqComputerModes* _s) : _pd_seq(_s) {}
  inline seqComputerModes_var(const seqComputerModes_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqComputerModes(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqComputerModes_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqComputerModes_var& operator = (seqComputerModes* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqComputerModes_var& operator = (const seqComputerModes_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqComputerModes;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sComputerMode& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqComputerModes* operator -> () { return _pd_seq; }
  inline const seqComputerModes* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqComputerModes& () const { return *_pd_seq; }
#else
  inline operator const seqComputerModes& () const { return *_pd_seq; }
  inline operator seqComputerModes& () { return *_pd_seq; }
#endif
    
  inline const seqComputerModes& in() const { return *_pd_seq; }
  inline seqComputerModes&       inout()    { return *_pd_seq; }
  inline seqComputerModes*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqComputerModes* _retn() { seqComputerModes* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqComputerModes_out;
  
private:
  seqComputerModes* _pd_seq;
};

class seqComputerModes_out {
public:
  inline seqComputerModes_out(seqComputerModes*& _s) : _data(_s) { _data = 0; }
  inline seqComputerModes_out(seqComputerModes_var& _s)
    : _data(_s._pd_seq) { _s = (seqComputerModes*) 0; }
  inline seqComputerModes_out(const seqComputerModes_out& _s) : _data(_s._data) {}
  inline seqComputerModes_out& operator = (const seqComputerModes_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqComputerModes_out& operator = (seqComputerModes* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqComputerModes*&()  { return _data; }
  inline seqComputerModes*& ptr()       { return _data; }
  inline seqComputerModes* operator->() { return _data; }

  inline sComputerMode& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqComputerModes*& _data;

private:
  seqComputerModes_out();
  seqComputerModes_out& operator=(const seqComputerModes_var&);
};

struct sWireFeeder {
  typedef _CORBA_ConstrType_Variable_Var<sWireFeeder> _var_type;

  
  ::CORBA::Long WireFeederLineNo;

  ::CORBA::String_member WireFeederMatCode;

  ::CORBA::Double WireFeedSpeed;

  ::CORBA::Double WireFeederAmount;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sWireFeeder::_var_type sWireFeeder_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sWireFeeder,sWireFeeder_var > sWireFeeder_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sWireFeeder;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqWireFeeder;

class seqWireFeeder_var;

class seqWireFeeder : public _CORBA_Unbounded_Sequence< sWireFeeder >  {
public:
  typedef seqWireFeeder_var _var_type;
  inline seqWireFeeder() {}
  inline seqWireFeeder(const seqWireFeeder& _s)
    : _CORBA_Unbounded_Sequence< sWireFeeder > (_s) {}

  inline seqWireFeeder(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sWireFeeder > (_max) {}
  inline seqWireFeeder(_CORBA_ULong _max, _CORBA_ULong _len, sWireFeeder* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sWireFeeder > (_max, _len, _val, _rel) {}



  inline seqWireFeeder& operator = (const seqWireFeeder& _s) {
    _CORBA_Unbounded_Sequence< sWireFeeder > ::operator=(_s);
    return *this;
  }
};

class seqWireFeeder_out;

class seqWireFeeder_var {
public:
  inline seqWireFeeder_var() : _pd_seq(0) {}
  inline seqWireFeeder_var(seqWireFeeder* _s) : _pd_seq(_s) {}
  inline seqWireFeeder_var(const seqWireFeeder_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqWireFeeder(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqWireFeeder_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqWireFeeder_var& operator = (seqWireFeeder* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqWireFeeder_var& operator = (const seqWireFeeder_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqWireFeeder;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sWireFeeder& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqWireFeeder* operator -> () { return _pd_seq; }
  inline const seqWireFeeder* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqWireFeeder& () const { return *_pd_seq; }
#else
  inline operator const seqWireFeeder& () const { return *_pd_seq; }
  inline operator seqWireFeeder& () { return *_pd_seq; }
#endif
    
  inline const seqWireFeeder& in() const { return *_pd_seq; }
  inline seqWireFeeder&       inout()    { return *_pd_seq; }
  inline seqWireFeeder*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqWireFeeder* _retn() { seqWireFeeder* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqWireFeeder_out;
  
private:
  seqWireFeeder* _pd_seq;
};

class seqWireFeeder_out {
public:
  inline seqWireFeeder_out(seqWireFeeder*& _s) : _data(_s) { _data = 0; }
  inline seqWireFeeder_out(seqWireFeeder_var& _s)
    : _data(_s._pd_seq) { _s = (seqWireFeeder*) 0; }
  inline seqWireFeeder_out(const seqWireFeeder_out& _s) : _data(_s._data) {}
  inline seqWireFeeder_out& operator = (const seqWireFeeder_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqWireFeeder_out& operator = (seqWireFeeder* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqWireFeeder*&()  { return _data; }
  inline seqWireFeeder*& ptr()       { return _data; }
  inline seqWireFeeder* operator->() { return _data; }

  inline sWireFeeder& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqWireFeeder*& _data;

private:
  seqWireFeeder_out();
  seqWireFeeder_out& operator=(const seqWireFeeder_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqStringList;

class seqStringList_var;

class seqStringList : public _CORBA_Unbounded_Sequence_String {
public:
  typedef seqStringList_var _var_type;
  inline seqStringList() {}
  inline seqStringList(const seqStringList& _s)
    : _CORBA_Unbounded_Sequence_String(_s) {}

  inline seqStringList(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence_String(_max) {}
  inline seqStringList(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}



  inline seqStringList& operator = (const seqStringList& _s) {
    _CORBA_Unbounded_Sequence_String::operator=(_s);
    return *this;
  }
};

class seqStringList_out;

class seqStringList_var {
public:
  inline seqStringList_var() : _pd_seq(0) {}
  inline seqStringList_var(seqStringList* _s) : _pd_seq(_s) {}
  inline seqStringList_var(const seqStringList_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqStringList(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqStringList_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqStringList_var& operator = (seqStringList* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqStringList_var& operator = (const seqStringList_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqStringList;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqStringList* operator -> () { return _pd_seq; }
  inline const seqStringList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqStringList& () const { return *_pd_seq; }
#else
  inline operator const seqStringList& () const { return *_pd_seq; }
  inline operator seqStringList& () { return *_pd_seq; }
#endif
    
  inline const seqStringList& in() const { return *_pd_seq; }
  inline seqStringList&       inout()    { return *_pd_seq; }
  inline seqStringList*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqStringList* _retn() { seqStringList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqStringList_out;
  
private:
  seqStringList* _pd_seq;
};

class seqStringList_out {
public:
  inline seqStringList_out(seqStringList*& _s) : _data(_s) { _data = 0; }
  inline seqStringList_out(seqStringList_var& _s)
    : _data(_s._pd_seq) { _s = (seqStringList*) 0; }
  inline seqStringList_out(const seqStringList_out& _s) : _data(_s._data) {}
  inline seqStringList_out& operator = (const seqStringList_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqStringList_out& operator = (seqStringList* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqStringList*&()  { return _data; }
  inline seqStringList*& ptr()       { return _data; }
  inline seqStringList* operator->() { return _data; }

  inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqStringList*& _data;

private:
  seqStringList_out();
  seqStringList_out& operator=(const seqStringList_var&);
};

struct sGasData {
  typedef _CORBA_ConstrType_Variable_Var<sGasData> _var_type;

  
  ::CORBA::String_member GasType;

  ::CORBA::Double GasValue;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sGasData::_var_type sGasData_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sGasData,sGasData_var > sGasData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sGasData;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqGasData;

class seqGasData_var;

class seqGasData : public _CORBA_Unbounded_Sequence< sGasData >  {
public:
  typedef seqGasData_var _var_type;
  inline seqGasData() {}
  inline seqGasData(const seqGasData& _s)
    : _CORBA_Unbounded_Sequence< sGasData > (_s) {}

  inline seqGasData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sGasData > (_max) {}
  inline seqGasData(_CORBA_ULong _max, _CORBA_ULong _len, sGasData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sGasData > (_max, _len, _val, _rel) {}



  inline seqGasData& operator = (const seqGasData& _s) {
    _CORBA_Unbounded_Sequence< sGasData > ::operator=(_s);
    return *this;
  }
};

class seqGasData_out;

class seqGasData_var {
public:
  inline seqGasData_var() : _pd_seq(0) {}
  inline seqGasData_var(seqGasData* _s) : _pd_seq(_s) {}
  inline seqGasData_var(const seqGasData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqGasData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqGasData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqGasData_var& operator = (seqGasData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqGasData_var& operator = (const seqGasData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqGasData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sGasData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqGasData* operator -> () { return _pd_seq; }
  inline const seqGasData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqGasData& () const { return *_pd_seq; }
#else
  inline operator const seqGasData& () const { return *_pd_seq; }
  inline operator seqGasData& () { return *_pd_seq; }
#endif
    
  inline const seqGasData& in() const { return *_pd_seq; }
  inline seqGasData&       inout()    { return *_pd_seq; }
  inline seqGasData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqGasData* _retn() { seqGasData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqGasData_out;
  
private:
  seqGasData* _pd_seq;
};

class seqGasData_out {
public:
  inline seqGasData_out(seqGasData*& _s) : _data(_s) { _data = 0; }
  inline seqGasData_out(seqGasData_var& _s)
    : _data(_s._pd_seq) { _s = (seqGasData*) 0; }
  inline seqGasData_out(const seqGasData_out& _s) : _data(_s._data) {}
  inline seqGasData_out& operator = (const seqGasData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqGasData_out& operator = (seqGasData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqGasData*&()  { return _data; }
  inline seqGasData*& ptr()       { return _data; }
  inline seqGasData* operator->() { return _data; }

  inline sGasData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqGasData*& _data;

private:
  seqGasData_out();
  seqGasData_out& operator=(const seqGasData_var&);
};

struct sGasLanceData {
  typedef _CORBA_ConstrType_Variable_Var<sGasLanceData> _var_type;

  
  seqGasData LanceData;

  ::CORBA::String_member Device;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sGasLanceData::_var_type sGasLanceData_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sGasLanceData,sGasLanceData_var > sGasLanceData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sGasLanceData;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqGasLanceData;

class seqGasLanceData_var;

class seqGasLanceData : public _CORBA_Unbounded_Sequence< sGasLanceData >  {
public:
  typedef seqGasLanceData_var _var_type;
  inline seqGasLanceData() {}
  inline seqGasLanceData(const seqGasLanceData& _s)
    : _CORBA_Unbounded_Sequence< sGasLanceData > (_s) {}

  inline seqGasLanceData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sGasLanceData > (_max) {}
  inline seqGasLanceData(_CORBA_ULong _max, _CORBA_ULong _len, sGasLanceData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sGasLanceData > (_max, _len, _val, _rel) {}



  inline seqGasLanceData& operator = (const seqGasLanceData& _s) {
    _CORBA_Unbounded_Sequence< sGasLanceData > ::operator=(_s);
    return *this;
  }
};

class seqGasLanceData_out;

class seqGasLanceData_var {
public:
  inline seqGasLanceData_var() : _pd_seq(0) {}
  inline seqGasLanceData_var(seqGasLanceData* _s) : _pd_seq(_s) {}
  inline seqGasLanceData_var(const seqGasLanceData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqGasLanceData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqGasLanceData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqGasLanceData_var& operator = (seqGasLanceData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqGasLanceData_var& operator = (const seqGasLanceData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqGasLanceData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sGasLanceData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqGasLanceData* operator -> () { return _pd_seq; }
  inline const seqGasLanceData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqGasLanceData& () const { return *_pd_seq; }
#else
  inline operator const seqGasLanceData& () const { return *_pd_seq; }
  inline operator seqGasLanceData& () { return *_pd_seq; }
#endif
    
  inline const seqGasLanceData& in() const { return *_pd_seq; }
  inline seqGasLanceData&       inout()    { return *_pd_seq; }
  inline seqGasLanceData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqGasLanceData* _retn() { seqGasLanceData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqGasLanceData_out;
  
private:
  seqGasLanceData* _pd_seq;
};

class seqGasLanceData_out {
public:
  inline seqGasLanceData_out(seqGasLanceData*& _s) : _data(_s) { _data = 0; }
  inline seqGasLanceData_out(seqGasLanceData_var& _s)
    : _data(_s._pd_seq) { _s = (seqGasLanceData*) 0; }
  inline seqGasLanceData_out(const seqGasLanceData_out& _s) : _data(_s._data) {}
  inline seqGasLanceData_out& operator = (const seqGasLanceData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqGasLanceData_out& operator = (seqGasLanceData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqGasLanceData*&()  { return _data; }
  inline seqGasLanceData*& ptr()       { return _data; }
  inline seqGasLanceData* operator->() { return _data; }

  inline sGasLanceData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqGasLanceData*& _data;

private:
  seqGasLanceData_out();
  seqGasLanceData_out& operator=(const seqGasLanceData_var&);
};

struct sDeviceGasData {
  typedef _CORBA_ConstrType_Variable_Var<sDeviceGasData> _var_type;

  
  ::CORBA::String_member Device;

  seqGasData GasData;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sDeviceGasData::_var_type sDeviceGasData_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sDeviceGasData,sDeviceGasData_var > sDeviceGasData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sDeviceGasData;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqDeviceGasData;

class seqDeviceGasData_var;

class seqDeviceGasData : public _CORBA_Unbounded_Sequence< sDeviceGasData >  {
public:
  typedef seqDeviceGasData_var _var_type;
  inline seqDeviceGasData() {}
  inline seqDeviceGasData(const seqDeviceGasData& _s)
    : _CORBA_Unbounded_Sequence< sDeviceGasData > (_s) {}

  inline seqDeviceGasData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sDeviceGasData > (_max) {}
  inline seqDeviceGasData(_CORBA_ULong _max, _CORBA_ULong _len, sDeviceGasData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sDeviceGasData > (_max, _len, _val, _rel) {}



  inline seqDeviceGasData& operator = (const seqDeviceGasData& _s) {
    _CORBA_Unbounded_Sequence< sDeviceGasData > ::operator=(_s);
    return *this;
  }
};

class seqDeviceGasData_out;

class seqDeviceGasData_var {
public:
  inline seqDeviceGasData_var() : _pd_seq(0) {}
  inline seqDeviceGasData_var(seqDeviceGasData* _s) : _pd_seq(_s) {}
  inline seqDeviceGasData_var(const seqDeviceGasData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqDeviceGasData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqDeviceGasData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqDeviceGasData_var& operator = (seqDeviceGasData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqDeviceGasData_var& operator = (const seqDeviceGasData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqDeviceGasData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sDeviceGasData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqDeviceGasData* operator -> () { return _pd_seq; }
  inline const seqDeviceGasData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqDeviceGasData& () const { return *_pd_seq; }
#else
  inline operator const seqDeviceGasData& () const { return *_pd_seq; }
  inline operator seqDeviceGasData& () { return *_pd_seq; }
#endif
    
  inline const seqDeviceGasData& in() const { return *_pd_seq; }
  inline seqDeviceGasData&       inout()    { return *_pd_seq; }
  inline seqDeviceGasData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqDeviceGasData* _retn() { seqDeviceGasData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqDeviceGasData_out;
  
private:
  seqDeviceGasData* _pd_seq;
};

class seqDeviceGasData_out {
public:
  inline seqDeviceGasData_out(seqDeviceGasData*& _s) : _data(_s) { _data = 0; }
  inline seqDeviceGasData_out(seqDeviceGasData_var& _s)
    : _data(_s._pd_seq) { _s = (seqDeviceGasData*) 0; }
  inline seqDeviceGasData_out(const seqDeviceGasData_out& _s) : _data(_s._data) {}
  inline seqDeviceGasData_out& operator = (const seqDeviceGasData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqDeviceGasData_out& operator = (seqDeviceGasData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqDeviceGasData*&()  { return _data; }
  inline seqDeviceGasData*& ptr()       { return _data; }
  inline seqDeviceGasData* operator->() { return _data; }

  inline sDeviceGasData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqDeviceGasData*& _data;

private:
  seqDeviceGasData_out();
  seqDeviceGasData_out& operator=(const seqDeviceGasData_var&);
};

struct sEAFGasLancePredRes {
  typedef _CORBA_ConstrType_Variable_Var<sEAFGasLancePredRes> _var_type;

  
  ::CORBA::String_member Phase;

  ::CORBA::Long PhaseNo;

  ::CORBA::Long Step;

  ::CORBA::Double DurStep;

  seqDeviceGasData GasFlow;

  ::CORBA::Double ElecEgy;

  ::CORBA::Double DurUntilEndOfStep;

  ::CORBA::Double DurUntilStartOfStep;

  ::CORBA::Double SpecEgyStep;

  ::CORBA::Double ElecEgyStep;

  ::CORBA::Double SpecEgy;

  ::CORBA::Double BaseMass;

  seqDeviceGasData GasAmount;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sEAFGasLancePredRes::_var_type sEAFGasLancePredRes_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sEAFGasLancePredRes,sEAFGasLancePredRes_var > sEAFGasLancePredRes_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sEAFGasLancePredRes;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqEAFGasLancePredRes;

class seqEAFGasLancePredRes_var;

class seqEAFGasLancePredRes : public _CORBA_Unbounded_Sequence< sEAFGasLancePredRes >  {
public:
  typedef seqEAFGasLancePredRes_var _var_type;
  inline seqEAFGasLancePredRes() {}
  inline seqEAFGasLancePredRes(const seqEAFGasLancePredRes& _s)
    : _CORBA_Unbounded_Sequence< sEAFGasLancePredRes > (_s) {}

  inline seqEAFGasLancePredRes(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sEAFGasLancePredRes > (_max) {}
  inline seqEAFGasLancePredRes(_CORBA_ULong _max, _CORBA_ULong _len, sEAFGasLancePredRes* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sEAFGasLancePredRes > (_max, _len, _val, _rel) {}



  inline seqEAFGasLancePredRes& operator = (const seqEAFGasLancePredRes& _s) {
    _CORBA_Unbounded_Sequence< sEAFGasLancePredRes > ::operator=(_s);
    return *this;
  }
};

class seqEAFGasLancePredRes_out;

class seqEAFGasLancePredRes_var {
public:
  inline seqEAFGasLancePredRes_var() : _pd_seq(0) {}
  inline seqEAFGasLancePredRes_var(seqEAFGasLancePredRes* _s) : _pd_seq(_s) {}
  inline seqEAFGasLancePredRes_var(const seqEAFGasLancePredRes_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqEAFGasLancePredRes(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqEAFGasLancePredRes_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqEAFGasLancePredRes_var& operator = (seqEAFGasLancePredRes* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqEAFGasLancePredRes_var& operator = (const seqEAFGasLancePredRes_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqEAFGasLancePredRes;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sEAFGasLancePredRes& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqEAFGasLancePredRes* operator -> () { return _pd_seq; }
  inline const seqEAFGasLancePredRes* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqEAFGasLancePredRes& () const { return *_pd_seq; }
#else
  inline operator const seqEAFGasLancePredRes& () const { return *_pd_seq; }
  inline operator seqEAFGasLancePredRes& () { return *_pd_seq; }
#endif
    
  inline const seqEAFGasLancePredRes& in() const { return *_pd_seq; }
  inline seqEAFGasLancePredRes&       inout()    { return *_pd_seq; }
  inline seqEAFGasLancePredRes*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqEAFGasLancePredRes* _retn() { seqEAFGasLancePredRes* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqEAFGasLancePredRes_out;
  
private:
  seqEAFGasLancePredRes* _pd_seq;
};

class seqEAFGasLancePredRes_out {
public:
  inline seqEAFGasLancePredRes_out(seqEAFGasLancePredRes*& _s) : _data(_s) { _data = 0; }
  inline seqEAFGasLancePredRes_out(seqEAFGasLancePredRes_var& _s)
    : _data(_s._pd_seq) { _s = (seqEAFGasLancePredRes*) 0; }
  inline seqEAFGasLancePredRes_out(const seqEAFGasLancePredRes_out& _s) : _data(_s._data) {}
  inline seqEAFGasLancePredRes_out& operator = (const seqEAFGasLancePredRes_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqEAFGasLancePredRes_out& operator = (seqEAFGasLancePredRes* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqEAFGasLancePredRes*&()  { return _data; }
  inline seqEAFGasLancePredRes*& ptr()       { return _data; }
  inline seqEAFGasLancePredRes* operator->() { return _data; }

  inline sEAFGasLancePredRes& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqEAFGasLancePredRes*& _data;

private:
  seqEAFGasLancePredRes_out();
  seqEAFGasLancePredRes_out& operator=(const seqEAFGasLancePredRes_var&);
};

struct sGasAvail {
  typedef _CORBA_ConstrType_Variable_Var<sGasAvail> _var_type;

  
  ::CORBA::String_member GasType;

  ::CORBA::Long GasAvail;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sGasAvail::_var_type sGasAvail_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sGasAvail,sGasAvail_var > sGasAvail_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sGasAvail;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqGasAvail;

class seqGasAvail_var;

class seqGasAvail : public _CORBA_Unbounded_Sequence< sGasAvail >  {
public:
  typedef seqGasAvail_var _var_type;
  inline seqGasAvail() {}
  inline seqGasAvail(const seqGasAvail& _s)
    : _CORBA_Unbounded_Sequence< sGasAvail > (_s) {}

  inline seqGasAvail(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sGasAvail > (_max) {}
  inline seqGasAvail(_CORBA_ULong _max, _CORBA_ULong _len, sGasAvail* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sGasAvail > (_max, _len, _val, _rel) {}



  inline seqGasAvail& operator = (const seqGasAvail& _s) {
    _CORBA_Unbounded_Sequence< sGasAvail > ::operator=(_s);
    return *this;
  }
};

class seqGasAvail_out;

class seqGasAvail_var {
public:
  inline seqGasAvail_var() : _pd_seq(0) {}
  inline seqGasAvail_var(seqGasAvail* _s) : _pd_seq(_s) {}
  inline seqGasAvail_var(const seqGasAvail_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqGasAvail(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqGasAvail_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqGasAvail_var& operator = (seqGasAvail* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqGasAvail_var& operator = (const seqGasAvail_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqGasAvail;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sGasAvail& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqGasAvail* operator -> () { return _pd_seq; }
  inline const seqGasAvail* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqGasAvail& () const { return *_pd_seq; }
#else
  inline operator const seqGasAvail& () const { return *_pd_seq; }
  inline operator seqGasAvail& () { return *_pd_seq; }
#endif
    
  inline const seqGasAvail& in() const { return *_pd_seq; }
  inline seqGasAvail&       inout()    { return *_pd_seq; }
  inline seqGasAvail*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqGasAvail* _retn() { seqGasAvail* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqGasAvail_out;
  
private:
  seqGasAvail* _pd_seq;
};

class seqGasAvail_out {
public:
  inline seqGasAvail_out(seqGasAvail*& _s) : _data(_s) { _data = 0; }
  inline seqGasAvail_out(seqGasAvail_var& _s)
    : _data(_s._pd_seq) { _s = (seqGasAvail*) 0; }
  inline seqGasAvail_out(const seqGasAvail_out& _s) : _data(_s._data) {}
  inline seqGasAvail_out& operator = (const seqGasAvail_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqGasAvail_out& operator = (seqGasAvail* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqGasAvail*&()  { return _data; }
  inline seqGasAvail*& ptr()       { return _data; }
  inline seqGasAvail* operator->() { return _data; }

  inline sGasAvail& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqGasAvail*& _data;

private:
  seqGasAvail_out();
  seqGasAvail_out& operator=(const seqGasAvail_var&);
};

struct sWasteGas {
  typedef _CORBA_ConstrType_Variable_Var<sWasteGas> _var_type;

  
  ::CORBA::String_member WasteGasType;

  ::CORBA::Double WasteGasConc;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sWasteGas::_var_type sWasteGas_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sWasteGas,sWasteGas_var > sWasteGas_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sWasteGas;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqWasteGas;

class seqWasteGas_var;

class seqWasteGas : public _CORBA_Unbounded_Sequence< sWasteGas >  {
public:
  typedef seqWasteGas_var _var_type;
  inline seqWasteGas() {}
  inline seqWasteGas(const seqWasteGas& _s)
    : _CORBA_Unbounded_Sequence< sWasteGas > (_s) {}

  inline seqWasteGas(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sWasteGas > (_max) {}
  inline seqWasteGas(_CORBA_ULong _max, _CORBA_ULong _len, sWasteGas* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sWasteGas > (_max, _len, _val, _rel) {}



  inline seqWasteGas& operator = (const seqWasteGas& _s) {
    _CORBA_Unbounded_Sequence< sWasteGas > ::operator=(_s);
    return *this;
  }
};

class seqWasteGas_out;

class seqWasteGas_var {
public:
  inline seqWasteGas_var() : _pd_seq(0) {}
  inline seqWasteGas_var(seqWasteGas* _s) : _pd_seq(_s) {}
  inline seqWasteGas_var(const seqWasteGas_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqWasteGas(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqWasteGas_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqWasteGas_var& operator = (seqWasteGas* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqWasteGas_var& operator = (const seqWasteGas_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqWasteGas;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sWasteGas& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqWasteGas* operator -> () { return _pd_seq; }
  inline const seqWasteGas* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqWasteGas& () const { return *_pd_seq; }
#else
  inline operator const seqWasteGas& () const { return *_pd_seq; }
  inline operator seqWasteGas& () { return *_pd_seq; }
#endif
    
  inline const seqWasteGas& in() const { return *_pd_seq; }
  inline seqWasteGas&       inout()    { return *_pd_seq; }
  inline seqWasteGas*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqWasteGas* _retn() { seqWasteGas* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqWasteGas_out;
  
private:
  seqWasteGas* _pd_seq;
};

class seqWasteGas_out {
public:
  inline seqWasteGas_out(seqWasteGas*& _s) : _data(_s) { _data = 0; }
  inline seqWasteGas_out(seqWasteGas_var& _s)
    : _data(_s._pd_seq) { _s = (seqWasteGas*) 0; }
  inline seqWasteGas_out(const seqWasteGas_out& _s) : _data(_s._data) {}
  inline seqWasteGas_out& operator = (const seqWasteGas_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqWasteGas_out& operator = (seqWasteGas* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqWasteGas*&()  { return _data; }
  inline seqWasteGas*& ptr()       { return _data; }
  inline seqWasteGas* operator->() { return _data; }

  inline sWasteGas& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqWasteGas*& _data;

private:
  seqWasteGas_out();
  seqWasteGas_out& operator=(const seqWasteGas_var&);
};

struct sBlowStatus {
  typedef _CORBA_ConstrType_Variable_Var<sBlowStatus> _var_type;

  
  ::CORBA::String_member BlowDevice;

  ::CORBA::Long BlowStatus;

  sDate BlowTime;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sBlowStatus::_var_type sBlowStatus_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sBlowStatus,sBlowStatus_var > sBlowStatus_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sBlowStatus;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqBlowStatus;

class seqBlowStatus_var;

class seqBlowStatus : public _CORBA_Unbounded_Sequence< sBlowStatus >  {
public:
  typedef seqBlowStatus_var _var_type;
  inline seqBlowStatus() {}
  inline seqBlowStatus(const seqBlowStatus& _s)
    : _CORBA_Unbounded_Sequence< sBlowStatus > (_s) {}

  inline seqBlowStatus(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sBlowStatus > (_max) {}
  inline seqBlowStatus(_CORBA_ULong _max, _CORBA_ULong _len, sBlowStatus* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sBlowStatus > (_max, _len, _val, _rel) {}



  inline seqBlowStatus& operator = (const seqBlowStatus& _s) {
    _CORBA_Unbounded_Sequence< sBlowStatus > ::operator=(_s);
    return *this;
  }
};

class seqBlowStatus_out;

class seqBlowStatus_var {
public:
  inline seqBlowStatus_var() : _pd_seq(0) {}
  inline seqBlowStatus_var(seqBlowStatus* _s) : _pd_seq(_s) {}
  inline seqBlowStatus_var(const seqBlowStatus_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqBlowStatus(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqBlowStatus_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqBlowStatus_var& operator = (seqBlowStatus* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqBlowStatus_var& operator = (const seqBlowStatus_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqBlowStatus;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sBlowStatus& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqBlowStatus* operator -> () { return _pd_seq; }
  inline const seqBlowStatus* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqBlowStatus& () const { return *_pd_seq; }
#else
  inline operator const seqBlowStatus& () const { return *_pd_seq; }
  inline operator seqBlowStatus& () { return *_pd_seq; }
#endif
    
  inline const seqBlowStatus& in() const { return *_pd_seq; }
  inline seqBlowStatus&       inout()    { return *_pd_seq; }
  inline seqBlowStatus*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqBlowStatus* _retn() { seqBlowStatus* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqBlowStatus_out;
  
private:
  seqBlowStatus* _pd_seq;
};

class seqBlowStatus_out {
public:
  inline seqBlowStatus_out(seqBlowStatus*& _s) : _data(_s) { _data = 0; }
  inline seqBlowStatus_out(seqBlowStatus_var& _s)
    : _data(_s._pd_seq) { _s = (seqBlowStatus*) 0; }
  inline seqBlowStatus_out(const seqBlowStatus_out& _s) : _data(_s._data) {}
  inline seqBlowStatus_out& operator = (const seqBlowStatus_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqBlowStatus_out& operator = (seqBlowStatus* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqBlowStatus*&()  { return _data; }
  inline seqBlowStatus*& ptr()       { return _data; }
  inline seqBlowStatus* operator->() { return _data; }

  inline sBlowStatus& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqBlowStatus*& _data;

private:
  seqBlowStatus_out();
  seqBlowStatus_out& operator=(const seqBlowStatus_var&);
};

struct sStatus {
  typedef _CORBA_ConstrType_Variable_Var<sStatus> _var_type;

  
  ::CORBA::String_member Device;

  ::CORBA::Long Status;

  ::CORBA::String_member StatusName;

  sDate EndTime;

  sDate StartTime;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sStatus::_var_type sStatus_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sStatus,sStatus_var > sStatus_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sStatus;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqStatus;

class seqStatus_var;

class seqStatus : public _CORBA_Unbounded_Sequence< sStatus >  {
public:
  typedef seqStatus_var _var_type;
  inline seqStatus() {}
  inline seqStatus(const seqStatus& _s)
    : _CORBA_Unbounded_Sequence< sStatus > (_s) {}

  inline seqStatus(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sStatus > (_max) {}
  inline seqStatus(_CORBA_ULong _max, _CORBA_ULong _len, sStatus* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sStatus > (_max, _len, _val, _rel) {}



  inline seqStatus& operator = (const seqStatus& _s) {
    _CORBA_Unbounded_Sequence< sStatus > ::operator=(_s);
    return *this;
  }
};

class seqStatus_out;

class seqStatus_var {
public:
  inline seqStatus_var() : _pd_seq(0) {}
  inline seqStatus_var(seqStatus* _s) : _pd_seq(_s) {}
  inline seqStatus_var(const seqStatus_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqStatus(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqStatus_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqStatus_var& operator = (seqStatus* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqStatus_var& operator = (const seqStatus_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqStatus;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sStatus& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqStatus* operator -> () { return _pd_seq; }
  inline const seqStatus* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqStatus& () const { return *_pd_seq; }
#else
  inline operator const seqStatus& () const { return *_pd_seq; }
  inline operator seqStatus& () { return *_pd_seq; }
#endif
    
  inline const seqStatus& in() const { return *_pd_seq; }
  inline seqStatus&       inout()    { return *_pd_seq; }
  inline seqStatus*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqStatus* _retn() { seqStatus* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqStatus_out;
  
private:
  seqStatus* _pd_seq;
};

class seqStatus_out {
public:
  inline seqStatus_out(seqStatus*& _s) : _data(_s) { _data = 0; }
  inline seqStatus_out(seqStatus_var& _s)
    : _data(_s._pd_seq) { _s = (seqStatus*) 0; }
  inline seqStatus_out(const seqStatus_out& _s) : _data(_s._data) {}
  inline seqStatus_out& operator = (const seqStatus_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqStatus_out& operator = (seqStatus* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqStatus*&()  { return _data; }
  inline seqStatus*& ptr()       { return _data; }
  inline seqStatus* operator->() { return _data; }

  inline sStatus& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqStatus*& _data;

private:
  seqStatus_out();
  seqStatus_out& operator=(const seqStatus_var&);
};

struct sHeatSchedulePlant {
  typedef _CORBA_ConstrType_Variable_Var<sHeatSchedulePlant> _var_type;

  
  ::CORBA::String_member Plant;

  ::CORBA::String_member TreatID;

  sDate TreatStartPlan;

  sDate TreatEndPlan;

  ::CORBA::Long PlantNo;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sHeatSchedulePlant::_var_type sHeatSchedulePlant_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sHeatSchedulePlant,sHeatSchedulePlant_var > sHeatSchedulePlant_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sHeatSchedulePlant;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqHeatSchedulePlant;

class seqHeatSchedulePlant_var;

class seqHeatSchedulePlant : public _CORBA_Unbounded_Sequence< sHeatSchedulePlant >  {
public:
  typedef seqHeatSchedulePlant_var _var_type;
  inline seqHeatSchedulePlant() {}
  inline seqHeatSchedulePlant(const seqHeatSchedulePlant& _s)
    : _CORBA_Unbounded_Sequence< sHeatSchedulePlant > (_s) {}

  inline seqHeatSchedulePlant(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sHeatSchedulePlant > (_max) {}
  inline seqHeatSchedulePlant(_CORBA_ULong _max, _CORBA_ULong _len, sHeatSchedulePlant* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sHeatSchedulePlant > (_max, _len, _val, _rel) {}



  inline seqHeatSchedulePlant& operator = (const seqHeatSchedulePlant& _s) {
    _CORBA_Unbounded_Sequence< sHeatSchedulePlant > ::operator=(_s);
    return *this;
  }
};

class seqHeatSchedulePlant_out;

class seqHeatSchedulePlant_var {
public:
  inline seqHeatSchedulePlant_var() : _pd_seq(0) {}
  inline seqHeatSchedulePlant_var(seqHeatSchedulePlant* _s) : _pd_seq(_s) {}
  inline seqHeatSchedulePlant_var(const seqHeatSchedulePlant_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqHeatSchedulePlant(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqHeatSchedulePlant_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqHeatSchedulePlant_var& operator = (seqHeatSchedulePlant* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqHeatSchedulePlant_var& operator = (const seqHeatSchedulePlant_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqHeatSchedulePlant;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sHeatSchedulePlant& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqHeatSchedulePlant* operator -> () { return _pd_seq; }
  inline const seqHeatSchedulePlant* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqHeatSchedulePlant& () const { return *_pd_seq; }
#else
  inline operator const seqHeatSchedulePlant& () const { return *_pd_seq; }
  inline operator seqHeatSchedulePlant& () { return *_pd_seq; }
#endif
    
  inline const seqHeatSchedulePlant& in() const { return *_pd_seq; }
  inline seqHeatSchedulePlant&       inout()    { return *_pd_seq; }
  inline seqHeatSchedulePlant*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqHeatSchedulePlant* _retn() { seqHeatSchedulePlant* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqHeatSchedulePlant_out;
  
private:
  seqHeatSchedulePlant* _pd_seq;
};

class seqHeatSchedulePlant_out {
public:
  inline seqHeatSchedulePlant_out(seqHeatSchedulePlant*& _s) : _data(_s) { _data = 0; }
  inline seqHeatSchedulePlant_out(seqHeatSchedulePlant_var& _s)
    : _data(_s._pd_seq) { _s = (seqHeatSchedulePlant*) 0; }
  inline seqHeatSchedulePlant_out(const seqHeatSchedulePlant_out& _s) : _data(_s._data) {}
  inline seqHeatSchedulePlant_out& operator = (const seqHeatSchedulePlant_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqHeatSchedulePlant_out& operator = (seqHeatSchedulePlant* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqHeatSchedulePlant*&()  { return _data; }
  inline seqHeatSchedulePlant*& ptr()       { return _data; }
  inline seqHeatSchedulePlant* operator->() { return _data; }

  inline sHeatSchedulePlant& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqHeatSchedulePlant*& _data;

private:
  seqHeatSchedulePlant_out();
  seqHeatSchedulePlant_out& operator=(const seqHeatSchedulePlant_var&);
};

struct sHeatSchedule {
  typedef _CORBA_ConstrType_Variable_Var<sHeatSchedule> _var_type;

  
  ::CORBA::String_member HeatId;

  ::CORBA::String_member OrderId;

  ::CORBA::String_member RouteCode;

  ::CORBA::String_member CasterSeqId;

  ::CORBA::Long CasterSeqNo;

  ::CORBA::Long ActionFlag;

  seqHeatSchedulePlant HeatPlant;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sHeatSchedule::_var_type sHeatSchedule_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sHeatSchedule,sHeatSchedule_var > sHeatSchedule_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sHeatSchedule;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqHeatSchedule;

class seqHeatSchedule_var;

class seqHeatSchedule : public _CORBA_Unbounded_Sequence< sHeatSchedule >  {
public:
  typedef seqHeatSchedule_var _var_type;
  inline seqHeatSchedule() {}
  inline seqHeatSchedule(const seqHeatSchedule& _s)
    : _CORBA_Unbounded_Sequence< sHeatSchedule > (_s) {}

  inline seqHeatSchedule(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sHeatSchedule > (_max) {}
  inline seqHeatSchedule(_CORBA_ULong _max, _CORBA_ULong _len, sHeatSchedule* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sHeatSchedule > (_max, _len, _val, _rel) {}



  inline seqHeatSchedule& operator = (const seqHeatSchedule& _s) {
    _CORBA_Unbounded_Sequence< sHeatSchedule > ::operator=(_s);
    return *this;
  }
};

class seqHeatSchedule_out;

class seqHeatSchedule_var {
public:
  inline seqHeatSchedule_var() : _pd_seq(0) {}
  inline seqHeatSchedule_var(seqHeatSchedule* _s) : _pd_seq(_s) {}
  inline seqHeatSchedule_var(const seqHeatSchedule_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqHeatSchedule(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqHeatSchedule_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqHeatSchedule_var& operator = (seqHeatSchedule* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqHeatSchedule_var& operator = (const seqHeatSchedule_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqHeatSchedule;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sHeatSchedule& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqHeatSchedule* operator -> () { return _pd_seq; }
  inline const seqHeatSchedule* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqHeatSchedule& () const { return *_pd_seq; }
#else
  inline operator const seqHeatSchedule& () const { return *_pd_seq; }
  inline operator seqHeatSchedule& () { return *_pd_seq; }
#endif
    
  inline const seqHeatSchedule& in() const { return *_pd_seq; }
  inline seqHeatSchedule&       inout()    { return *_pd_seq; }
  inline seqHeatSchedule*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqHeatSchedule* _retn() { seqHeatSchedule* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqHeatSchedule_out;
  
private:
  seqHeatSchedule* _pd_seq;
};

class seqHeatSchedule_out {
public:
  inline seqHeatSchedule_out(seqHeatSchedule*& _s) : _data(_s) { _data = 0; }
  inline seqHeatSchedule_out(seqHeatSchedule_var& _s)
    : _data(_s._pd_seq) { _s = (seqHeatSchedule*) 0; }
  inline seqHeatSchedule_out(const seqHeatSchedule_out& _s) : _data(_s._data) {}
  inline seqHeatSchedule_out& operator = (const seqHeatSchedule_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqHeatSchedule_out& operator = (seqHeatSchedule* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqHeatSchedule*&()  { return _data; }
  inline seqHeatSchedule*& ptr()       { return _data; }
  inline seqHeatSchedule* operator->() { return _data; }

  inline sHeatSchedule& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqHeatSchedule*& _data;

private:
  seqHeatSchedule_out();
  seqHeatSchedule_out& operator=(const seqHeatSchedule_var&);
};

struct sOrderData {
  typedef _CORBA_ConstrType_Variable_Var<sOrderData> _var_type;

  
  ::CORBA::String_member SteelGradeCode;

  ::CORBA::String_member OrderId;

  ::CORBA::Double AimSteelEAF;

  ::CORBA::Long ActionFlag;

  ::CORBA::Double AimSteelCCS;

  ::CORBA::String_member SlabDimension;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sOrderData::_var_type sOrderData_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sOrderData,sOrderData_var > sOrderData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sOrderData;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqOrderData;

class seqOrderData_var;

class seqOrderData : public _CORBA_Unbounded_Sequence< sOrderData >  {
public:
  typedef seqOrderData_var _var_type;
  inline seqOrderData() {}
  inline seqOrderData(const seqOrderData& _s)
    : _CORBA_Unbounded_Sequence< sOrderData > (_s) {}

  inline seqOrderData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sOrderData > (_max) {}
  inline seqOrderData(_CORBA_ULong _max, _CORBA_ULong _len, sOrderData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sOrderData > (_max, _len, _val, _rel) {}



  inline seqOrderData& operator = (const seqOrderData& _s) {
    _CORBA_Unbounded_Sequence< sOrderData > ::operator=(_s);
    return *this;
  }
};

class seqOrderData_out;

class seqOrderData_var {
public:
  inline seqOrderData_var() : _pd_seq(0) {}
  inline seqOrderData_var(seqOrderData* _s) : _pd_seq(_s) {}
  inline seqOrderData_var(const seqOrderData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqOrderData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqOrderData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqOrderData_var& operator = (seqOrderData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqOrderData_var& operator = (const seqOrderData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqOrderData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sOrderData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqOrderData* operator -> () { return _pd_seq; }
  inline const seqOrderData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqOrderData& () const { return *_pd_seq; }
#else
  inline operator const seqOrderData& () const { return *_pd_seq; }
  inline operator seqOrderData& () { return *_pd_seq; }
#endif
    
  inline const seqOrderData& in() const { return *_pd_seq; }
  inline seqOrderData&       inout()    { return *_pd_seq; }
  inline seqOrderData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqOrderData* _retn() { seqOrderData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqOrderData_out;
  
private:
  seqOrderData* _pd_seq;
};

class seqOrderData_out {
public:
  inline seqOrderData_out(seqOrderData*& _s) : _data(_s) { _data = 0; }
  inline seqOrderData_out(seqOrderData_var& _s)
    : _data(_s._pd_seq) { _s = (seqOrderData*) 0; }
  inline seqOrderData_out(const seqOrderData_out& _s) : _data(_s._data) {}
  inline seqOrderData_out& operator = (const seqOrderData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqOrderData_out& operator = (seqOrderData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqOrderData*&()  { return _data; }
  inline seqOrderData*& ptr()       { return _data; }
  inline seqOrderData* operator->() { return _data; }

  inline sOrderData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqOrderData*& _data;

private:
  seqOrderData_out();
  seqOrderData_out& operator=(const seqOrderData_var&);
};

struct sSampleData {
  typedef _CORBA_ConstrType_Variable_Var<sSampleData> _var_type;

  
  ::CORBA::String_member SampleCode;

  sDate SampleTime;

  ::CORBA::Long SampleNo;

  ::CORBA::Long SampleType;

  ::CORBA::String_member PlantID;

  ::CORBA::String_member ProcessStage;

  ::CORBA::String_member SampleId;

  ::CORBA::Long SampleMode;

  ::CORBA::String_member SampleLocation;

  ::CORBA::Long SampleOrigin;

  ::CORBA::Long SampleUsable;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sSampleData::_var_type sSampleData_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sSampleData,sSampleData_var > sSampleData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sSampleData;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqSampleData;

class seqSampleData_var;

class seqSampleData : public _CORBA_Unbounded_Sequence< sSampleData >  {
public:
  typedef seqSampleData_var _var_type;
  inline seqSampleData() {}
  inline seqSampleData(const seqSampleData& _s)
    : _CORBA_Unbounded_Sequence< sSampleData > (_s) {}

  inline seqSampleData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sSampleData > (_max) {}
  inline seqSampleData(_CORBA_ULong _max, _CORBA_ULong _len, sSampleData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sSampleData > (_max, _len, _val, _rel) {}



  inline seqSampleData& operator = (const seqSampleData& _s) {
    _CORBA_Unbounded_Sequence< sSampleData > ::operator=(_s);
    return *this;
  }
};

class seqSampleData_out;

class seqSampleData_var {
public:
  inline seqSampleData_var() : _pd_seq(0) {}
  inline seqSampleData_var(seqSampleData* _s) : _pd_seq(_s) {}
  inline seqSampleData_var(const seqSampleData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqSampleData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqSampleData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqSampleData_var& operator = (seqSampleData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqSampleData_var& operator = (const seqSampleData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqSampleData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sSampleData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqSampleData* operator -> () { return _pd_seq; }
  inline const seqSampleData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqSampleData& () const { return *_pd_seq; }
#else
  inline operator const seqSampleData& () const { return *_pd_seq; }
  inline operator seqSampleData& () { return *_pd_seq; }
#endif
    
  inline const seqSampleData& in() const { return *_pd_seq; }
  inline seqSampleData&       inout()    { return *_pd_seq; }
  inline seqSampleData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqSampleData* _retn() { seqSampleData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqSampleData_out;
  
private:
  seqSampleData* _pd_seq;
};

class seqSampleData_out {
public:
  inline seqSampleData_out(seqSampleData*& _s) : _data(_s) { _data = 0; }
  inline seqSampleData_out(seqSampleData_var& _s)
    : _data(_s._pd_seq) { _s = (seqSampleData*) 0; }
  inline seqSampleData_out(const seqSampleData_out& _s) : _data(_s._data) {}
  inline seqSampleData_out& operator = (const seqSampleData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqSampleData_out& operator = (seqSampleData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqSampleData*&()  { return _data; }
  inline seqSampleData*& ptr()       { return _data; }
  inline seqSampleData* operator->() { return _data; }

  inline sSampleData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqSampleData*& _data;

private:
  seqSampleData_out();
  seqSampleData_out& operator=(const seqSampleData_var&);
};

struct sAnalysisData {
  typedef _CORBA_ConstrType_Variable_Var<sAnalysisData> _var_type;

  
  sSampleData SampleData;

  seqAnalysis Analysis;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sAnalysisData::_var_type sAnalysisData_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sAnalysisData,sAnalysisData_var > sAnalysisData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sAnalysisData;

struct sHeatData {
  typedef _CORBA_ConstrType_Variable_Var<sHeatData> _var_type;

  
  ::CORBA::String_member Plant;

  ::CORBA::String_member HeatId;

  ::CORBA::String_member Device;

  ::CORBA::String_member TreatId;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sHeatData::_var_type sHeatData_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sHeatData,sHeatData_var > sHeatData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sHeatData;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqHeatData;

class seqHeatData_var;

class seqHeatData : public _CORBA_Unbounded_Sequence< sHeatData >  {
public:
  typedef seqHeatData_var _var_type;
  inline seqHeatData() {}
  inline seqHeatData(const seqHeatData& _s)
    : _CORBA_Unbounded_Sequence< sHeatData > (_s) {}

  inline seqHeatData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sHeatData > (_max) {}
  inline seqHeatData(_CORBA_ULong _max, _CORBA_ULong _len, sHeatData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sHeatData > (_max, _len, _val, _rel) {}



  inline seqHeatData& operator = (const seqHeatData& _s) {
    _CORBA_Unbounded_Sequence< sHeatData > ::operator=(_s);
    return *this;
  }
};

class seqHeatData_out;

class seqHeatData_var {
public:
  inline seqHeatData_var() : _pd_seq(0) {}
  inline seqHeatData_var(seqHeatData* _s) : _pd_seq(_s) {}
  inline seqHeatData_var(const seqHeatData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqHeatData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqHeatData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqHeatData_var& operator = (seqHeatData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqHeatData_var& operator = (const seqHeatData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqHeatData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sHeatData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqHeatData* operator -> () { return _pd_seq; }
  inline const seqHeatData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqHeatData& () const { return *_pd_seq; }
#else
  inline operator const seqHeatData& () const { return *_pd_seq; }
  inline operator seqHeatData& () { return *_pd_seq; }
#endif
    
  inline const seqHeatData& in() const { return *_pd_seq; }
  inline seqHeatData&       inout()    { return *_pd_seq; }
  inline seqHeatData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqHeatData* _retn() { seqHeatData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqHeatData_out;
  
private:
  seqHeatData* _pd_seq;
};

class seqHeatData_out {
public:
  inline seqHeatData_out(seqHeatData*& _s) : _data(_s) { _data = 0; }
  inline seqHeatData_out(seqHeatData_var& _s)
    : _data(_s._pd_seq) { _s = (seqHeatData*) 0; }
  inline seqHeatData_out(const seqHeatData_out& _s) : _data(_s._data) {}
  inline seqHeatData_out& operator = (const seqHeatData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqHeatData_out& operator = (seqHeatData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqHeatData*&()  { return _data; }
  inline seqHeatData*& ptr()       { return _data; }
  inline seqHeatData* operator->() { return _data; }

  inline sHeatData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqHeatData*& _data;

private:
  seqHeatData_out();
  seqHeatData_out& operator=(const seqHeatData_var&);
};

struct sInjectLanceData {
  typedef _CORBA_ConstrType_Variable_Var<sInjectLanceData> _var_type;

  
  ::CORBA::String_member Device;

  ::CORBA::Double Value;

  ::CORBA::String_member MatCode;

  ::CORBA::String_member InjectionType;

  ::CORBA::String_member ModuleName;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sInjectLanceData::_var_type sInjectLanceData_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sInjectLanceData,sInjectLanceData_var > sInjectLanceData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sInjectLanceData;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqInjectLanceData;

class seqInjectLanceData_var;

class seqInjectLanceData : public _CORBA_Unbounded_Sequence< sInjectLanceData >  {
public:
  typedef seqInjectLanceData_var _var_type;
  inline seqInjectLanceData() {}
  inline seqInjectLanceData(const seqInjectLanceData& _s)
    : _CORBA_Unbounded_Sequence< sInjectLanceData > (_s) {}

  inline seqInjectLanceData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sInjectLanceData > (_max) {}
  inline seqInjectLanceData(_CORBA_ULong _max, _CORBA_ULong _len, sInjectLanceData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sInjectLanceData > (_max, _len, _val, _rel) {}



  inline seqInjectLanceData& operator = (const seqInjectLanceData& _s) {
    _CORBA_Unbounded_Sequence< sInjectLanceData > ::operator=(_s);
    return *this;
  }
};

class seqInjectLanceData_out;

class seqInjectLanceData_var {
public:
  inline seqInjectLanceData_var() : _pd_seq(0) {}
  inline seqInjectLanceData_var(seqInjectLanceData* _s) : _pd_seq(_s) {}
  inline seqInjectLanceData_var(const seqInjectLanceData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqInjectLanceData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqInjectLanceData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqInjectLanceData_var& operator = (seqInjectLanceData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqInjectLanceData_var& operator = (const seqInjectLanceData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqInjectLanceData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sInjectLanceData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqInjectLanceData* operator -> () { return _pd_seq; }
  inline const seqInjectLanceData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqInjectLanceData& () const { return *_pd_seq; }
#else
  inline operator const seqInjectLanceData& () const { return *_pd_seq; }
  inline operator seqInjectLanceData& () { return *_pd_seq; }
#endif
    
  inline const seqInjectLanceData& in() const { return *_pd_seq; }
  inline seqInjectLanceData&       inout()    { return *_pd_seq; }
  inline seqInjectLanceData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqInjectLanceData* _retn() { seqInjectLanceData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqInjectLanceData_out;
  
private:
  seqInjectLanceData* _pd_seq;
};

class seqInjectLanceData_out {
public:
  inline seqInjectLanceData_out(seqInjectLanceData*& _s) : _data(_s) { _data = 0; }
  inline seqInjectLanceData_out(seqInjectLanceData_var& _s)
    : _data(_s._pd_seq) { _s = (seqInjectLanceData*) 0; }
  inline seqInjectLanceData_out(const seqInjectLanceData_out& _s) : _data(_s._data) {}
  inline seqInjectLanceData_out& operator = (const seqInjectLanceData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqInjectLanceData_out& operator = (seqInjectLanceData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqInjectLanceData*&()  { return _data; }
  inline seqInjectLanceData*& ptr()       { return _data; }
  inline seqInjectLanceData* operator->() { return _data; }

  inline sInjectLanceData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqInjectLanceData*& _data;

private:
  seqInjectLanceData_out();
  seqInjectLanceData_out& operator=(const seqInjectLanceData_var&);
};

struct sGasLanceGasAvail {
  typedef _CORBA_ConstrType_Variable_Var<sGasLanceGasAvail> _var_type;

  
  ::CORBA::String_member Device;

  seqGasAvail GasAvail;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sGasLanceGasAvail::_var_type sGasLanceGasAvail_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sGasLanceGasAvail,sGasLanceGasAvail_var > sGasLanceGasAvail_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sGasLanceGasAvail;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqGasLanceGasAvail;

class seqGasLanceGasAvail_var;

class seqGasLanceGasAvail : public _CORBA_Unbounded_Sequence< sGasLanceGasAvail >  {
public:
  typedef seqGasLanceGasAvail_var _var_type;
  inline seqGasLanceGasAvail() {}
  inline seqGasLanceGasAvail(const seqGasLanceGasAvail& _s)
    : _CORBA_Unbounded_Sequence< sGasLanceGasAvail > (_s) {}

  inline seqGasLanceGasAvail(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sGasLanceGasAvail > (_max) {}
  inline seqGasLanceGasAvail(_CORBA_ULong _max, _CORBA_ULong _len, sGasLanceGasAvail* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sGasLanceGasAvail > (_max, _len, _val, _rel) {}



  inline seqGasLanceGasAvail& operator = (const seqGasLanceGasAvail& _s) {
    _CORBA_Unbounded_Sequence< sGasLanceGasAvail > ::operator=(_s);
    return *this;
  }
};

class seqGasLanceGasAvail_out;

class seqGasLanceGasAvail_var {
public:
  inline seqGasLanceGasAvail_var() : _pd_seq(0) {}
  inline seqGasLanceGasAvail_var(seqGasLanceGasAvail* _s) : _pd_seq(_s) {}
  inline seqGasLanceGasAvail_var(const seqGasLanceGasAvail_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqGasLanceGasAvail(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqGasLanceGasAvail_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqGasLanceGasAvail_var& operator = (seqGasLanceGasAvail* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqGasLanceGasAvail_var& operator = (const seqGasLanceGasAvail_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqGasLanceGasAvail;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sGasLanceGasAvail& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqGasLanceGasAvail* operator -> () { return _pd_seq; }
  inline const seqGasLanceGasAvail* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqGasLanceGasAvail& () const { return *_pd_seq; }
#else
  inline operator const seqGasLanceGasAvail& () const { return *_pd_seq; }
  inline operator seqGasLanceGasAvail& () { return *_pd_seq; }
#endif
    
  inline const seqGasLanceGasAvail& in() const { return *_pd_seq; }
  inline seqGasLanceGasAvail&       inout()    { return *_pd_seq; }
  inline seqGasLanceGasAvail*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqGasLanceGasAvail* _retn() { seqGasLanceGasAvail* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqGasLanceGasAvail_out;
  
private:
  seqGasLanceGasAvail* _pd_seq;
};

class seqGasLanceGasAvail_out {
public:
  inline seqGasLanceGasAvail_out(seqGasLanceGasAvail*& _s) : _data(_s) { _data = 0; }
  inline seqGasLanceGasAvail_out(seqGasLanceGasAvail_var& _s)
    : _data(_s._pd_seq) { _s = (seqGasLanceGasAvail*) 0; }
  inline seqGasLanceGasAvail_out(const seqGasLanceGasAvail_out& _s) : _data(_s._data) {}
  inline seqGasLanceGasAvail_out& operator = (const seqGasLanceGasAvail_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqGasLanceGasAvail_out& operator = (seqGasLanceGasAvail* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqGasLanceGasAvail*&()  { return _data; }
  inline seqGasLanceGasAvail*& ptr()       { return _data; }
  inline seqGasLanceGasAvail* operator->() { return _data; }

  inline sGasLanceGasAvail& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqGasLanceGasAvail*& _data;

private:
  seqGasLanceGasAvail_out();
  seqGasLanceGasAvail_out& operator=(const seqGasLanceGasAvail_var&);
};

struct sBatchPrio {
  typedef _CORBA_ConstrType_Variable_Var<sBatchPrio> _var_type;

  
  sBatch BatchData;

  ::CORBA::Long ChargPrio;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sBatchPrio::_var_type sBatchPrio_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sBatchPrio,sBatchPrio_var > sBatchPrio_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sBatchPrio;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqBatchPrio;

class seqBatchPrio_var;

class seqBatchPrio : public _CORBA_Unbounded_Sequence< sBatchPrio >  {
public:
  typedef seqBatchPrio_var _var_type;
  inline seqBatchPrio() {}
  inline seqBatchPrio(const seqBatchPrio& _s)
    : _CORBA_Unbounded_Sequence< sBatchPrio > (_s) {}

  inline seqBatchPrio(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sBatchPrio > (_max) {}
  inline seqBatchPrio(_CORBA_ULong _max, _CORBA_ULong _len, sBatchPrio* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sBatchPrio > (_max, _len, _val, _rel) {}



  inline seqBatchPrio& operator = (const seqBatchPrio& _s) {
    _CORBA_Unbounded_Sequence< sBatchPrio > ::operator=(_s);
    return *this;
  }
};

class seqBatchPrio_out;

class seqBatchPrio_var {
public:
  inline seqBatchPrio_var() : _pd_seq(0) {}
  inline seqBatchPrio_var(seqBatchPrio* _s) : _pd_seq(_s) {}
  inline seqBatchPrio_var(const seqBatchPrio_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqBatchPrio(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqBatchPrio_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqBatchPrio_var& operator = (seqBatchPrio* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqBatchPrio_var& operator = (const seqBatchPrio_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqBatchPrio;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sBatchPrio& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqBatchPrio* operator -> () { return _pd_seq; }
  inline const seqBatchPrio* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqBatchPrio& () const { return *_pd_seq; }
#else
  inline operator const seqBatchPrio& () const { return *_pd_seq; }
  inline operator seqBatchPrio& () { return *_pd_seq; }
#endif
    
  inline const seqBatchPrio& in() const { return *_pd_seq; }
  inline seqBatchPrio&       inout()    { return *_pd_seq; }
  inline seqBatchPrio*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqBatchPrio* _retn() { seqBatchPrio* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqBatchPrio_out;
  
private:
  seqBatchPrio* _pd_seq;
};

class seqBatchPrio_out {
public:
  inline seqBatchPrio_out(seqBatchPrio*& _s) : _data(_s) { _data = 0; }
  inline seqBatchPrio_out(seqBatchPrio_var& _s)
    : _data(_s._pd_seq) { _s = (seqBatchPrio*) 0; }
  inline seqBatchPrio_out(const seqBatchPrio_out& _s) : _data(_s._data) {}
  inline seqBatchPrio_out& operator = (const seqBatchPrio_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqBatchPrio_out& operator = (seqBatchPrio* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqBatchPrio*&()  { return _data; }
  inline seqBatchPrio*& ptr()       { return _data; }
  inline seqBatchPrio* operator->() { return _data; }

  inline sBatchPrio& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqBatchPrio*& _data;

private:
  seqBatchPrio_out();
  seqBatchPrio_out& operator=(const seqBatchPrio_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqAnalysisData;

class seqAnalysisData_var;

class seqAnalysisData : public _CORBA_Unbounded_Sequence< sAnalysisData >  {
public:
  typedef seqAnalysisData_var _var_type;
  inline seqAnalysisData() {}
  inline seqAnalysisData(const seqAnalysisData& _s)
    : _CORBA_Unbounded_Sequence< sAnalysisData > (_s) {}

  inline seqAnalysisData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sAnalysisData > (_max) {}
  inline seqAnalysisData(_CORBA_ULong _max, _CORBA_ULong _len, sAnalysisData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sAnalysisData > (_max, _len, _val, _rel) {}



  inline seqAnalysisData& operator = (const seqAnalysisData& _s) {
    _CORBA_Unbounded_Sequence< sAnalysisData > ::operator=(_s);
    return *this;
  }
};

class seqAnalysisData_out;

class seqAnalysisData_var {
public:
  inline seqAnalysisData_var() : _pd_seq(0) {}
  inline seqAnalysisData_var(seqAnalysisData* _s) : _pd_seq(_s) {}
  inline seqAnalysisData_var(const seqAnalysisData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqAnalysisData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqAnalysisData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqAnalysisData_var& operator = (seqAnalysisData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqAnalysisData_var& operator = (const seqAnalysisData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqAnalysisData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sAnalysisData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqAnalysisData* operator -> () { return _pd_seq; }
  inline const seqAnalysisData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqAnalysisData& () const { return *_pd_seq; }
#else
  inline operator const seqAnalysisData& () const { return *_pd_seq; }
  inline operator seqAnalysisData& () { return *_pd_seq; }
#endif
    
  inline const seqAnalysisData& in() const { return *_pd_seq; }
  inline seqAnalysisData&       inout()    { return *_pd_seq; }
  inline seqAnalysisData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqAnalysisData* _retn() { seqAnalysisData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqAnalysisData_out;
  
private:
  seqAnalysisData* _pd_seq;
};

class seqAnalysisData_out {
public:
  inline seqAnalysisData_out(seqAnalysisData*& _s) : _data(_s) { _data = 0; }
  inline seqAnalysisData_out(seqAnalysisData_var& _s)
    : _data(_s._pd_seq) { _s = (seqAnalysisData*) 0; }
  inline seqAnalysisData_out(const seqAnalysisData_out& _s) : _data(_s._data) {}
  inline seqAnalysisData_out& operator = (const seqAnalysisData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqAnalysisData_out& operator = (seqAnalysisData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqAnalysisData*&()  { return _data; }
  inline seqAnalysisData*& ptr()       { return _data; }
  inline seqAnalysisData* operator->() { return _data; }

  inline sAnalysisData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqAnalysisData*& _data;

private:
  seqAnalysisData_out();
  seqAnalysisData_out& operator=(const seqAnalysisData_var&);
};

struct LFGlobalSetpoints {
  typedef _CORBA_ConstrType_Variable_Var<LFGlobalSetpoints> _var_type;

  
  ::CORBA::String_member GasType;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef LFGlobalSetpoints::_var_type LFGlobalSetpoints_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< LFGlobalSetpoints,LFGlobalSetpoints_var > LFGlobalSetpoints_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LFGlobalSetpoints;

struct sLiqMatReport {
  typedef _CORBA_ConstrType_Variable_Var<sLiqMatReport> _var_type;

  
  ::CORBA::Long WeighingType;

  ::CORBA::String_member LiqMatType;

  ::CORBA::Double LiqMatWeight;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sLiqMatReport::_var_type sLiqMatReport_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sLiqMatReport,sLiqMatReport_var > sLiqMatReport_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sLiqMatReport;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqLiqMatReport;

class seqLiqMatReport_var;

class seqLiqMatReport : public _CORBA_Unbounded_Sequence< sLiqMatReport >  {
public:
  typedef seqLiqMatReport_var _var_type;
  inline seqLiqMatReport() {}
  inline seqLiqMatReport(const seqLiqMatReport& _s)
    : _CORBA_Unbounded_Sequence< sLiqMatReport > (_s) {}

  inline seqLiqMatReport(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sLiqMatReport > (_max) {}
  inline seqLiqMatReport(_CORBA_ULong _max, _CORBA_ULong _len, sLiqMatReport* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sLiqMatReport > (_max, _len, _val, _rel) {}



  inline seqLiqMatReport& operator = (const seqLiqMatReport& _s) {
    _CORBA_Unbounded_Sequence< sLiqMatReport > ::operator=(_s);
    return *this;
  }
};

class seqLiqMatReport_out;

class seqLiqMatReport_var {
public:
  inline seqLiqMatReport_var() : _pd_seq(0) {}
  inline seqLiqMatReport_var(seqLiqMatReport* _s) : _pd_seq(_s) {}
  inline seqLiqMatReport_var(const seqLiqMatReport_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqLiqMatReport(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqLiqMatReport_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqLiqMatReport_var& operator = (seqLiqMatReport* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqLiqMatReport_var& operator = (const seqLiqMatReport_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqLiqMatReport;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sLiqMatReport& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqLiqMatReport* operator -> () { return _pd_seq; }
  inline const seqLiqMatReport* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqLiqMatReport& () const { return *_pd_seq; }
#else
  inline operator const seqLiqMatReport& () const { return *_pd_seq; }
  inline operator seqLiqMatReport& () { return *_pd_seq; }
#endif
    
  inline const seqLiqMatReport& in() const { return *_pd_seq; }
  inline seqLiqMatReport&       inout()    { return *_pd_seq; }
  inline seqLiqMatReport*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqLiqMatReport* _retn() { seqLiqMatReport* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqLiqMatReport_out;
  
private:
  seqLiqMatReport* _pd_seq;
};

class seqLiqMatReport_out {
public:
  inline seqLiqMatReport_out(seqLiqMatReport*& _s) : _data(_s) { _data = 0; }
  inline seqLiqMatReport_out(seqLiqMatReport_var& _s)
    : _data(_s._pd_seq) { _s = (seqLiqMatReport*) 0; }
  inline seqLiqMatReport_out(const seqLiqMatReport_out& _s) : _data(_s._data) {}
  inline seqLiqMatReport_out& operator = (const seqLiqMatReport_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqLiqMatReport_out& operator = (seqLiqMatReport* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqLiqMatReport*&()  { return _data; }
  inline seqLiqMatReport*& ptr()       { return _data; }
  inline seqLiqMatReport* operator->() { return _data; }

  inline sLiqMatReport& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqLiqMatReport*& _data;

private:
  seqLiqMatReport_out();
  seqLiqMatReport_out& operator=(const seqLiqMatReport_var&);
};

struct sBOFPredBlowRes {
  typedef _CORBA_ConstrType_Variable_Var<sBOFPredBlowRes> _var_type;

  
  ::CORBA::String_member Phase;

  ::CORBA::Long PhaseNo;

  ::CORBA::Long PhaseActive;

  ::CORBA::Double O2Vol;

  ::CORBA::Double TopLanceO2Flow;

  ::CORBA::Double TopLanceHeight;

  ::CORBA::Double PorousPlugN2Flow;

  ::CORBA::Double PorousPlugArFlow;

  ::CORBA::Double O2MomentPorPlugs;

  ::CORBA::Double DecarbRate;

  ::CORBA::Double O2MomentTopLance;

  sGenRes GenRes;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sBOFPredBlowRes::_var_type sBOFPredBlowRes_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sBOFPredBlowRes,sBOFPredBlowRes_var > sBOFPredBlowRes_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sBOFPredBlowRes;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqBOFBlowPredRes;

class seqBOFBlowPredRes_var;

class seqBOFBlowPredRes : public _CORBA_Unbounded_Sequence< sBOFPredBlowRes >  {
public:
  typedef seqBOFBlowPredRes_var _var_type;
  inline seqBOFBlowPredRes() {}
  inline seqBOFBlowPredRes(const seqBOFBlowPredRes& _s)
    : _CORBA_Unbounded_Sequence< sBOFPredBlowRes > (_s) {}

  inline seqBOFBlowPredRes(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sBOFPredBlowRes > (_max) {}
  inline seqBOFBlowPredRes(_CORBA_ULong _max, _CORBA_ULong _len, sBOFPredBlowRes* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sBOFPredBlowRes > (_max, _len, _val, _rel) {}



  inline seqBOFBlowPredRes& operator = (const seqBOFBlowPredRes& _s) {
    _CORBA_Unbounded_Sequence< sBOFPredBlowRes > ::operator=(_s);
    return *this;
  }
};

class seqBOFBlowPredRes_out;

class seqBOFBlowPredRes_var {
public:
  inline seqBOFBlowPredRes_var() : _pd_seq(0) {}
  inline seqBOFBlowPredRes_var(seqBOFBlowPredRes* _s) : _pd_seq(_s) {}
  inline seqBOFBlowPredRes_var(const seqBOFBlowPredRes_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqBOFBlowPredRes(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqBOFBlowPredRes_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqBOFBlowPredRes_var& operator = (seqBOFBlowPredRes* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqBOFBlowPredRes_var& operator = (const seqBOFBlowPredRes_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqBOFBlowPredRes;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sBOFPredBlowRes& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqBOFBlowPredRes* operator -> () { return _pd_seq; }
  inline const seqBOFBlowPredRes* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqBOFBlowPredRes& () const { return *_pd_seq; }
#else
  inline operator const seqBOFBlowPredRes& () const { return *_pd_seq; }
  inline operator seqBOFBlowPredRes& () { return *_pd_seq; }
#endif
    
  inline const seqBOFBlowPredRes& in() const { return *_pd_seq; }
  inline seqBOFBlowPredRes&       inout()    { return *_pd_seq; }
  inline seqBOFBlowPredRes*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqBOFBlowPredRes* _retn() { seqBOFBlowPredRes* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqBOFBlowPredRes_out;
  
private:
  seqBOFBlowPredRes* _pd_seq;
};

class seqBOFBlowPredRes_out {
public:
  inline seqBOFBlowPredRes_out(seqBOFBlowPredRes*& _s) : _data(_s) { _data = 0; }
  inline seqBOFBlowPredRes_out(seqBOFBlowPredRes_var& _s)
    : _data(_s._pd_seq) { _s = (seqBOFBlowPredRes*) 0; }
  inline seqBOFBlowPredRes_out(const seqBOFBlowPredRes_out& _s) : _data(_s._data) {}
  inline seqBOFBlowPredRes_out& operator = (const seqBOFBlowPredRes_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqBOFBlowPredRes_out& operator = (seqBOFBlowPredRes* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqBOFBlowPredRes*&()  { return _data; }
  inline seqBOFBlowPredRes*& ptr()       { return _data; }
  inline seqBOFBlowPredRes* operator->() { return _data; }

  inline sBOFPredBlowRes& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqBOFBlowPredRes*& _data;

private:
  seqBOFBlowPredRes_out();
  seqBOFBlowPredRes_out& operator=(const seqBOFBlowPredRes_var&);
};

struct sInjectData {
  typedef _CORBA_ConstrType_Variable_Var<sInjectData> _var_type;

  
  ::CORBA::String_member InjectMatCode;

  ::CORBA::Double InjectMatValue;

  ::CORBA::String_member InjectType;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sInjectData::_var_type sInjectData_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sInjectData,sInjectData_var > sInjectData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sInjectData;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqInjectData;

class seqInjectData_var;

class seqInjectData : public _CORBA_Unbounded_Sequence< sInjectData >  {
public:
  typedef seqInjectData_var _var_type;
  inline seqInjectData() {}
  inline seqInjectData(const seqInjectData& _s)
    : _CORBA_Unbounded_Sequence< sInjectData > (_s) {}

  inline seqInjectData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sInjectData > (_max) {}
  inline seqInjectData(_CORBA_ULong _max, _CORBA_ULong _len, sInjectData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sInjectData > (_max, _len, _val, _rel) {}



  inline seqInjectData& operator = (const seqInjectData& _s) {
    _CORBA_Unbounded_Sequence< sInjectData > ::operator=(_s);
    return *this;
  }
};

class seqInjectData_out;

class seqInjectData_var {
public:
  inline seqInjectData_var() : _pd_seq(0) {}
  inline seqInjectData_var(seqInjectData* _s) : _pd_seq(_s) {}
  inline seqInjectData_var(const seqInjectData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqInjectData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqInjectData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqInjectData_var& operator = (seqInjectData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqInjectData_var& operator = (const seqInjectData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqInjectData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sInjectData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqInjectData* operator -> () { return _pd_seq; }
  inline const seqInjectData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqInjectData& () const { return *_pd_seq; }
#else
  inline operator const seqInjectData& () const { return *_pd_seq; }
  inline operator seqInjectData& () { return *_pd_seq; }
#endif
    
  inline const seqInjectData& in() const { return *_pd_seq; }
  inline seqInjectData&       inout()    { return *_pd_seq; }
  inline seqInjectData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqInjectData* _retn() { seqInjectData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqInjectData_out;
  
private:
  seqInjectData* _pd_seq;
};

class seqInjectData_out {
public:
  inline seqInjectData_out(seqInjectData*& _s) : _data(_s) { _data = 0; }
  inline seqInjectData_out(seqInjectData_var& _s)
    : _data(_s._pd_seq) { _s = (seqInjectData*) 0; }
  inline seqInjectData_out(const seqInjectData_out& _s) : _data(_s._data) {}
  inline seqInjectData_out& operator = (const seqInjectData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqInjectData_out& operator = (seqInjectData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqInjectData*&()  { return _data; }
  inline seqInjectData*& ptr()       { return _data; }
  inline seqInjectData* operator->() { return _data; }

  inline sInjectData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqInjectData*& _data;

private:
  seqInjectData_out();
  seqInjectData_out& operator=(const seqInjectData_var&);
};

struct sEAFInjectLance {
  typedef _CORBA_ConstrType_Variable_Var<sEAFInjectLance> _var_type;

  
  ::CORBA::String_member Phase;

  ::CORBA::Long PhaseNo;

  ::CORBA::Long Step;

  ::CORBA::Double DurStep;

  ::CORBA::Double Egy;

  ::CORBA::Double RemEgy;

  ::CORBA::Double DurUntilEndOfStep;

  ::CORBA::Double DurUntilStartOfStep;

  ::CORBA::Double SpecEgyStep;

  ::CORBA::Double ElecEgyStep;

  ::CORBA::Double SpecEgy;

  ::CORBA::Double BaseMass;

  seqInjectLanceData InjectFlow;

  seqInjectLanceData InjectAmount;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sEAFInjectLance::_var_type sEAFInjectLance_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sEAFInjectLance,sEAFInjectLance_var > sEAFInjectLance_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sEAFInjectLance;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqEAFInjectLance;

class seqEAFInjectLance_var;

class seqEAFInjectLance : public _CORBA_Unbounded_Sequence< sEAFInjectLance >  {
public:
  typedef seqEAFInjectLance_var _var_type;
  inline seqEAFInjectLance() {}
  inline seqEAFInjectLance(const seqEAFInjectLance& _s)
    : _CORBA_Unbounded_Sequence< sEAFInjectLance > (_s) {}

  inline seqEAFInjectLance(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sEAFInjectLance > (_max) {}
  inline seqEAFInjectLance(_CORBA_ULong _max, _CORBA_ULong _len, sEAFInjectLance* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sEAFInjectLance > (_max, _len, _val, _rel) {}



  inline seqEAFInjectLance& operator = (const seqEAFInjectLance& _s) {
    _CORBA_Unbounded_Sequence< sEAFInjectLance > ::operator=(_s);
    return *this;
  }
};

class seqEAFInjectLance_out;

class seqEAFInjectLance_var {
public:
  inline seqEAFInjectLance_var() : _pd_seq(0) {}
  inline seqEAFInjectLance_var(seqEAFInjectLance* _s) : _pd_seq(_s) {}
  inline seqEAFInjectLance_var(const seqEAFInjectLance_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqEAFInjectLance(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqEAFInjectLance_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqEAFInjectLance_var& operator = (seqEAFInjectLance* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqEAFInjectLance_var& operator = (const seqEAFInjectLance_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqEAFInjectLance;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sEAFInjectLance& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqEAFInjectLance* operator -> () { return _pd_seq; }
  inline const seqEAFInjectLance* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqEAFInjectLance& () const { return *_pd_seq; }
#else
  inline operator const seqEAFInjectLance& () const { return *_pd_seq; }
  inline operator seqEAFInjectLance& () { return *_pd_seq; }
#endif
    
  inline const seqEAFInjectLance& in() const { return *_pd_seq; }
  inline seqEAFInjectLance&       inout()    { return *_pd_seq; }
  inline seqEAFInjectLance*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqEAFInjectLance* _retn() { seqEAFInjectLance* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqEAFInjectLance_out;
  
private:
  seqEAFInjectLance* _pd_seq;
};

class seqEAFInjectLance_out {
public:
  inline seqEAFInjectLance_out(seqEAFInjectLance*& _s) : _data(_s) { _data = 0; }
  inline seqEAFInjectLance_out(seqEAFInjectLance_var& _s)
    : _data(_s._pd_seq) { _s = (seqEAFInjectLance*) 0; }
  inline seqEAFInjectLance_out(const seqEAFInjectLance_out& _s) : _data(_s._data) {}
  inline seqEAFInjectLance_out& operator = (const seqEAFInjectLance_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqEAFInjectLance_out& operator = (seqEAFInjectLance* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqEAFInjectLance*&()  { return _data; }
  inline seqEAFInjectLance*& ptr()       { return _data; }
  inline seqEAFInjectLance* operator->() { return _data; }

  inline sEAFInjectLance& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqEAFInjectLance*& _data;

private:
  seqEAFInjectLance_out();
  seqEAFInjectLance_out& operator=(const seqEAFInjectLance_var&);
};

struct sHMDCalc {
  typedef _CORBA_ConstrType_Variable_Var<sHMDCalc> _var_type;

  
  DEF::seqDouble Lime;

  seqBatchPrio Material;

  seqAnalysis Analysis;

  DEF::seqDouble Carbide;

  DEF::seqDouble Magnesium;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sHMDCalc::_var_type sHMDCalc_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sHMDCalc,sHMDCalc_var > sHMDCalc_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sHMDCalc;

struct sConArcElecData {
  typedef _CORBA_ConstrType_Fix_Var<sConArcElecData> _var_type;

  
  ::CORBA::Long BasketNo;

  ::CORBA::Long ReactTapNo;

  ::CORBA::Long TransfTapNo;

  ::CORBA::Long ArcLenNo;

  ::CORBA::Double DurUntilEndOfStep;

  ::CORBA::Double DurUntilStartOfStep;

  ::CORBA::Double SpecEgyStep;

  ::CORBA::Double SpecEgy;

  ::CORBA::Double ElecEgyStep;

  ::CORBA::Double ElecEgy;

  ::CORBA::Double EnergyStart;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sConArcElecData::_var_type sConArcElecData_var;

typedef sConArcElecData& sConArcElecData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sConArcElecData;

struct sConArcMediaData {
  typedef _CORBA_ConstrType_Variable_Var<sConArcMediaData> _var_type;

  
  ::CORBA::String_member DeviceName;

  ::CORBA::Long DeviceNo;

  ::CORBA::Long MediaTypeSelect;

  ::CORBA::String_member MediaType;

  ::CORBA::Double Flow;

  ::CORBA::Double Cons;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sConArcMediaData::_var_type sConArcMediaData_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sConArcMediaData,sConArcMediaData_var > sConArcMediaData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sConArcMediaData;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqConArcElecData;

class seqConArcElecData_var;

class seqConArcElecData : public _CORBA_Unbounded_Sequence< sConArcElecData >  {
public:
  typedef seqConArcElecData_var _var_type;
  inline seqConArcElecData() {}
  inline seqConArcElecData(const seqConArcElecData& _s)
    : _CORBA_Unbounded_Sequence< sConArcElecData > (_s) {}

  inline seqConArcElecData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sConArcElecData > (_max) {}
  inline seqConArcElecData(_CORBA_ULong _max, _CORBA_ULong _len, sConArcElecData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sConArcElecData > (_max, _len, _val, _rel) {}



  inline seqConArcElecData& operator = (const seqConArcElecData& _s) {
    _CORBA_Unbounded_Sequence< sConArcElecData > ::operator=(_s);
    return *this;
  }
};

class seqConArcElecData_out;

class seqConArcElecData_var {
public:
  inline seqConArcElecData_var() : _pd_seq(0) {}
  inline seqConArcElecData_var(seqConArcElecData* _s) : _pd_seq(_s) {}
  inline seqConArcElecData_var(const seqConArcElecData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqConArcElecData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqConArcElecData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqConArcElecData_var& operator = (seqConArcElecData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqConArcElecData_var& operator = (const seqConArcElecData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqConArcElecData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sConArcElecData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqConArcElecData* operator -> () { return _pd_seq; }
  inline const seqConArcElecData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqConArcElecData& () const { return *_pd_seq; }
#else
  inline operator const seqConArcElecData& () const { return *_pd_seq; }
  inline operator seqConArcElecData& () { return *_pd_seq; }
#endif
    
  inline const seqConArcElecData& in() const { return *_pd_seq; }
  inline seqConArcElecData&       inout()    { return *_pd_seq; }
  inline seqConArcElecData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqConArcElecData* _retn() { seqConArcElecData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqConArcElecData_out;
  
private:
  seqConArcElecData* _pd_seq;
};

class seqConArcElecData_out {
public:
  inline seqConArcElecData_out(seqConArcElecData*& _s) : _data(_s) { _data = 0; }
  inline seqConArcElecData_out(seqConArcElecData_var& _s)
    : _data(_s._pd_seq) { _s = (seqConArcElecData*) 0; }
  inline seqConArcElecData_out(const seqConArcElecData_out& _s) : _data(_s._data) {}
  inline seqConArcElecData_out& operator = (const seqConArcElecData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqConArcElecData_out& operator = (seqConArcElecData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqConArcElecData*&()  { return _data; }
  inline seqConArcElecData*& ptr()       { return _data; }
  inline seqConArcElecData* operator->() { return _data; }

  inline sConArcElecData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqConArcElecData*& _data;

private:
  seqConArcElecData_out();
  seqConArcElecData_out& operator=(const seqConArcElecData_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqConArcMediaData;

class seqConArcMediaData_var;

class seqConArcMediaData : public _CORBA_Unbounded_Sequence< sConArcMediaData >  {
public:
  typedef seqConArcMediaData_var _var_type;
  inline seqConArcMediaData() {}
  inline seqConArcMediaData(const seqConArcMediaData& _s)
    : _CORBA_Unbounded_Sequence< sConArcMediaData > (_s) {}

  inline seqConArcMediaData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sConArcMediaData > (_max) {}
  inline seqConArcMediaData(_CORBA_ULong _max, _CORBA_ULong _len, sConArcMediaData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sConArcMediaData > (_max, _len, _val, _rel) {}



  inline seqConArcMediaData& operator = (const seqConArcMediaData& _s) {
    _CORBA_Unbounded_Sequence< sConArcMediaData > ::operator=(_s);
    return *this;
  }
};

class seqConArcMediaData_out;

class seqConArcMediaData_var {
public:
  inline seqConArcMediaData_var() : _pd_seq(0) {}
  inline seqConArcMediaData_var(seqConArcMediaData* _s) : _pd_seq(_s) {}
  inline seqConArcMediaData_var(const seqConArcMediaData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqConArcMediaData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqConArcMediaData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqConArcMediaData_var& operator = (seqConArcMediaData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqConArcMediaData_var& operator = (const seqConArcMediaData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqConArcMediaData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sConArcMediaData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqConArcMediaData* operator -> () { return _pd_seq; }
  inline const seqConArcMediaData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqConArcMediaData& () const { return *_pd_seq; }
#else
  inline operator const seqConArcMediaData& () const { return *_pd_seq; }
  inline operator seqConArcMediaData& () { return *_pd_seq; }
#endif
    
  inline const seqConArcMediaData& in() const { return *_pd_seq; }
  inline seqConArcMediaData&       inout()    { return *_pd_seq; }
  inline seqConArcMediaData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqConArcMediaData* _retn() { seqConArcMediaData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqConArcMediaData_out;
  
private:
  seqConArcMediaData* _pd_seq;
};

class seqConArcMediaData_out {
public:
  inline seqConArcMediaData_out(seqConArcMediaData*& _s) : _data(_s) { _data = 0; }
  inline seqConArcMediaData_out(seqConArcMediaData_var& _s)
    : _data(_s._pd_seq) { _s = (seqConArcMediaData*) 0; }
  inline seqConArcMediaData_out(const seqConArcMediaData_out& _s) : _data(_s._data) {}
  inline seqConArcMediaData_out& operator = (const seqConArcMediaData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqConArcMediaData_out& operator = (seqConArcMediaData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqConArcMediaData*&()  { return _data; }
  inline seqConArcMediaData*& ptr()       { return _data; }
  inline seqConArcMediaData* operator->() { return _data; }

  inline sConArcMediaData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqConArcMediaData*& _data;

private:
  seqConArcMediaData_out();
  seqConArcMediaData_out& operator=(const seqConArcMediaData_var&);
};

struct sConArcSetptData {
  typedef _CORBA_ConstrType_Variable_Var<sConArcSetptData> _var_type;

  
  ::CORBA::Double EgyTotal;

  seqConArcMediaData MediaData;

  sConArcElecData ElecData;

  seqConArcMediaData MatFeedTotalMass;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sConArcSetptData::_var_type sConArcSetptData_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sConArcSetptData,sConArcSetptData_var > sConArcSetptData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sConArcSetptData;

struct sConArcMeasData {
  typedef _CORBA_ConstrType_Variable_Var<sConArcMeasData> _var_type;

  
  ::CORBA::Double SlagQuality;

  seqConArcMediaData MediaData;

  sConArcElecData ElecData;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sConArcMeasData::_var_type sConArcMeasData_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sConArcMeasData,sConArcMeasData_var > sConArcMeasData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sConArcMeasData;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqConArcSetptData;

class seqConArcSetptData_var;

class seqConArcSetptData : public _CORBA_Unbounded_Sequence< sConArcSetptData >  {
public:
  typedef seqConArcSetptData_var _var_type;
  inline seqConArcSetptData() {}
  inline seqConArcSetptData(const seqConArcSetptData& _s)
    : _CORBA_Unbounded_Sequence< sConArcSetptData > (_s) {}

  inline seqConArcSetptData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sConArcSetptData > (_max) {}
  inline seqConArcSetptData(_CORBA_ULong _max, _CORBA_ULong _len, sConArcSetptData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sConArcSetptData > (_max, _len, _val, _rel) {}



  inline seqConArcSetptData& operator = (const seqConArcSetptData& _s) {
    _CORBA_Unbounded_Sequence< sConArcSetptData > ::operator=(_s);
    return *this;
  }
};

class seqConArcSetptData_out;

class seqConArcSetptData_var {
public:
  inline seqConArcSetptData_var() : _pd_seq(0) {}
  inline seqConArcSetptData_var(seqConArcSetptData* _s) : _pd_seq(_s) {}
  inline seqConArcSetptData_var(const seqConArcSetptData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqConArcSetptData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqConArcSetptData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqConArcSetptData_var& operator = (seqConArcSetptData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqConArcSetptData_var& operator = (const seqConArcSetptData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqConArcSetptData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sConArcSetptData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqConArcSetptData* operator -> () { return _pd_seq; }
  inline const seqConArcSetptData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqConArcSetptData& () const { return *_pd_seq; }
#else
  inline operator const seqConArcSetptData& () const { return *_pd_seq; }
  inline operator seqConArcSetptData& () { return *_pd_seq; }
#endif
    
  inline const seqConArcSetptData& in() const { return *_pd_seq; }
  inline seqConArcSetptData&       inout()    { return *_pd_seq; }
  inline seqConArcSetptData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqConArcSetptData* _retn() { seqConArcSetptData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqConArcSetptData_out;
  
private:
  seqConArcSetptData* _pd_seq;
};

class seqConArcSetptData_out {
public:
  inline seqConArcSetptData_out(seqConArcSetptData*& _s) : _data(_s) { _data = 0; }
  inline seqConArcSetptData_out(seqConArcSetptData_var& _s)
    : _data(_s._pd_seq) { _s = (seqConArcSetptData*) 0; }
  inline seqConArcSetptData_out(const seqConArcSetptData_out& _s) : _data(_s._data) {}
  inline seqConArcSetptData_out& operator = (const seqConArcSetptData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqConArcSetptData_out& operator = (seqConArcSetptData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqConArcSetptData*&()  { return _data; }
  inline seqConArcSetptData*& ptr()       { return _data; }
  inline seqConArcSetptData* operator->() { return _data; }

  inline sConArcSetptData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqConArcSetptData*& _data;

private:
  seqConArcSetptData_out();
  seqConArcSetptData_out& operator=(const seqConArcSetptData_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqConArcMeasData;

class seqConArcMeasData_var;

class seqConArcMeasData : public _CORBA_Unbounded_Sequence< sConArcMeasData >  {
public:
  typedef seqConArcMeasData_var _var_type;
  inline seqConArcMeasData() {}
  inline seqConArcMeasData(const seqConArcMeasData& _s)
    : _CORBA_Unbounded_Sequence< sConArcMeasData > (_s) {}

  inline seqConArcMeasData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sConArcMeasData > (_max) {}
  inline seqConArcMeasData(_CORBA_ULong _max, _CORBA_ULong _len, sConArcMeasData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sConArcMeasData > (_max, _len, _val, _rel) {}



  inline seqConArcMeasData& operator = (const seqConArcMeasData& _s) {
    _CORBA_Unbounded_Sequence< sConArcMeasData > ::operator=(_s);
    return *this;
  }
};

class seqConArcMeasData_out;

class seqConArcMeasData_var {
public:
  inline seqConArcMeasData_var() : _pd_seq(0) {}
  inline seqConArcMeasData_var(seqConArcMeasData* _s) : _pd_seq(_s) {}
  inline seqConArcMeasData_var(const seqConArcMeasData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqConArcMeasData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqConArcMeasData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqConArcMeasData_var& operator = (seqConArcMeasData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqConArcMeasData_var& operator = (const seqConArcMeasData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqConArcMeasData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sConArcMeasData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqConArcMeasData* operator -> () { return _pd_seq; }
  inline const seqConArcMeasData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqConArcMeasData& () const { return *_pd_seq; }
#else
  inline operator const seqConArcMeasData& () const { return *_pd_seq; }
  inline operator seqConArcMeasData& () { return *_pd_seq; }
#endif
    
  inline const seqConArcMeasData& in() const { return *_pd_seq; }
  inline seqConArcMeasData&       inout()    { return *_pd_seq; }
  inline seqConArcMeasData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqConArcMeasData* _retn() { seqConArcMeasData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqConArcMeasData_out;
  
private:
  seqConArcMeasData* _pd_seq;
};

class seqConArcMeasData_out {
public:
  inline seqConArcMeasData_out(seqConArcMeasData*& _s) : _data(_s) { _data = 0; }
  inline seqConArcMeasData_out(seqConArcMeasData_var& _s)
    : _data(_s._pd_seq) { _s = (seqConArcMeasData*) 0; }
  inline seqConArcMeasData_out(const seqConArcMeasData_out& _s) : _data(_s._data) {}
  inline seqConArcMeasData_out& operator = (const seqConArcMeasData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqConArcMeasData_out& operator = (seqConArcMeasData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqConArcMeasData*&()  { return _data; }
  inline seqConArcMeasData*& ptr()       { return _data; }
  inline seqConArcMeasData* operator->() { return _data; }

  inline sConArcMeasData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqConArcMeasData*& _data;

private:
  seqConArcMeasData_out();
  seqConArcMeasData_out& operator=(const seqConArcMeasData_var&);
};

struct sEAFMatFeedPredRes {
  typedef _CORBA_ConstrType_Variable_Var<sEAFMatFeedPredRes> _var_type;

  
  ::CORBA::Long BasketNo;

  ::CORBA::Long Step;

  ::CORBA::Double DurStep;

  ::CORBA::Double DurUntilStartOfStep;

  ::CORBA::Double DurUntilEndOfStep;

  ::CORBA::Double Egy;

  ::CORBA::Double SpecEgy;

  ::CORBA::Double ElecEgyStep;

  ::CORBA::Double BaseMass;

  seqBatch MatFeedData;

  ::CORBA::String_member PhaseName;

  ::CORBA::Double SpecEgyStep;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sEAFMatFeedPredRes::_var_type sEAFMatFeedPredRes_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sEAFMatFeedPredRes,sEAFMatFeedPredRes_var > sEAFMatFeedPredRes_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sEAFMatFeedPredRes;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqEAFMatFeedPredRes;

class seqEAFMatFeedPredRes_var;

class seqEAFMatFeedPredRes : public _CORBA_Unbounded_Sequence< sEAFMatFeedPredRes >  {
public:
  typedef seqEAFMatFeedPredRes_var _var_type;
  inline seqEAFMatFeedPredRes() {}
  inline seqEAFMatFeedPredRes(const seqEAFMatFeedPredRes& _s)
    : _CORBA_Unbounded_Sequence< sEAFMatFeedPredRes > (_s) {}

  inline seqEAFMatFeedPredRes(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sEAFMatFeedPredRes > (_max) {}
  inline seqEAFMatFeedPredRes(_CORBA_ULong _max, _CORBA_ULong _len, sEAFMatFeedPredRes* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sEAFMatFeedPredRes > (_max, _len, _val, _rel) {}



  inline seqEAFMatFeedPredRes& operator = (const seqEAFMatFeedPredRes& _s) {
    _CORBA_Unbounded_Sequence< sEAFMatFeedPredRes > ::operator=(_s);
    return *this;
  }
};

class seqEAFMatFeedPredRes_out;

class seqEAFMatFeedPredRes_var {
public:
  inline seqEAFMatFeedPredRes_var() : _pd_seq(0) {}
  inline seqEAFMatFeedPredRes_var(seqEAFMatFeedPredRes* _s) : _pd_seq(_s) {}
  inline seqEAFMatFeedPredRes_var(const seqEAFMatFeedPredRes_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqEAFMatFeedPredRes(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqEAFMatFeedPredRes_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqEAFMatFeedPredRes_var& operator = (seqEAFMatFeedPredRes* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqEAFMatFeedPredRes_var& operator = (const seqEAFMatFeedPredRes_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqEAFMatFeedPredRes;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sEAFMatFeedPredRes& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqEAFMatFeedPredRes* operator -> () { return _pd_seq; }
  inline const seqEAFMatFeedPredRes* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqEAFMatFeedPredRes& () const { return *_pd_seq; }
#else
  inline operator const seqEAFMatFeedPredRes& () const { return *_pd_seq; }
  inline operator seqEAFMatFeedPredRes& () { return *_pd_seq; }
#endif
    
  inline const seqEAFMatFeedPredRes& in() const { return *_pd_seq; }
  inline seqEAFMatFeedPredRes&       inout()    { return *_pd_seq; }
  inline seqEAFMatFeedPredRes*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqEAFMatFeedPredRes* _retn() { seqEAFMatFeedPredRes* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqEAFMatFeedPredRes_out;
  
private:
  seqEAFMatFeedPredRes* _pd_seq;
};

class seqEAFMatFeedPredRes_out {
public:
  inline seqEAFMatFeedPredRes_out(seqEAFMatFeedPredRes*& _s) : _data(_s) { _data = 0; }
  inline seqEAFMatFeedPredRes_out(seqEAFMatFeedPredRes_var& _s)
    : _data(_s._pd_seq) { _s = (seqEAFMatFeedPredRes*) 0; }
  inline seqEAFMatFeedPredRes_out(const seqEAFMatFeedPredRes_out& _s) : _data(_s._data) {}
  inline seqEAFMatFeedPredRes_out& operator = (const seqEAFMatFeedPredRes_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqEAFMatFeedPredRes_out& operator = (seqEAFMatFeedPredRes* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqEAFMatFeedPredRes*&()  { return _data; }
  inline seqEAFMatFeedPredRes*& ptr()       { return _data; }
  inline seqEAFMatFeedPredRes* operator->() { return _data; }

  inline sEAFMatFeedPredRes& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqEAFMatFeedPredRes*& _data;

private:
  seqEAFMatFeedPredRes_out();
  seqEAFMatFeedPredRes_out& operator=(const seqEAFMatFeedPredRes_var&);
};

struct sPhaseStatus {
  typedef _CORBA_ConstrType_Variable_Var<sPhaseStatus> _var_type;

  
  ::CORBA::String_member PhaseName;

  ::CORBA::Long Status;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sPhaseStatus::_var_type sPhaseStatus_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sPhaseStatus,sPhaseStatus_var > sPhaseStatus_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sPhaseStatus;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqPhaseStatus;

class seqPhaseStatus_var;

class seqPhaseStatus : public _CORBA_Unbounded_Sequence< sPhaseStatus >  {
public:
  typedef seqPhaseStatus_var _var_type;
  inline seqPhaseStatus() {}
  inline seqPhaseStatus(const seqPhaseStatus& _s)
    : _CORBA_Unbounded_Sequence< sPhaseStatus > (_s) {}

  inline seqPhaseStatus(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sPhaseStatus > (_max) {}
  inline seqPhaseStatus(_CORBA_ULong _max, _CORBA_ULong _len, sPhaseStatus* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sPhaseStatus > (_max, _len, _val, _rel) {}



  inline seqPhaseStatus& operator = (const seqPhaseStatus& _s) {
    _CORBA_Unbounded_Sequence< sPhaseStatus > ::operator=(_s);
    return *this;
  }
};

class seqPhaseStatus_out;

class seqPhaseStatus_var {
public:
  inline seqPhaseStatus_var() : _pd_seq(0) {}
  inline seqPhaseStatus_var(seqPhaseStatus* _s) : _pd_seq(_s) {}
  inline seqPhaseStatus_var(const seqPhaseStatus_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqPhaseStatus(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqPhaseStatus_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqPhaseStatus_var& operator = (seqPhaseStatus* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqPhaseStatus_var& operator = (const seqPhaseStatus_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqPhaseStatus;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sPhaseStatus& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqPhaseStatus* operator -> () { return _pd_seq; }
  inline const seqPhaseStatus* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqPhaseStatus& () const { return *_pd_seq; }
#else
  inline operator const seqPhaseStatus& () const { return *_pd_seq; }
  inline operator seqPhaseStatus& () { return *_pd_seq; }
#endif
    
  inline const seqPhaseStatus& in() const { return *_pd_seq; }
  inline seqPhaseStatus&       inout()    { return *_pd_seq; }
  inline seqPhaseStatus*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqPhaseStatus* _retn() { seqPhaseStatus* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqPhaseStatus_out;
  
private:
  seqPhaseStatus* _pd_seq;
};

class seqPhaseStatus_out {
public:
  inline seqPhaseStatus_out(seqPhaseStatus*& _s) : _data(_s) { _data = 0; }
  inline seqPhaseStatus_out(seqPhaseStatus_var& _s)
    : _data(_s._pd_seq) { _s = (seqPhaseStatus*) 0; }
  inline seqPhaseStatus_out(const seqPhaseStatus_out& _s) : _data(_s._data) {}
  inline seqPhaseStatus_out& operator = (const seqPhaseStatus_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqPhaseStatus_out& operator = (seqPhaseStatus* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqPhaseStatus*&()  { return _data; }
  inline seqPhaseStatus*& ptr()       { return _data; }
  inline seqPhaseStatus* operator->() { return _data; }

  inline sPhaseStatus& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqPhaseStatus*& _data;

private:
  seqPhaseStatus_out();
  seqPhaseStatus_out& operator=(const seqPhaseStatus_var&);
};

struct sMaterial {
  typedef _CORBA_ConstrType_Variable_Var<sMaterial> _var_type;

  
  ::CORBA::String_member MatCode;

  ::CORBA::Double MatWeight;

  ::CORBA::String_member Purpose;

  ::CORBA::Long SourceNo;

  ::CORBA::Long Source;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sMaterial::_var_type sMaterial_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sMaterial,sMaterial_var > sMaterial_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sMaterial;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqMaterials;

class seqMaterials_var;

class seqMaterials : public _CORBA_Unbounded_Sequence< sMaterial >  {
public:
  typedef seqMaterials_var _var_type;
  inline seqMaterials() {}
  inline seqMaterials(const seqMaterials& _s)
    : _CORBA_Unbounded_Sequence< sMaterial > (_s) {}

  inline seqMaterials(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sMaterial > (_max) {}
  inline seqMaterials(_CORBA_ULong _max, _CORBA_ULong _len, sMaterial* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sMaterial > (_max, _len, _val, _rel) {}



  inline seqMaterials& operator = (const seqMaterials& _s) {
    _CORBA_Unbounded_Sequence< sMaterial > ::operator=(_s);
    return *this;
  }
};

class seqMaterials_out;

class seqMaterials_var {
public:
  inline seqMaterials_var() : _pd_seq(0) {}
  inline seqMaterials_var(seqMaterials* _s) : _pd_seq(_s) {}
  inline seqMaterials_var(const seqMaterials_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqMaterials(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqMaterials_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqMaterials_var& operator = (seqMaterials* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqMaterials_var& operator = (const seqMaterials_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqMaterials;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sMaterial& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqMaterials* operator -> () { return _pd_seq; }
  inline const seqMaterials* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqMaterials& () const { return *_pd_seq; }
#else
  inline operator const seqMaterials& () const { return *_pd_seq; }
  inline operator seqMaterials& () { return *_pd_seq; }
#endif
    
  inline const seqMaterials& in() const { return *_pd_seq; }
  inline seqMaterials&       inout()    { return *_pd_seq; }
  inline seqMaterials*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqMaterials* _retn() { seqMaterials* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqMaterials_out;
  
private:
  seqMaterials* _pd_seq;
};

class seqMaterials_out {
public:
  inline seqMaterials_out(seqMaterials*& _s) : _data(_s) { _data = 0; }
  inline seqMaterials_out(seqMaterials_var& _s)
    : _data(_s._pd_seq) { _s = (seqMaterials*) 0; }
  inline seqMaterials_out(const seqMaterials_out& _s) : _data(_s._data) {}
  inline seqMaterials_out& operator = (const seqMaterials_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqMaterials_out& operator = (seqMaterials* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqMaterials*&()  { return _data; }
  inline seqMaterials*& ptr()       { return _data; }
  inline seqMaterials* operator->() { return _data; }

  inline sMaterial& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqMaterials*& _data;

private:
  seqMaterials_out();
  seqMaterials_out& operator=(const seqMaterials_var&);
};

struct sStirringData {
  typedef _CORBA_ConstrType_Variable_Var<sStirringData> _var_type;

  
  ::CORBA::String_member Device;

  seqGasData GasData;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sStirringData::_var_type sStirringData_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sStirringData,sStirringData_var > sStirringData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sStirringData;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqStirringData;

class seqStirringData_var;

class seqStirringData : public _CORBA_Unbounded_Sequence< sStirringData >  {
public:
  typedef seqStirringData_var _var_type;
  inline seqStirringData() {}
  inline seqStirringData(const seqStirringData& _s)
    : _CORBA_Unbounded_Sequence< sStirringData > (_s) {}

  inline seqStirringData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sStirringData > (_max) {}
  inline seqStirringData(_CORBA_ULong _max, _CORBA_ULong _len, sStirringData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sStirringData > (_max, _len, _val, _rel) {}



  inline seqStirringData& operator = (const seqStirringData& _s) {
    _CORBA_Unbounded_Sequence< sStirringData > ::operator=(_s);
    return *this;
  }
};

class seqStirringData_out;

class seqStirringData_var {
public:
  inline seqStirringData_var() : _pd_seq(0) {}
  inline seqStirringData_var(seqStirringData* _s) : _pd_seq(_s) {}
  inline seqStirringData_var(const seqStirringData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqStirringData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqStirringData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqStirringData_var& operator = (seqStirringData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqStirringData_var& operator = (const seqStirringData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqStirringData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sStirringData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqStirringData* operator -> () { return _pd_seq; }
  inline const seqStirringData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqStirringData& () const { return *_pd_seq; }
#else
  inline operator const seqStirringData& () const { return *_pd_seq; }
  inline operator seqStirringData& () { return *_pd_seq; }
#endif
    
  inline const seqStirringData& in() const { return *_pd_seq; }
  inline seqStirringData&       inout()    { return *_pd_seq; }
  inline seqStirringData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqStirringData* _retn() { seqStirringData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqStirringData_out;
  
private:
  seqStirringData* _pd_seq;
};

class seqStirringData_out {
public:
  inline seqStirringData_out(seqStirringData*& _s) : _data(_s) { _data = 0; }
  inline seqStirringData_out(seqStirringData_var& _s)
    : _data(_s._pd_seq) { _s = (seqStirringData*) 0; }
  inline seqStirringData_out(const seqStirringData_out& _s) : _data(_s._data) {}
  inline seqStirringData_out& operator = (const seqStirringData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqStirringData_out& operator = (seqStirringData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqStirringData*&()  { return _data; }
  inline seqStirringData*& ptr()       { return _data; }
  inline seqStirringData* operator->() { return _data; }

  inline sStirringData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqStirringData*& _data;

private:
  seqStirringData_out();
  seqStirringData_out& operator=(const seqStirringData_var&);
};

struct sProductIdentification {
  typedef _CORBA_ConstrType_Variable_Var<sProductIdentification> _var_type;

  
  ::CORBA::String_member HeatId;

  ::CORBA::String_member TreatId;

  ::CORBA::String_member OrderId;

  ::CORBA::String_member Plant;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sProductIdentification::_var_type sProductIdentification_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sProductIdentification,sProductIdentification_var > sProductIdentification_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sProductIdentification;

struct sRecipe {
  typedef _CORBA_ConstrType_Variable_Var<sRecipe> _var_type;

  
  ::CORBA::String_member RecipeName;

  ::CORBA::Long RecipeNo;

  ::CORBA::String_member RecipeSource;

  seqBatchPrio RecipeContent;

  sMetTimeStamp TimeStamp;

  sProductIdentification Product;

  sRecipeProperties RecipeData;

  ::CORBA::Double MatFeedRate;

  ::CORBA::Double ChargeMoment;

  ::CORBA::String_member RecipeName_Model;

  ::CORBA::Long RecipeNo_Model;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sRecipe::_var_type sRecipe_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sRecipe,sRecipe_var > sRecipe_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sRecipe;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqRecipeList;

class seqRecipeList_var;

class seqRecipeList : public _CORBA_Unbounded_Sequence< sRecipe >  {
public:
  typedef seqRecipeList_var _var_type;
  inline seqRecipeList() {}
  inline seqRecipeList(const seqRecipeList& _s)
    : _CORBA_Unbounded_Sequence< sRecipe > (_s) {}

  inline seqRecipeList(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sRecipe > (_max) {}
  inline seqRecipeList(_CORBA_ULong _max, _CORBA_ULong _len, sRecipe* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sRecipe > (_max, _len, _val, _rel) {}



  inline seqRecipeList& operator = (const seqRecipeList& _s) {
    _CORBA_Unbounded_Sequence< sRecipe > ::operator=(_s);
    return *this;
  }
};

class seqRecipeList_out;

class seqRecipeList_var {
public:
  inline seqRecipeList_var() : _pd_seq(0) {}
  inline seqRecipeList_var(seqRecipeList* _s) : _pd_seq(_s) {}
  inline seqRecipeList_var(const seqRecipeList_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqRecipeList(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqRecipeList_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqRecipeList_var& operator = (seqRecipeList* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqRecipeList_var& operator = (const seqRecipeList_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqRecipeList;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sRecipe& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqRecipeList* operator -> () { return _pd_seq; }
  inline const seqRecipeList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqRecipeList& () const { return *_pd_seq; }
#else
  inline operator const seqRecipeList& () const { return *_pd_seq; }
  inline operator seqRecipeList& () { return *_pd_seq; }
#endif
    
  inline const seqRecipeList& in() const { return *_pd_seq; }
  inline seqRecipeList&       inout()    { return *_pd_seq; }
  inline seqRecipeList*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqRecipeList* _retn() { seqRecipeList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqRecipeList_out;
  
private:
  seqRecipeList* _pd_seq;
};

class seqRecipeList_out {
public:
  inline seqRecipeList_out(seqRecipeList*& _s) : _data(_s) { _data = 0; }
  inline seqRecipeList_out(seqRecipeList_var& _s)
    : _data(_s._pd_seq) { _s = (seqRecipeList*) 0; }
  inline seqRecipeList_out(const seqRecipeList_out& _s) : _data(_s._data) {}
  inline seqRecipeList_out& operator = (const seqRecipeList_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqRecipeList_out& operator = (seqRecipeList* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqRecipeList*&()  { return _data; }
  inline seqRecipeList*& ptr()       { return _data; }
  inline seqRecipeList* operator->() { return _data; }

  inline sRecipe& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqRecipeList*& _data;

private:
  seqRecipeList_out();
  seqRecipeList_out& operator=(const seqRecipeList_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqProductIdentification;

class seqProductIdentification_var;

class seqProductIdentification : public _CORBA_Unbounded_Sequence< sProductIdentification >  {
public:
  typedef seqProductIdentification_var _var_type;
  inline seqProductIdentification() {}
  inline seqProductIdentification(const seqProductIdentification& _s)
    : _CORBA_Unbounded_Sequence< sProductIdentification > (_s) {}

  inline seqProductIdentification(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sProductIdentification > (_max) {}
  inline seqProductIdentification(_CORBA_ULong _max, _CORBA_ULong _len, sProductIdentification* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sProductIdentification > (_max, _len, _val, _rel) {}



  inline seqProductIdentification& operator = (const seqProductIdentification& _s) {
    _CORBA_Unbounded_Sequence< sProductIdentification > ::operator=(_s);
    return *this;
  }
};

class seqProductIdentification_out;

class seqProductIdentification_var {
public:
  inline seqProductIdentification_var() : _pd_seq(0) {}
  inline seqProductIdentification_var(seqProductIdentification* _s) : _pd_seq(_s) {}
  inline seqProductIdentification_var(const seqProductIdentification_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqProductIdentification(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqProductIdentification_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqProductIdentification_var& operator = (seqProductIdentification* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqProductIdentification_var& operator = (const seqProductIdentification_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqProductIdentification;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sProductIdentification& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqProductIdentification* operator -> () { return _pd_seq; }
  inline const seqProductIdentification* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqProductIdentification& () const { return *_pd_seq; }
#else
  inline operator const seqProductIdentification& () const { return *_pd_seq; }
  inline operator seqProductIdentification& () { return *_pd_seq; }
#endif
    
  inline const seqProductIdentification& in() const { return *_pd_seq; }
  inline seqProductIdentification&       inout()    { return *_pd_seq; }
  inline seqProductIdentification*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqProductIdentification* _retn() { seqProductIdentification* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqProductIdentification_out;
  
private:
  seqProductIdentification* _pd_seq;
};

class seqProductIdentification_out {
public:
  inline seqProductIdentification_out(seqProductIdentification*& _s) : _data(_s) { _data = 0; }
  inline seqProductIdentification_out(seqProductIdentification_var& _s)
    : _data(_s._pd_seq) { _s = (seqProductIdentification*) 0; }
  inline seqProductIdentification_out(const seqProductIdentification_out& _s) : _data(_s._data) {}
  inline seqProductIdentification_out& operator = (const seqProductIdentification_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqProductIdentification_out& operator = (seqProductIdentification* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqProductIdentification*&()  { return _data; }
  inline seqProductIdentification*& ptr()       { return _data; }
  inline seqProductIdentification* operator->() { return _data; }

  inline sProductIdentification& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqProductIdentification*& _data;

private:
  seqProductIdentification_out();
  seqProductIdentification_out& operator=(const seqProductIdentification_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqHMDCalc;

class seqHMDCalc_var;

class seqHMDCalc : public _CORBA_Unbounded_Sequence< sHMDCalc >  {
public:
  typedef seqHMDCalc_var _var_type;
  inline seqHMDCalc() {}
  inline seqHMDCalc(const seqHMDCalc& _s)
    : _CORBA_Unbounded_Sequence< sHMDCalc > (_s) {}

  inline seqHMDCalc(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sHMDCalc > (_max) {}
  inline seqHMDCalc(_CORBA_ULong _max, _CORBA_ULong _len, sHMDCalc* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sHMDCalc > (_max, _len, _val, _rel) {}



  inline seqHMDCalc& operator = (const seqHMDCalc& _s) {
    _CORBA_Unbounded_Sequence< sHMDCalc > ::operator=(_s);
    return *this;
  }
};

class seqHMDCalc_out;

class seqHMDCalc_var {
public:
  inline seqHMDCalc_var() : _pd_seq(0) {}
  inline seqHMDCalc_var(seqHMDCalc* _s) : _pd_seq(_s) {}
  inline seqHMDCalc_var(const seqHMDCalc_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqHMDCalc(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqHMDCalc_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqHMDCalc_var& operator = (seqHMDCalc* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqHMDCalc_var& operator = (const seqHMDCalc_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqHMDCalc;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sHMDCalc& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqHMDCalc* operator -> () { return _pd_seq; }
  inline const seqHMDCalc* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqHMDCalc& () const { return *_pd_seq; }
#else
  inline operator const seqHMDCalc& () const { return *_pd_seq; }
  inline operator seqHMDCalc& () { return *_pd_seq; }
#endif
    
  inline const seqHMDCalc& in() const { return *_pd_seq; }
  inline seqHMDCalc&       inout()    { return *_pd_seq; }
  inline seqHMDCalc*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqHMDCalc* _retn() { seqHMDCalc* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqHMDCalc_out;
  
private:
  seqHMDCalc* _pd_seq;
};

class seqHMDCalc_out {
public:
  inline seqHMDCalc_out(seqHMDCalc*& _s) : _data(_s) { _data = 0; }
  inline seqHMDCalc_out(seqHMDCalc_var& _s)
    : _data(_s._pd_seq) { _s = (seqHMDCalc*) 0; }
  inline seqHMDCalc_out(const seqHMDCalc_out& _s) : _data(_s._data) {}
  inline seqHMDCalc_out& operator = (const seqHMDCalc_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqHMDCalc_out& operator = (seqHMDCalc* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqHMDCalc*&()  { return _data; }
  inline seqHMDCalc*& ptr()       { return _data; }
  inline seqHMDCalc* operator->() { return _data; }

  inline sHMDCalc& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqHMDCalc*& _data;

private:
  seqHMDCalc_out();
  seqHMDCalc_out& operator=(const seqHMDCalc_var&);
};

struct sHMDModelResult {
  typedef _CORBA_ConstrType_Variable_Var<sHMDModelResult> _var_type;

  
  ::CORBA::Long TreatmentKind;

  seqHMDCalc CalcAmount;

  seqHMDCalc CalcFlow;

  DEF::seqDouble SlagAmount;

  DEF::seqDouble DurationDeslagging;

  DEF::seqDouble TemperatureAfter;

  DEF::seqDouble Cost;

  DEF::seqDouble Duration;

  ::CORBA::Long IWarn;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sHMDModelResult::_var_type sHMDModelResult_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sHMDModelResult,sHMDModelResult_var > sHMDModelResult_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sHMDModelResult;

struct sRHModelResult {
  typedef _CORBA_ConstrType_Variable_Var<sRHModelResult> _var_type;

  
  ::CORBA::Long PhaseNo;

  ::CORBA::Long Res_PhaseNoModel;

  ::CORBA::Double TotDurPhase;

  seqRecipeList Alloy;

  ::CORBA::Double TempDiffAlloy;

  seqAnalysis Analysis;

  ::CORBA::Double SlagWeight;

  ::CORBA::Double SteelWeight;

  ::CORBA::String_member PhaseCodeModel;

  ::CORBA::String_member PhaseName;

  ::CORBA::Double HeatTemp;

  ::CORBA::Double TempDiffPassive;

  ::CORBA::Double OxygenAmount;

  ::CORBA::Double OxygenFlow;

  ::CORBA::Double PowderFlow;

  ::CORBA::Double LanceDist;

  ::CORBA::Double DurSinceHeatAnnouncement;

  ::CORBA::Double RemDur;

  ::CORBA::Double AlHeat;

  ::CORBA::Double AlAlloy;

  ::CORBA::Double AlDeox;

  ::CORBA::Double VacuumPressure;

  ::CORBA::Double DNTime;

  ::CORBA::Double DHTime;

  ::CORBA::Double TempDiffStep;

  ::CORBA::Double LiftGasFlow;

  ::CORBA::Long VacCurve;

  ::CORBA::Long StirrIntensity;

  ::CORBA::Double StirrGasFlow;

  ::CORBA::String_member StirrGasType;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sRHModelResult::_var_type sRHModelResult_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sRHModelResult,sRHModelResult_var > sRHModelResult_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sRHModelResult;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqRHModelResult;

class seqRHModelResult_var;

class seqRHModelResult : public _CORBA_Unbounded_Sequence< sRHModelResult >  {
public:
  typedef seqRHModelResult_var _var_type;
  inline seqRHModelResult() {}
  inline seqRHModelResult(const seqRHModelResult& _s)
    : _CORBA_Unbounded_Sequence< sRHModelResult > (_s) {}

  inline seqRHModelResult(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sRHModelResult > (_max) {}
  inline seqRHModelResult(_CORBA_ULong _max, _CORBA_ULong _len, sRHModelResult* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sRHModelResult > (_max, _len, _val, _rel) {}



  inline seqRHModelResult& operator = (const seqRHModelResult& _s) {
    _CORBA_Unbounded_Sequence< sRHModelResult > ::operator=(_s);
    return *this;
  }
};

class seqRHModelResult_out;

class seqRHModelResult_var {
public:
  inline seqRHModelResult_var() : _pd_seq(0) {}
  inline seqRHModelResult_var(seqRHModelResult* _s) : _pd_seq(_s) {}
  inline seqRHModelResult_var(const seqRHModelResult_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqRHModelResult(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqRHModelResult_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqRHModelResult_var& operator = (seqRHModelResult* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqRHModelResult_var& operator = (const seqRHModelResult_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqRHModelResult;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sRHModelResult& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqRHModelResult* operator -> () { return _pd_seq; }
  inline const seqRHModelResult* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqRHModelResult& () const { return *_pd_seq; }
#else
  inline operator const seqRHModelResult& () const { return *_pd_seq; }
  inline operator seqRHModelResult& () { return *_pd_seq; }
#endif
    
  inline const seqRHModelResult& in() const { return *_pd_seq; }
  inline seqRHModelResult&       inout()    { return *_pd_seq; }
  inline seqRHModelResult*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqRHModelResult* _retn() { seqRHModelResult* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqRHModelResult_out;
  
private:
  seqRHModelResult* _pd_seq;
};

class seqRHModelResult_out {
public:
  inline seqRHModelResult_out(seqRHModelResult*& _s) : _data(_s) { _data = 0; }
  inline seqRHModelResult_out(seqRHModelResult_var& _s)
    : _data(_s._pd_seq) { _s = (seqRHModelResult*) 0; }
  inline seqRHModelResult_out(const seqRHModelResult_out& _s) : _data(_s._data) {}
  inline seqRHModelResult_out& operator = (const seqRHModelResult_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqRHModelResult_out& operator = (seqRHModelResult* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqRHModelResult*&()  { return _data; }
  inline seqRHModelResult*& ptr()       { return _data; }
  inline seqRHModelResult* operator->() { return _data; }

  inline sRHModelResult& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqRHModelResult*& _data;

private:
  seqRHModelResult_out();
  seqRHModelResult_out& operator=(const seqRHModelResult_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqHMDModelResult;

class seqHMDModelResult_var;

class seqHMDModelResult : public _CORBA_Unbounded_Sequence< sHMDModelResult >  {
public:
  typedef seqHMDModelResult_var _var_type;
  inline seqHMDModelResult() {}
  inline seqHMDModelResult(const seqHMDModelResult& _s)
    : _CORBA_Unbounded_Sequence< sHMDModelResult > (_s) {}

  inline seqHMDModelResult(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sHMDModelResult > (_max) {}
  inline seqHMDModelResult(_CORBA_ULong _max, _CORBA_ULong _len, sHMDModelResult* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sHMDModelResult > (_max, _len, _val, _rel) {}



  inline seqHMDModelResult& operator = (const seqHMDModelResult& _s) {
    _CORBA_Unbounded_Sequence< sHMDModelResult > ::operator=(_s);
    return *this;
  }
};

class seqHMDModelResult_out;

class seqHMDModelResult_var {
public:
  inline seqHMDModelResult_var() : _pd_seq(0) {}
  inline seqHMDModelResult_var(seqHMDModelResult* _s) : _pd_seq(_s) {}
  inline seqHMDModelResult_var(const seqHMDModelResult_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqHMDModelResult(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqHMDModelResult_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqHMDModelResult_var& operator = (seqHMDModelResult* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqHMDModelResult_var& operator = (const seqHMDModelResult_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqHMDModelResult;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sHMDModelResult& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqHMDModelResult* operator -> () { return _pd_seq; }
  inline const seqHMDModelResult* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqHMDModelResult& () const { return *_pd_seq; }
#else
  inline operator const seqHMDModelResult& () const { return *_pd_seq; }
  inline operator seqHMDModelResult& () { return *_pd_seq; }
#endif
    
  inline const seqHMDModelResult& in() const { return *_pd_seq; }
  inline seqHMDModelResult&       inout()    { return *_pd_seq; }
  inline seqHMDModelResult*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqHMDModelResult* _retn() { seqHMDModelResult* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqHMDModelResult_out;
  
private:
  seqHMDModelResult* _pd_seq;
};

class seqHMDModelResult_out {
public:
  inline seqHMDModelResult_out(seqHMDModelResult*& _s) : _data(_s) { _data = 0; }
  inline seqHMDModelResult_out(seqHMDModelResult_var& _s)
    : _data(_s._pd_seq) { _s = (seqHMDModelResult*) 0; }
  inline seqHMDModelResult_out(const seqHMDModelResult_out& _s) : _data(_s._data) {}
  inline seqHMDModelResult_out& operator = (const seqHMDModelResult_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqHMDModelResult_out& operator = (seqHMDModelResult* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqHMDModelResult*&()  { return _data; }
  inline seqHMDModelResult*& ptr()       { return _data; }
  inline seqHMDModelResult* operator->() { return _data; }

  inline sHMDModelResult& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqHMDModelResult*& _data;

private:
  seqHMDModelResult_out();
  seqHMDModelResult_out& operator=(const seqHMDModelResult_var&);
};

struct sElecPhaseData {
  typedef _CORBA_ConstrType_Variable_Var<sElecPhaseData> _var_type;

  
  ::CORBA::Long PhaseNo;

  ::CORBA::String_member PhaseName;

  ::CORBA::Long PhaseType;

  sDate StartTime;

  sDate EndTime;

  ::CORBA::Double Duration;

  ::CORBA::Double ElecCons;

  ::CORBA::Double ElecConsStart;

  seqGasData GasData;

  seqGasData GasDataStart;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sElecPhaseData::_var_type sElecPhaseData_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sElecPhaseData,sElecPhaseData_var > sElecPhaseData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sElecPhaseData;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqElecPhaseData;

class seqElecPhaseData_var;

class seqElecPhaseData : public _CORBA_Unbounded_Sequence< sElecPhaseData >  {
public:
  typedef seqElecPhaseData_var _var_type;
  inline seqElecPhaseData() {}
  inline seqElecPhaseData(const seqElecPhaseData& _s)
    : _CORBA_Unbounded_Sequence< sElecPhaseData > (_s) {}

  inline seqElecPhaseData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sElecPhaseData > (_max) {}
  inline seqElecPhaseData(_CORBA_ULong _max, _CORBA_ULong _len, sElecPhaseData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sElecPhaseData > (_max, _len, _val, _rel) {}



  inline seqElecPhaseData& operator = (const seqElecPhaseData& _s) {
    _CORBA_Unbounded_Sequence< sElecPhaseData > ::operator=(_s);
    return *this;
  }
};

class seqElecPhaseData_out;

class seqElecPhaseData_var {
public:
  inline seqElecPhaseData_var() : _pd_seq(0) {}
  inline seqElecPhaseData_var(seqElecPhaseData* _s) : _pd_seq(_s) {}
  inline seqElecPhaseData_var(const seqElecPhaseData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqElecPhaseData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqElecPhaseData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqElecPhaseData_var& operator = (seqElecPhaseData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqElecPhaseData_var& operator = (const seqElecPhaseData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqElecPhaseData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sElecPhaseData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqElecPhaseData* operator -> () { return _pd_seq; }
  inline const seqElecPhaseData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqElecPhaseData& () const { return *_pd_seq; }
#else
  inline operator const seqElecPhaseData& () const { return *_pd_seq; }
  inline operator seqElecPhaseData& () { return *_pd_seq; }
#endif
    
  inline const seqElecPhaseData& in() const { return *_pd_seq; }
  inline seqElecPhaseData&       inout()    { return *_pd_seq; }
  inline seqElecPhaseData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqElecPhaseData* _retn() { seqElecPhaseData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqElecPhaseData_out;
  
private:
  seqElecPhaseData* _pd_seq;
};

class seqElecPhaseData_out {
public:
  inline seqElecPhaseData_out(seqElecPhaseData*& _s) : _data(_s) { _data = 0; }
  inline seqElecPhaseData_out(seqElecPhaseData_var& _s)
    : _data(_s._pd_seq) { _s = (seqElecPhaseData*) 0; }
  inline seqElecPhaseData_out(const seqElecPhaseData_out& _s) : _data(_s._data) {}
  inline seqElecPhaseData_out& operator = (const seqElecPhaseData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqElecPhaseData_out& operator = (seqElecPhaseData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqElecPhaseData*&()  { return _data; }
  inline seqElecPhaseData*& ptr()       { return _data; }
  inline seqElecPhaseData* operator->() { return _data; }

  inline sElecPhaseData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqElecPhaseData*& _data;

private:
  seqElecPhaseData_out();
  seqElecPhaseData_out& operator=(const seqElecPhaseData_var&);
};

struct sVDModelResult {
  typedef _CORBA_ConstrType_Variable_Var<sVDModelResult> _var_type;

  
  ::CORBA::Long PhaseNo;

  ::CORBA::String_member PhaseName;

  seqAnalysis Analysis;

  ::CORBA::Double SteelWeight;

  ::CORBA::Double SlagWeight;

  ::CORBA::Double HeatTemp;

  ::CORBA::Double TotDurPhase;

  seqRecipeList Alloy;

  ::CORBA::Double TempDiffAlloy;

  ::CORBA::Double TempDiffStep;

  ::CORBA::Double TempDiffPassive;

  ::CORBA::Double RemDur;

  ::CORBA::Double AlHeat;

  ::CORBA::Double AlAlloy;

  ::CORBA::Double AlDeox;

  ::CORBA::Double DCTime;

  ::CORBA::Double VacuumPressure;

  ::CORBA::Double DNTime;

  ::CORBA::Double DHTime;

  ::CORBA::Double StirringFlow;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sVDModelResult::_var_type sVDModelResult_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sVDModelResult,sVDModelResult_var > sVDModelResult_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sVDModelResult;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqVDModelResult;

class seqVDModelResult_var;

class seqVDModelResult : public _CORBA_Unbounded_Sequence< sVDModelResult >  {
public:
  typedef seqVDModelResult_var _var_type;
  inline seqVDModelResult() {}
  inline seqVDModelResult(const seqVDModelResult& _s)
    : _CORBA_Unbounded_Sequence< sVDModelResult > (_s) {}

  inline seqVDModelResult(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sVDModelResult > (_max) {}
  inline seqVDModelResult(_CORBA_ULong _max, _CORBA_ULong _len, sVDModelResult* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sVDModelResult > (_max, _len, _val, _rel) {}



  inline seqVDModelResult& operator = (const seqVDModelResult& _s) {
    _CORBA_Unbounded_Sequence< sVDModelResult > ::operator=(_s);
    return *this;
  }
};

class seqVDModelResult_out;

class seqVDModelResult_var {
public:
  inline seqVDModelResult_var() : _pd_seq(0) {}
  inline seqVDModelResult_var(seqVDModelResult* _s) : _pd_seq(_s) {}
  inline seqVDModelResult_var(const seqVDModelResult_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqVDModelResult(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqVDModelResult_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqVDModelResult_var& operator = (seqVDModelResult* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqVDModelResult_var& operator = (const seqVDModelResult_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqVDModelResult;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sVDModelResult& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqVDModelResult* operator -> () { return _pd_seq; }
  inline const seqVDModelResult* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqVDModelResult& () const { return *_pd_seq; }
#else
  inline operator const seqVDModelResult& () const { return *_pd_seq; }
  inline operator seqVDModelResult& () { return *_pd_seq; }
#endif
    
  inline const seqVDModelResult& in() const { return *_pd_seq; }
  inline seqVDModelResult&       inout()    { return *_pd_seq; }
  inline seqVDModelResult*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqVDModelResult* _retn() { seqVDModelResult* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqVDModelResult_out;
  
private:
  seqVDModelResult* _pd_seq;
};

class seqVDModelResult_out {
public:
  inline seqVDModelResult_out(seqVDModelResult*& _s) : _data(_s) { _data = 0; }
  inline seqVDModelResult_out(seqVDModelResult_var& _s)
    : _data(_s._pd_seq) { _s = (seqVDModelResult*) 0; }
  inline seqVDModelResult_out(const seqVDModelResult_out& _s) : _data(_s._data) {}
  inline seqVDModelResult_out& operator = (const seqVDModelResult_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqVDModelResult_out& operator = (seqVDModelResult* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqVDModelResult*&()  { return _data; }
  inline seqVDModelResult*& ptr()       { return _data; }
  inline seqVDModelResult* operator->() { return _data; }

  inline sVDModelResult& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqVDModelResult*& _data;

private:
  seqVDModelResult_out();
  seqVDModelResult_out& operator=(const seqVDModelResult_var&);
};

struct sConArcBlowData {
  typedef _CORBA_ConstrType_Fix_Var<sConArcBlowData> _var_type;

  
  ::CORBA::Double O2MomentEndStep;

  ::CORBA::Double O2Flow;

  ::CORBA::Double O2Cons;

  ::CORBA::Long TopLanceHeight;

  ::CORBA::Double PorousPlugN2Flow;

  ::CORBA::Double PorousPlugArFlow;

  ::CORBA::Double O2Start;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sConArcBlowData::_var_type sConArcBlowData_var;

typedef sConArcBlowData& sConArcBlowData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sConArcBlowData;

struct sConArcModelResult {
  typedef _CORBA_ConstrType_Variable_Var<sConArcModelResult> _var_type;

  
  ::CORBA::String_member Phase;

  ::CORBA::Long PhaseNo;

  sGenRes GenRes;

  ::CORBA::Double BaseMass;

  ::CORBA::Long PhaseActive;

  sConArcElecData ElectricalData;

  sConArcBlowData BlowingData;

  seqConArcMediaData MaterialData;

  ::CORBA::Long StepNo;

  ::CORBA::Double DecarbRate;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sConArcModelResult::_var_type sConArcModelResult_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sConArcModelResult,sConArcModelResult_var > sConArcModelResult_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sConArcModelResult;

struct sConArcMediaPredRes {
  typedef _CORBA_ConstrType_Variable_Var<sConArcMediaPredRes> _var_type;

  
  ::CORBA::Long StepNo;

  seqConArcMediaData MediaData;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sConArcMediaPredRes::_var_type sConArcMediaPredRes_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sConArcMediaPredRes,sConArcMediaPredRes_var > sConArcMediaPredRes_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sConArcMediaPredRes;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqConArcMediaPredRes;

class seqConArcMediaPredRes_var;

class seqConArcMediaPredRes : public _CORBA_Unbounded_Sequence< sConArcMediaPredRes >  {
public:
  typedef seqConArcMediaPredRes_var _var_type;
  inline seqConArcMediaPredRes() {}
  inline seqConArcMediaPredRes(const seqConArcMediaPredRes& _s)
    : _CORBA_Unbounded_Sequence< sConArcMediaPredRes > (_s) {}

  inline seqConArcMediaPredRes(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sConArcMediaPredRes > (_max) {}
  inline seqConArcMediaPredRes(_CORBA_ULong _max, _CORBA_ULong _len, sConArcMediaPredRes* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sConArcMediaPredRes > (_max, _len, _val, _rel) {}



  inline seqConArcMediaPredRes& operator = (const seqConArcMediaPredRes& _s) {
    _CORBA_Unbounded_Sequence< sConArcMediaPredRes > ::operator=(_s);
    return *this;
  }
};

class seqConArcMediaPredRes_out;

class seqConArcMediaPredRes_var {
public:
  inline seqConArcMediaPredRes_var() : _pd_seq(0) {}
  inline seqConArcMediaPredRes_var(seqConArcMediaPredRes* _s) : _pd_seq(_s) {}
  inline seqConArcMediaPredRes_var(const seqConArcMediaPredRes_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqConArcMediaPredRes(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqConArcMediaPredRes_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqConArcMediaPredRes_var& operator = (seqConArcMediaPredRes* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqConArcMediaPredRes_var& operator = (const seqConArcMediaPredRes_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqConArcMediaPredRes;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sConArcMediaPredRes& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqConArcMediaPredRes* operator -> () { return _pd_seq; }
  inline const seqConArcMediaPredRes* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqConArcMediaPredRes& () const { return *_pd_seq; }
#else
  inline operator const seqConArcMediaPredRes& () const { return *_pd_seq; }
  inline operator seqConArcMediaPredRes& () { return *_pd_seq; }
#endif
    
  inline const seqConArcMediaPredRes& in() const { return *_pd_seq; }
  inline seqConArcMediaPredRes&       inout()    { return *_pd_seq; }
  inline seqConArcMediaPredRes*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqConArcMediaPredRes* _retn() { seqConArcMediaPredRes* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqConArcMediaPredRes_out;
  
private:
  seqConArcMediaPredRes* _pd_seq;
};

class seqConArcMediaPredRes_out {
public:
  inline seqConArcMediaPredRes_out(seqConArcMediaPredRes*& _s) : _data(_s) { _data = 0; }
  inline seqConArcMediaPredRes_out(seqConArcMediaPredRes_var& _s)
    : _data(_s._pd_seq) { _s = (seqConArcMediaPredRes*) 0; }
  inline seqConArcMediaPredRes_out(const seqConArcMediaPredRes_out& _s) : _data(_s._data) {}
  inline seqConArcMediaPredRes_out& operator = (const seqConArcMediaPredRes_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqConArcMediaPredRes_out& operator = (seqConArcMediaPredRes* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqConArcMediaPredRes*&()  { return _data; }
  inline seqConArcMediaPredRes*& ptr()       { return _data; }
  inline seqConArcMediaPredRes* operator->() { return _data; }

  inline sConArcMediaPredRes& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqConArcMediaPredRes*& _data;

private:
  seqConArcMediaPredRes_out();
  seqConArcMediaPredRes_out& operator=(const seqConArcMediaPredRes_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqConArcBlowData;

class seqConArcBlowData_var;

class seqConArcBlowData : public _CORBA_Unbounded_Sequence< sConArcBlowData >  {
public:
  typedef seqConArcBlowData_var _var_type;
  inline seqConArcBlowData() {}
  inline seqConArcBlowData(const seqConArcBlowData& _s)
    : _CORBA_Unbounded_Sequence< sConArcBlowData > (_s) {}

  inline seqConArcBlowData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sConArcBlowData > (_max) {}
  inline seqConArcBlowData(_CORBA_ULong _max, _CORBA_ULong _len, sConArcBlowData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sConArcBlowData > (_max, _len, _val, _rel) {}



  inline seqConArcBlowData& operator = (const seqConArcBlowData& _s) {
    _CORBA_Unbounded_Sequence< sConArcBlowData > ::operator=(_s);
    return *this;
  }
};

class seqConArcBlowData_out;

class seqConArcBlowData_var {
public:
  inline seqConArcBlowData_var() : _pd_seq(0) {}
  inline seqConArcBlowData_var(seqConArcBlowData* _s) : _pd_seq(_s) {}
  inline seqConArcBlowData_var(const seqConArcBlowData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqConArcBlowData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqConArcBlowData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqConArcBlowData_var& operator = (seqConArcBlowData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqConArcBlowData_var& operator = (const seqConArcBlowData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqConArcBlowData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sConArcBlowData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqConArcBlowData* operator -> () { return _pd_seq; }
  inline const seqConArcBlowData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqConArcBlowData& () const { return *_pd_seq; }
#else
  inline operator const seqConArcBlowData& () const { return *_pd_seq; }
  inline operator seqConArcBlowData& () { return *_pd_seq; }
#endif
    
  inline const seqConArcBlowData& in() const { return *_pd_seq; }
  inline seqConArcBlowData&       inout()    { return *_pd_seq; }
  inline seqConArcBlowData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqConArcBlowData* _retn() { seqConArcBlowData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqConArcBlowData_out;
  
private:
  seqConArcBlowData* _pd_seq;
};

class seqConArcBlowData_out {
public:
  inline seqConArcBlowData_out(seqConArcBlowData*& _s) : _data(_s) { _data = 0; }
  inline seqConArcBlowData_out(seqConArcBlowData_var& _s)
    : _data(_s._pd_seq) { _s = (seqConArcBlowData*) 0; }
  inline seqConArcBlowData_out(const seqConArcBlowData_out& _s) : _data(_s._data) {}
  inline seqConArcBlowData_out& operator = (const seqConArcBlowData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqConArcBlowData_out& operator = (seqConArcBlowData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqConArcBlowData*&()  { return _data; }
  inline seqConArcBlowData*& ptr()       { return _data; }
  inline seqConArcBlowData* operator->() { return _data; }

  inline sConArcBlowData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqConArcBlowData*& _data;

private:
  seqConArcBlowData_out();
  seqConArcBlowData_out& operator=(const seqConArcBlowData_var&);
};

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqConArcModelResult;

class seqConArcModelResult_var;

class seqConArcModelResult : public _CORBA_Unbounded_Sequence< sConArcModelResult >  {
public:
  typedef seqConArcModelResult_var _var_type;
  inline seqConArcModelResult() {}
  inline seqConArcModelResult(const seqConArcModelResult& _s)
    : _CORBA_Unbounded_Sequence< sConArcModelResult > (_s) {}

  inline seqConArcModelResult(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sConArcModelResult > (_max) {}
  inline seqConArcModelResult(_CORBA_ULong _max, _CORBA_ULong _len, sConArcModelResult* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sConArcModelResult > (_max, _len, _val, _rel) {}



  inline seqConArcModelResult& operator = (const seqConArcModelResult& _s) {
    _CORBA_Unbounded_Sequence< sConArcModelResult > ::operator=(_s);
    return *this;
  }
};

class seqConArcModelResult_out;

class seqConArcModelResult_var {
public:
  inline seqConArcModelResult_var() : _pd_seq(0) {}
  inline seqConArcModelResult_var(seqConArcModelResult* _s) : _pd_seq(_s) {}
  inline seqConArcModelResult_var(const seqConArcModelResult_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqConArcModelResult(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqConArcModelResult_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqConArcModelResult_var& operator = (seqConArcModelResult* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqConArcModelResult_var& operator = (const seqConArcModelResult_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqConArcModelResult;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sConArcModelResult& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqConArcModelResult* operator -> () { return _pd_seq; }
  inline const seqConArcModelResult* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqConArcModelResult& () const { return *_pd_seq; }
#else
  inline operator const seqConArcModelResult& () const { return *_pd_seq; }
  inline operator seqConArcModelResult& () { return *_pd_seq; }
#endif
    
  inline const seqConArcModelResult& in() const { return *_pd_seq; }
  inline seqConArcModelResult&       inout()    { return *_pd_seq; }
  inline seqConArcModelResult*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqConArcModelResult* _retn() { seqConArcModelResult* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqConArcModelResult_out;
  
private:
  seqConArcModelResult* _pd_seq;
};

class seqConArcModelResult_out {
public:
  inline seqConArcModelResult_out(seqConArcModelResult*& _s) : _data(_s) { _data = 0; }
  inline seqConArcModelResult_out(seqConArcModelResult_var& _s)
    : _data(_s._pd_seq) { _s = (seqConArcModelResult*) 0; }
  inline seqConArcModelResult_out(const seqConArcModelResult_out& _s) : _data(_s._data) {}
  inline seqConArcModelResult_out& operator = (const seqConArcModelResult_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqConArcModelResult_out& operator = (seqConArcModelResult* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqConArcModelResult*&()  { return _data; }
  inline seqConArcModelResult*& ptr()       { return _data; }
  inline seqConArcModelResult* operator->() { return _data; }

  inline sConArcModelResult& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqConArcModelResult*& _data;

private:
  seqConArcModelResult_out();
  seqConArcModelResult_out& operator=(const seqConArcModelResult_var&);
};

struct sLTSStirrPredRes {
  typedef _CORBA_ConstrType_Variable_Var<sLTSStirrPredRes> _var_type;

  
  ::CORBA::String_member StirrPhase;

  ::CORBA::Long StirrIntensity;

  ::CORBA::Double StirrFlow;

  ::CORBA::String_member GasType;

  ::CORBA::Long Priority;

  ::CORBA::Double DurStep;

  ::CORBA::String_member StirrIntensityCode;

  ::CORBA::Long Enable;

  ::CORBA::Long Order;

  ::CORBA::Long isPatternOrActivity;

  ::CORBA::Double DurUntilEndOfStep;

  ::CORBA::Double DurUntilStartOfStep;

  ::CORBA::Long VoltTap;

  ::CORBA::Long ImpCurve;

  ::CORBA::Double ElecEgy;

  ::CORBA::Double SteelMass;

  ::CORBA::Double SlagMass;

  ::CORBA::Double Temp;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sLTSStirrPredRes::_var_type sLTSStirrPredRes_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sLTSStirrPredRes,sLTSStirrPredRes_var > sLTSStirrPredRes_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sLTSStirrPredRes;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqLTSStirrPredRes;

class seqLTSStirrPredRes_var;

class seqLTSStirrPredRes : public _CORBA_Unbounded_Sequence< sLTSStirrPredRes >  {
public:
  typedef seqLTSStirrPredRes_var _var_type;
  inline seqLTSStirrPredRes() {}
  inline seqLTSStirrPredRes(const seqLTSStirrPredRes& _s)
    : _CORBA_Unbounded_Sequence< sLTSStirrPredRes > (_s) {}

  inline seqLTSStirrPredRes(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sLTSStirrPredRes > (_max) {}
  inline seqLTSStirrPredRes(_CORBA_ULong _max, _CORBA_ULong _len, sLTSStirrPredRes* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sLTSStirrPredRes > (_max, _len, _val, _rel) {}



  inline seqLTSStirrPredRes& operator = (const seqLTSStirrPredRes& _s) {
    _CORBA_Unbounded_Sequence< sLTSStirrPredRes > ::operator=(_s);
    return *this;
  }
};

class seqLTSStirrPredRes_out;

class seqLTSStirrPredRes_var {
public:
  inline seqLTSStirrPredRes_var() : _pd_seq(0) {}
  inline seqLTSStirrPredRes_var(seqLTSStirrPredRes* _s) : _pd_seq(_s) {}
  inline seqLTSStirrPredRes_var(const seqLTSStirrPredRes_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqLTSStirrPredRes(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqLTSStirrPredRes_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqLTSStirrPredRes_var& operator = (seqLTSStirrPredRes* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqLTSStirrPredRes_var& operator = (const seqLTSStirrPredRes_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqLTSStirrPredRes;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sLTSStirrPredRes& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqLTSStirrPredRes* operator -> () { return _pd_seq; }
  inline const seqLTSStirrPredRes* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqLTSStirrPredRes& () const { return *_pd_seq; }
#else
  inline operator const seqLTSStirrPredRes& () const { return *_pd_seq; }
  inline operator seqLTSStirrPredRes& () { return *_pd_seq; }
#endif
    
  inline const seqLTSStirrPredRes& in() const { return *_pd_seq; }
  inline seqLTSStirrPredRes&       inout()    { return *_pd_seq; }
  inline seqLTSStirrPredRes*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqLTSStirrPredRes* _retn() { seqLTSStirrPredRes* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqLTSStirrPredRes_out;
  
private:
  seqLTSStirrPredRes* _pd_seq;
};

class seqLTSStirrPredRes_out {
public:
  inline seqLTSStirrPredRes_out(seqLTSStirrPredRes*& _s) : _data(_s) { _data = 0; }
  inline seqLTSStirrPredRes_out(seqLTSStirrPredRes_var& _s)
    : _data(_s._pd_seq) { _s = (seqLTSStirrPredRes*) 0; }
  inline seqLTSStirrPredRes_out(const seqLTSStirrPredRes_out& _s) : _data(_s._data) {}
  inline seqLTSStirrPredRes_out& operator = (const seqLTSStirrPredRes_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqLTSStirrPredRes_out& operator = (seqLTSStirrPredRes* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqLTSStirrPredRes*&()  { return _data; }
  inline seqLTSStirrPredRes*& ptr()       { return _data; }
  inline seqLTSStirrPredRes* operator->() { return _data; }

  inline sLTSStirrPredRes& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqLTSStirrPredRes*& _data;

private:
  seqLTSStirrPredRes_out();
  seqLTSStirrPredRes_out& operator=(const seqLTSStirrPredRes_var&);
};

struct sBOFGlobalSetpoints {
  typedef _CORBA_ConstrType_Fix_Var<sBOFGlobalSetpoints> _var_type;

  
  ::CORBA::Double O2VolStartMatAddn;

  ::CORBA::Double O2VolSartMatDynAddn;

  ::CORBA::Double O2VolStartScrapChute;

  ::CORBA::Double O2VolSubLance;

  ::CORBA::Double O2VolTotal;

  ::CORBA::Double O2VolTotalLance;

  ::CORBA::Double N2VolTotal;

  ::CORBA::Double MatFeedRate;

  ::CORBA::Double MatDynFeedRate;

  ::CORBA::Double AimTapWeightCalc;

  ::CORBA::Double DurStartMatAddn;

  ::CORBA::Double DurStartMatDynAddn;

  ::CORBA::Double DurStartScrapChute;

  ::CORBA::Double DurSubLance;

  ::CORBA::Double O2VolStartMat2ndAddn;

  ::CORBA::Double DurStartMat2ndAddn;

  ::CORBA::Double MatFeedRate2ndAdd;

  ::CORBA::Double AimSteelMassCalc;

  ::CORBA::Long ReblowCode;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sBOFGlobalSetpoints::_var_type sBOFGlobalSetpoints_var;

typedef sBOFGlobalSetpoints& sBOFGlobalSetpoints_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sBOFGlobalSetpoints;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqBOFGlobalSetpoints;

class seqBOFGlobalSetpoints_var;

class seqBOFGlobalSetpoints : public _CORBA_Unbounded_Sequence< sBOFGlobalSetpoints >  {
public:
  typedef seqBOFGlobalSetpoints_var _var_type;
  inline seqBOFGlobalSetpoints() {}
  inline seqBOFGlobalSetpoints(const seqBOFGlobalSetpoints& _s)
    : _CORBA_Unbounded_Sequence< sBOFGlobalSetpoints > (_s) {}

  inline seqBOFGlobalSetpoints(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sBOFGlobalSetpoints > (_max) {}
  inline seqBOFGlobalSetpoints(_CORBA_ULong _max, _CORBA_ULong _len, sBOFGlobalSetpoints* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sBOFGlobalSetpoints > (_max, _len, _val, _rel) {}



  inline seqBOFGlobalSetpoints& operator = (const seqBOFGlobalSetpoints& _s) {
    _CORBA_Unbounded_Sequence< sBOFGlobalSetpoints > ::operator=(_s);
    return *this;
  }
};

class seqBOFGlobalSetpoints_out;

class seqBOFGlobalSetpoints_var {
public:
  inline seqBOFGlobalSetpoints_var() : _pd_seq(0) {}
  inline seqBOFGlobalSetpoints_var(seqBOFGlobalSetpoints* _s) : _pd_seq(_s) {}
  inline seqBOFGlobalSetpoints_var(const seqBOFGlobalSetpoints_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqBOFGlobalSetpoints(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqBOFGlobalSetpoints_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqBOFGlobalSetpoints_var& operator = (seqBOFGlobalSetpoints* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqBOFGlobalSetpoints_var& operator = (const seqBOFGlobalSetpoints_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqBOFGlobalSetpoints;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sBOFGlobalSetpoints& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqBOFGlobalSetpoints* operator -> () { return _pd_seq; }
  inline const seqBOFGlobalSetpoints* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqBOFGlobalSetpoints& () const { return *_pd_seq; }
#else
  inline operator const seqBOFGlobalSetpoints& () const { return *_pd_seq; }
  inline operator seqBOFGlobalSetpoints& () { return *_pd_seq; }
#endif
    
  inline const seqBOFGlobalSetpoints& in() const { return *_pd_seq; }
  inline seqBOFGlobalSetpoints&       inout()    { return *_pd_seq; }
  inline seqBOFGlobalSetpoints*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqBOFGlobalSetpoints* _retn() { seqBOFGlobalSetpoints* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqBOFGlobalSetpoints_out;
  
private:
  seqBOFGlobalSetpoints* _pd_seq;
};

class seqBOFGlobalSetpoints_out {
public:
  inline seqBOFGlobalSetpoints_out(seqBOFGlobalSetpoints*& _s) : _data(_s) { _data = 0; }
  inline seqBOFGlobalSetpoints_out(seqBOFGlobalSetpoints_var& _s)
    : _data(_s._pd_seq) { _s = (seqBOFGlobalSetpoints*) 0; }
  inline seqBOFGlobalSetpoints_out(const seqBOFGlobalSetpoints_out& _s) : _data(_s._data) {}
  inline seqBOFGlobalSetpoints_out& operator = (const seqBOFGlobalSetpoints_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqBOFGlobalSetpoints_out& operator = (seqBOFGlobalSetpoints* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqBOFGlobalSetpoints*&()  { return _data; }
  inline seqBOFGlobalSetpoints*& ptr()       { return _data; }
  inline seqBOFGlobalSetpoints* operator->() { return _data; }

  inline sBOFGlobalSetpoints& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqBOFGlobalSetpoints*& _data;

private:
  seqBOFGlobalSetpoints_out();
  seqBOFGlobalSetpoints_out& operator=(const seqBOFGlobalSetpoints_var&);
};

struct sConArcGlobalSetpoints {
  typedef _CORBA_ConstrType_Fix_Var<sConArcGlobalSetpoints> _var_type;

  
  ::CORBA::Double O2VolStartMatAddn;

  ::CORBA::Double O2VolSartMatDynAddn;

  ::CORBA::Double O2VolStartScrapChute;

  ::CORBA::Double O2VolSubLance;

  ::CORBA::Double O2VolTotal;

  ::CORBA::Double O2VolTotalLance;

  ::CORBA::Double N2VolTotal;

  ::CORBA::Double ArVolTotal;

  ::CORBA::Double MatFeedRate;

  ::CORBA::Double MatDynFeedRate;

  ::CORBA::Double AimTapWeightCalc;

  ::CORBA::Double AimSteelMassCalc;

  ::CORBA::Double DurStartMatAddn;

  ::CORBA::Double DurStartMatDynAddn;

  ::CORBA::Double DurStartScrapChute;

  ::CORBA::Double DurSubLance;

  ::CORBA::Double O2VolStartMat2ndAddn;

  ::CORBA::Double DurStartMat2ndAddn;

  ::CORBA::Double MatFeedRate2ndAdd;

  ::CORBA::Long ReblowCode;

  ::CORBA::Double DRICons;

  ::CORBA::Double LimeCons;

  ::CORBA::Double DoloCons;

  ::CORBA::Double CoalCons;

  ::CORBA::Double EgyTotal;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sConArcGlobalSetpoints::_var_type sConArcGlobalSetpoints_var;

typedef sConArcGlobalSetpoints& sConArcGlobalSetpoints_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sConArcGlobalSetpoints;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqConArcGlobalSetpoints;

class seqConArcGlobalSetpoints_var;

class seqConArcGlobalSetpoints : public _CORBA_Unbounded_Sequence< sConArcGlobalSetpoints >  {
public:
  typedef seqConArcGlobalSetpoints_var _var_type;
  inline seqConArcGlobalSetpoints() {}
  inline seqConArcGlobalSetpoints(const seqConArcGlobalSetpoints& _s)
    : _CORBA_Unbounded_Sequence< sConArcGlobalSetpoints > (_s) {}

  inline seqConArcGlobalSetpoints(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sConArcGlobalSetpoints > (_max) {}
  inline seqConArcGlobalSetpoints(_CORBA_ULong _max, _CORBA_ULong _len, sConArcGlobalSetpoints* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sConArcGlobalSetpoints > (_max, _len, _val, _rel) {}



  inline seqConArcGlobalSetpoints& operator = (const seqConArcGlobalSetpoints& _s) {
    _CORBA_Unbounded_Sequence< sConArcGlobalSetpoints > ::operator=(_s);
    return *this;
  }
};

class seqConArcGlobalSetpoints_out;

class seqConArcGlobalSetpoints_var {
public:
  inline seqConArcGlobalSetpoints_var() : _pd_seq(0) {}
  inline seqConArcGlobalSetpoints_var(seqConArcGlobalSetpoints* _s) : _pd_seq(_s) {}
  inline seqConArcGlobalSetpoints_var(const seqConArcGlobalSetpoints_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqConArcGlobalSetpoints(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqConArcGlobalSetpoints_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqConArcGlobalSetpoints_var& operator = (seqConArcGlobalSetpoints* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqConArcGlobalSetpoints_var& operator = (const seqConArcGlobalSetpoints_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqConArcGlobalSetpoints;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sConArcGlobalSetpoints& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqConArcGlobalSetpoints* operator -> () { return _pd_seq; }
  inline const seqConArcGlobalSetpoints* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqConArcGlobalSetpoints& () const { return *_pd_seq; }
#else
  inline operator const seqConArcGlobalSetpoints& () const { return *_pd_seq; }
  inline operator seqConArcGlobalSetpoints& () { return *_pd_seq; }
#endif
    
  inline const seqConArcGlobalSetpoints& in() const { return *_pd_seq; }
  inline seqConArcGlobalSetpoints&       inout()    { return *_pd_seq; }
  inline seqConArcGlobalSetpoints*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqConArcGlobalSetpoints* _retn() { seqConArcGlobalSetpoints* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqConArcGlobalSetpoints_out;
  
private:
  seqConArcGlobalSetpoints* _pd_seq;
};

class seqConArcGlobalSetpoints_out {
public:
  inline seqConArcGlobalSetpoints_out(seqConArcGlobalSetpoints*& _s) : _data(_s) { _data = 0; }
  inline seqConArcGlobalSetpoints_out(seqConArcGlobalSetpoints_var& _s)
    : _data(_s._pd_seq) { _s = (seqConArcGlobalSetpoints*) 0; }
  inline seqConArcGlobalSetpoints_out(const seqConArcGlobalSetpoints_out& _s) : _data(_s._data) {}
  inline seqConArcGlobalSetpoints_out& operator = (const seqConArcGlobalSetpoints_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqConArcGlobalSetpoints_out& operator = (seqConArcGlobalSetpoints* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqConArcGlobalSetpoints*&()  { return _data; }
  inline seqConArcGlobalSetpoints*& ptr()       { return _data; }
  inline seqConArcGlobalSetpoints* operator->() { return _data; }

  inline sConArcGlobalSetpoints& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqConArcGlobalSetpoints*& _data;

private:
  seqConArcGlobalSetpoints_out();
  seqConArcGlobalSetpoints_out& operator=(const seqConArcGlobalSetpoints_var&);
};

struct sSample {
  typedef _CORBA_ConstrType_Variable_Var<sSample> _var_type;

  
  ::CORBA::String_member MeasName;

  ::CORBA::Double MeasValue;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sSample::_var_type sSample_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sSample,sSample_var > sSample_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sSample;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqSample;

class seqSample_var;

class seqSample : public _CORBA_Unbounded_Sequence< sSample >  {
public:
  typedef seqSample_var _var_type;
  inline seqSample() {}
  inline seqSample(const seqSample& _s)
    : _CORBA_Unbounded_Sequence< sSample > (_s) {}

  inline seqSample(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sSample > (_max) {}
  inline seqSample(_CORBA_ULong _max, _CORBA_ULong _len, sSample* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sSample > (_max, _len, _val, _rel) {}



  inline seqSample& operator = (const seqSample& _s) {
    _CORBA_Unbounded_Sequence< sSample > ::operator=(_s);
    return *this;
  }
};

class seqSample_out;

class seqSample_var {
public:
  inline seqSample_var() : _pd_seq(0) {}
  inline seqSample_var(seqSample* _s) : _pd_seq(_s) {}
  inline seqSample_var(const seqSample_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqSample(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqSample_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqSample_var& operator = (seqSample* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqSample_var& operator = (const seqSample_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqSample;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sSample& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqSample* operator -> () { return _pd_seq; }
  inline const seqSample* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqSample& () const { return *_pd_seq; }
#else
  inline operator const seqSample& () const { return *_pd_seq; }
  inline operator seqSample& () { return *_pd_seq; }
#endif
    
  inline const seqSample& in() const { return *_pd_seq; }
  inline seqSample&       inout()    { return *_pd_seq; }
  inline seqSample*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqSample* _retn() { seqSample* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqSample_out;
  
private:
  seqSample* _pd_seq;
};

class seqSample_out {
public:
  inline seqSample_out(seqSample*& _s) : _data(_s) { _data = 0; }
  inline seqSample_out(seqSample_var& _s)
    : _data(_s._pd_seq) { _s = (seqSample*) 0; }
  inline seqSample_out(const seqSample_out& _s) : _data(_s._data) {}
  inline seqSample_out& operator = (const seqSample_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqSample_out& operator = (seqSample* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqSample*&()  { return _data; }
  inline seqSample*& ptr()       { return _data; }
  inline seqSample* operator->() { return _data; }

  inline sSample& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqSample*& _data;

private:
  seqSample_out();
  seqSample_out& operator=(const seqSample_var&);
};

struct sTorpedoData {
  typedef _CORBA_ConstrType_Fix_Var<sTorpedoData> _var_type;

  
  ::CORBA::Long TorpedoNo;

  ::CORBA::Double Weight;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sTorpedoData::_var_type sTorpedoData_var;

typedef sTorpedoData& sTorpedoData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sTorpedoData;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqTorpedoData;

class seqTorpedoData_var;

class seqTorpedoData : public _CORBA_Unbounded_Sequence< sTorpedoData >  {
public:
  typedef seqTorpedoData_var _var_type;
  inline seqTorpedoData() {}
  inline seqTorpedoData(const seqTorpedoData& _s)
    : _CORBA_Unbounded_Sequence< sTorpedoData > (_s) {}

  inline seqTorpedoData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sTorpedoData > (_max) {}
  inline seqTorpedoData(_CORBA_ULong _max, _CORBA_ULong _len, sTorpedoData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sTorpedoData > (_max, _len, _val, _rel) {}



  inline seqTorpedoData& operator = (const seqTorpedoData& _s) {
    _CORBA_Unbounded_Sequence< sTorpedoData > ::operator=(_s);
    return *this;
  }
};

class seqTorpedoData_out;

class seqTorpedoData_var {
public:
  inline seqTorpedoData_var() : _pd_seq(0) {}
  inline seqTorpedoData_var(seqTorpedoData* _s) : _pd_seq(_s) {}
  inline seqTorpedoData_var(const seqTorpedoData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqTorpedoData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqTorpedoData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqTorpedoData_var& operator = (seqTorpedoData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqTorpedoData_var& operator = (const seqTorpedoData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqTorpedoData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sTorpedoData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqTorpedoData* operator -> () { return _pd_seq; }
  inline const seqTorpedoData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqTorpedoData& () const { return *_pd_seq; }
#else
  inline operator const seqTorpedoData& () const { return *_pd_seq; }
  inline operator seqTorpedoData& () { return *_pd_seq; }
#endif
    
  inline const seqTorpedoData& in() const { return *_pd_seq; }
  inline seqTorpedoData&       inout()    { return *_pd_seq; }
  inline seqTorpedoData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqTorpedoData* _retn() { seqTorpedoData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqTorpedoData_out;
  
private:
  seqTorpedoData* _pd_seq;
};

class seqTorpedoData_out {
public:
  inline seqTorpedoData_out(seqTorpedoData*& _s) : _data(_s) { _data = 0; }
  inline seqTorpedoData_out(seqTorpedoData_var& _s)
    : _data(_s._pd_seq) { _s = (seqTorpedoData*) 0; }
  inline seqTorpedoData_out(const seqTorpedoData_out& _s) : _data(_s._data) {}
  inline seqTorpedoData_out& operator = (const seqTorpedoData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqTorpedoData_out& operator = (seqTorpedoData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqTorpedoData*&()  { return _data; }
  inline seqTorpedoData*& ptr()       { return _data; }
  inline seqTorpedoData* operator->() { return _data; }

  inline sTorpedoData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqTorpedoData*& _data;

private:
  seqTorpedoData_out();
  seqTorpedoData_out& operator=(const seqTorpedoData_var&);
};

struct strSampleRef {
  typedef _CORBA_ConstrType_Fix_Var<strSampleRef> _var_type;

  
  ::CORBA::Long mSteel;

  ::CORBA::Long mSteelCalc;

  ::CORBA::Long mSlag;

  ::CORBA::Long mSlagCalc;

  ::CORBA::Long mCarbon;

  ::CORBA::Long mOxygen;

  ::CORBA::Long mHydrogen;

  ::CORBA::Long mCelogSlag;

  ::CORBA::Long mAluminium;

  ::CORBA::Long mEMF;

  ::CORBA::Long mTemp;

  ::CORBA::Long mTempCalc;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef strSampleRef::_var_type strSampleRef_var;

typedef strSampleRef& strSampleRef_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_strSampleRef;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sSampleRef;

typedef strSampleRef sSampleRef;
typedef strSampleRef_var sSampleRef_var;
typedef strSampleRef_out sSampleRef_out;

struct sPhaseDataReport {
  typedef _CORBA_ConstrType_Variable_Var<sPhaseDataReport> _var_type;

  
  ::CORBA::String_member PhaseName;

  ::CORBA::Long PhaseNo;

  sDate StartTime;

  sDate EndTime;

  ::CORBA::Double Duration;

  ::CORBA::Double ElecCons;

  ::CORBA::Double ElecConsStart;

  seqDeviceGasData GasCons;

  seqDeviceGasData GasConsStart;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sPhaseDataReport::_var_type sPhaseDataReport_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sPhaseDataReport,sPhaseDataReport_var > sPhaseDataReport_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sPhaseDataReport;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqPhaseDataReport;

class seqPhaseDataReport_var;

class seqPhaseDataReport : public _CORBA_Unbounded_Sequence< sPhaseDataReport >  {
public:
  typedef seqPhaseDataReport_var _var_type;
  inline seqPhaseDataReport() {}
  inline seqPhaseDataReport(const seqPhaseDataReport& _s)
    : _CORBA_Unbounded_Sequence< sPhaseDataReport > (_s) {}

  inline seqPhaseDataReport(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sPhaseDataReport > (_max) {}
  inline seqPhaseDataReport(_CORBA_ULong _max, _CORBA_ULong _len, sPhaseDataReport* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sPhaseDataReport > (_max, _len, _val, _rel) {}



  inline seqPhaseDataReport& operator = (const seqPhaseDataReport& _s) {
    _CORBA_Unbounded_Sequence< sPhaseDataReport > ::operator=(_s);
    return *this;
  }
};

class seqPhaseDataReport_out;

class seqPhaseDataReport_var {
public:
  inline seqPhaseDataReport_var() : _pd_seq(0) {}
  inline seqPhaseDataReport_var(seqPhaseDataReport* _s) : _pd_seq(_s) {}
  inline seqPhaseDataReport_var(const seqPhaseDataReport_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqPhaseDataReport(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqPhaseDataReport_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqPhaseDataReport_var& operator = (seqPhaseDataReport* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqPhaseDataReport_var& operator = (const seqPhaseDataReport_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqPhaseDataReport;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sPhaseDataReport& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqPhaseDataReport* operator -> () { return _pd_seq; }
  inline const seqPhaseDataReport* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqPhaseDataReport& () const { return *_pd_seq; }
#else
  inline operator const seqPhaseDataReport& () const { return *_pd_seq; }
  inline operator seqPhaseDataReport& () { return *_pd_seq; }
#endif
    
  inline const seqPhaseDataReport& in() const { return *_pd_seq; }
  inline seqPhaseDataReport&       inout()    { return *_pd_seq; }
  inline seqPhaseDataReport*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqPhaseDataReport* _retn() { seqPhaseDataReport* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqPhaseDataReport_out;
  
private:
  seqPhaseDataReport* _pd_seq;
};

class seqPhaseDataReport_out {
public:
  inline seqPhaseDataReport_out(seqPhaseDataReport*& _s) : _data(_s) { _data = 0; }
  inline seqPhaseDataReport_out(seqPhaseDataReport_var& _s)
    : _data(_s._pd_seq) { _s = (seqPhaseDataReport*) 0; }
  inline seqPhaseDataReport_out(const seqPhaseDataReport_out& _s) : _data(_s._data) {}
  inline seqPhaseDataReport_out& operator = (const seqPhaseDataReport_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqPhaseDataReport_out& operator = (seqPhaseDataReport* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqPhaseDataReport*&()  { return _data; }
  inline seqPhaseDataReport*& ptr()       { return _data; }
  inline seqPhaseDataReport* operator->() { return _data; }

  inline sPhaseDataReport& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqPhaseDataReport*& _data;

private:
  seqPhaseDataReport_out();
  seqPhaseDataReport_out& operator=(const seqPhaseDataReport_var&);
};

struct sEquipmentLifeData {
  typedef _CORBA_ConstrType_Fix_Var<sEquipmentLifeData> _var_type;

  
  ::CORBA::Long EquipID;

  ::CORBA::Long EquipPartID;

  ::CORBA::Long EquipCounter1Life;

  ::CORBA::Long EquipCounter2Life;

  sDate ChangeTime;

  ::CORBA::Double Weight;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sEquipmentLifeData::_var_type sEquipmentLifeData_var;

typedef sEquipmentLifeData& sEquipmentLifeData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sEquipmentLifeData;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqEquipmentLifeData;

class seqEquipmentLifeData_var;

class seqEquipmentLifeData : public _CORBA_Unbounded_Sequence< sEquipmentLifeData >  {
public:
  typedef seqEquipmentLifeData_var _var_type;
  inline seqEquipmentLifeData() {}
  inline seqEquipmentLifeData(const seqEquipmentLifeData& _s)
    : _CORBA_Unbounded_Sequence< sEquipmentLifeData > (_s) {}

  inline seqEquipmentLifeData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sEquipmentLifeData > (_max) {}
  inline seqEquipmentLifeData(_CORBA_ULong _max, _CORBA_ULong _len, sEquipmentLifeData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sEquipmentLifeData > (_max, _len, _val, _rel) {}



  inline seqEquipmentLifeData& operator = (const seqEquipmentLifeData& _s) {
    _CORBA_Unbounded_Sequence< sEquipmentLifeData > ::operator=(_s);
    return *this;
  }
};

class seqEquipmentLifeData_out;

class seqEquipmentLifeData_var {
public:
  inline seqEquipmentLifeData_var() : _pd_seq(0) {}
  inline seqEquipmentLifeData_var(seqEquipmentLifeData* _s) : _pd_seq(_s) {}
  inline seqEquipmentLifeData_var(const seqEquipmentLifeData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqEquipmentLifeData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqEquipmentLifeData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqEquipmentLifeData_var& operator = (seqEquipmentLifeData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqEquipmentLifeData_var& operator = (const seqEquipmentLifeData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqEquipmentLifeData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sEquipmentLifeData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqEquipmentLifeData* operator -> () { return _pd_seq; }
  inline const seqEquipmentLifeData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqEquipmentLifeData& () const { return *_pd_seq; }
#else
  inline operator const seqEquipmentLifeData& () const { return *_pd_seq; }
  inline operator seqEquipmentLifeData& () { return *_pd_seq; }
#endif
    
  inline const seqEquipmentLifeData& in() const { return *_pd_seq; }
  inline seqEquipmentLifeData&       inout()    { return *_pd_seq; }
  inline seqEquipmentLifeData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqEquipmentLifeData* _retn() { seqEquipmentLifeData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqEquipmentLifeData_out;
  
private:
  seqEquipmentLifeData* _pd_seq;
};

class seqEquipmentLifeData_out {
public:
  inline seqEquipmentLifeData_out(seqEquipmentLifeData*& _s) : _data(_s) { _data = 0; }
  inline seqEquipmentLifeData_out(seqEquipmentLifeData_var& _s)
    : _data(_s._pd_seq) { _s = (seqEquipmentLifeData*) 0; }
  inline seqEquipmentLifeData_out(const seqEquipmentLifeData_out& _s) : _data(_s._data) {}
  inline seqEquipmentLifeData_out& operator = (const seqEquipmentLifeData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqEquipmentLifeData_out& operator = (seqEquipmentLifeData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqEquipmentLifeData*&()  { return _data; }
  inline seqEquipmentLifeData*& ptr()       { return _data; }
  inline seqEquipmentLifeData* operator->() { return _data; }

  inline sEquipmentLifeData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqEquipmentLifeData*& _data;

private:
  seqEquipmentLifeData_out();
  seqEquipmentLifeData_out& operator=(const seqEquipmentLifeData_var&);
};

struct sPPRestriction {
  typedef _CORBA_ConstrType_Variable_Var<sPPRestriction> _var_type;

  
  ::CORBA::String_member PPDescription;

  ::CORBA::Long PPNumber;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sPPRestriction::_var_type sPPRestriction_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sPPRestriction,sPPRestriction_var > sPPRestriction_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sPPRestriction;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqPPRestriction;

class seqPPRestriction_var;

class seqPPRestriction : public _CORBA_Unbounded_Sequence< sPPRestriction >  {
public:
  typedef seqPPRestriction_var _var_type;
  inline seqPPRestriction() {}
  inline seqPPRestriction(const seqPPRestriction& _s)
    : _CORBA_Unbounded_Sequence< sPPRestriction > (_s) {}

  inline seqPPRestriction(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sPPRestriction > (_max) {}
  inline seqPPRestriction(_CORBA_ULong _max, _CORBA_ULong _len, sPPRestriction* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sPPRestriction > (_max, _len, _val, _rel) {}



  inline seqPPRestriction& operator = (const seqPPRestriction& _s) {
    _CORBA_Unbounded_Sequence< sPPRestriction > ::operator=(_s);
    return *this;
  }
};

class seqPPRestriction_out;

class seqPPRestriction_var {
public:
  inline seqPPRestriction_var() : _pd_seq(0) {}
  inline seqPPRestriction_var(seqPPRestriction* _s) : _pd_seq(_s) {}
  inline seqPPRestriction_var(const seqPPRestriction_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqPPRestriction(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqPPRestriction_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqPPRestriction_var& operator = (seqPPRestriction* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqPPRestriction_var& operator = (const seqPPRestriction_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqPPRestriction;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sPPRestriction& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqPPRestriction* operator -> () { return _pd_seq; }
  inline const seqPPRestriction* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqPPRestriction& () const { return *_pd_seq; }
#else
  inline operator const seqPPRestriction& () const { return *_pd_seq; }
  inline operator seqPPRestriction& () { return *_pd_seq; }
#endif
    
  inline const seqPPRestriction& in() const { return *_pd_seq; }
  inline seqPPRestriction&       inout()    { return *_pd_seq; }
  inline seqPPRestriction*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqPPRestriction* _retn() { seqPPRestriction* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqPPRestriction_out;
  
private:
  seqPPRestriction* _pd_seq;
};

class seqPPRestriction_out {
public:
  inline seqPPRestriction_out(seqPPRestriction*& _s) : _data(_s) { _data = 0; }
  inline seqPPRestriction_out(seqPPRestriction_var& _s)
    : _data(_s._pd_seq) { _s = (seqPPRestriction*) 0; }
  inline seqPPRestriction_out(const seqPPRestriction_out& _s) : _data(_s._data) {}
  inline seqPPRestriction_out& operator = (const seqPPRestriction_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqPPRestriction_out& operator = (seqPPRestriction* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqPPRestriction*&()  { return _data; }
  inline seqPPRestriction*& ptr()       { return _data; }
  inline seqPPRestriction* operator->() { return _data; }

  inline sPPRestriction& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqPPRestriction*& _data;

private:
  seqPPRestriction_out();
  seqPPRestriction_out& operator=(const seqPPRestriction_var&);
};

struct sHeatStack {
  typedef _CORBA_ConstrType_Variable_Var<sHeatStack> _var_type;

  
  ::CORBA::String_member ExternalHeatID;

  ::CORBA::String_member ExternalTreatID;

  ::CORBA::String_member HeatId;

  ::CORBA::String_member TreatId;

  ::CORBA::String_member OrderId;

  ::CORBA::String_member Plant;

  ::CORBA::Long PlantNo;

  ::CORBA::Long HeatStatus;

  ::CORBA::Long ScrapOrderStatus;

  ::CORBA::Long HotMetalOrderStatus;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sHeatStack::_var_type sHeatStack_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sHeatStack,sHeatStack_var > sHeatStack_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sHeatStack;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqHeatStack;

class seqHeatStack_var;

class seqHeatStack : public _CORBA_Unbounded_Sequence< sHeatStack >  {
public:
  typedef seqHeatStack_var _var_type;
  inline seqHeatStack() {}
  inline seqHeatStack(const seqHeatStack& _s)
    : _CORBA_Unbounded_Sequence< sHeatStack > (_s) {}

  inline seqHeatStack(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sHeatStack > (_max) {}
  inline seqHeatStack(_CORBA_ULong _max, _CORBA_ULong _len, sHeatStack* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sHeatStack > (_max, _len, _val, _rel) {}



  inline seqHeatStack& operator = (const seqHeatStack& _s) {
    _CORBA_Unbounded_Sequence< sHeatStack > ::operator=(_s);
    return *this;
  }
};

class seqHeatStack_out;

class seqHeatStack_var {
public:
  inline seqHeatStack_var() : _pd_seq(0) {}
  inline seqHeatStack_var(seqHeatStack* _s) : _pd_seq(_s) {}
  inline seqHeatStack_var(const seqHeatStack_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqHeatStack(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqHeatStack_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqHeatStack_var& operator = (seqHeatStack* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqHeatStack_var& operator = (const seqHeatStack_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqHeatStack;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sHeatStack& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqHeatStack* operator -> () { return _pd_seq; }
  inline const seqHeatStack* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqHeatStack& () const { return *_pd_seq; }
#else
  inline operator const seqHeatStack& () const { return *_pd_seq; }
  inline operator seqHeatStack& () { return *_pd_seq; }
#endif
    
  inline const seqHeatStack& in() const { return *_pd_seq; }
  inline seqHeatStack&       inout()    { return *_pd_seq; }
  inline seqHeatStack*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqHeatStack* _retn() { seqHeatStack* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqHeatStack_out;
  
private:
  seqHeatStack* _pd_seq;
};

class seqHeatStack_out {
public:
  inline seqHeatStack_out(seqHeatStack*& _s) : _data(_s) { _data = 0; }
  inline seqHeatStack_out(seqHeatStack_var& _s)
    : _data(_s._pd_seq) { _s = (seqHeatStack*) 0; }
  inline seqHeatStack_out(const seqHeatStack_out& _s) : _data(_s._data) {}
  inline seqHeatStack_out& operator = (const seqHeatStack_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqHeatStack_out& operator = (seqHeatStack* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqHeatStack*&()  { return _data; }
  inline seqHeatStack*& ptr()       { return _data; }
  inline seqHeatStack* operator->() { return _data; }

  inline sHeatStack& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqHeatStack*& _data;

private:
  seqHeatStack_out();
  seqHeatStack_out& operator=(const seqHeatStack_var&);
};

struct sMediaConsumed {
  typedef _CORBA_ConstrType_Variable_Var<sMediaConsumed> _var_type;

  
  ::CORBA::String_member ConsumerUnit;

  ::CORBA::Double N2Cons;

  ::CORBA::Double O2Cons;

  ::CORBA::Double WaterCons;

  ::CORBA::Double AirCons;

  ::CORBA::Double N2Flow;

  ::CORBA::Double O2Flow;

  ::CORBA::Double WaterFlow;

  ::CORBA::Double AirFlow;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sMediaConsumed::_var_type sMediaConsumed_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sMediaConsumed,sMediaConsumed_var > sMediaConsumed_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sMediaConsumed;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqMediaConsumed;

class seqMediaConsumed_var;

class seqMediaConsumed : public _CORBA_Unbounded_Sequence< sMediaConsumed >  {
public:
  typedef seqMediaConsumed_var _var_type;
  inline seqMediaConsumed() {}
  inline seqMediaConsumed(const seqMediaConsumed& _s)
    : _CORBA_Unbounded_Sequence< sMediaConsumed > (_s) {}

  inline seqMediaConsumed(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sMediaConsumed > (_max) {}
  inline seqMediaConsumed(_CORBA_ULong _max, _CORBA_ULong _len, sMediaConsumed* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sMediaConsumed > (_max, _len, _val, _rel) {}



  inline seqMediaConsumed& operator = (const seqMediaConsumed& _s) {
    _CORBA_Unbounded_Sequence< sMediaConsumed > ::operator=(_s);
    return *this;
  }
};

class seqMediaConsumed_out;

class seqMediaConsumed_var {
public:
  inline seqMediaConsumed_var() : _pd_seq(0) {}
  inline seqMediaConsumed_var(seqMediaConsumed* _s) : _pd_seq(_s) {}
  inline seqMediaConsumed_var(const seqMediaConsumed_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqMediaConsumed(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqMediaConsumed_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqMediaConsumed_var& operator = (seqMediaConsumed* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqMediaConsumed_var& operator = (const seqMediaConsumed_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqMediaConsumed;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sMediaConsumed& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqMediaConsumed* operator -> () { return _pd_seq; }
  inline const seqMediaConsumed* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqMediaConsumed& () const { return *_pd_seq; }
#else
  inline operator const seqMediaConsumed& () const { return *_pd_seq; }
  inline operator seqMediaConsumed& () { return *_pd_seq; }
#endif
    
  inline const seqMediaConsumed& in() const { return *_pd_seq; }
  inline seqMediaConsumed&       inout()    { return *_pd_seq; }
  inline seqMediaConsumed*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqMediaConsumed* _retn() { seqMediaConsumed* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqMediaConsumed_out;
  
private:
  seqMediaConsumed* _pd_seq;
};

class seqMediaConsumed_out {
public:
  inline seqMediaConsumed_out(seqMediaConsumed*& _s) : _data(_s) { _data = 0; }
  inline seqMediaConsumed_out(seqMediaConsumed_var& _s)
    : _data(_s._pd_seq) { _s = (seqMediaConsumed*) 0; }
  inline seqMediaConsumed_out(const seqMediaConsumed_out& _s) : _data(_s._data) {}
  inline seqMediaConsumed_out& operator = (const seqMediaConsumed_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqMediaConsumed_out& operator = (seqMediaConsumed* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqMediaConsumed*&()  { return _data; }
  inline seqMediaConsumed*& ptr()       { return _data; }
  inline seqMediaConsumed* operator->() { return _data; }

  inline sMediaConsumed& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqMediaConsumed*& _data;

private:
  seqMediaConsumed_out();
  seqMediaConsumed_out& operator=(const seqMediaConsumed_var&);
};

struct sEnergyConsumed {
  typedef _CORBA_ConstrType_Variable_Var<sEnergyConsumed> _var_type;

  
  ::CORBA::String_member ConsumerUnit;

  ::CORBA::Double Voltage;

  ::CORBA::Double ElecCurrent;

  ::CORBA::Double ActivePower;

  ::CORBA::Double ReactivePower;

  ::CORBA::Double ApparentPower;

  ::CORBA::Double ActiveEnergy;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sEnergyConsumed::_var_type sEnergyConsumed_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sEnergyConsumed,sEnergyConsumed_var > sEnergyConsumed_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sEnergyConsumed;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqEnergyConsumed;

class seqEnergyConsumed_var;

class seqEnergyConsumed : public _CORBA_Unbounded_Sequence< sEnergyConsumed >  {
public:
  typedef seqEnergyConsumed_var _var_type;
  inline seqEnergyConsumed() {}
  inline seqEnergyConsumed(const seqEnergyConsumed& _s)
    : _CORBA_Unbounded_Sequence< sEnergyConsumed > (_s) {}

  inline seqEnergyConsumed(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sEnergyConsumed > (_max) {}
  inline seqEnergyConsumed(_CORBA_ULong _max, _CORBA_ULong _len, sEnergyConsumed* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sEnergyConsumed > (_max, _len, _val, _rel) {}



  inline seqEnergyConsumed& operator = (const seqEnergyConsumed& _s) {
    _CORBA_Unbounded_Sequence< sEnergyConsumed > ::operator=(_s);
    return *this;
  }
};

class seqEnergyConsumed_out;

class seqEnergyConsumed_var {
public:
  inline seqEnergyConsumed_var() : _pd_seq(0) {}
  inline seqEnergyConsumed_var(seqEnergyConsumed* _s) : _pd_seq(_s) {}
  inline seqEnergyConsumed_var(const seqEnergyConsumed_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqEnergyConsumed(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqEnergyConsumed_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqEnergyConsumed_var& operator = (seqEnergyConsumed* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqEnergyConsumed_var& operator = (const seqEnergyConsumed_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqEnergyConsumed;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sEnergyConsumed& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqEnergyConsumed* operator -> () { return _pd_seq; }
  inline const seqEnergyConsumed* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqEnergyConsumed& () const { return *_pd_seq; }
#else
  inline operator const seqEnergyConsumed& () const { return *_pd_seq; }
  inline operator seqEnergyConsumed& () { return *_pd_seq; }
#endif
    
  inline const seqEnergyConsumed& in() const { return *_pd_seq; }
  inline seqEnergyConsumed&       inout()    { return *_pd_seq; }
  inline seqEnergyConsumed*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqEnergyConsumed* _retn() { seqEnergyConsumed* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqEnergyConsumed_out;
  
private:
  seqEnergyConsumed* _pd_seq;
};

class seqEnergyConsumed_out {
public:
  inline seqEnergyConsumed_out(seqEnergyConsumed*& _s) : _data(_s) { _data = 0; }
  inline seqEnergyConsumed_out(seqEnergyConsumed_var& _s)
    : _data(_s._pd_seq) { _s = (seqEnergyConsumed*) 0; }
  inline seqEnergyConsumed_out(const seqEnergyConsumed_out& _s) : _data(_s._data) {}
  inline seqEnergyConsumed_out& operator = (const seqEnergyConsumed_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqEnergyConsumed_out& operator = (seqEnergyConsumed* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqEnergyConsumed*&()  { return _data; }
  inline seqEnergyConsumed*& ptr()       { return _data; }
  inline seqEnergyConsumed* operator->() { return _data; }

  inline sEnergyConsumed& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqEnergyConsumed*& _data;

private:
  seqEnergyConsumed_out();
  seqEnergyConsumed_out& operator=(const seqEnergyConsumed_var&);
};

struct sSAF_Bin {
  typedef _CORBA_ConstrType_Variable_Var<sSAF_Bin> _var_type;

  
  ::CORBA::String_member FurnaceBinID;

  ::CORBA::String_member RecipeCode;

  ::CORBA::Double Amount;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sSAF_Bin::_var_type sSAF_Bin_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sSAF_Bin,sSAF_Bin_var > sSAF_Bin_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sSAF_Bin;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqSAF_Bin;

class seqSAF_Bin_var;

class seqSAF_Bin : public _CORBA_Unbounded_Sequence< sSAF_Bin >  {
public:
  typedef seqSAF_Bin_var _var_type;
  inline seqSAF_Bin() {}
  inline seqSAF_Bin(const seqSAF_Bin& _s)
    : _CORBA_Unbounded_Sequence< sSAF_Bin > (_s) {}

  inline seqSAF_Bin(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sSAF_Bin > (_max) {}
  inline seqSAF_Bin(_CORBA_ULong _max, _CORBA_ULong _len, sSAF_Bin* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sSAF_Bin > (_max, _len, _val, _rel) {}



  inline seqSAF_Bin& operator = (const seqSAF_Bin& _s) {
    _CORBA_Unbounded_Sequence< sSAF_Bin > ::operator=(_s);
    return *this;
  }
};

class seqSAF_Bin_out;

class seqSAF_Bin_var {
public:
  inline seqSAF_Bin_var() : _pd_seq(0) {}
  inline seqSAF_Bin_var(seqSAF_Bin* _s) : _pd_seq(_s) {}
  inline seqSAF_Bin_var(const seqSAF_Bin_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqSAF_Bin(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqSAF_Bin_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqSAF_Bin_var& operator = (seqSAF_Bin* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqSAF_Bin_var& operator = (const seqSAF_Bin_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqSAF_Bin;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sSAF_Bin& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqSAF_Bin* operator -> () { return _pd_seq; }
  inline const seqSAF_Bin* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqSAF_Bin& () const { return *_pd_seq; }
#else
  inline operator const seqSAF_Bin& () const { return *_pd_seq; }
  inline operator seqSAF_Bin& () { return *_pd_seq; }
#endif
    
  inline const seqSAF_Bin& in() const { return *_pd_seq; }
  inline seqSAF_Bin&       inout()    { return *_pd_seq; }
  inline seqSAF_Bin*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqSAF_Bin* _retn() { seqSAF_Bin* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqSAF_Bin_out;
  
private:
  seqSAF_Bin* _pd_seq;
};

class seqSAF_Bin_out {
public:
  inline seqSAF_Bin_out(seqSAF_Bin*& _s) : _data(_s) { _data = 0; }
  inline seqSAF_Bin_out(seqSAF_Bin_var& _s)
    : _data(_s._pd_seq) { _s = (seqSAF_Bin*) 0; }
  inline seqSAF_Bin_out(const seqSAF_Bin_out& _s) : _data(_s._data) {}
  inline seqSAF_Bin_out& operator = (const seqSAF_Bin_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqSAF_Bin_out& operator = (seqSAF_Bin* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqSAF_Bin*&()  { return _data; }
  inline seqSAF_Bin*& ptr()       { return _data; }
  inline seqSAF_Bin* operator->() { return _data; }

  inline sSAF_Bin& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqSAF_Bin*& _data;

private:
  seqSAF_Bin_out();
  seqSAF_Bin_out& operator=(const seqSAF_Bin_var&);
};

struct sHarmonics {
  typedef _CORBA_ConstrType_Fix_Var<sHarmonics> _var_type;

  
  ::CORBA::Double Harmonics;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sHarmonics::_var_type sHarmonics_var;

typedef sHarmonics& sHarmonics_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sHarmonics;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqHarmonics;

class seqHarmonics_var;

class seqHarmonics : public _CORBA_Unbounded_Sequence< sHarmonics >  {
public:
  typedef seqHarmonics_var _var_type;
  inline seqHarmonics() {}
  inline seqHarmonics(const seqHarmonics& _s)
    : _CORBA_Unbounded_Sequence< sHarmonics > (_s) {}

  inline seqHarmonics(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sHarmonics > (_max) {}
  inline seqHarmonics(_CORBA_ULong _max, _CORBA_ULong _len, sHarmonics* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sHarmonics > (_max, _len, _val, _rel) {}



  inline seqHarmonics& operator = (const seqHarmonics& _s) {
    _CORBA_Unbounded_Sequence< sHarmonics > ::operator=(_s);
    return *this;
  }
};

class seqHarmonics_out;

class seqHarmonics_var {
public:
  inline seqHarmonics_var() : _pd_seq(0) {}
  inline seqHarmonics_var(seqHarmonics* _s) : _pd_seq(_s) {}
  inline seqHarmonics_var(const seqHarmonics_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqHarmonics(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqHarmonics_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqHarmonics_var& operator = (seqHarmonics* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqHarmonics_var& operator = (const seqHarmonics_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqHarmonics;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sHarmonics& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqHarmonics* operator -> () { return _pd_seq; }
  inline const seqHarmonics* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqHarmonics& () const { return *_pd_seq; }
#else
  inline operator const seqHarmonics& () const { return *_pd_seq; }
  inline operator seqHarmonics& () { return *_pd_seq; }
#endif
    
  inline const seqHarmonics& in() const { return *_pd_seq; }
  inline seqHarmonics&       inout()    { return *_pd_seq; }
  inline seqHarmonics*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqHarmonics* _retn() { seqHarmonics* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqHarmonics_out;
  
private:
  seqHarmonics* _pd_seq;
};

class seqHarmonics_out {
public:
  inline seqHarmonics_out(seqHarmonics*& _s) : _data(_s) { _data = 0; }
  inline seqHarmonics_out(seqHarmonics_var& _s)
    : _data(_s._pd_seq) { _s = (seqHarmonics*) 0; }
  inline seqHarmonics_out(const seqHarmonics_out& _s) : _data(_s._data) {}
  inline seqHarmonics_out& operator = (const seqHarmonics_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqHarmonics_out& operator = (seqHarmonics* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqHarmonics*&()  { return _data; }
  inline seqHarmonics*& ptr()       { return _data; }
  inline seqHarmonics* operator->() { return _data; }

  inline sHarmonics& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqHarmonics*& _data;

private:
  seqHarmonics_out();
  seqHarmonics_out& operator=(const seqHarmonics_var&);
};

struct sWallTemp {
  typedef _CORBA_ConstrType_Variable_Var<sWallTemp> _var_type;

  
  ::CORBA::String_member Name;

  ::CORBA::Double Temp;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sWallTemp::_var_type sWallTemp_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sWallTemp,sWallTemp_var > sWallTemp_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sWallTemp;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqWallTemp;

class seqWallTemp_var;

class seqWallTemp : public _CORBA_Unbounded_Sequence< sWallTemp >  {
public:
  typedef seqWallTemp_var _var_type;
  inline seqWallTemp() {}
  inline seqWallTemp(const seqWallTemp& _s)
    : _CORBA_Unbounded_Sequence< sWallTemp > (_s) {}

  inline seqWallTemp(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sWallTemp > (_max) {}
  inline seqWallTemp(_CORBA_ULong _max, _CORBA_ULong _len, sWallTemp* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sWallTemp > (_max, _len, _val, _rel) {}



  inline seqWallTemp& operator = (const seqWallTemp& _s) {
    _CORBA_Unbounded_Sequence< sWallTemp > ::operator=(_s);
    return *this;
  }
};

class seqWallTemp_out;

class seqWallTemp_var {
public:
  inline seqWallTemp_var() : _pd_seq(0) {}
  inline seqWallTemp_var(seqWallTemp* _s) : _pd_seq(_s) {}
  inline seqWallTemp_var(const seqWallTemp_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqWallTemp(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqWallTemp_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqWallTemp_var& operator = (seqWallTemp* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqWallTemp_var& operator = (const seqWallTemp_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqWallTemp;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sWallTemp& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqWallTemp* operator -> () { return _pd_seq; }
  inline const seqWallTemp* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqWallTemp& () const { return *_pd_seq; }
#else
  inline operator const seqWallTemp& () const { return *_pd_seq; }
  inline operator seqWallTemp& () { return *_pd_seq; }
#endif
    
  inline const seqWallTemp& in() const { return *_pd_seq; }
  inline seqWallTemp&       inout()    { return *_pd_seq; }
  inline seqWallTemp*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqWallTemp* _retn() { seqWallTemp* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqWallTemp_out;
  
private:
  seqWallTemp* _pd_seq;
};

class seqWallTemp_out {
public:
  inline seqWallTemp_out(seqWallTemp*& _s) : _data(_s) { _data = 0; }
  inline seqWallTemp_out(seqWallTemp_var& _s)
    : _data(_s._pd_seq) { _s = (seqWallTemp*) 0; }
  inline seqWallTemp_out(const seqWallTemp_out& _s) : _data(_s._data) {}
  inline seqWallTemp_out& operator = (const seqWallTemp_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqWallTemp_out& operator = (seqWallTemp* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqWallTemp*&()  { return _data; }
  inline seqWallTemp*& ptr()       { return _data; }
  inline seqWallTemp* operator->() { return _data; }

  inline sWallTemp& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqWallTemp*& _data;

private:
  seqWallTemp_out();
  seqWallTemp_out& operator=(const seqWallTemp_var&);
};

struct sHMPouringData {
  typedef _CORBA_ConstrType_Variable_Var<sHMPouringData> _var_type;

  
  ::CORBA::Long SourceNo;

  ::CORBA::Double Weight;

  ::CORBA::Double Temperature;

  sDate TempTime;

  seqAnalysis Analysis;

  sDate SampleTime;



  void operator>>= (cdrStream &) const;
  void operator<<= (cdrStream &);
};

typedef sHMPouringData::_var_type sHMPouringData_var;

typedef _CORBA_ConstrType_Variable_OUT_arg< sHMPouringData,sHMPouringData_var > sHMPouringData_out;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_sHMPouringData;

_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_seqHMPouringData;

class seqHMPouringData_var;

class seqHMPouringData : public _CORBA_Unbounded_Sequence< sHMPouringData >  {
public:
  typedef seqHMPouringData_var _var_type;
  inline seqHMPouringData() {}
  inline seqHMPouringData(const seqHMPouringData& _s)
    : _CORBA_Unbounded_Sequence< sHMPouringData > (_s) {}

  inline seqHMPouringData(_CORBA_ULong _max)
    : _CORBA_Unbounded_Sequence< sHMPouringData > (_max) {}
  inline seqHMPouringData(_CORBA_ULong _max, _CORBA_ULong _len, sHMPouringData* _val, _CORBA_Boolean _rel=0)
    : _CORBA_Unbounded_Sequence< sHMPouringData > (_max, _len, _val, _rel) {}



  inline seqHMPouringData& operator = (const seqHMPouringData& _s) {
    _CORBA_Unbounded_Sequence< sHMPouringData > ::operator=(_s);
    return *this;
  }
};

class seqHMPouringData_out;

class seqHMPouringData_var {
public:
  inline seqHMPouringData_var() : _pd_seq(0) {}
  inline seqHMPouringData_var(seqHMPouringData* _s) : _pd_seq(_s) {}
  inline seqHMPouringData_var(const seqHMPouringData_var& _s) {
    if( _s._pd_seq )  _pd_seq = new seqHMPouringData(*_s._pd_seq);
    else              _pd_seq = 0;
  }
  inline ~seqHMPouringData_var() { if( _pd_seq )  delete _pd_seq; }
    
  inline seqHMPouringData_var& operator = (seqHMPouringData* _s) {
    if( _pd_seq )  delete _pd_seq;
    _pd_seq = _s;
    return *this;
  }
  inline seqHMPouringData_var& operator = (const seqHMPouringData_var& _s) {
    if( _s._pd_seq ) {
      if( !_pd_seq )  _pd_seq = new seqHMPouringData;
      *_pd_seq = *_s._pd_seq;
    } else if( _pd_seq ) {
      delete _pd_seq;
      _pd_seq = 0;
    }
    return *this;
  }
  inline sHMPouringData& operator [] (_CORBA_ULong _s) {
    return (*_pd_seq)[_s];
  }



  inline seqHMPouringData* operator -> () { return _pd_seq; }
  inline const seqHMPouringData* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
  inline operator seqHMPouringData& () const { return *_pd_seq; }
#else
  inline operator const seqHMPouringData& () const { return *_pd_seq; }
  inline operator seqHMPouringData& () { return *_pd_seq; }
#endif
    
  inline const seqHMPouringData& in() const { return *_pd_seq; }
  inline seqHMPouringData&       inout()    { return *_pd_seq; }
  inline seqHMPouringData*&      out() {
    if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
    return _pd_seq;
  }
  inline seqHMPouringData* _retn() { seqHMPouringData* tmp = _pd_seq; _pd_seq = 0; return tmp; }
    
  friend class seqHMPouringData_out;
  
private:
  seqHMPouringData* _pd_seq;
};

class seqHMPouringData_out {
public:
  inline seqHMPouringData_out(seqHMPouringData*& _s) : _data(_s) { _data = 0; }
  inline seqHMPouringData_out(seqHMPouringData_var& _s)
    : _data(_s._pd_seq) { _s = (seqHMPouringData*) 0; }
  inline seqHMPouringData_out(const seqHMPouringData_out& _s) : _data(_s._data) {}
  inline seqHMPouringData_out& operator = (const seqHMPouringData_out& _s) {
    _data = _s._data;
    return *this;
  }
  inline seqHMPouringData_out& operator = (seqHMPouringData* _s) {
    _data = _s;
    return *this;
  }
  inline operator seqHMPouringData*&()  { return _data; }
  inline seqHMPouringData*& ptr()       { return _data; }
  inline seqHMPouringData* operator->() { return _data; }

  inline sHMPouringData& operator [] (_CORBA_ULong _i) {
    return (*_data)[_i];
  }



  seqHMPouringData*& _data;

private:
  seqHMPouringData_out();
  seqHMPouringData_out& operator=(const seqHMPouringData_var&);
};

#ifndef __iSMC__DataProvider__
#define __iSMC__DataProvider__

class iSMC_DataProvider;
class _objref_iSMC_DataProvider;
class _impl_iSMC_DataProvider;

typedef _objref_iSMC_DataProvider* iSMC_DataProvider_ptr;
typedef iSMC_DataProvider_ptr iSMC_DataProviderRef;

class iSMC_DataProvider_Helper {
public:
  typedef iSMC_DataProvider_ptr _ptr_type;

  static _ptr_type _nil();
  static _CORBA_Boolean is_nil(_ptr_type);
  static void release(_ptr_type);
  static void duplicate(_ptr_type);
  static void marshalObjRef(_ptr_type, cdrStream&);
  static _ptr_type unmarshalObjRef(cdrStream&);
};

typedef _CORBA_ObjRef_Var<_objref_iSMC_DataProvider, iSMC_DataProvider_Helper> iSMC_DataProvider_var;
typedef _CORBA_ObjRef_OUT_arg<_objref_iSMC_DataProvider,iSMC_DataProvider_Helper > iSMC_DataProvider_out;

#endif

// interface iSMC_DataProvider
class iSMC_DataProvider {
public:
  // Declarations for this interface type.
  typedef iSMC_DataProvider_ptr _ptr_type;
  typedef iSMC_DataProvider_var _var_type;

  static _ptr_type _duplicate(_ptr_type);
  static _ptr_type _narrow(::CORBA::Object_ptr);
  static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
  
  static _ptr_type _nil();

  static inline void _marshalObjRef(_ptr_type, cdrStream&);

  static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
    omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
    if (o)
      return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
    else
      return _nil();
  }

  static _core_attr const char* _PD_repoId;

  // Other IDL defined within this scope.
  
};

class _objref_iSMC_DataProvider :
  public virtual _objref_iData_Provider
{
public:
  seqAnalysis* getAnalysis(const char* Key, const char* Name);
  seqAnalysisData* getAnalysisData(const char* Key, const char* Name);
  seqAODBlowPredRes* getAODBlowPredRes(const char* Key, const char* Name);
  seqAODGlobalSetpoints* getAODGlobalSetpoints(const char* Key, const char* Name);
  seqBatch* getBatch(const char* Key, const char* Name);
  seqBlowStatus* getBlowStatus(const char* Key, const char* Name);
  seqBOFBlowPredRes* getBOFBlowPredRes(const char* Key, const char* Name);
  seqBOFGlobalSetpoints* getBOFGlobalSetpoints(const char* Key, const char* Name);
  seqComputerModes* getComputerModes(const char* Key, const char* Name);
  seqConArcBlowData* getConArcBlowData(const char* Key, const char* Name);
  seqConArcElecData* getConArcElecData(const char* Key, const char* Name);
  seqConArcModelResult* getConArcModelResult(const char* Key, const char* Name);
  seqConArcMeasData* getConArcMeasData(const char* Key, const char* Name);
  seqConArcMediaData* getConArcMediaData(const char* Key, const char* Name);
  seqConArcSetptData* getConArcSetptData(const char* Key, const char* Name);
  seqCoolWaterData* getCoolWaterData(const char* Key, const char* Name);
  sDate getDate(const char* Key, const char* Name);
  seqEAFBurnerPredRes* getEAFBurnerPredRes(const char* Key, const char* Name);
  seqEAFGasLancePredRes* getEAFGasLancePredRes(const char* Key, const char* Name);
  seqEAFProcessPredRes* getEAFProcessPredRes(const char* Key, const char* Name);
  seqEAFMatFeed* getEAFMatFeed(const char* Key, const char* Name);
  seqEAFMatFeedPredRes* getEAFMatFeedPredRes(const char* Key, const char* Name);
  seqElecPhaseData* getElecPhaseData(const char* Key, const char* Name);
  seqGasAvail* getGasAvail(const char* Key, const char* Name);
  seqGasData* getGasData(const char* Key, const char* Name);
  seqGasLanceData* getGasLanceData(const char* Key, const char* Name);
  seqGasLanceGasAvail* getGasLanceGasAvail(const char* Key, const char* Name);
  seqHeatData* getHeatData(const char* Key, const char* Name);
  seqHeatSchedule* getHeatSchedule(const char* Key, const char* Name);
  seqHeatSchedulePlant* getHeatSchedulePlant(const char* Key, const char* Name);
  seqHMDModelResult* getHMDModelResult(const char* Key, const char* Name);
  seqInjectData* getInjectData(const char* Key, const char* Name);
  seqInjectLanceData* getInjectLanceData(const char* Key, const char* Name);
  seqEAFInjectLance* getEAFInjectLance(const char* Key, const char* Name);
  seqLFElecPredRes* getLFElecPredRes(const char* Key, const char* Name);
  seqLFStirrPredRes* getLFStirrPredRes(const char* Key, const char* Name);
  seqLiqMatReport* getLiqMatReport(const char* Key, const char* Name);
  seqMaterials* getMaterials(const char* Key, const char* Name);
  seqOrderData* getOrderData(const char* Key, const char* Name);
  seqPhaseStatus* getPhaseStatus(const char* Key, const char* Name);
  seqPredRes* getPredRes(const char* Key, const char* Name);
  seqProductIdentification* getProductIdentification(const char* Key, const char* Name);
  seqRecipeList* getRecipeList(const char* Key, const char* Name);
  seqRHModelResult* getRHModelResult(const char* Key, const char* Name);
  seqVDModelResult* getVDModelResult(const char* Key, const char* Name);
  seqSampleData* getSampleData(const char* Key, const char* Name);
  seqStatus* getStatus(const char* Key, const char* Name);
  seqStirringData* getStirringData(const char* Key, const char* Name);
  seqStringList* getStringList(const char* Key, const char* Name);
  seqWasteGas* getWasteGas(const char* Key, const char* Name);
  seqWireFeeder* getWireFeeder(const char* Key, const char* Name);
  void setAnalysis(const char* Key, const char* Name, const ::seqAnalysis& NewData);
  void setAnalysisData(const char* Key, const char* Name, const ::seqAnalysisData& NewData);
  void setAODBlowPredRes(const char* Key, const char* Name, const ::seqAODBlowPredRes& NewData);
  void setAODGlobalSetpoints(const char* Key, const char* Name, const ::seqAODGlobalSetpoints& NewData);
  void setBatch(const char* Key, const char* Name, const ::seqBatch& NewData);
  void setBlowStatus(const char* Key, const char* Name, const ::seqBlowStatus& NewData);
  void setBOFBlowPredRes(const char* Key, const char* Name, const ::seqBOFBlowPredRes& NewData);
  void setBOFGlobalSetpoints(const char* Key, const char* Name, const ::seqBOFGlobalSetpoints& NewData);
  void setComputerModes(const char* Key, const char* Name, const ::seqComputerModes& NewData);
  void setConArcBlowData(const char* Key, const char* Name, const ::seqConArcBlowData& NewData);
  void setConArcElecData(const char* Key, const char* Name, const ::seqConArcElecData& NewData);
  void setConArcModelResult(const char* Key, const char* Name, const ::seqConArcModelResult& NewData);
  void setConArcMeasData(const char* Key, const char* Name, const ::seqConArcMeasData& NewData);
  void setConArcMediaData(const char* Key, const char* Name, const ::seqConArcMediaData& NewData);
  void setConArcSetptData(const char* Key, const char* Name, const ::seqConArcSetptData& NewData);
  void setCoolWaterData(const char* Key, const char* Name, const ::seqCoolWaterData& NewData);
  void setDate(const char* Key, const char* Name, const ::sDate& NewData);
  void setEAFBurnerPredRes(const char* Key, const char* Name, const ::seqEAFBurnerPredRes& NewData);
  void setEAFGasLancePredRes(const char* Key, const char* Name, const ::seqEAFGasLancePredRes& NewData);
  void setEAFProcessPredRes(const char* Key, const char* Name, const ::seqEAFProcessPredRes& NewData);
  void setEAFInjectLance(const char* Key, const char* Name, const ::seqEAFInjectLance& NewData);
  void setEAFMatFeed(const char* Key, const char* Name, const ::seqEAFMatFeed& NewData);
  void setEAFMatFeedPredRes(const char* Key, const char* Name, const ::seqEAFMatFeedPredRes& NewData);
  void setElecPhaseData(const char* Key, const char* Name, const ::seqElecPhaseData& NewData);
  void setGasAvail(const char* Key, const char* Name, const ::seqGasAvail& NewData);
  void setGasData(const char* Key, const char* Name, const ::seqGasData& NewData);
  void setGasLanceData(const char* Key, const char* Name, const ::seqGasLanceData& NewData);
  void setGasLanceGasAvail(const char* Key, const char* Name, const ::seqGasLanceGasAvail& NewData);
  void setHeatData(const char* Key, const char* Name, const ::seqHeatData& NewData);
  void setHeatSchedule(const char* Key, const char* Name, const ::seqHeatSchedule& NewData);
  void setHeatSchedulePlant(const char* Key, const char* Name, const ::seqHeatSchedulePlant& NewData);
  void setHMDModelResult(const char* Key, const char* Name, const ::seqHMDModelResult& NewData);
  void setInjectData(const char* Key, const char* Name, const ::seqInjectData& NewData);
  void setInjectLanceData(const char* Key, const char* Name, const ::seqInjectLanceData& NewData);
  void setLFElecPredRes(const char* Key, const char* Name, const ::seqLFElecPredRes& NewData);
  void setLFStirrPredRes(const char* Key, const char* Name, const ::seqLFStirrPredRes& NewData);
  void setLiqMatReport(const char* Key, const char* Name, const ::seqLiqMatReport& NewData);
  void setMaterials(const char* Key, const char* Name, const ::seqMaterials& NewData);
  void setOrderData(const char* Key, const char* Name, const ::seqOrderData& NewData);
  void setPhaseStatus(const char* Key, const char* Name, const ::seqPhaseStatus& NewData);
  void setPredRes(const char* Key, const char* Name, const ::seqPredRes& NewData);
  void setProductIdentification(const char* Key, const char* Name, const ::seqProductIdentification& NewData);
  void setRecipeList(const char* Key, const char* Name, const ::seqRecipeList& NewData);
  void setRHModelResult(const char* Key, const char* Name, const ::seqRHModelResult& NewData);
  void setVDModelResult(const char* Key, const char* Name, const ::seqVDModelResult& NewData);
  void setSampleData(const char* Key, const char* Name, const ::seqSampleData& NewData);
  void setStatus(const char* Key, const char* Name, const ::seqStatus& NewData);
  void setStirringData(const char* Key, const char* Name, const ::seqStirringData& NewData);
  void setStringList(const char* Key, const char* Name, const ::seqStringList& NewData);
  void setWasteGas(const char* Key, const char* Name, const ::seqWasteGas& NewData);
  void setWireFeeder(const char* Key, const char* Name, const ::seqWireFeeder& NewData);
  seqLTSStirrPredRes* getLTSStirrPredRes(const char* Key, const char* Name);
  void setLTSStirrPredRes(const char* Key, const char* Name, const ::seqLTSStirrPredRes& NewData);
  void setConArcGlobalSetpoints(const char* Key, const char* Name, const ::seqConArcGlobalSetpoints& NewData);
  seqConArcGlobalSetpoints* getConArcGlobalSetpoints(const char* Key, const char* Name);
  void setSample(const char* Key, const char* Name, const ::seqSample& NewData);
  seqSample* getSample(const char* Key, const char* Name);
  void setPhaseDataReport(const char* Key, const char* Name, const ::seqPhaseDataReport& NewData);
  seqPhaseDataReport* getPhaseDataReport(const char* Key, const char* Name);
  void setTorpedoData(const char* Key, const char* Name, const ::seqTorpedoData& NewData);
  seqTorpedoData* getTorpedoData(const char* Key, const char* Name);
  void setMediaConsumed(const char* Key, const char* Name, const ::seqMediaConsumed& NewData);
  seqMediaConsumed* getMediaConsumed(const char* Key, const char* Name);
  void setEnergyConsumed(const char* Key, const char* Name, const ::seqEnergyConsumed& NewData);
  seqEnergyConsumed* getEnergyConsumed(const char* Key, const char* Name);
  void setSAFBinData(const char* Key, const char* Name, const ::seqSAF_Bin& NewData);
  seqSAF_Bin* getSAFBinData(const char* Key, const char* Name);
  void setHarmonics(const char* Key, const char* Name, const ::seqHarmonics& NewData);
  seqHarmonics* getHarmonics(const char* Key, const char* Name);
  void setWallTemp(const char* Key, const char* Name, const ::seqWallTemp& NewData);
  seqWallTemp* getWallTemp(const char* Key, const char* Name);
  void setPPRestriction(const char* Key, const char* Name, const ::seqPPRestriction& NewData);
  seqPPRestriction* getPPRestriction(const char* Key, const char* Name);
  void setHeatStack(const char* Key, const char* Name, const ::seqHeatStack& NewData);
  seqHeatStack* getHeatStack(const char* Key, const char* Name);
  void setHMPouringData(const char* Key, const char* Name, const ::seqHMPouringData& MewData);
  seqHMPouringData* getHMPouringData(const char* Key, const char* Name);

  inline _objref_iSMC_DataProvider()  { _PR_setobj(0); }  // nil
  _objref_iSMC_DataProvider(omniIOR*, omniIdentity*);

protected:
  virtual ~_objref_iSMC_DataProvider();

  
private:
  virtual void* _ptrToObjRef(const char*);

  _objref_iSMC_DataProvider(const _objref_iSMC_DataProvider&);
  _objref_iSMC_DataProvider& operator = (const _objref_iSMC_DataProvider&);
  // not implemented

  friend class iSMC_DataProvider;
};

class _pof_iSMC_DataProvider : public _OMNI_NS(proxyObjectFactory) {
public:
  inline _pof_iSMC_DataProvider() : _OMNI_NS(proxyObjectFactory)(iSMC_DataProvider::_PD_repoId) {}
  virtual ~_pof_iSMC_DataProvider();

  virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
  virtual _CORBA_Boolean is_a(const char*) const;
};

class _impl_iSMC_DataProvider :
  public virtual _impl_iData_Provider
{
public:
  virtual ~_impl_iSMC_DataProvider();

  virtual seqAnalysis* getAnalysis(const char* Key, const char* Name) = 0;
  virtual seqAnalysisData* getAnalysisData(const char* Key, const char* Name) = 0;
  virtual seqAODBlowPredRes* getAODBlowPredRes(const char* Key, const char* Name) = 0;
  virtual seqAODGlobalSetpoints* getAODGlobalSetpoints(const char* Key, const char* Name) = 0;
  virtual seqBatch* getBatch(const char* Key, const char* Name) = 0;
  virtual seqBlowStatus* getBlowStatus(const char* Key, const char* Name) = 0;
  virtual seqBOFBlowPredRes* getBOFBlowPredRes(const char* Key, const char* Name) = 0;
  virtual seqBOFGlobalSetpoints* getBOFGlobalSetpoints(const char* Key, const char* Name) = 0;
  virtual seqComputerModes* getComputerModes(const char* Key, const char* Name) = 0;
  virtual seqConArcBlowData* getConArcBlowData(const char* Key, const char* Name) = 0;
  virtual seqConArcElecData* getConArcElecData(const char* Key, const char* Name) = 0;
  virtual seqConArcModelResult* getConArcModelResult(const char* Key, const char* Name) = 0;
  virtual seqConArcMeasData* getConArcMeasData(const char* Key, const char* Name) = 0;
  virtual seqConArcMediaData* getConArcMediaData(const char* Key, const char* Name) = 0;
  virtual seqConArcSetptData* getConArcSetptData(const char* Key, const char* Name) = 0;
  virtual seqCoolWaterData* getCoolWaterData(const char* Key, const char* Name) = 0;
  virtual sDate getDate(const char* Key, const char* Name) = 0;
  virtual seqEAFBurnerPredRes* getEAFBurnerPredRes(const char* Key, const char* Name) = 0;
  virtual seqEAFGasLancePredRes* getEAFGasLancePredRes(const char* Key, const char* Name) = 0;
  virtual seqEAFProcessPredRes* getEAFProcessPredRes(const char* Key, const char* Name) = 0;
  virtual seqEAFMatFeed* getEAFMatFeed(const char* Key, const char* Name) = 0;
  virtual seqEAFMatFeedPredRes* getEAFMatFeedPredRes(const char* Key, const char* Name) = 0;
  virtual seqElecPhaseData* getElecPhaseData(const char* Key, const char* Name) = 0;
  virtual seqGasAvail* getGasAvail(const char* Key, const char* Name) = 0;
  virtual seqGasData* getGasData(const char* Key, const char* Name) = 0;
  virtual seqGasLanceData* getGasLanceData(const char* Key, const char* Name) = 0;
  virtual seqGasLanceGasAvail* getGasLanceGasAvail(const char* Key, const char* Name) = 0;
  virtual seqHeatData* getHeatData(const char* Key, const char* Name) = 0;
  virtual seqHeatSchedule* getHeatSchedule(const char* Key, const char* Name) = 0;
  virtual seqHeatSchedulePlant* getHeatSchedulePlant(const char* Key, const char* Name) = 0;
  virtual seqHMDModelResult* getHMDModelResult(const char* Key, const char* Name) = 0;
  virtual seqInjectData* getInjectData(const char* Key, const char* Name) = 0;
  virtual seqInjectLanceData* getInjectLanceData(const char* Key, const char* Name) = 0;
  virtual seqEAFInjectLance* getEAFInjectLance(const char* Key, const char* Name) = 0;
  virtual seqLFElecPredRes* getLFElecPredRes(const char* Key, const char* Name) = 0;
  virtual seqLFStirrPredRes* getLFStirrPredRes(const char* Key, const char* Name) = 0;
  virtual seqLiqMatReport* getLiqMatReport(const char* Key, const char* Name) = 0;
  virtual seqMaterials* getMaterials(const char* Key, const char* Name) = 0;
  virtual seqOrderData* getOrderData(const char* Key, const char* Name) = 0;
  virtual seqPhaseStatus* getPhaseStatus(const char* Key, const char* Name) = 0;
  virtual seqPredRes* getPredRes(const char* Key, const char* Name) = 0;
  virtual seqProductIdentification* getProductIdentification(const char* Key, const char* Name) = 0;
  virtual seqRecipeList* getRecipeList(const char* Key, const char* Name) = 0;
  virtual seqRHModelResult* getRHModelResult(const char* Key, const char* Name) = 0;
  virtual seqVDModelResult* getVDModelResult(const char* Key, const char* Name) = 0;
  virtual seqSampleData* getSampleData(const char* Key, const char* Name) = 0;
  virtual seqStatus* getStatus(const char* Key, const char* Name) = 0;
  virtual seqStirringData* getStirringData(const char* Key, const char* Name) = 0;
  virtual seqStringList* getStringList(const char* Key, const char* Name) = 0;
  virtual seqWasteGas* getWasteGas(const char* Key, const char* Name) = 0;
  virtual seqWireFeeder* getWireFeeder(const char* Key, const char* Name) = 0;
  virtual void setAnalysis(const char* Key, const char* Name, const ::seqAnalysis& NewData) = 0;
  virtual void setAnalysisData(const char* Key, const char* Name, const ::seqAnalysisData& NewData) = 0;
  virtual void setAODBlowPredRes(const char* Key, const char* Name, const ::seqAODBlowPredRes& NewData) = 0;
  virtual void setAODGlobalSetpoints(const char* Key, const char* Name, const ::seqAODGlobalSetpoints& NewData) = 0;
  virtual void setBatch(const char* Key, const char* Name, const ::seqBatch& NewData) = 0;
  virtual void setBlowStatus(const char* Key, const char* Name, const ::seqBlowStatus& NewData) = 0;
  virtual void setBOFBlowPredRes(const char* Key, const char* Name, const ::seqBOFBlowPredRes& NewData) = 0;
  virtual void setBOFGlobalSetpoints(const char* Key, const char* Name, const ::seqBOFGlobalSetpoints& NewData) = 0;
  virtual void setComputerModes(const char* Key, const char* Name, const ::seqComputerModes& NewData) = 0;
  virtual void setConArcBlowData(const char* Key, const char* Name, const ::seqConArcBlowData& NewData) = 0;
  virtual void setConArcElecData(const char* Key, const char* Name, const ::seqConArcElecData& NewData) = 0;
  virtual void setConArcModelResult(const char* Key, const char* Name, const ::seqConArcModelResult& NewData) = 0;
  virtual void setConArcMeasData(const char* Key, const char* Name, const ::seqConArcMeasData& NewData) = 0;
  virtual void setConArcMediaData(const char* Key, const char* Name, const ::seqConArcMediaData& NewData) = 0;
  virtual void setConArcSetptData(const char* Key, const char* Name, const ::seqConArcSetptData& NewData) = 0;
  virtual void setCoolWaterData(const char* Key, const char* Name, const ::seqCoolWaterData& NewData) = 0;
  virtual void setDate(const char* Key, const char* Name, const ::sDate& NewData) = 0;
  virtual void setEAFBurnerPredRes(const char* Key, const char* Name, const ::seqEAFBurnerPredRes& NewData) = 0;
  virtual void setEAFGasLancePredRes(const char* Key, const char* Name, const ::seqEAFGasLancePredRes& NewData) = 0;
  virtual void setEAFProcessPredRes(const char* Key, const char* Name, const ::seqEAFProcessPredRes& NewData) = 0;
  virtual void setEAFInjectLance(const char* Key, const char* Name, const ::seqEAFInjectLance& NewData) = 0;
  virtual void setEAFMatFeed(const char* Key, const char* Name, const ::seqEAFMatFeed& NewData) = 0;
  virtual void setEAFMatFeedPredRes(const char* Key, const char* Name, const ::seqEAFMatFeedPredRes& NewData) = 0;
  virtual void setElecPhaseData(const char* Key, const char* Name, const ::seqElecPhaseData& NewData) = 0;
  virtual void setGasAvail(const char* Key, const char* Name, const ::seqGasAvail& NewData) = 0;
  virtual void setGasData(const char* Key, const char* Name, const ::seqGasData& NewData) = 0;
  virtual void setGasLanceData(const char* Key, const char* Name, const ::seqGasLanceData& NewData) = 0;
  virtual void setGasLanceGasAvail(const char* Key, const char* Name, const ::seqGasLanceGasAvail& NewData) = 0;
  virtual void setHeatData(const char* Key, const char* Name, const ::seqHeatData& NewData) = 0;
  virtual void setHeatSchedule(const char* Key, const char* Name, const ::seqHeatSchedule& NewData) = 0;
  virtual void setHeatSchedulePlant(const char* Key, const char* Name, const ::seqHeatSchedulePlant& NewData) = 0;
  virtual void setHMDModelResult(const char* Key, const char* Name, const ::seqHMDModelResult& NewData) = 0;
  virtual void setInjectData(const char* Key, const char* Name, const ::seqInjectData& NewData) = 0;
  virtual void setInjectLanceData(const char* Key, const char* Name, const ::seqInjectLanceData& NewData) = 0;
  virtual void setLFElecPredRes(const char* Key, const char* Name, const ::seqLFElecPredRes& NewData) = 0;
  virtual void setLFStirrPredRes(const char* Key, const char* Name, const ::seqLFStirrPredRes& NewData) = 0;
  virtual void setLiqMatReport(const char* Key, const char* Name, const ::seqLiqMatReport& NewData) = 0;
  virtual void setMaterials(const char* Key, const char* Name, const ::seqMaterials& NewData) = 0;
  virtual void setOrderData(const char* Key, const char* Name, const ::seqOrderData& NewData) = 0;
  virtual void setPhaseStatus(const char* Key, const char* Name, const ::seqPhaseStatus& NewData) = 0;
  virtual void setPredRes(const char* Key, const char* Name, const ::seqPredRes& NewData) = 0;
  virtual void setProductIdentification(const char* Key, const char* Name, const ::seqProductIdentification& NewData) = 0;
  virtual void setRecipeList(const char* Key, const char* Name, const ::seqRecipeList& NewData) = 0;
  virtual void setRHModelResult(const char* Key, const char* Name, const ::seqRHModelResult& NewData) = 0;
  virtual void setVDModelResult(const char* Key, const char* Name, const ::seqVDModelResult& NewData) = 0;
  virtual void setSampleData(const char* Key, const char* Name, const ::seqSampleData& NewData) = 0;
  virtual void setStatus(const char* Key, const char* Name, const ::seqStatus& NewData) = 0;
  virtual void setStirringData(const char* Key, const char* Name, const ::seqStirringData& NewData) = 0;
  virtual void setStringList(const char* Key, const char* Name, const ::seqStringList& NewData) = 0;
  virtual void setWasteGas(const char* Key, const char* Name, const ::seqWasteGas& NewData) = 0;
  virtual void setWireFeeder(const char* Key, const char* Name, const ::seqWireFeeder& NewData) = 0;
  virtual seqLTSStirrPredRes* getLTSStirrPredRes(const char* Key, const char* Name) = 0;
  virtual void setLTSStirrPredRes(const char* Key, const char* Name, const ::seqLTSStirrPredRes& NewData) = 0;
  virtual void setConArcGlobalSetpoints(const char* Key, const char* Name, const ::seqConArcGlobalSetpoints& NewData) = 0;
  virtual seqConArcGlobalSetpoints* getConArcGlobalSetpoints(const char* Key, const char* Name) = 0;
  virtual void setSample(const char* Key, const char* Name, const ::seqSample& NewData) = 0;
  virtual seqSample* getSample(const char* Key, const char* Name) = 0;
  virtual void setPhaseDataReport(const char* Key, const char* Name, const ::seqPhaseDataReport& NewData) = 0;
  virtual seqPhaseDataReport* getPhaseDataReport(const char* Key, const char* Name) = 0;
  virtual void setTorpedoData(const char* Key, const char* Name, const ::seqTorpedoData& NewData) = 0;
  virtual seqTorpedoData* getTorpedoData(const char* Key, const char* Name) = 0;
  virtual void setMediaConsumed(const char* Key, const char* Name, const ::seqMediaConsumed& NewData) = 0;
  virtual seqMediaConsumed* getMediaConsumed(const char* Key, const char* Name) = 0;
  virtual void setEnergyConsumed(const char* Key, const char* Name, const ::seqEnergyConsumed& NewData) = 0;
  virtual seqEnergyConsumed* getEnergyConsumed(const char* Key, const char* Name) = 0;
  virtual void setSAFBinData(const char* Key, const char* Name, const ::seqSAF_Bin& NewData) = 0;
  virtual seqSAF_Bin* getSAFBinData(const char* Key, const char* Name) = 0;
  virtual void setHarmonics(const char* Key, const char* Name, const ::seqHarmonics& NewData) = 0;
  virtual seqHarmonics* getHarmonics(const char* Key, const char* Name) = 0;
  virtual void setWallTemp(const char* Key, const char* Name, const ::seqWallTemp& NewData) = 0;
  virtual seqWallTemp* getWallTemp(const char* Key, const char* Name) = 0;
  virtual void setPPRestriction(const char* Key, const char* Name, const ::seqPPRestriction& NewData) = 0;
  virtual seqPPRestriction* getPPRestriction(const char* Key, const char* Name) = 0;
  virtual void setHeatStack(const char* Key, const char* Name, const ::seqHeatStack& NewData) = 0;
  virtual seqHeatStack* getHeatStack(const char* Key, const char* Name) = 0;
  virtual void setHMPouringData(const char* Key, const char* Name, const ::seqHMPouringData& MewData) = 0;
  virtual seqHMPouringData* getHMPouringData(const char* Key, const char* Name) = 0;
  
public:  // Really protected, workaround for xlC
  virtual _CORBA_Boolean _dispatch(omniCallHandle&);

private:
  virtual void* _ptrToInterface(const char*);
  virtual const char* _mostDerivedRepoId();
  
};


_CORBA_GLOBAL_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_iSMC_DataProvider;



class POA_iSMC_DataProvider :
  public virtual _impl_iSMC_DataProvider,
  public virtual POA_iData_Provider
{
public:
  virtual ~POA_iSMC_DataProvider();

  inline ::iSMC_DataProvider_ptr _this() {
    return (::iSMC_DataProvider_ptr) _do_this(::iSMC_DataProvider::_PD_repoId);
  }
};







#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const sTlgRecordElem& _s);
extern void operator<<=(::CORBA::Any& _a, sTlgRecordElem* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sTlgRecordElem*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sTlgRecordElem*& _sp);

void operator<<=(::CORBA::Any& _a, const seqTlgRecordElem& _s);
void operator<<=(::CORBA::Any& _a, seqTlgRecordElem* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqTlgRecordElem*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqTlgRecordElem*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sTlgRecord& _s);
extern void operator<<=(::CORBA::Any& _a, sTlgRecord* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sTlgRecord*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sTlgRecord*& _sp);

void operator<<=(::CORBA::Any& _a, const seqTlgRecord& _s);
void operator<<=(::CORBA::Any& _a, seqTlgRecord* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqTlgRecord*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqTlgRecord*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sAnalysisString& _s);
extern void operator<<=(::CORBA::Any& _a, sAnalysisString* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sAnalysisString*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sAnalysisString*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sAnalysis& _s);
extern void operator<<=(::CORBA::Any& _a, sAnalysis* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sAnalysis*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sAnalysis*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sBatch& _s);
extern void operator<<=(::CORBA::Any& _a, sBatch* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sBatch*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sBatch*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sEAFBurnerPredRes& _s);
extern void operator<<=(::CORBA::Any& _a, sEAFBurnerPredRes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sEAFBurnerPredRes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sEAFBurnerPredRes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sEAFProcessPredRes& _s);
extern void operator<<=(::CORBA::Any& _a, sEAFProcessPredRes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sEAFProcessPredRes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sEAFProcessPredRes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sLFElecPredRes& _s);
extern void operator<<=(::CORBA::Any& _a, sLFElecPredRes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sLFElecPredRes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sLFElecPredRes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sLFStirrPredRes& _s);
extern void operator<<=(::CORBA::Any& _a, sLFStirrPredRes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sLFStirrPredRes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sLFStirrPredRes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sMetTimeStamp& _s);
extern void operator<<=(::CORBA::Any& _a, sMetTimeStamp* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sMetTimeStamp*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sMetTimeStamp*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sRecipeProperties& _s);
extern void operator<<=(::CORBA::Any& _a, sRecipeProperties* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sRecipeProperties*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sRecipeProperties*& _sp);

void operator<<=(::CORBA::Any& _a, const seqAnalysis& _s);
void operator<<=(::CORBA::Any& _a, seqAnalysis* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqAnalysis*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqAnalysis*& _sp);

void operator<<=(::CORBA::Any& _a, const seqBatch& _s);
void operator<<=(::CORBA::Any& _a, seqBatch* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqBatch*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqBatch*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sEAFMatFeed& _s);
extern void operator<<=(::CORBA::Any& _a, sEAFMatFeed* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sEAFMatFeed*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sEAFMatFeed*& _sp);

void operator<<=(::CORBA::Any& _a, const seqEAFBurnerPredRes& _s);
void operator<<=(::CORBA::Any& _a, seqEAFBurnerPredRes* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqEAFBurnerPredRes*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqEAFBurnerPredRes*& _sp);

void operator<<=(::CORBA::Any& _a, const seqEAFProcessPredRes& _s);
void operator<<=(::CORBA::Any& _a, seqEAFProcessPredRes* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqEAFProcessPredRes*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqEAFProcessPredRes*& _sp);

void operator<<=(::CORBA::Any& _a, const seqEAFMatFeed& _s);
void operator<<=(::CORBA::Any& _a, seqEAFMatFeed* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqEAFMatFeed*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqEAFMatFeed*& _sp);

void operator<<=(::CORBA::Any& _a, const seqLFElecPredRes& _s);
void operator<<=(::CORBA::Any& _a, seqLFElecPredRes* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqLFElecPredRes*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqLFElecPredRes*& _sp);

void operator<<=(::CORBA::Any& _a, const seqLFStirrPredRes& _s);
void operator<<=(::CORBA::Any& _a, seqLFStirrPredRes* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqLFStirrPredRes*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqLFStirrPredRes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sAODGlobalSetpoints& _s);
extern void operator<<=(::CORBA::Any& _a, sAODGlobalSetpoints* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sAODGlobalSetpoints*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sAODGlobalSetpoints*& _sp);

void operator<<=(::CORBA::Any& _a, const seqAODGlobalSetpoints& _s);
void operator<<=(::CORBA::Any& _a, seqAODGlobalSetpoints* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqAODGlobalSetpoints*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqAODGlobalSetpoints*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sGenRes& _s);
extern void operator<<=(::CORBA::Any& _a, sGenRes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sGenRes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sGenRes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sAODPredBlowRes& _s);
extern void operator<<=(::CORBA::Any& _a, sAODPredBlowRes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sAODPredBlowRes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sAODPredBlowRes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sPredRes& _s);
extern void operator<<=(::CORBA::Any& _a, sPredRes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sPredRes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sPredRes*& _sp);

void operator<<=(::CORBA::Any& _a, const seqAODBlowPredRes& _s);
void operator<<=(::CORBA::Any& _a, seqAODBlowPredRes* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqAODBlowPredRes*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqAODBlowPredRes*& _sp);

void operator<<=(::CORBA::Any& _a, const seqPredRes& _s);
void operator<<=(::CORBA::Any& _a, seqPredRes* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqPredRes*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqPredRes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sCoolWater& _s);
extern void operator<<=(::CORBA::Any& _a, sCoolWater* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sCoolWater*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sCoolWater*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sComputerMode& _s);
extern void operator<<=(::CORBA::Any& _a, sComputerMode* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sComputerMode*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sComputerMode*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sCoolWaterDevice& _s);
extern void operator<<=(::CORBA::Any& _a, sCoolWaterDevice* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sCoolWaterDevice*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sCoolWaterDevice*& _sp);

void operator<<=(::CORBA::Any& _a, const seqCoolWaterData& _s);
void operator<<=(::CORBA::Any& _a, seqCoolWaterData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqCoolWaterData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqCoolWaterData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqComputerModes& _s);
void operator<<=(::CORBA::Any& _a, seqComputerModes* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqComputerModes*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqComputerModes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sWireFeeder& _s);
extern void operator<<=(::CORBA::Any& _a, sWireFeeder* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sWireFeeder*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sWireFeeder*& _sp);

void operator<<=(::CORBA::Any& _a, const seqWireFeeder& _s);
void operator<<=(::CORBA::Any& _a, seqWireFeeder* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqWireFeeder*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqWireFeeder*& _sp);

void operator<<=(::CORBA::Any& _a, const seqStringList& _s);
void operator<<=(::CORBA::Any& _a, seqStringList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqStringList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqStringList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sGasData& _s);
extern void operator<<=(::CORBA::Any& _a, sGasData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sGasData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sGasData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqGasData& _s);
void operator<<=(::CORBA::Any& _a, seqGasData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqGasData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqGasData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sGasLanceData& _s);
extern void operator<<=(::CORBA::Any& _a, sGasLanceData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sGasLanceData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sGasLanceData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqGasLanceData& _s);
void operator<<=(::CORBA::Any& _a, seqGasLanceData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqGasLanceData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqGasLanceData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sDeviceGasData& _s);
extern void operator<<=(::CORBA::Any& _a, sDeviceGasData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sDeviceGasData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sDeviceGasData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqDeviceGasData& _s);
void operator<<=(::CORBA::Any& _a, seqDeviceGasData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqDeviceGasData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqDeviceGasData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sEAFGasLancePredRes& _s);
extern void operator<<=(::CORBA::Any& _a, sEAFGasLancePredRes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sEAFGasLancePredRes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sEAFGasLancePredRes*& _sp);

void operator<<=(::CORBA::Any& _a, const seqEAFGasLancePredRes& _s);
void operator<<=(::CORBA::Any& _a, seqEAFGasLancePredRes* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqEAFGasLancePredRes*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqEAFGasLancePredRes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sGasAvail& _s);
extern void operator<<=(::CORBA::Any& _a, sGasAvail* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sGasAvail*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sGasAvail*& _sp);

void operator<<=(::CORBA::Any& _a, const seqGasAvail& _s);
void operator<<=(::CORBA::Any& _a, seqGasAvail* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqGasAvail*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqGasAvail*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sWasteGas& _s);
extern void operator<<=(::CORBA::Any& _a, sWasteGas* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sWasteGas*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sWasteGas*& _sp);

void operator<<=(::CORBA::Any& _a, const seqWasteGas& _s);
void operator<<=(::CORBA::Any& _a, seqWasteGas* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqWasteGas*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqWasteGas*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sBlowStatus& _s);
extern void operator<<=(::CORBA::Any& _a, sBlowStatus* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sBlowStatus*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sBlowStatus*& _sp);

void operator<<=(::CORBA::Any& _a, const seqBlowStatus& _s);
void operator<<=(::CORBA::Any& _a, seqBlowStatus* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqBlowStatus*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqBlowStatus*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sStatus& _s);
extern void operator<<=(::CORBA::Any& _a, sStatus* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sStatus*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sStatus*& _sp);

void operator<<=(::CORBA::Any& _a, const seqStatus& _s);
void operator<<=(::CORBA::Any& _a, seqStatus* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqStatus*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqStatus*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sHeatSchedulePlant& _s);
extern void operator<<=(::CORBA::Any& _a, sHeatSchedulePlant* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sHeatSchedulePlant*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sHeatSchedulePlant*& _sp);

void operator<<=(::CORBA::Any& _a, const seqHeatSchedulePlant& _s);
void operator<<=(::CORBA::Any& _a, seqHeatSchedulePlant* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqHeatSchedulePlant*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqHeatSchedulePlant*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sHeatSchedule& _s);
extern void operator<<=(::CORBA::Any& _a, sHeatSchedule* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sHeatSchedule*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sHeatSchedule*& _sp);

void operator<<=(::CORBA::Any& _a, const seqHeatSchedule& _s);
void operator<<=(::CORBA::Any& _a, seqHeatSchedule* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqHeatSchedule*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqHeatSchedule*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sOrderData& _s);
extern void operator<<=(::CORBA::Any& _a, sOrderData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sOrderData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sOrderData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqOrderData& _s);
void operator<<=(::CORBA::Any& _a, seqOrderData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqOrderData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqOrderData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sSampleData& _s);
extern void operator<<=(::CORBA::Any& _a, sSampleData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sSampleData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sSampleData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqSampleData& _s);
void operator<<=(::CORBA::Any& _a, seqSampleData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqSampleData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqSampleData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sAnalysisData& _s);
extern void operator<<=(::CORBA::Any& _a, sAnalysisData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sAnalysisData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sAnalysisData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sHeatData& _s);
extern void operator<<=(::CORBA::Any& _a, sHeatData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sHeatData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sHeatData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqHeatData& _s);
void operator<<=(::CORBA::Any& _a, seqHeatData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqHeatData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqHeatData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sInjectLanceData& _s);
extern void operator<<=(::CORBA::Any& _a, sInjectLanceData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sInjectLanceData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sInjectLanceData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqInjectLanceData& _s);
void operator<<=(::CORBA::Any& _a, seqInjectLanceData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqInjectLanceData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqInjectLanceData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sGasLanceGasAvail& _s);
extern void operator<<=(::CORBA::Any& _a, sGasLanceGasAvail* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sGasLanceGasAvail*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sGasLanceGasAvail*& _sp);

void operator<<=(::CORBA::Any& _a, const seqGasLanceGasAvail& _s);
void operator<<=(::CORBA::Any& _a, seqGasLanceGasAvail* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqGasLanceGasAvail*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqGasLanceGasAvail*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sBatchPrio& _s);
extern void operator<<=(::CORBA::Any& _a, sBatchPrio* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sBatchPrio*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sBatchPrio*& _sp);

void operator<<=(::CORBA::Any& _a, const seqBatchPrio& _s);
void operator<<=(::CORBA::Any& _a, seqBatchPrio* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqBatchPrio*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqBatchPrio*& _sp);

void operator<<=(::CORBA::Any& _a, const seqAnalysisData& _s);
void operator<<=(::CORBA::Any& _a, seqAnalysisData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqAnalysisData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqAnalysisData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const LFGlobalSetpoints& _s);
extern void operator<<=(::CORBA::Any& _a, LFGlobalSetpoints* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, LFGlobalSetpoints*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const LFGlobalSetpoints*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sLiqMatReport& _s);
extern void operator<<=(::CORBA::Any& _a, sLiqMatReport* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sLiqMatReport*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sLiqMatReport*& _sp);

void operator<<=(::CORBA::Any& _a, const seqLiqMatReport& _s);
void operator<<=(::CORBA::Any& _a, seqLiqMatReport* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqLiqMatReport*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqLiqMatReport*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sBOFPredBlowRes& _s);
extern void operator<<=(::CORBA::Any& _a, sBOFPredBlowRes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sBOFPredBlowRes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sBOFPredBlowRes*& _sp);

void operator<<=(::CORBA::Any& _a, const seqBOFBlowPredRes& _s);
void operator<<=(::CORBA::Any& _a, seqBOFBlowPredRes* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqBOFBlowPredRes*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqBOFBlowPredRes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sInjectData& _s);
extern void operator<<=(::CORBA::Any& _a, sInjectData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sInjectData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sInjectData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqInjectData& _s);
void operator<<=(::CORBA::Any& _a, seqInjectData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqInjectData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqInjectData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sEAFInjectLance& _s);
extern void operator<<=(::CORBA::Any& _a, sEAFInjectLance* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sEAFInjectLance*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sEAFInjectLance*& _sp);

void operator<<=(::CORBA::Any& _a, const seqEAFInjectLance& _s);
void operator<<=(::CORBA::Any& _a, seqEAFInjectLance* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqEAFInjectLance*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqEAFInjectLance*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sHMDCalc& _s);
extern void operator<<=(::CORBA::Any& _a, sHMDCalc* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sHMDCalc*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sHMDCalc*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sConArcElecData& _s);
extern void operator<<=(::CORBA::Any& _a, sConArcElecData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sConArcElecData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sConArcElecData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sConArcMediaData& _s);
extern void operator<<=(::CORBA::Any& _a, sConArcMediaData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sConArcMediaData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sConArcMediaData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqConArcElecData& _s);
void operator<<=(::CORBA::Any& _a, seqConArcElecData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqConArcElecData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqConArcElecData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqConArcMediaData& _s);
void operator<<=(::CORBA::Any& _a, seqConArcMediaData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqConArcMediaData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqConArcMediaData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sConArcSetptData& _s);
extern void operator<<=(::CORBA::Any& _a, sConArcSetptData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sConArcSetptData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sConArcSetptData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sConArcMeasData& _s);
extern void operator<<=(::CORBA::Any& _a, sConArcMeasData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sConArcMeasData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sConArcMeasData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqConArcSetptData& _s);
void operator<<=(::CORBA::Any& _a, seqConArcSetptData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqConArcSetptData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqConArcSetptData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqConArcMeasData& _s);
void operator<<=(::CORBA::Any& _a, seqConArcMeasData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqConArcMeasData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqConArcMeasData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sEAFMatFeedPredRes& _s);
extern void operator<<=(::CORBA::Any& _a, sEAFMatFeedPredRes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sEAFMatFeedPredRes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sEAFMatFeedPredRes*& _sp);

void operator<<=(::CORBA::Any& _a, const seqEAFMatFeedPredRes& _s);
void operator<<=(::CORBA::Any& _a, seqEAFMatFeedPredRes* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqEAFMatFeedPredRes*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqEAFMatFeedPredRes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sPhaseStatus& _s);
extern void operator<<=(::CORBA::Any& _a, sPhaseStatus* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sPhaseStatus*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sPhaseStatus*& _sp);

void operator<<=(::CORBA::Any& _a, const seqPhaseStatus& _s);
void operator<<=(::CORBA::Any& _a, seqPhaseStatus* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqPhaseStatus*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqPhaseStatus*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sMaterial& _s);
extern void operator<<=(::CORBA::Any& _a, sMaterial* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sMaterial*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sMaterial*& _sp);

void operator<<=(::CORBA::Any& _a, const seqMaterials& _s);
void operator<<=(::CORBA::Any& _a, seqMaterials* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqMaterials*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqMaterials*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sStirringData& _s);
extern void operator<<=(::CORBA::Any& _a, sStirringData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sStirringData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sStirringData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqStirringData& _s);
void operator<<=(::CORBA::Any& _a, seqStirringData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqStirringData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqStirringData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sProductIdentification& _s);
extern void operator<<=(::CORBA::Any& _a, sProductIdentification* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sProductIdentification*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sProductIdentification*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sRecipe& _s);
extern void operator<<=(::CORBA::Any& _a, sRecipe* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sRecipe*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sRecipe*& _sp);

void operator<<=(::CORBA::Any& _a, const seqRecipeList& _s);
void operator<<=(::CORBA::Any& _a, seqRecipeList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqRecipeList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqRecipeList*& _sp);

void operator<<=(::CORBA::Any& _a, const seqProductIdentification& _s);
void operator<<=(::CORBA::Any& _a, seqProductIdentification* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqProductIdentification*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqProductIdentification*& _sp);

void operator<<=(::CORBA::Any& _a, const seqHMDCalc& _s);
void operator<<=(::CORBA::Any& _a, seqHMDCalc* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqHMDCalc*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqHMDCalc*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sHMDModelResult& _s);
extern void operator<<=(::CORBA::Any& _a, sHMDModelResult* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sHMDModelResult*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sHMDModelResult*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sRHModelResult& _s);
extern void operator<<=(::CORBA::Any& _a, sRHModelResult* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sRHModelResult*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sRHModelResult*& _sp);

void operator<<=(::CORBA::Any& _a, const seqRHModelResult& _s);
void operator<<=(::CORBA::Any& _a, seqRHModelResult* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqRHModelResult*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqRHModelResult*& _sp);

void operator<<=(::CORBA::Any& _a, const seqHMDModelResult& _s);
void operator<<=(::CORBA::Any& _a, seqHMDModelResult* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqHMDModelResult*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqHMDModelResult*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sElecPhaseData& _s);
extern void operator<<=(::CORBA::Any& _a, sElecPhaseData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sElecPhaseData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sElecPhaseData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqElecPhaseData& _s);
void operator<<=(::CORBA::Any& _a, seqElecPhaseData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqElecPhaseData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqElecPhaseData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sVDModelResult& _s);
extern void operator<<=(::CORBA::Any& _a, sVDModelResult* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sVDModelResult*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sVDModelResult*& _sp);

void operator<<=(::CORBA::Any& _a, const seqVDModelResult& _s);
void operator<<=(::CORBA::Any& _a, seqVDModelResult* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqVDModelResult*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqVDModelResult*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sConArcBlowData& _s);
extern void operator<<=(::CORBA::Any& _a, sConArcBlowData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sConArcBlowData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sConArcBlowData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sConArcModelResult& _s);
extern void operator<<=(::CORBA::Any& _a, sConArcModelResult* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sConArcModelResult*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sConArcModelResult*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sConArcMediaPredRes& _s);
extern void operator<<=(::CORBA::Any& _a, sConArcMediaPredRes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sConArcMediaPredRes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sConArcMediaPredRes*& _sp);

void operator<<=(::CORBA::Any& _a, const seqConArcMediaPredRes& _s);
void operator<<=(::CORBA::Any& _a, seqConArcMediaPredRes* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqConArcMediaPredRes*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqConArcMediaPredRes*& _sp);

void operator<<=(::CORBA::Any& _a, const seqConArcBlowData& _s);
void operator<<=(::CORBA::Any& _a, seqConArcBlowData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqConArcBlowData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqConArcBlowData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqConArcModelResult& _s);
void operator<<=(::CORBA::Any& _a, seqConArcModelResult* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqConArcModelResult*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqConArcModelResult*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sLTSStirrPredRes& _s);
extern void operator<<=(::CORBA::Any& _a, sLTSStirrPredRes* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sLTSStirrPredRes*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sLTSStirrPredRes*& _sp);

void operator<<=(::CORBA::Any& _a, const seqLTSStirrPredRes& _s);
void operator<<=(::CORBA::Any& _a, seqLTSStirrPredRes* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqLTSStirrPredRes*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqLTSStirrPredRes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sBOFGlobalSetpoints& _s);
extern void operator<<=(::CORBA::Any& _a, sBOFGlobalSetpoints* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sBOFGlobalSetpoints*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sBOFGlobalSetpoints*& _sp);

void operator<<=(::CORBA::Any& _a, const seqBOFGlobalSetpoints& _s);
void operator<<=(::CORBA::Any& _a, seqBOFGlobalSetpoints* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqBOFGlobalSetpoints*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqBOFGlobalSetpoints*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sConArcGlobalSetpoints& _s);
extern void operator<<=(::CORBA::Any& _a, sConArcGlobalSetpoints* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sConArcGlobalSetpoints*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sConArcGlobalSetpoints*& _sp);

void operator<<=(::CORBA::Any& _a, const seqConArcGlobalSetpoints& _s);
void operator<<=(::CORBA::Any& _a, seqConArcGlobalSetpoints* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqConArcGlobalSetpoints*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqConArcGlobalSetpoints*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sSample& _s);
extern void operator<<=(::CORBA::Any& _a, sSample* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sSample*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sSample*& _sp);

void operator<<=(::CORBA::Any& _a, const seqSample& _s);
void operator<<=(::CORBA::Any& _a, seqSample* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqSample*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqSample*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sTorpedoData& _s);
extern void operator<<=(::CORBA::Any& _a, sTorpedoData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sTorpedoData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sTorpedoData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqTorpedoData& _s);
void operator<<=(::CORBA::Any& _a, seqTorpedoData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqTorpedoData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqTorpedoData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const strSampleRef& _s);
extern void operator<<=(::CORBA::Any& _a, strSampleRef* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, strSampleRef*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const strSampleRef*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sPhaseDataReport& _s);
extern void operator<<=(::CORBA::Any& _a, sPhaseDataReport* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sPhaseDataReport*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sPhaseDataReport*& _sp);

void operator<<=(::CORBA::Any& _a, const seqPhaseDataReport& _s);
void operator<<=(::CORBA::Any& _a, seqPhaseDataReport* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqPhaseDataReport*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqPhaseDataReport*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sEquipmentLifeData& _s);
extern void operator<<=(::CORBA::Any& _a, sEquipmentLifeData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sEquipmentLifeData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sEquipmentLifeData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqEquipmentLifeData& _s);
void operator<<=(::CORBA::Any& _a, seqEquipmentLifeData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqEquipmentLifeData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqEquipmentLifeData*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sPPRestriction& _s);
extern void operator<<=(::CORBA::Any& _a, sPPRestriction* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sPPRestriction*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sPPRestriction*& _sp);

void operator<<=(::CORBA::Any& _a, const seqPPRestriction& _s);
void operator<<=(::CORBA::Any& _a, seqPPRestriction* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqPPRestriction*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqPPRestriction*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sHeatStack& _s);
extern void operator<<=(::CORBA::Any& _a, sHeatStack* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sHeatStack*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sHeatStack*& _sp);

void operator<<=(::CORBA::Any& _a, const seqHeatStack& _s);
void operator<<=(::CORBA::Any& _a, seqHeatStack* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqHeatStack*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqHeatStack*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sMediaConsumed& _s);
extern void operator<<=(::CORBA::Any& _a, sMediaConsumed* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sMediaConsumed*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sMediaConsumed*& _sp);

void operator<<=(::CORBA::Any& _a, const seqMediaConsumed& _s);
void operator<<=(::CORBA::Any& _a, seqMediaConsumed* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqMediaConsumed*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqMediaConsumed*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sEnergyConsumed& _s);
extern void operator<<=(::CORBA::Any& _a, sEnergyConsumed* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sEnergyConsumed*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sEnergyConsumed*& _sp);

void operator<<=(::CORBA::Any& _a, const seqEnergyConsumed& _s);
void operator<<=(::CORBA::Any& _a, seqEnergyConsumed* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqEnergyConsumed*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqEnergyConsumed*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sSAF_Bin& _s);
extern void operator<<=(::CORBA::Any& _a, sSAF_Bin* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sSAF_Bin*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sSAF_Bin*& _sp);

void operator<<=(::CORBA::Any& _a, const seqSAF_Bin& _s);
void operator<<=(::CORBA::Any& _a, seqSAF_Bin* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqSAF_Bin*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqSAF_Bin*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sHarmonics& _s);
extern void operator<<=(::CORBA::Any& _a, sHarmonics* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sHarmonics*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sHarmonics*& _sp);

void operator<<=(::CORBA::Any& _a, const seqHarmonics& _s);
void operator<<=(::CORBA::Any& _a, seqHarmonics* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqHarmonics*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqHarmonics*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sWallTemp& _s);
extern void operator<<=(::CORBA::Any& _a, sWallTemp* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sWallTemp*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sWallTemp*& _sp);

void operator<<=(::CORBA::Any& _a, const seqWallTemp& _s);
void operator<<=(::CORBA::Any& _a, seqWallTemp* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqWallTemp*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqWallTemp*& _sp);

extern void operator<<=(::CORBA::Any& _a, const sHMPouringData& _s);
extern void operator<<=(::CORBA::Any& _a, sHMPouringData* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, sHMPouringData*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const sHMPouringData*& _sp);

void operator<<=(::CORBA::Any& _a, const seqHMPouringData& _s);
void operator<<=(::CORBA::Any& _a, seqHMPouringData* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, seqHMPouringData*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const seqHMPouringData*& _sp);

void operator<<=(::CORBA::Any& _a, iSMC_DataProvider_ptr _s);
void operator<<=(::CORBA::Any& _a, iSMC_DataProvider_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, iSMC_DataProvider_ptr& _s);



inline void
iSMC_DataProvider::_marshalObjRef(::iSMC_DataProvider_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_iSMC__DataProvider
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_iSMC__DataProvider
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_iSMC__DataProvider
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_iSMC__DataProvider
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_iSMC__DataProvider
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_iSMC__DataProvider
#endif

#endif  // __iSMC__DataProvider_hh__

