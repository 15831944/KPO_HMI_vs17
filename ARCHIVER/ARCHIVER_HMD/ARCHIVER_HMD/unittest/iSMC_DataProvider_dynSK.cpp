// This file is generated by omniidl (C++ backend)- omniORB_4_0. Do not edit.

#include "iSMC_DataProvider_s.hh"
#include <omniORB4/tcDescriptor.h>

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_0;

static CORBA::PR_structMember _0RL_structmember_sAnalysis[] = {
  {"Element", CORBA::TypeCode::PR_string_tc(0)},
  {"Concentration", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sAnalysis = CORBA::TypeCode::PR_struct_tc("IDL:sAnalysis:1.0", "sAnalysis", _0RL_structmember_sAnalysis, 2);
const CORBA::TypeCode_ptr _tc_sAnalysis = _0RL_tc_sAnalysis;


static CORBA::PR_structMember _0RL_structmember_sBatch[] = {
  {"MatCode", CORBA::TypeCode::PR_string_tc(0)},
  {"Mass", CORBA::TypeCode::PR_double_tc()},
  {"MatFeedSpeed", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sBatch = CORBA::TypeCode::PR_struct_tc("IDL:sBatch:1.0", "sBatch", _0RL_structmember_sBatch, 3);
const CORBA::TypeCode_ptr _tc_sBatch = _0RL_tc_sBatch;


static CORBA::PR_structMember _0RL_structmember_MCBS_mCBS__LocalTime[] = {
  {"year", CORBA::TypeCode::PR_ushort_tc()},
  {"month", CORBA::TypeCode::PR_ushort_tc()},
  {"day", CORBA::TypeCode::PR_ushort_tc()},
  {"hour", CORBA::TypeCode::PR_ushort_tc()},
  {"minute", CORBA::TypeCode::PR_ushort_tc()},
  {"second", CORBA::TypeCode::PR_ushort_tc()},
  {"msec", CORBA::TypeCode::PR_ushort_tc()},
  {"dstFlag", CORBA::TypeCode::PR_boolean_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_MCBS_mCBS__LocalTime = CORBA::TypeCode::PR_struct_tc("IDL:MCBS/CBS_LocalTime:1.0", "CBS_LocalTime", _0RL_structmember_MCBS_mCBS__LocalTime, 8);



static CORBA::TypeCode_ptr _0RL_tc_sDate = CORBA::TypeCode::PR_alias_tc("IDL:sDate:1.0", "sDate", _0RL_tc_MCBS_mCBS__LocalTime);


const CORBA::TypeCode_ptr _tc_sDate = _0RL_tc_sDate;

static CORBA::PR_structMember _0RL_structmember_sEAFBurnerPredRes[] = {
  {"Phase", CORBA::TypeCode::PR_string_tc(0)},
  {"BasketNo", CORBA::TypeCode::PR_long_tc()},
  {"Step", CORBA::TypeCode::PR_long_tc()},
  {"BurnerNo", CORBA::TypeCode::PR_long_tc()},
  {"GasFlow", CORBA::TypeCode::PR_double_tc()},
  {"DurStep", CORBA::TypeCode::PR_double_tc()},
  {"SpecEgy", CORBA::TypeCode::PR_double_tc()},
  {"ElecEgy", CORBA::TypeCode::PR_double_tc()},
  {"O2Flow", CORBA::TypeCode::PR_double_tc()},
  {"ElecEgyStep", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilEndOfStep", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilStartOfStep", CORBA::TypeCode::PR_double_tc()},
  {"SpecEgyStep", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sEAFBurnerPredRes = CORBA::TypeCode::PR_struct_tc("IDL:sEAFBurnerPredRes:1.0", "sEAFBurnerPredRes", _0RL_structmember_sEAFBurnerPredRes, 13);
const CORBA::TypeCode_ptr _tc_sEAFBurnerPredRes = _0RL_tc_sEAFBurnerPredRes;


static CORBA::PR_structMember _0RL_structmember_sEAFElecPredRes[] = {
  {"Phase", CORBA::TypeCode::PR_string_tc(0)},
  {"BasketNo", CORBA::TypeCode::PR_long_tc()},
  {"Step", CORBA::TypeCode::PR_long_tc()},
  {"VoltTap", CORBA::TypeCode::PR_long_tc()},
  {"ImpCurve", CORBA::TypeCode::PR_long_tc()},
  {"DurStep", CORBA::TypeCode::PR_double_tc()},
  {"Temp", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilEndOfStep", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilStartOfStep", CORBA::TypeCode::PR_double_tc()},
  {"SpecEgyStep", CORBA::TypeCode::PR_double_tc()},
  {"SpecEgy", CORBA::TypeCode::PR_double_tc()},
  {"ElecEgyStep", CORBA::TypeCode::PR_double_tc()},
  {"ElecEgy", CORBA::TypeCode::PR_double_tc()},
  {"BaseMass", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sEAFElecPredRes = CORBA::TypeCode::PR_struct_tc("IDL:sEAFElecPredRes:1.0", "sEAFElecPredRes", _0RL_structmember_sEAFElecPredRes, 14);
const CORBA::TypeCode_ptr _tc_sEAFElecPredRes = _0RL_tc_sEAFElecPredRes;



static CORBA::PR_structMember _0RL_structmember_sLFElecPredRes[] = {
  {"Step", CORBA::TypeCode::PR_long_tc()},
  {"VoltTap", CORBA::TypeCode::PR_long_tc()},
  {"ImpCurve", CORBA::TypeCode::PR_long_tc()},
  {"ElecEgy", CORBA::TypeCode::PR_double_tc()},
  {"SpecEgy", CORBA::TypeCode::PR_double_tc()},
  {"StirrIntensity", CORBA::TypeCode::PR_long_tc()},
  {"StirrFlow", CORBA::TypeCode::PR_double_tc()},
  {"GasType", CORBA::TypeCode::PR_string_tc(0)},
  {"Priority", CORBA::TypeCode::PR_long_tc()},
  {"DurStep", CORBA::TypeCode::PR_double_tc()},
  {"Enable", CORBA::TypeCode::PR_long_tc()},
  {"Order", CORBA::TypeCode::PR_long_tc()},
  {"RevDate", _0RL_tc_sDate},
  {"StirrIntensityCode", CORBA::TypeCode::PR_string_tc(0)},
  {"ElecPhase", CORBA::TypeCode::PR_string_tc(0)},
  {"ElecEgyStep", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilEndOfStep", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilStartOfStep", CORBA::TypeCode::PR_double_tc()},
  {"BaseMass", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sLFElecPredRes = CORBA::TypeCode::PR_struct_tc("IDL:sLFElecPredRes:1.0", "sLFElecPredRes", _0RL_structmember_sLFElecPredRes, 19);

const CORBA::TypeCode_ptr _tc_sLFElecPredRes = _0RL_tc_sLFElecPredRes;


static CORBA::PR_structMember _0RL_structmember_sLFStirrPredRes[] = {
  {"StirrPhase", CORBA::TypeCode::PR_string_tc(0)},
  {"StirrIntensity", CORBA::TypeCode::PR_long_tc()},
  {"StirrFlow", CORBA::TypeCode::PR_double_tc()},
  {"GasType", CORBA::TypeCode::PR_string_tc(0)},
  {"Priority", CORBA::TypeCode::PR_long_tc()},
  {"DurStep", CORBA::TypeCode::PR_double_tc()},
  {"StirrIntensityCode", CORBA::TypeCode::PR_string_tc(0)},
  {"Enable", CORBA::TypeCode::PR_long_tc()},
  {"Order", CORBA::TypeCode::PR_long_tc()},
  {"isPatternOrActivity", CORBA::TypeCode::PR_long_tc()},
  {"DurUntilEndOfStep", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilStartOfStep", CORBA::TypeCode::PR_double_tc()},
  {"VoltTap", CORBA::TypeCode::PR_long_tc()},
  {"ImpCurve", CORBA::TypeCode::PR_long_tc()},
  {"ElecEgy", CORBA::TypeCode::PR_double_tc()},
  {"SteelMass", CORBA::TypeCode::PR_double_tc()},
  {"SlagMass", CORBA::TypeCode::PR_double_tc()},
  {"Temp", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sLFStirrPredRes = CORBA::TypeCode::PR_struct_tc("IDL:sLFStirrPredRes:1.0", "sLFStirrPredRes", _0RL_structmember_sLFStirrPredRes, 18);
const CORBA::TypeCode_ptr _tc_sLFStirrPredRes = _0RL_tc_sLFStirrPredRes;




static CORBA::PR_structMember _0RL_structmember_sMetTimeStamp[] = {
  {"O2_Moment", CORBA::TypeCode::PR_double_tc()},
  {"Ar_Moment", CORBA::TypeCode::PR_double_tc()},
  {"N2_Moment", CORBA::TypeCode::PR_double_tc()},
  {"Elec_Moment", CORBA::TypeCode::PR_double_tc()},
  {"DurSinceHeatAnnouncement", CORBA::TypeCode::PR_double_tc()},
  {"DurSinceStartOfHeat", CORBA::TypeCode::PR_double_tc()},
  {"RevDate", _0RL_tc_sDate},
  {"ActionDate", _0RL_tc_sDate}
};

static CORBA::TypeCode_ptr _0RL_tc_sMetTimeStamp = CORBA::TypeCode::PR_struct_tc("IDL:sMetTimeStamp:1.0", "sMetTimeStamp", _0RL_structmember_sMetTimeStamp, 8);


const CORBA::TypeCode_ptr _tc_sMetTimeStamp = _0RL_tc_sMetTimeStamp;


static CORBA::PR_structMember _0RL_structmember_sRecipeProperties[] = {
  {"RecipeStatus", CORBA::TypeCode::PR_long_tc()},
  {"HomogDuration", CORBA::TypeCode::PR_double_tc()},
  {"TotalMass", CORBA::TypeCode::PR_double_tc()},
  {"BulkVolume", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sRecipeProperties = CORBA::TypeCode::PR_struct_tc("IDL:sRecipeProperties:1.0", "sRecipeProperties", _0RL_structmember_sRecipeProperties, 4);
const CORBA::TypeCode_ptr _tc_sRecipeProperties = _0RL_tc_sRecipeProperties;






static CORBA::TypeCode_ptr _0RL_tc_seqAnalysis = CORBA::TypeCode::PR_alias_tc("IDL:seqAnalysis:1.0", "seqAnalysis", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sAnalysis));


const CORBA::TypeCode_ptr _tc_seqAnalysis = _0RL_tc_seqAnalysis;





static CORBA::TypeCode_ptr _0RL_tc_seqBatch = CORBA::TypeCode::PR_alias_tc("IDL:seqBatch:1.0", "seqBatch", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sBatch));


const CORBA::TypeCode_ptr _tc_seqBatch = _0RL_tc_seqBatch;


static CORBA::PR_structMember _0RL_structmember_sEAFMatFeed[] = {
  {"Phase", CORBA::TypeCode::PR_string_tc(0)},
  {"BasketNo", CORBA::TypeCode::PR_long_tc()},
  {"Step", CORBA::TypeCode::PR_long_tc()},
  {"DurStep", CORBA::TypeCode::PR_double_tc()},
  {"SpecEgy", CORBA::TypeCode::PR_double_tc()},
  {"MatFeed", _0RL_tc_seqBatch}
};

static CORBA::TypeCode_ptr _0RL_tc_sEAFMatFeed = CORBA::TypeCode::PR_struct_tc("IDL:sEAFMatFeed:1.0", "sEAFMatFeed", _0RL_structmember_sEAFMatFeed, 6);

const CORBA::TypeCode_ptr _tc_sEAFMatFeed = _0RL_tc_sEAFMatFeed;






static CORBA::TypeCode_ptr _0RL_tc_seqEAFBurnerPredRes = CORBA::TypeCode::PR_alias_tc("IDL:seqEAFBurnerPredRes:1.0", "seqEAFBurnerPredRes", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sEAFBurnerPredRes));


const CORBA::TypeCode_ptr _tc_seqEAFBurnerPredRes = _0RL_tc_seqEAFBurnerPredRes;





static CORBA::TypeCode_ptr _0RL_tc_seqEAFElecPredRes = CORBA::TypeCode::PR_alias_tc("IDL:seqEAFElecPredRes:1.0", "seqEAFElecPredRes", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sEAFElecPredRes));


const CORBA::TypeCode_ptr _tc_seqEAFElecPredRes = _0RL_tc_seqEAFElecPredRes;









static CORBA::TypeCode_ptr _0RL_tc_seqEAFMatFeed = CORBA::TypeCode::PR_alias_tc("IDL:seqEAFMatFeed:1.0", "seqEAFMatFeed", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sEAFMatFeed));


const CORBA::TypeCode_ptr _tc_seqEAFMatFeed = _0RL_tc_seqEAFMatFeed;









static CORBA::TypeCode_ptr _0RL_tc_seqLFElecPredRes = CORBA::TypeCode::PR_alias_tc("IDL:seqLFElecPredRes:1.0", "seqLFElecPredRes", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sLFElecPredRes));


const CORBA::TypeCode_ptr _tc_seqLFElecPredRes = _0RL_tc_seqLFElecPredRes;





static CORBA::TypeCode_ptr _0RL_tc_seqLFStirrPredRes = CORBA::TypeCode::PR_alias_tc("IDL:seqLFStirrPredRes:1.0", "seqLFStirrPredRes", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sLFStirrPredRes));


const CORBA::TypeCode_ptr _tc_seqLFStirrPredRes = _0RL_tc_seqLFStirrPredRes;

static CORBA::PR_structMember _0RL_structmember_sAODGlobalSetpoints[] = {
  {"O2VolStartMatAddn", CORBA::TypeCode::PR_double_tc()},
  {"O2VolStartScrapChute", CORBA::TypeCode::PR_double_tc()},
  {"O2VolSubLance", CORBA::TypeCode::PR_double_tc()},
  {"O2VolTotal", CORBA::TypeCode::PR_double_tc()},
  {"O2VolTotalLance", CORBA::TypeCode::PR_double_tc()},
  {"N2VolTotal", CORBA::TypeCode::PR_double_tc()},
  {"MatFeedRate", CORBA::TypeCode::PR_double_tc()},
  {"MatDynFeedRate", CORBA::TypeCode::PR_double_tc()},
  {"O2VolSartMatDynAddn", CORBA::TypeCode::PR_double_tc()},
  {"AimTapWeightCalc", CORBA::TypeCode::PR_double_tc()},
  {"DurStartMatAddn", CORBA::TypeCode::PR_double_tc()},
  {"DurSartMatDynAddn", CORBA::TypeCode::PR_double_tc()},
  {"DurStartScrapChute", CORBA::TypeCode::PR_double_tc()},
  {"DurSubLance", CORBA::TypeCode::PR_double_tc()},
  {"O2VolStartMat2ndAddn", CORBA::TypeCode::PR_double_tc()},
  {"DurStartMat2ndAddn", CORBA::TypeCode::PR_double_tc()},
  {"MatFeedRate2ndAdd", CORBA::TypeCode::PR_double_tc()},
  {"O2VolSwN2toAr", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilN2ToAr", CORBA::TypeCode::PR_double_tc()},
  {"N2VolSwN2toAr", CORBA::TypeCode::PR_double_tc()},
  {"AimSteelMassCalc", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sAODGlobalSetpoints = CORBA::TypeCode::PR_struct_tc("IDL:sAODGlobalSetpoints:1.0", "sAODGlobalSetpoints", _0RL_structmember_sAODGlobalSetpoints, 21);
const CORBA::TypeCode_ptr _tc_sAODGlobalSetpoints = _0RL_tc_sAODGlobalSetpoints;






static CORBA::TypeCode_ptr _0RL_tc_seqAODGlobalSetpoints = CORBA::TypeCode::PR_alias_tc("IDL:seqAODGlobalSetpoints:1.0", "seqAODGlobalSetpoints", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sAODGlobalSetpoints));


const CORBA::TypeCode_ptr _tc_seqAODGlobalSetpoints = _0RL_tc_seqAODGlobalSetpoints;





static CORBA::PR_structMember _0RL_structmember_sGenRes[] = {
  {"Analysis", _0RL_tc_seqAnalysis},
  {"SteelWeight", CORBA::TypeCode::PR_double_tc()},
  {"SlagWeight", CORBA::TypeCode::PR_double_tc()},
  {"Temp", CORBA::TypeCode::PR_double_tc()},
  {"DurPhase", CORBA::TypeCode::PR_double_tc()},
  {"MetTimeStamp", _0RL_tc_sMetTimeStamp}
};

static CORBA::TypeCode_ptr _0RL_tc_sGenRes = CORBA::TypeCode::PR_struct_tc("IDL:sGenRes:1.0", "sGenRes", _0RL_structmember_sGenRes, 6);




const CORBA::TypeCode_ptr _tc_sGenRes = _0RL_tc_sGenRes;







static CORBA::PR_structMember _0RL_structmember_sAODPredBlowRes[] = {
  {"Phase", CORBA::TypeCode::PR_string_tc(0)},
  {"PhaseNo", CORBA::TypeCode::PR_long_tc()},
  {"O2Vol", CORBA::TypeCode::PR_double_tc()},
  {"TopLanceO2Flow", CORBA::TypeCode::PR_double_tc()},
  {"TopLanceN2Flow", CORBA::TypeCode::PR_double_tc()},
  {"TopLanceArFlow", CORBA::TypeCode::PR_double_tc()},
  {"TuyerO2Flow", CORBA::TypeCode::PR_double_tc()},
  {"TuyerN2Flow", CORBA::TypeCode::PR_double_tc()},
  {"TuyerArFlow", CORBA::TypeCode::PR_double_tc()},
  {"DecarbRate", CORBA::TypeCode::PR_double_tc()},
  {"ChromDeslagRate", CORBA::TypeCode::PR_double_tc()},
  {"TopLanceHeight", CORBA::TypeCode::PR_double_tc()},
  {"PhaseActive", CORBA::TypeCode::PR_long_tc()},
  {"GenRes", _0RL_tc_sGenRes}
};

static CORBA::TypeCode_ptr _0RL_tc_sAODPredBlowRes = CORBA::TypeCode::PR_struct_tc("IDL:sAODPredBlowRes:1.0", "sAODPredBlowRes", _0RL_structmember_sAODPredBlowRes, 14);





const CORBA::TypeCode_ptr _tc_sAODPredBlowRes = _0RL_tc_sAODPredBlowRes;







static CORBA::PR_structMember _0RL_structmember_sPredRes[] = {
  {"Phase", CORBA::TypeCode::PR_string_tc(0)},
  {"PhaseNo", CORBA::TypeCode::PR_long_tc()},
  {"GenRes", _0RL_tc_sGenRes},
  {"PhaseActive", CORBA::TypeCode::PR_long_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sPredRes = CORBA::TypeCode::PR_struct_tc("IDL:sPredRes:1.0", "sPredRes", _0RL_structmember_sPredRes, 4);





const CORBA::TypeCode_ptr _tc_sPredRes = _0RL_tc_sPredRes;


























static CORBA::TypeCode_ptr _0RL_tc_seqAODBlowPredRes = CORBA::TypeCode::PR_alias_tc("IDL:seqAODBlowPredRes:1.0", "seqAODBlowPredRes", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sAODPredBlowRes));


const CORBA::TypeCode_ptr _tc_seqAODBlowPredRes = _0RL_tc_seqAODBlowPredRes;

























static CORBA::TypeCode_ptr _0RL_tc_seqPredRes = CORBA::TypeCode::PR_alias_tc("IDL:seqPredRes:1.0", "seqPredRes", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sPredRes));


const CORBA::TypeCode_ptr _tc_seqPredRes = _0RL_tc_seqPredRes;

static CORBA::PR_structMember _0RL_structmember_sCoolWater[] = {
  {"WaterFlow", CORBA::TypeCode::PR_double_tc()},
  {"OutletTemp", CORBA::TypeCode::PR_double_tc()},
  {"InletTemp", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sCoolWater = CORBA::TypeCode::PR_struct_tc("IDL:sCoolWater:1.0", "sCoolWater", _0RL_structmember_sCoolWater, 3);
const CORBA::TypeCode_ptr _tc_sCoolWater = _0RL_tc_sCoolWater;


static CORBA::PR_structMember _0RL_structmember_sComputerMode[] = {
  {"Device", CORBA::TypeCode::PR_string_tc(0)},
  {"Status", CORBA::TypeCode::PR_long_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sComputerMode = CORBA::TypeCode::PR_struct_tc("IDL:sComputerMode:1.0", "sComputerMode", _0RL_structmember_sComputerMode, 2);
const CORBA::TypeCode_ptr _tc_sComputerMode = _0RL_tc_sComputerMode;



static CORBA::PR_structMember _0RL_structmember_sCoolWaterDevice[] = {
  {"CoolWaterDeviceNo", CORBA::TypeCode::PR_long_tc()},
  {"CoolWaterDevice", CORBA::TypeCode::PR_string_tc(0)},
  {"CoolWaterData", _0RL_tc_sCoolWater}
};

static CORBA::TypeCode_ptr _0RL_tc_sCoolWaterDevice = CORBA::TypeCode::PR_struct_tc("IDL:sCoolWaterDevice:1.0", "sCoolWaterDevice", _0RL_structmember_sCoolWaterDevice, 3);

const CORBA::TypeCode_ptr _tc_sCoolWaterDevice = _0RL_tc_sCoolWaterDevice;










static CORBA::TypeCode_ptr _0RL_tc_seqCoolWaterData = CORBA::TypeCode::PR_alias_tc("IDL:seqCoolWaterData:1.0", "seqCoolWaterData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sCoolWaterDevice));


const CORBA::TypeCode_ptr _tc_seqCoolWaterData = _0RL_tc_seqCoolWaterData;





static CORBA::TypeCode_ptr _0RL_tc_seqComputerModes = CORBA::TypeCode::PR_alias_tc("IDL:seqComputerModes:1.0", "seqComputerModes", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sComputerMode));


const CORBA::TypeCode_ptr _tc_seqComputerModes = _0RL_tc_seqComputerModes;

static CORBA::PR_structMember _0RL_structmember_sWireFeeder[] = {
  {"WireFeederLineNo", CORBA::TypeCode::PR_long_tc()},
  {"WireFeederMatCode", CORBA::TypeCode::PR_string_tc(0)},
  {"WireFeedSpeed", CORBA::TypeCode::PR_double_tc()},
  {"WireFeederAmount", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sWireFeeder = CORBA::TypeCode::PR_struct_tc("IDL:sWireFeeder:1.0", "sWireFeeder", _0RL_structmember_sWireFeeder, 4);
const CORBA::TypeCode_ptr _tc_sWireFeeder = _0RL_tc_sWireFeeder;






static CORBA::TypeCode_ptr _0RL_tc_seqWireFeeder = CORBA::TypeCode::PR_alias_tc("IDL:seqWireFeeder:1.0", "seqWireFeeder", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sWireFeeder));


const CORBA::TypeCode_ptr _tc_seqWireFeeder = _0RL_tc_seqWireFeeder;

static CORBA::TypeCode_ptr _0RL_tc_seqStringList = CORBA::TypeCode::PR_alias_tc("IDL:seqStringList:1.0", "seqStringList", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_string_tc(0)));


const CORBA::TypeCode_ptr _tc_seqStringList = _0RL_tc_seqStringList;

static CORBA::PR_structMember _0RL_structmember_sGasData[] = {
  {"GasType", CORBA::TypeCode::PR_string_tc(0)},
  {"GasValue", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sGasData = CORBA::TypeCode::PR_struct_tc("IDL:sGasData:1.0", "sGasData", _0RL_structmember_sGasData, 2);
const CORBA::TypeCode_ptr _tc_sGasData = _0RL_tc_sGasData;






static CORBA::TypeCode_ptr _0RL_tc_seqGasData = CORBA::TypeCode::PR_alias_tc("IDL:seqGasData:1.0", "seqGasData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sGasData));


const CORBA::TypeCode_ptr _tc_seqGasData = _0RL_tc_seqGasData;



static CORBA::PR_structMember _0RL_structmember_sEAFGasLancePredRes[] = {
  {"Phase", CORBA::TypeCode::PR_string_tc(0)},
  {"BasketNo", CORBA::TypeCode::PR_long_tc()},
  {"Step", CORBA::TypeCode::PR_long_tc()},
  {"LanceNo", CORBA::TypeCode::PR_long_tc()},
  {"DurStep", CORBA::TypeCode::PR_double_tc()},
  {"GasFlow", _0RL_tc_seqGasData},
  {"Egy", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilEndOfStep", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilStartOfStep", CORBA::TypeCode::PR_double_tc()},
  {"SpecEgyStep", CORBA::TypeCode::PR_double_tc()},
  {"ElecEgyStep", CORBA::TypeCode::PR_double_tc()},
  {"SpecEgy", CORBA::TypeCode::PR_double_tc()},
  {"BaseMass", CORBA::TypeCode::PR_double_tc()},
  {"GasAmount", _0RL_tc_seqGasData}
};

static CORBA::TypeCode_ptr _0RL_tc_sEAFGasLancePredRes = CORBA::TypeCode::PR_struct_tc("IDL:sEAFGasLancePredRes:1.0", "sEAFGasLancePredRes", _0RL_structmember_sEAFGasLancePredRes, 14);


const CORBA::TypeCode_ptr _tc_sEAFGasLancePredRes = _0RL_tc_sEAFGasLancePredRes;














static CORBA::TypeCode_ptr _0RL_tc_seqEAFGasLancePredRes = CORBA::TypeCode::PR_alias_tc("IDL:seqEAFGasLancePredRes:1.0", "seqEAFGasLancePredRes", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sEAFGasLancePredRes));


const CORBA::TypeCode_ptr _tc_seqEAFGasLancePredRes = _0RL_tc_seqEAFGasLancePredRes;

static CORBA::PR_structMember _0RL_structmember_sGasAvail[] = {
  {"GasType", CORBA::TypeCode::PR_string_tc(0)},
  {"GasAvail", CORBA::TypeCode::PR_long_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sGasAvail = CORBA::TypeCode::PR_struct_tc("IDL:sGasAvail:1.0", "sGasAvail", _0RL_structmember_sGasAvail, 2);
const CORBA::TypeCode_ptr _tc_sGasAvail = _0RL_tc_sGasAvail;






static CORBA::TypeCode_ptr _0RL_tc_seqGasAvail = CORBA::TypeCode::PR_alias_tc("IDL:seqGasAvail:1.0", "seqGasAvail", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sGasAvail));


const CORBA::TypeCode_ptr _tc_seqGasAvail = _0RL_tc_seqGasAvail;

static CORBA::PR_structMember _0RL_structmember_sWasteGas[] = {
  {"WasteGasType", CORBA::TypeCode::PR_string_tc(0)},
  {"WasteGasConc", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sWasteGas = CORBA::TypeCode::PR_struct_tc("IDL:sWasteGas:1.0", "sWasteGas", _0RL_structmember_sWasteGas, 2);
const CORBA::TypeCode_ptr _tc_sWasteGas = _0RL_tc_sWasteGas;






static CORBA::TypeCode_ptr _0RL_tc_seqWasteGas = CORBA::TypeCode::PR_alias_tc("IDL:seqWasteGas:1.0", "seqWasteGas", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sWasteGas));


const CORBA::TypeCode_ptr _tc_seqWasteGas = _0RL_tc_seqWasteGas;


static CORBA::PR_structMember _0RL_structmember_sBlowStatus[] = {
  {"BlowDevice", CORBA::TypeCode::PR_string_tc(0)},
  {"BlowStatus", CORBA::TypeCode::PR_long_tc()},
  {"BlowTime", _0RL_tc_sDate}
};

static CORBA::TypeCode_ptr _0RL_tc_sBlowStatus = CORBA::TypeCode::PR_struct_tc("IDL:sBlowStatus:1.0", "sBlowStatus", _0RL_structmember_sBlowStatus, 3);

const CORBA::TypeCode_ptr _tc_sBlowStatus = _0RL_tc_sBlowStatus;










static CORBA::TypeCode_ptr _0RL_tc_seqBlowStatus = CORBA::TypeCode::PR_alias_tc("IDL:seqBlowStatus:1.0", "seqBlowStatus", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sBlowStatus));


const CORBA::TypeCode_ptr _tc_seqBlowStatus = _0RL_tc_seqBlowStatus;



static CORBA::PR_structMember _0RL_structmember_sStatus[] = {
  {"Device", CORBA::TypeCode::PR_string_tc(0)},
  {"Status", CORBA::TypeCode::PR_long_tc()},
  {"StatusName", CORBA::TypeCode::PR_string_tc(0)},
  {"EndTime", _0RL_tc_sDate},
  {"StartTime", _0RL_tc_sDate}
};

static CORBA::TypeCode_ptr _0RL_tc_sStatus = CORBA::TypeCode::PR_struct_tc("IDL:sStatus:1.0", "sStatus", _0RL_structmember_sStatus, 5);


const CORBA::TypeCode_ptr _tc_sStatus = _0RL_tc_sStatus;














static CORBA::TypeCode_ptr _0RL_tc_seqStatus = CORBA::TypeCode::PR_alias_tc("IDL:seqStatus:1.0", "seqStatus", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sStatus));


const CORBA::TypeCode_ptr _tc_seqStatus = _0RL_tc_seqStatus;



static CORBA::PR_structMember _0RL_structmember_sHeatSchedulePlant[] = {
  {"Plant", CORBA::TypeCode::PR_string_tc(0)},
  {"TreatID", CORBA::TypeCode::PR_string_tc(0)},
  {"TreatStartPlan", _0RL_tc_sDate},
  {"TreatEndPlan", _0RL_tc_sDate},
  {"PlantNo", CORBA::TypeCode::PR_long_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sHeatSchedulePlant = CORBA::TypeCode::PR_struct_tc("IDL:sHeatSchedulePlant:1.0", "sHeatSchedulePlant", _0RL_structmember_sHeatSchedulePlant, 5);


const CORBA::TypeCode_ptr _tc_sHeatSchedulePlant = _0RL_tc_sHeatSchedulePlant;














static CORBA::TypeCode_ptr _0RL_tc_seqHeatSchedulePlant = CORBA::TypeCode::PR_alias_tc("IDL:seqHeatSchedulePlant:1.0", "seqHeatSchedulePlant", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sHeatSchedulePlant));


const CORBA::TypeCode_ptr _tc_seqHeatSchedulePlant = _0RL_tc_seqHeatSchedulePlant;




static CORBA::PR_structMember _0RL_structmember_sHeatSchedule[] = {
  {"HeatId", CORBA::TypeCode::PR_string_tc(0)},
  {"OrderId", CORBA::TypeCode::PR_string_tc(0)},
  {"RouteCode", CORBA::TypeCode::PR_string_tc(0)},
  {"CasterSeqId", CORBA::TypeCode::PR_string_tc(0)},
  {"CasterSeqNo", CORBA::TypeCode::PR_long_tc()},
  {"ActionFlag", CORBA::TypeCode::PR_long_tc()},
  {"HeatPlant", _0RL_tc_seqHeatSchedulePlant}
};

static CORBA::TypeCode_ptr _0RL_tc_sHeatSchedule = CORBA::TypeCode::PR_struct_tc("IDL:sHeatSchedule:1.0", "sHeatSchedule", _0RL_structmember_sHeatSchedule, 7);



const CORBA::TypeCode_ptr _tc_sHeatSchedule = _0RL_tc_sHeatSchedule;


















static CORBA::TypeCode_ptr _0RL_tc_seqHeatSchedule = CORBA::TypeCode::PR_alias_tc("IDL:seqHeatSchedule:1.0", "seqHeatSchedule", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sHeatSchedule));


const CORBA::TypeCode_ptr _tc_seqHeatSchedule = _0RL_tc_seqHeatSchedule;

static CORBA::PR_structMember _0RL_structmember_sOrderData[] = {
  {"SteelGradeCode", CORBA::TypeCode::PR_string_tc(0)},
  {"OrderId", CORBA::TypeCode::PR_string_tc(0)},
  {"AimSteelEAF", CORBA::TypeCode::PR_double_tc()},
  {"ActionFlag", CORBA::TypeCode::PR_long_tc()},
  {"AimSteelCCS", CORBA::TypeCode::PR_double_tc()},
  {"SlabDimension", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_sOrderData = CORBA::TypeCode::PR_struct_tc("IDL:sOrderData:1.0", "sOrderData", _0RL_structmember_sOrderData, 6);
const CORBA::TypeCode_ptr _tc_sOrderData = _0RL_tc_sOrderData;






static CORBA::TypeCode_ptr _0RL_tc_seqOrderData = CORBA::TypeCode::PR_alias_tc("IDL:seqOrderData:1.0", "seqOrderData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sOrderData));


const CORBA::TypeCode_ptr _tc_seqOrderData = _0RL_tc_seqOrderData;


static CORBA::PR_structMember _0RL_structmember_sSampleData[] = {
  {"SampleCode", CORBA::TypeCode::PR_string_tc(0)},
  {"SampleTime", _0RL_tc_sDate},
  {"SampleCounter", CORBA::TypeCode::PR_long_tc()},
  {"ProbeType", CORBA::TypeCode::PR_long_tc()},
  {"PlantID", CORBA::TypeCode::PR_string_tc(0)},
  {"ProcessStage", CORBA::TypeCode::PR_string_tc(0)},
  {"SampleId", CORBA::TypeCode::PR_string_tc(0)},
  {"SampleMode", CORBA::TypeCode::PR_string_tc(0)},
  {"SampleLocation", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_sSampleData = CORBA::TypeCode::PR_struct_tc("IDL:sSampleData:1.0", "sSampleData", _0RL_structmember_sSampleData, 9);

const CORBA::TypeCode_ptr _tc_sSampleData = _0RL_tc_sSampleData;










static CORBA::TypeCode_ptr _0RL_tc_seqSampleData = CORBA::TypeCode::PR_alias_tc("IDL:seqSampleData:1.0", "seqSampleData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sSampleData));


const CORBA::TypeCode_ptr _tc_seqSampleData = _0RL_tc_seqSampleData;




static CORBA::PR_structMember _0RL_structmember_sAnalysisData[] = {
  {"SampleData", _0RL_tc_sSampleData},
  {"Analysis", _0RL_tc_seqAnalysis}
};

static CORBA::TypeCode_ptr _0RL_tc_sAnalysisData = CORBA::TypeCode::PR_struct_tc("IDL:sAnalysisData:1.0", "sAnalysisData", _0RL_structmember_sAnalysisData, 2);



const CORBA::TypeCode_ptr _tc_sAnalysisData = _0RL_tc_sAnalysisData;


static CORBA::PR_structMember _0RL_structmember_sHeatData[] = {
  {"Plant", CORBA::TypeCode::PR_string_tc(0)},
  {"HeatId", CORBA::TypeCode::PR_string_tc(0)},
  {"Device", CORBA::TypeCode::PR_string_tc(0)},
  {"TreatId", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_sHeatData = CORBA::TypeCode::PR_struct_tc("IDL:sHeatData:1.0", "sHeatData", _0RL_structmember_sHeatData, 4);
const CORBA::TypeCode_ptr _tc_sHeatData = _0RL_tc_sHeatData;






static CORBA::TypeCode_ptr _0RL_tc_seqHeatData = CORBA::TypeCode::PR_alias_tc("IDL:seqHeatData:1.0", "seqHeatData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sHeatData));


const CORBA::TypeCode_ptr _tc_seqHeatData = _0RL_tc_seqHeatData;


static CORBA::PR_structMember _0RL_structmember_sGasLanceData[] = {
  {"LanceData", _0RL_tc_seqGasData},
  {"Device", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_sGasLanceData = CORBA::TypeCode::PR_struct_tc("IDL:sGasLanceData:1.0", "sGasLanceData", _0RL_structmember_sGasLanceData, 2);

const CORBA::TypeCode_ptr _tc_sGasLanceData = _0RL_tc_sGasLanceData;


static CORBA::PR_structMember _0RL_structmember_sInjectLanceData[] = {
  {"Device", CORBA::TypeCode::PR_string_tc(0)},
  {"LanceVal", CORBA::TypeCode::PR_double_tc()},
  {"MatNumber", CORBA::TypeCode::PR_long_tc()},
  {"ModuleName", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_sInjectLanceData = CORBA::TypeCode::PR_struct_tc("IDL:sInjectLanceData:1.0", "sInjectLanceData", _0RL_structmember_sInjectLanceData, 4);
const CORBA::TypeCode_ptr _tc_sInjectLanceData = _0RL_tc_sInjectLanceData;






static CORBA::TypeCode_ptr _0RL_tc_seqInjectLanceData = CORBA::TypeCode::PR_alias_tc("IDL:seqInjectLanceData:1.0", "seqInjectLanceData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sInjectLanceData));


const CORBA::TypeCode_ptr _tc_seqInjectLanceData = _0RL_tc_seqInjectLanceData;

static CORBA::PR_structMember _0RL_structmember_sInjectLanceMat[] = {
  {"Device", CORBA::TypeCode::PR_string_tc(0)},
  {"LanceMatCode", CORBA::TypeCode::PR_string_tc(0)},
  {"MatNumber", CORBA::TypeCode::PR_long_tc()},
  {"ModuleName", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_sInjectLanceMat = CORBA::TypeCode::PR_struct_tc("IDL:sInjectLanceMat:1.0", "sInjectLanceMat", _0RL_structmember_sInjectLanceMat, 4);
const CORBA::TypeCode_ptr _tc_sInjectLanceMat = _0RL_tc_sInjectLanceMat;






static CORBA::TypeCode_ptr _0RL_tc_seqInjectLanceMat = CORBA::TypeCode::PR_alias_tc("IDL:seqInjectLanceMat:1.0", "seqInjectLanceMat", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sInjectLanceMat));


const CORBA::TypeCode_ptr _tc_seqInjectLanceMat = _0RL_tc_seqInjectLanceMat;


static CORBA::PR_structMember _0RL_structmember_sGasLanceGasAvail[] = {
  {"Device", CORBA::TypeCode::PR_string_tc(0)},
  {"GasAvail", _0RL_tc_seqGasAvail}
};

static CORBA::TypeCode_ptr _0RL_tc_sGasLanceGasAvail = CORBA::TypeCode::PR_struct_tc("IDL:sGasLanceGasAvail:1.0", "sGasLanceGasAvail", _0RL_structmember_sGasLanceGasAvail, 2);

const CORBA::TypeCode_ptr _tc_sGasLanceGasAvail = _0RL_tc_sGasLanceGasAvail;










static CORBA::TypeCode_ptr _0RL_tc_seqGasLanceGasAvail = CORBA::TypeCode::PR_alias_tc("IDL:seqGasLanceGasAvail:1.0", "seqGasLanceGasAvail", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sGasLanceGasAvail));


const CORBA::TypeCode_ptr _tc_seqGasLanceGasAvail = _0RL_tc_seqGasLanceGasAvail;


static CORBA::PR_structMember _0RL_structmember_sBatchPrio[] = {
  {"BatchData", _0RL_tc_sBatch},
  {"ChargPrio", CORBA::TypeCode::PR_long_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sBatchPrio = CORBA::TypeCode::PR_struct_tc("IDL:sBatchPrio:1.0", "sBatchPrio", _0RL_structmember_sBatchPrio, 2);

const CORBA::TypeCode_ptr _tc_sBatchPrio = _0RL_tc_sBatchPrio;










static CORBA::TypeCode_ptr _0RL_tc_seqBatchPrio = CORBA::TypeCode::PR_alias_tc("IDL:seqBatchPrio:1.0", "seqBatchPrio", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sBatchPrio));


const CORBA::TypeCode_ptr _tc_seqBatchPrio = _0RL_tc_seqBatchPrio;









static CORBA::TypeCode_ptr _0RL_tc_seqGasLanceData = CORBA::TypeCode::PR_alias_tc("IDL:seqGasLanceData:1.0", "seqGasLanceData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sGasLanceData));


const CORBA::TypeCode_ptr _tc_seqGasLanceData = _0RL_tc_seqGasLanceData;

















static CORBA::TypeCode_ptr _0RL_tc_seqAnalysisData = CORBA::TypeCode::PR_alias_tc("IDL:seqAnalysisData:1.0", "seqAnalysisData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sAnalysisData));


const CORBA::TypeCode_ptr _tc_seqAnalysisData = _0RL_tc_seqAnalysisData;

static CORBA::PR_structMember _0RL_structmember_LFGlobalSetpoints[] = {
  {"GasType", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_LFGlobalSetpoints = CORBA::TypeCode::PR_struct_tc("IDL:LFGlobalSetpoints:1.0", "LFGlobalSetpoints", _0RL_structmember_LFGlobalSetpoints, 1);
const CORBA::TypeCode_ptr _tc_LFGlobalSetpoints = _0RL_tc_LFGlobalSetpoints;


static CORBA::PR_structMember _0RL_structmember_sLiqMatReport[] = {
  {"LiqMatType", CORBA::TypeCode::PR_long_tc()},
  {"LiqMatWeight", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sLiqMatReport = CORBA::TypeCode::PR_struct_tc("IDL:sLiqMatReport:1.0", "sLiqMatReport", _0RL_structmember_sLiqMatReport, 2);
const CORBA::TypeCode_ptr _tc_sLiqMatReport = _0RL_tc_sLiqMatReport;






static CORBA::TypeCode_ptr _0RL_tc_seqLiqMatReport = CORBA::TypeCode::PR_alias_tc("IDL:seqLiqMatReport:1.0", "seqLiqMatReport", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sLiqMatReport));


const CORBA::TypeCode_ptr _tc_seqLiqMatReport = _0RL_tc_seqLiqMatReport;






static CORBA::PR_structMember _0RL_structmember_sBOFPredBlowRes[] = {
  {"Phase", CORBA::TypeCode::PR_string_tc(0)},
  {"PhaseNo", CORBA::TypeCode::PR_long_tc()},
  {"PhaseActive", CORBA::TypeCode::PR_long_tc()},
  {"O2Vol", CORBA::TypeCode::PR_double_tc()},
  {"TopLanceO2Flow", CORBA::TypeCode::PR_double_tc()},
  {"TopLanceHeight", CORBA::TypeCode::PR_double_tc()},
  {"PorousPlugN2Flow", CORBA::TypeCode::PR_double_tc()},
  {"PorousPlugArFlow", CORBA::TypeCode::PR_double_tc()},
  {"O2MomentPorPlugs", CORBA::TypeCode::PR_double_tc()},
  {"DecarbRate", CORBA::TypeCode::PR_double_tc()},
  {"O2MomentTopLance", CORBA::TypeCode::PR_double_tc()},
  {"GenRes", _0RL_tc_sGenRes}
};

static CORBA::TypeCode_ptr _0RL_tc_sBOFPredBlowRes = CORBA::TypeCode::PR_struct_tc("IDL:sBOFPredBlowRes:1.0", "sBOFPredBlowRes", _0RL_structmember_sBOFPredBlowRes, 12);





const CORBA::TypeCode_ptr _tc_sBOFPredBlowRes = _0RL_tc_sBOFPredBlowRes;


























static CORBA::TypeCode_ptr _0RL_tc_seqBOFBlowPredRes = CORBA::TypeCode::PR_alias_tc("IDL:seqBOFBlowPredRes:1.0", "seqBOFBlowPredRes", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sBOFPredBlowRes));


const CORBA::TypeCode_ptr _tc_seqBOFBlowPredRes = _0RL_tc_seqBOFBlowPredRes;

static CORBA::PR_structMember _0RL_structmember_sInjectData[] = {
  {"InjectMatCode", CORBA::TypeCode::PR_string_tc(0)},
  {"InjectMatValue", CORBA::TypeCode::PR_double_tc()},
  {"InjectType", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_sInjectData = CORBA::TypeCode::PR_struct_tc("IDL:sInjectData:1.0", "sInjectData", _0RL_structmember_sInjectData, 3);
const CORBA::TypeCode_ptr _tc_sInjectData = _0RL_tc_sInjectData;






static CORBA::TypeCode_ptr _0RL_tc_seqInjectData = CORBA::TypeCode::PR_alias_tc("IDL:seqInjectData:1.0", "seqInjectData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sInjectData));


const CORBA::TypeCode_ptr _tc_seqInjectData = _0RL_tc_seqInjectData;



static CORBA::PR_structMember _0RL_structmember_sEAFInjectLance[] = {
  {"Phase", CORBA::TypeCode::PR_string_tc(0)},
  {"BasketNo", CORBA::TypeCode::PR_long_tc()},
  {"Step", CORBA::TypeCode::PR_long_tc()},
  {"DurStep", CORBA::TypeCode::PR_double_tc()},
  {"Egy", CORBA::TypeCode::PR_double_tc()},
  {"RemEgy", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilEndOfStep", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilStartOfStep", CORBA::TypeCode::PR_double_tc()},
  {"SpecEgyStep", CORBA::TypeCode::PR_double_tc()},
  {"ElecEgyStep", CORBA::TypeCode::PR_double_tc()},
  {"SpecEgy", CORBA::TypeCode::PR_double_tc()},
  {"BaseMass", CORBA::TypeCode::PR_double_tc()},
  {"InjectFlow", _0RL_tc_seqInjectData},
  {"InjectAmount", _0RL_tc_seqInjectData}
};

static CORBA::TypeCode_ptr _0RL_tc_sEAFInjectLance = CORBA::TypeCode::PR_struct_tc("IDL:sEAFInjectLance:1.0", "sEAFInjectLance", _0RL_structmember_sEAFInjectLance, 14);


const CORBA::TypeCode_ptr _tc_sEAFInjectLance = _0RL_tc_sEAFInjectLance;














static CORBA::TypeCode_ptr _0RL_tc_seqEAFInjectLance = CORBA::TypeCode::PR_alias_tc("IDL:seqEAFInjectLance:1.0", "seqEAFInjectLance", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sEAFInjectLance));


const CORBA::TypeCode_ptr _tc_seqEAFInjectLance = _0RL_tc_seqEAFInjectLance;

static CORBA::TypeCode_ptr _0RL_tc_DEF_mseqDouble = CORBA::TypeCode::PR_alias_tc("IDL:DEF/seqDouble:1.0", "seqDouble", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc()));





static CORBA::PR_structMember _0RL_structmember_sHMDCalc[] = {
  {"Lime", _0RL_tc_DEF_mseqDouble},
  {"Material", _0RL_tc_seqBatchPrio},
  {"Analysis", _0RL_tc_seqAnalysis},
  {"Carbide", _0RL_tc_DEF_mseqDouble},
  {"Magnesium", _0RL_tc_DEF_mseqDouble}
};

static CORBA::TypeCode_ptr _0RL_tc_sHMDCalc = CORBA::TypeCode::PR_struct_tc("IDL:sHMDCalc:1.0", "sHMDCalc", _0RL_structmember_sHMDCalc, 5);



const CORBA::TypeCode_ptr _tc_sHMDCalc = _0RL_tc_sHMDCalc;


static CORBA::PR_structMember _0RL_structmember_sConArcElecData[] = {
  {"BasketNo", CORBA::TypeCode::PR_long_tc()},
  {"ReactTapNo", CORBA::TypeCode::PR_long_tc()},
  {"TransfTapNo", CORBA::TypeCode::PR_long_tc()},
  {"ArcLenNo", CORBA::TypeCode::PR_long_tc()},
  {"DurUntilEndOfStep", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilStartOfStep", CORBA::TypeCode::PR_double_tc()},
  {"SpecEgyStep", CORBA::TypeCode::PR_double_tc()},
  {"SpecEgy", CORBA::TypeCode::PR_double_tc()},
  {"ElecEgyStep", CORBA::TypeCode::PR_double_tc()},
  {"ElecEgy", CORBA::TypeCode::PR_double_tc()},
  {"EnergyStart", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sConArcElecData = CORBA::TypeCode::PR_struct_tc("IDL:sConArcElecData:1.0", "sConArcElecData", _0RL_structmember_sConArcElecData, 11);
const CORBA::TypeCode_ptr _tc_sConArcElecData = _0RL_tc_sConArcElecData;


static CORBA::PR_structMember _0RL_structmember_sConArcMediaData[] = {
  {"DeviceName", CORBA::TypeCode::PR_string_tc(0)},
  {"DeviceNo", CORBA::TypeCode::PR_long_tc()},
  {"MediaTypeSelect", CORBA::TypeCode::PR_long_tc()},
  {"MediaType", CORBA::TypeCode::PR_string_tc(0)},
  {"Flow", CORBA::TypeCode::PR_double_tc()},
  {"Cons", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sConArcMediaData = CORBA::TypeCode::PR_struct_tc("IDL:sConArcMediaData:1.0", "sConArcMediaData", _0RL_structmember_sConArcMediaData, 6);
const CORBA::TypeCode_ptr _tc_sConArcMediaData = _0RL_tc_sConArcMediaData;






static CORBA::TypeCode_ptr _0RL_tc_seqConArcElecData = CORBA::TypeCode::PR_alias_tc("IDL:seqConArcElecData:1.0", "seqConArcElecData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sConArcElecData));


const CORBA::TypeCode_ptr _tc_seqConArcElecData = _0RL_tc_seqConArcElecData;





static CORBA::TypeCode_ptr _0RL_tc_seqConArcMediaData = CORBA::TypeCode::PR_alias_tc("IDL:seqConArcMediaData:1.0", "seqConArcMediaData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sConArcMediaData));


const CORBA::TypeCode_ptr _tc_seqConArcMediaData = _0RL_tc_seqConArcMediaData;




static CORBA::PR_structMember _0RL_structmember_sConArcSetptData[] = {
  {"EgyTotal", CORBA::TypeCode::PR_double_tc()},
  {"MediaData", _0RL_tc_seqConArcMediaData},
  {"ElecData", _0RL_tc_sConArcElecData},
  {"MatFeedTotalMass", _0RL_tc_seqConArcMediaData}
};

static CORBA::TypeCode_ptr _0RL_tc_sConArcSetptData = CORBA::TypeCode::PR_struct_tc("IDL:sConArcSetptData:1.0", "sConArcSetptData", _0RL_structmember_sConArcSetptData, 4);



const CORBA::TypeCode_ptr _tc_sConArcSetptData = _0RL_tc_sConArcSetptData;




static CORBA::PR_structMember _0RL_structmember_sConArcMeasData[] = {
  {"SlagQuality", CORBA::TypeCode::PR_double_tc()},
  {"MediaData", _0RL_tc_seqConArcMediaData},
  {"ElecData", _0RL_tc_sConArcElecData}
};

static CORBA::TypeCode_ptr _0RL_tc_sConArcMeasData = CORBA::TypeCode::PR_struct_tc("IDL:sConArcMeasData:1.0", "sConArcMeasData", _0RL_structmember_sConArcMeasData, 3);


const CORBA::TypeCode_ptr _tc_sConArcMeasData = _0RL_tc_sConArcMeasData;


















static CORBA::TypeCode_ptr _0RL_tc_seqConArcSetptData = CORBA::TypeCode::PR_alias_tc("IDL:seqConArcSetptData:1.0", "seqConArcSetptData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sConArcSetptData));


const CORBA::TypeCode_ptr _tc_seqConArcSetptData = _0RL_tc_seqConArcSetptData;













static CORBA::TypeCode_ptr _0RL_tc_seqConArcMeasData = CORBA::TypeCode::PR_alias_tc("IDL:seqConArcMeasData:1.0", "seqConArcMeasData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sConArcMeasData));


const CORBA::TypeCode_ptr _tc_seqConArcMeasData = _0RL_tc_seqConArcMeasData;


static CORBA::PR_structMember _0RL_structmember_sEAFMatFeedPredRes[] = {
  {"BasketNo", CORBA::TypeCode::PR_long_tc()},
  {"Step", CORBA::TypeCode::PR_long_tc()},
  {"DurStep", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilStartOfStep", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilEndOfStep", CORBA::TypeCode::PR_double_tc()},
  {"Egy", CORBA::TypeCode::PR_double_tc()},
  {"SpecEgy", CORBA::TypeCode::PR_double_tc()},
  {"ElecEgyStep", CORBA::TypeCode::PR_double_tc()},
  {"BaseMass", CORBA::TypeCode::PR_double_tc()},
  {"MatFeedData", _0RL_tc_seqBatch},
  {"PhaseName", CORBA::TypeCode::PR_string_tc(0)},
  {"SpecEgyStep", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sEAFMatFeedPredRes = CORBA::TypeCode::PR_struct_tc("IDL:sEAFMatFeedPredRes:1.0", "sEAFMatFeedPredRes", _0RL_structmember_sEAFMatFeedPredRes, 12);

const CORBA::TypeCode_ptr _tc_sEAFMatFeedPredRes = _0RL_tc_sEAFMatFeedPredRes;










static CORBA::TypeCode_ptr _0RL_tc_seqEAFMatFeedPredRes = CORBA::TypeCode::PR_alias_tc("IDL:seqEAFMatFeedPredRes:1.0", "seqEAFMatFeedPredRes", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sEAFMatFeedPredRes));


const CORBA::TypeCode_ptr _tc_seqEAFMatFeedPredRes = _0RL_tc_seqEAFMatFeedPredRes;

static CORBA::PR_structMember _0RL_structmember_sPhaseStatus[] = {
  {"PhaseName", CORBA::TypeCode::PR_string_tc(0)},
  {"Status", CORBA::TypeCode::PR_long_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sPhaseStatus = CORBA::TypeCode::PR_struct_tc("IDL:sPhaseStatus:1.0", "sPhaseStatus", _0RL_structmember_sPhaseStatus, 2);
const CORBA::TypeCode_ptr _tc_sPhaseStatus = _0RL_tc_sPhaseStatus;






static CORBA::TypeCode_ptr _0RL_tc_seqPhaseStatus = CORBA::TypeCode::PR_alias_tc("IDL:seqPhaseStatus:1.0", "seqPhaseStatus", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sPhaseStatus));


const CORBA::TypeCode_ptr _tc_seqPhaseStatus = _0RL_tc_seqPhaseStatus;

static CORBA::PR_structMember _0RL_structmember_sMaterial[] = {
  {"MatCode", CORBA::TypeCode::PR_string_tc(0)},
  {"MatWeight", CORBA::TypeCode::PR_double_tc()},
  {"Purpose", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_sMaterial = CORBA::TypeCode::PR_struct_tc("IDL:sMaterial:1.0", "sMaterial", _0RL_structmember_sMaterial, 3);
const CORBA::TypeCode_ptr _tc_sMaterial = _0RL_tc_sMaterial;






static CORBA::TypeCode_ptr _0RL_tc_seqMaterials = CORBA::TypeCode::PR_alias_tc("IDL:seqMaterials:1.0", "seqMaterials", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sMaterial));


const CORBA::TypeCode_ptr _tc_seqMaterials = _0RL_tc_seqMaterials;


static CORBA::PR_structMember _0RL_structmember_sStirringData[] = {
  {"Device", CORBA::TypeCode::PR_string_tc(0)},
  {"GasData", _0RL_tc_seqGasData}
};

static CORBA::TypeCode_ptr _0RL_tc_sStirringData = CORBA::TypeCode::PR_struct_tc("IDL:sStirringData:1.0", "sStirringData", _0RL_structmember_sStirringData, 2);

const CORBA::TypeCode_ptr _tc_sStirringData = _0RL_tc_sStirringData;










static CORBA::TypeCode_ptr _0RL_tc_seqStirringData = CORBA::TypeCode::PR_alias_tc("IDL:seqStirringData:1.0", "seqStirringData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sStirringData));


const CORBA::TypeCode_ptr _tc_seqStirringData = _0RL_tc_seqStirringData;

static CORBA::PR_structMember _0RL_structmember_sProductIdentification[] = {
  {"HeatId", CORBA::TypeCode::PR_string_tc(0)},
  {"TreatId", CORBA::TypeCode::PR_string_tc(0)},
  {"OrderId", CORBA::TypeCode::PR_string_tc(0)},
  {"Plant", CORBA::TypeCode::PR_string_tc(0)}
};

static CORBA::TypeCode_ptr _0RL_tc_sProductIdentification = CORBA::TypeCode::PR_struct_tc("IDL:sProductIdentification:1.0", "sProductIdentification", _0RL_structmember_sProductIdentification, 4);
const CORBA::TypeCode_ptr _tc_sProductIdentification = _0RL_tc_sProductIdentification;









static CORBA::PR_structMember _0RL_structmember_sRecipe[] = {
  {"RecipeName", CORBA::TypeCode::PR_string_tc(0)},
  {"RecipeNo", CORBA::TypeCode::PR_long_tc()},
  {"RecipeSource", CORBA::TypeCode::PR_string_tc(0)},
  {"RecipeContent", _0RL_tc_seqBatchPrio},
  {"TimeStamp", _0RL_tc_sMetTimeStamp},
  {"Product", _0RL_tc_sProductIdentification},
  {"RecipeData", _0RL_tc_sRecipeProperties},
  {"MatFeedRate", CORBA::TypeCode::PR_double_tc()},
  {"O2_Charge_Moment", CORBA::TypeCode::PR_double_tc()},
  {"RecipeName_Model", CORBA::TypeCode::PR_string_tc(0)},
  {"RecipeNo_Model", CORBA::TypeCode::PR_long_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sRecipe = CORBA::TypeCode::PR_struct_tc("IDL:sRecipe:1.0", "sRecipe", _0RL_structmember_sRecipe, 11);







const CORBA::TypeCode_ptr _tc_sRecipe = _0RL_tc_sRecipe;


































static CORBA::TypeCode_ptr _0RL_tc_seqRecipeList = CORBA::TypeCode::PR_alias_tc("IDL:seqRecipeList:1.0", "seqRecipeList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sRecipe));


const CORBA::TypeCode_ptr _tc_seqRecipeList = _0RL_tc_seqRecipeList;





static CORBA::TypeCode_ptr _0RL_tc_seqProductIdentification = CORBA::TypeCode::PR_alias_tc("IDL:seqProductIdentification:1.0", "seqProductIdentification", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sProductIdentification));


const CORBA::TypeCode_ptr _tc_seqProductIdentification = _0RL_tc_seqProductIdentification;

















static CORBA::TypeCode_ptr _0RL_tc_seqHMDCalc = CORBA::TypeCode::PR_alias_tc("IDL:seqHMDCalc:1.0", "seqHMDCalc", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sHMDCalc));


const CORBA::TypeCode_ptr _tc_seqHMDCalc = _0RL_tc_seqHMDCalc;









static CORBA::PR_structMember _0RL_structmember_sHMDModelResult[] = {
  {"TreatmentKind", CORBA::TypeCode::PR_long_tc()},
  {"CalcAmount", _0RL_tc_seqHMDCalc},
  {"CalcFlow", _0RL_tc_seqHMDCalc},
  {"SlagAmount", _0RL_tc_DEF_mseqDouble},
  {"DurationDeslagging", _0RL_tc_DEF_mseqDouble},
  {"TemperatureAfter", _0RL_tc_DEF_mseqDouble},
  {"Cost", _0RL_tc_DEF_mseqDouble},
  {"Duration", _0RL_tc_DEF_mseqDouble},
  {"IWarn", CORBA::TypeCode::PR_long_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sHMDModelResult = CORBA::TypeCode::PR_struct_tc("IDL:sHMDModelResult:1.0", "sHMDModelResult", _0RL_structmember_sHMDModelResult, 9);








const CORBA::TypeCode_ptr _tc_sHMDModelResult = _0RL_tc_sHMDModelResult;











static CORBA::PR_structMember _0RL_structmember_sRHModelResult[] = {
  {"PhaseNo", CORBA::TypeCode::PR_long_tc()},
  {"TotDurPhase", CORBA::TypeCode::PR_double_tc()},
  {"Alloy", _0RL_tc_seqRecipeList},
  {"TempDiffAlloy", CORBA::TypeCode::PR_double_tc()},
  {"Analysis", _0RL_tc_seqAnalysis},
  {"SlagWeight", CORBA::TypeCode::PR_double_tc()},
  {"SteelWeight", CORBA::TypeCode::PR_double_tc()},
  {"PhaseName", CORBA::TypeCode::PR_string_tc(0)},
  {"HeatTemp", CORBA::TypeCode::PR_double_tc()},
  {"TempDiffPassive", CORBA::TypeCode::PR_double_tc()},
  {"OxygenAmount", CORBA::TypeCode::PR_double_tc()},
  {"OxygenFlow", CORBA::TypeCode::PR_double_tc()},
  {"PowderFlow", CORBA::TypeCode::PR_double_tc()},
  {"LanceDist", CORBA::TypeCode::PR_long_tc()},
  {"RemDur", CORBA::TypeCode::PR_double_tc()},
  {"AlHeat", CORBA::TypeCode::PR_double_tc()},
  {"AlAlloy", CORBA::TypeCode::PR_double_tc()},
  {"AlDeox", CORBA::TypeCode::PR_double_tc()},
  {"VacuumPressure", CORBA::TypeCode::PR_double_tc()},
  {"DNTime", CORBA::TypeCode::PR_double_tc()},
  {"DHTime", CORBA::TypeCode::PR_double_tc()},
  {"TempDiffStep", CORBA::TypeCode::PR_double_tc()},
  {"LiftGasFlow", CORBA::TypeCode::PR_double_tc()},
  {"VacCurve", CORBA::TypeCode::PR_long_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sRHModelResult = CORBA::TypeCode::PR_struct_tc("IDL:sRHModelResult:1.0", "sRHModelResult", _0RL_structmember_sRHModelResult, 24);









const CORBA::TypeCode_ptr _tc_sRHModelResult = _0RL_tc_sRHModelResult;










































static CORBA::TypeCode_ptr _0RL_tc_seqRHModelResult = CORBA::TypeCode::PR_alias_tc("IDL:seqRHModelResult:1.0", "seqRHModelResult", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sRHModelResult));


const CORBA::TypeCode_ptr _tc_seqRHModelResult = _0RL_tc_seqRHModelResult;





































static CORBA::TypeCode_ptr _0RL_tc_seqHMDModelResult = CORBA::TypeCode::PR_alias_tc("IDL:seqHMDModelResult:1.0", "seqHMDModelResult", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sHMDModelResult));


const CORBA::TypeCode_ptr _tc_seqHMDModelResult = _0RL_tc_seqHMDModelResult;





static CORBA::PR_structMember _0RL_structmember_sElecPhaseData[] = {
  {"PhaseNo", CORBA::TypeCode::PR_long_tc()},
  {"PhaseName", CORBA::TypeCode::PR_string_tc(0)},
  {"PhaseType", CORBA::TypeCode::PR_long_tc()},
  {"StartTime", _0RL_tc_sDate},
  {"EndTime", _0RL_tc_sDate},
  {"Duration", CORBA::TypeCode::PR_double_tc()},
  {"ElecCons", CORBA::TypeCode::PR_double_tc()},
  {"ElecConsStart", CORBA::TypeCode::PR_double_tc()},
  {"GasData", _0RL_tc_seqGasData},
  {"GasDataStart", _0RL_tc_seqGasData}
};

static CORBA::TypeCode_ptr _0RL_tc_sElecPhaseData = CORBA::TypeCode::PR_struct_tc("IDL:sElecPhaseData:1.0", "sElecPhaseData", _0RL_structmember_sElecPhaseData, 10);




const CORBA::TypeCode_ptr _tc_sElecPhaseData = _0RL_tc_sElecPhaseData;






















static CORBA::TypeCode_ptr _0RL_tc_seqElecPhaseData = CORBA::TypeCode::PR_alias_tc("IDL:seqElecPhaseData:1.0", "seqElecPhaseData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sElecPhaseData));


const CORBA::TypeCode_ptr _tc_seqElecPhaseData = _0RL_tc_seqElecPhaseData;










static CORBA::PR_structMember _0RL_structmember_sVDModelResult[] = {
  {"PhaseNo", CORBA::TypeCode::PR_long_tc()},
  {"PhaseName", CORBA::TypeCode::PR_string_tc(0)},
  {"Analysis", _0RL_tc_seqAnalysis},
  {"SteelWeight", CORBA::TypeCode::PR_double_tc()},
  {"SlagWeight", CORBA::TypeCode::PR_double_tc()},
  {"HeatTemp", CORBA::TypeCode::PR_double_tc()},
  {"TotDurPhase", CORBA::TypeCode::PR_double_tc()},
  {"Alloy", _0RL_tc_seqRecipeList},
  {"TempDiffAlloy", CORBA::TypeCode::PR_double_tc()},
  {"TempDiffStep", CORBA::TypeCode::PR_double_tc()},
  {"TempDiffPassive", CORBA::TypeCode::PR_double_tc()},
  {"RemDur", CORBA::TypeCode::PR_double_tc()},
  {"AlHeat", CORBA::TypeCode::PR_double_tc()},
  {"AlAlloy", CORBA::TypeCode::PR_double_tc()},
  {"AlDeox", CORBA::TypeCode::PR_double_tc()},
  {"DCTime", CORBA::TypeCode::PR_double_tc()},
  {"VacuumPressure", CORBA::TypeCode::PR_double_tc()},
  {"DNTime", CORBA::TypeCode::PR_double_tc()},
  {"DHTime", CORBA::TypeCode::PR_double_tc()},
  {"StirringFlow", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sVDModelResult = CORBA::TypeCode::PR_struct_tc("IDL:sVDModelResult:1.0", "sVDModelResult", _0RL_structmember_sVDModelResult, 20);









const CORBA::TypeCode_ptr _tc_sVDModelResult = _0RL_tc_sVDModelResult;










































static CORBA::TypeCode_ptr _0RL_tc_seqVDModelResult = CORBA::TypeCode::PR_alias_tc("IDL:seqVDModelResult:1.0", "seqVDModelResult", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sVDModelResult));


const CORBA::TypeCode_ptr _tc_seqVDModelResult = _0RL_tc_seqVDModelResult;

static CORBA::PR_structMember _0RL_structmember_sConArcBlowData[] = {
  {"O2MomentEndStep", CORBA::TypeCode::PR_double_tc()},
  {"O2Flow", CORBA::TypeCode::PR_double_tc()},
  {"O2Cons", CORBA::TypeCode::PR_double_tc()},
  {"TopLanceHeight", CORBA::TypeCode::PR_long_tc()},
  {"PorousPlugN2Flow", CORBA::TypeCode::PR_double_tc()},
  {"PorousPlugArFlow", CORBA::TypeCode::PR_double_tc()},
  {"O2Start", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sConArcBlowData = CORBA::TypeCode::PR_struct_tc("IDL:sConArcBlowData:1.0", "sConArcBlowData", _0RL_structmember_sConArcBlowData, 7);
const CORBA::TypeCode_ptr _tc_sConArcBlowData = _0RL_tc_sConArcBlowData;










static CORBA::PR_structMember _0RL_structmember_sConArcModelResult[] = {
  {"Phase", CORBA::TypeCode::PR_string_tc(0)},
  {"PhaseNo", CORBA::TypeCode::PR_long_tc()},
  {"GenRes", _0RL_tc_sGenRes},
  {"BaseMass", CORBA::TypeCode::PR_double_tc()},
  {"PhaseActive", CORBA::TypeCode::PR_long_tc()},
  {"ElectricalData", _0RL_tc_sConArcElecData},
  {"BlowingData", _0RL_tc_sConArcBlowData},
  {"MaterialData", _0RL_tc_seqConArcMediaData},
  {"StepNo", CORBA::TypeCode::PR_long_tc()},
  {"DecarbRate", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sConArcModelResult = CORBA::TypeCode::PR_struct_tc("IDL:sConArcModelResult:1.0", "sConArcModelResult", _0RL_structmember_sConArcModelResult, 10);








const CORBA::TypeCode_ptr _tc_sConArcModelResult = _0RL_tc_sConArcModelResult;



static CORBA::PR_structMember _0RL_structmember_sConArcMediaPredRes[] = {
  {"StepNo", CORBA::TypeCode::PR_long_tc()},
  {"MediaData", _0RL_tc_seqConArcMediaData}
};

static CORBA::TypeCode_ptr _0RL_tc_sConArcMediaPredRes = CORBA::TypeCode::PR_struct_tc("IDL:sConArcMediaPredRes:1.0", "sConArcMediaPredRes", _0RL_structmember_sConArcMediaPredRes, 2);

const CORBA::TypeCode_ptr _tc_sConArcMediaPredRes = _0RL_tc_sConArcMediaPredRes;










static CORBA::TypeCode_ptr _0RL_tc_seqConArcMediaPredRes = CORBA::TypeCode::PR_alias_tc("IDL:seqConArcMediaPredRes:1.0", "seqConArcMediaPredRes", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sConArcMediaPredRes));


const CORBA::TypeCode_ptr _tc_seqConArcMediaPredRes = _0RL_tc_seqConArcMediaPredRes;





static CORBA::TypeCode_ptr _0RL_tc_seqConArcBlowData = CORBA::TypeCode::PR_alias_tc("IDL:seqConArcBlowData:1.0", "seqConArcBlowData", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sConArcBlowData));


const CORBA::TypeCode_ptr _tc_seqConArcBlowData = _0RL_tc_seqConArcBlowData;





































static CORBA::TypeCode_ptr _0RL_tc_seqConArcModelResult = CORBA::TypeCode::PR_alias_tc("IDL:seqConArcModelResult:1.0", "seqConArcModelResult", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sConArcModelResult));


const CORBA::TypeCode_ptr _tc_seqConArcModelResult = _0RL_tc_seqConArcModelResult;

static CORBA::PR_structMember _0RL_structmember_sLTSStirrPredRes[] = {
  {"StirrPhase", CORBA::TypeCode::PR_string_tc(0)},
  {"StirrIntensity", CORBA::TypeCode::PR_long_tc()},
  {"StirrFlow", CORBA::TypeCode::PR_double_tc()},
  {"GasType", CORBA::TypeCode::PR_string_tc(0)},
  {"Priority", CORBA::TypeCode::PR_long_tc()},
  {"DurStep", CORBA::TypeCode::PR_double_tc()},
  {"StirrIntensityCode", CORBA::TypeCode::PR_string_tc(0)},
  {"Enable", CORBA::TypeCode::PR_long_tc()},
  {"Order", CORBA::TypeCode::PR_long_tc()},
  {"isPatternOrActivity", CORBA::TypeCode::PR_long_tc()},
  {"DurUntilEndOfStep", CORBA::TypeCode::PR_double_tc()},
  {"DurUntilStartOfStep", CORBA::TypeCode::PR_double_tc()},
  {"VoltTap", CORBA::TypeCode::PR_long_tc()},
  {"ImpCurve", CORBA::TypeCode::PR_long_tc()},
  {"ElecEgy", CORBA::TypeCode::PR_double_tc()},
  {"SteelMass", CORBA::TypeCode::PR_double_tc()},
  {"SlagMass", CORBA::TypeCode::PR_double_tc()},
  {"Temp", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sLTSStirrPredRes = CORBA::TypeCode::PR_struct_tc("IDL:sLTSStirrPredRes:1.0", "sLTSStirrPredRes", _0RL_structmember_sLTSStirrPredRes, 18);
const CORBA::TypeCode_ptr _tc_sLTSStirrPredRes = _0RL_tc_sLTSStirrPredRes;






static CORBA::TypeCode_ptr _0RL_tc_seqLTSStirrPredRes = CORBA::TypeCode::PR_alias_tc("IDL:seqLTSStirrPredRes:1.0", "seqLTSStirrPredRes", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sLTSStirrPredRes));


const CORBA::TypeCode_ptr _tc_seqLTSStirrPredRes = _0RL_tc_seqLTSStirrPredRes;

static CORBA::PR_structMember _0RL_structmember_sBOFGlobalSetpoints[] = {
  {"O2VolStartMatAddn", CORBA::TypeCode::PR_double_tc()},
  {"O2VolSartMatDynAddn", CORBA::TypeCode::PR_double_tc()},
  {"O2VolStartScrapChute", CORBA::TypeCode::PR_double_tc()},
  {"O2VolSubLance", CORBA::TypeCode::PR_double_tc()},
  {"O2VolTotal", CORBA::TypeCode::PR_double_tc()},
  {"O2VolTotalLance", CORBA::TypeCode::PR_double_tc()},
  {"N2VolTotal", CORBA::TypeCode::PR_double_tc()},
  {"MatFeedRate", CORBA::TypeCode::PR_double_tc()},
  {"MatDynFeedRate", CORBA::TypeCode::PR_double_tc()},
  {"AimTapWeightCalc", CORBA::TypeCode::PR_double_tc()},
  {"DurStartMatAddn", CORBA::TypeCode::PR_double_tc()},
  {"DurSartMatDynAddn", CORBA::TypeCode::PR_double_tc()},
  {"DurStartScrapChute", CORBA::TypeCode::PR_double_tc()},
  {"DurSubLance", CORBA::TypeCode::PR_double_tc()},
  {"O2VolStartMat2ndAddn", CORBA::TypeCode::PR_double_tc()},
  {"DurStartMat2ndAddn", CORBA::TypeCode::PR_double_tc()},
  {"MatFeedRate2ndAdd", CORBA::TypeCode::PR_double_tc()},
  {"AimSteelMassCalc", CORBA::TypeCode::PR_double_tc()},
  {"ReblowCode", CORBA::TypeCode::PR_long_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sBOFGlobalSetpoints = CORBA::TypeCode::PR_struct_tc("IDL:sBOFGlobalSetpoints:1.0", "sBOFGlobalSetpoints", _0RL_structmember_sBOFGlobalSetpoints, 19);
const CORBA::TypeCode_ptr _tc_sBOFGlobalSetpoints = _0RL_tc_sBOFGlobalSetpoints;






static CORBA::TypeCode_ptr _0RL_tc_seqBOFGlobalSetpoints = CORBA::TypeCode::PR_alias_tc("IDL:seqBOFGlobalSetpoints:1.0", "seqBOFGlobalSetpoints", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sBOFGlobalSetpoints));


const CORBA::TypeCode_ptr _tc_seqBOFGlobalSetpoints = _0RL_tc_seqBOFGlobalSetpoints;

static CORBA::PR_structMember _0RL_structmember_sConArcGlobalSetpoints[] = {
  {"O2VolStartMatAddn", CORBA::TypeCode::PR_double_tc()},
  {"O2VolSartMatDynAddn", CORBA::TypeCode::PR_double_tc()},
  {"O2VolStartScrapChute", CORBA::TypeCode::PR_double_tc()},
  {"O2VolSubLance", CORBA::TypeCode::PR_double_tc()},
  {"O2VolTotal", CORBA::TypeCode::PR_double_tc()},
  {"O2VolTotalLance", CORBA::TypeCode::PR_double_tc()},
  {"N2VolTotal", CORBA::TypeCode::PR_double_tc()},
  {"ArVolTotal", CORBA::TypeCode::PR_double_tc()},
  {"MatFeedRate", CORBA::TypeCode::PR_double_tc()},
  {"MatDynFeedRate", CORBA::TypeCode::PR_double_tc()},
  {"AimTapWeightCalc", CORBA::TypeCode::PR_double_tc()},
  {"AimSteelMassCalc", CORBA::TypeCode::PR_double_tc()},
  {"DurStartMatAddn", CORBA::TypeCode::PR_double_tc()},
  {"DurSartMatDynAddn", CORBA::TypeCode::PR_double_tc()},
  {"DurStartScrapChute", CORBA::TypeCode::PR_double_tc()},
  {"DurSubLance", CORBA::TypeCode::PR_double_tc()},
  {"O2VolStartMat2ndAddn", CORBA::TypeCode::PR_double_tc()},
  {"DurStartMat2ndAddn", CORBA::TypeCode::PR_double_tc()},
  {"MatFeedRate2ndAdd", CORBA::TypeCode::PR_double_tc()},
  {"ReblowCode", CORBA::TypeCode::PR_long_tc()},
  {"DRICons", CORBA::TypeCode::PR_double_tc()},
  {"LimeCons", CORBA::TypeCode::PR_double_tc()},
  {"DoloCons", CORBA::TypeCode::PR_double_tc()},
  {"CoalCons", CORBA::TypeCode::PR_double_tc()},
  {"EgyTotal", CORBA::TypeCode::PR_double_tc()}
};

static CORBA::TypeCode_ptr _0RL_tc_sConArcGlobalSetpoints = CORBA::TypeCode::PR_struct_tc("IDL:sConArcGlobalSetpoints:1.0", "sConArcGlobalSetpoints", _0RL_structmember_sConArcGlobalSetpoints, 25);
const CORBA::TypeCode_ptr _tc_sConArcGlobalSetpoints = _0RL_tc_sConArcGlobalSetpoints;






static CORBA::TypeCode_ptr _0RL_tc_seqConArcGlobalSetpoints = CORBA::TypeCode::PR_alias_tc("IDL:seqConArcGlobalSetpoints:1.0", "seqConArcGlobalSetpoints", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_sConArcGlobalSetpoints));


const CORBA::TypeCode_ptr _tc_seqConArcGlobalSetpoints = _0RL_tc_seqConArcGlobalSetpoints;

const CORBA::TypeCode_ptr _tc_iSMC_DataProvider = CORBA::TypeCode::PR_interface_tc("IDL:iSMC_DataProvider:1.0", "iSMC_DataProvider");

void _0RL_delete_sAnalysis(void* _data) {
  sAnalysis* _0RL_t = (sAnalysis*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sAnalysis(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sAnalysis*)_desc->opq_struct)->Element);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sAnalysis*)_desc->opq_struct)->Concentration);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sAnalysis(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_csAnalysis(tcDescriptor &_desc, const sAnalysis& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sAnalysis;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sAnalysis;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sAnalysis& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csAnalysis(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sAnalysis, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sAnalysis* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csAnalysis(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sAnalysis, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sAnalysis*& _sp) {
  return _a >>= (const sAnalysis*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sAnalysis*& _sp) {
  _sp = (sAnalysis *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sAnalysis;
    _0RL_buildDesc_csAnalysis(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sAnalysis, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sAnalysis);
      return 1;
    } else {
      delete (sAnalysis *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sAnalysis)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sBatch(void* _data) {
  sBatch* _0RL_t = (sBatch*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sBatch(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sBatch*)_desc->opq_struct)->MatCode);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sBatch*)_desc->opq_struct)->Mass);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((sBatch*)_desc->opq_struct)->MatFeedSpeed);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sBatch(const tcStructDesc *_desc)
{
  return 3;
}

void _0RL_buildDesc_csBatch(tcDescriptor &_desc, const sBatch& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sBatch;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sBatch;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sBatch& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csBatch(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sBatch, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sBatch* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csBatch(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sBatch, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sBatch*& _sp) {
  return _a >>= (const sBatch*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sBatch*& _sp) {
  _sp = (sBatch *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sBatch;
    _0RL_buildDesc_csBatch(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sBatch, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sBatch);
      return 1;
    } else {
      delete (sBatch *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sBatch)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sEAFBurnerPredRes(void* _data) {
  sEAFBurnerPredRes* _0RL_t = (sEAFBurnerPredRes*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sEAFBurnerPredRes(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sEAFBurnerPredRes*)_desc->opq_struct)->Phase);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sEAFBurnerPredRes*)_desc->opq_struct)->BasketNo);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((sEAFBurnerPredRes*)_desc->opq_struct)->Step);
    return 1;
  case 3:
    _0RL_buildDesc_clong(_newdesc, ((sEAFBurnerPredRes*)_desc->opq_struct)->BurnerNo);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFBurnerPredRes*)_desc->opq_struct)->GasFlow);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFBurnerPredRes*)_desc->opq_struct)->DurStep);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFBurnerPredRes*)_desc->opq_struct)->SpecEgy);
    return 1;
  case 7:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFBurnerPredRes*)_desc->opq_struct)->ElecEgy);
    return 1;
  case 8:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFBurnerPredRes*)_desc->opq_struct)->O2Flow);
    return 1;
  case 9:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFBurnerPredRes*)_desc->opq_struct)->ElecEgyStep);
    return 1;
  case 10:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFBurnerPredRes*)_desc->opq_struct)->DurUntilEndOfStep);
    return 1;
  case 11:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFBurnerPredRes*)_desc->opq_struct)->DurUntilStartOfStep);
    return 1;
  case 12:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFBurnerPredRes*)_desc->opq_struct)->SpecEgyStep);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sEAFBurnerPredRes(const tcStructDesc *_desc)
{
  return 13;
}

void _0RL_buildDesc_csEAFBurnerPredRes(tcDescriptor &_desc, const sEAFBurnerPredRes& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sEAFBurnerPredRes;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sEAFBurnerPredRes;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sEAFBurnerPredRes& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csEAFBurnerPredRes(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sEAFBurnerPredRes, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sEAFBurnerPredRes* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csEAFBurnerPredRes(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sEAFBurnerPredRes, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sEAFBurnerPredRes*& _sp) {
  return _a >>= (const sEAFBurnerPredRes*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sEAFBurnerPredRes*& _sp) {
  _sp = (sEAFBurnerPredRes *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sEAFBurnerPredRes;
    _0RL_buildDesc_csEAFBurnerPredRes(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sEAFBurnerPredRes, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sEAFBurnerPredRes);
      return 1;
    } else {
      delete (sEAFBurnerPredRes *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sEAFBurnerPredRes)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sEAFElecPredRes(void* _data) {
  sEAFElecPredRes* _0RL_t = (sEAFElecPredRes*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sEAFElecPredRes(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sEAFElecPredRes*)_desc->opq_struct)->Phase);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sEAFElecPredRes*)_desc->opq_struct)->BasketNo);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((sEAFElecPredRes*)_desc->opq_struct)->Step);
    return 1;
  case 3:
    _0RL_buildDesc_clong(_newdesc, ((sEAFElecPredRes*)_desc->opq_struct)->VoltTap);
    return 1;
  case 4:
    _0RL_buildDesc_clong(_newdesc, ((sEAFElecPredRes*)_desc->opq_struct)->ImpCurve);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFElecPredRes*)_desc->opq_struct)->DurStep);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFElecPredRes*)_desc->opq_struct)->Temp);
    return 1;
  case 7:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFElecPredRes*)_desc->opq_struct)->DurUntilEndOfStep);
    return 1;
  case 8:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFElecPredRes*)_desc->opq_struct)->DurUntilStartOfStep);
    return 1;
  case 9:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFElecPredRes*)_desc->opq_struct)->SpecEgyStep);
    return 1;
  case 10:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFElecPredRes*)_desc->opq_struct)->SpecEgy);
    return 1;
  case 11:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFElecPredRes*)_desc->opq_struct)->ElecEgyStep);
    return 1;
  case 12:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFElecPredRes*)_desc->opq_struct)->ElecEgy);
    return 1;
  case 13:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFElecPredRes*)_desc->opq_struct)->BaseMass);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sEAFElecPredRes(const tcStructDesc *_desc)
{
  return 14;
}

void _0RL_buildDesc_csEAFElecPredRes(tcDescriptor &_desc, const sEAFElecPredRes& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sEAFElecPredRes;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sEAFElecPredRes;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sEAFElecPredRes& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csEAFElecPredRes(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sEAFElecPredRes, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sEAFElecPredRes* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csEAFElecPredRes(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sEAFElecPredRes, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sEAFElecPredRes*& _sp) {
  return _a >>= (const sEAFElecPredRes*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sEAFElecPredRes*& _sp) {
  _sp = (sEAFElecPredRes *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sEAFElecPredRes;
    _0RL_buildDesc_csEAFElecPredRes(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sEAFElecPredRes, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sEAFElecPredRes);
      return 1;
    } else {
      delete (sEAFElecPredRes *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sEAFElecPredRes)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sLFElecPredRes(void* _data) {
  sLFElecPredRes* _0RL_t = (sLFElecPredRes*) _data;
  delete _0RL_t;
}

extern void _0RL_buildDesc_cMCBS_mCBS__LocalTime(tcDescriptor &, const MCBS::CBS_LocalTime&);

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sLFElecPredRes(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_clong(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->Step);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->VoltTap);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->ImpCurve);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->ElecEgy);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->SpecEgy);
    return 1;
  case 5:
    _0RL_buildDesc_clong(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->StirrIntensity);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->StirrFlow);
    return 1;
  case 7:
    _0RL_buildDesc_cstring(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->GasType);
    return 1;
  case 8:
    _0RL_buildDesc_clong(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->Priority);
    return 1;
  case 9:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->DurStep);
    return 1;
  case 10:
    _0RL_buildDesc_clong(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->Enable);
    return 1;
  case 11:
    _0RL_buildDesc_clong(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->Order);
    return 1;
  case 12:
    _0RL_buildDesc_cMCBS_mCBS__LocalTime(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->RevDate);
    return 1;
  case 13:
    _0RL_buildDesc_cstring(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->StirrIntensityCode);
    return 1;
  case 14:
    _0RL_buildDesc_cstring(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->ElecPhase);
    return 1;
  case 15:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->ElecEgyStep);
    return 1;
  case 16:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->DurUntilEndOfStep);
    return 1;
  case 17:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->DurUntilStartOfStep);
    return 1;
  case 18:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFElecPredRes*)_desc->opq_struct)->BaseMass);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sLFElecPredRes(const tcStructDesc *_desc)
{
  return 19;
}

void _0RL_buildDesc_csLFElecPredRes(tcDescriptor &_desc, const sLFElecPredRes& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sLFElecPredRes;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sLFElecPredRes;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sLFElecPredRes& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csLFElecPredRes(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sLFElecPredRes, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sLFElecPredRes* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csLFElecPredRes(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sLFElecPredRes, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sLFElecPredRes*& _sp) {
  return _a >>= (const sLFElecPredRes*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sLFElecPredRes*& _sp) {
  _sp = (sLFElecPredRes *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sLFElecPredRes;
    _0RL_buildDesc_csLFElecPredRes(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sLFElecPredRes, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sLFElecPredRes);
      return 1;
    } else {
      delete (sLFElecPredRes *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sLFElecPredRes)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sLFStirrPredRes(void* _data) {
  sLFStirrPredRes* _0RL_t = (sLFStirrPredRes*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sLFStirrPredRes(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->StirrPhase);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->StirrIntensity);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->StirrFlow);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->GasType);
    return 1;
  case 4:
    _0RL_buildDesc_clong(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->Priority);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->DurStep);
    return 1;
  case 6:
    _0RL_buildDesc_cstring(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->StirrIntensityCode);
    return 1;
  case 7:
    _0RL_buildDesc_clong(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->Enable);
    return 1;
  case 8:
    _0RL_buildDesc_clong(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->Order);
    return 1;
  case 9:
    _0RL_buildDesc_clong(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->isPatternOrActivity);
    return 1;
  case 10:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->DurUntilEndOfStep);
    return 1;
  case 11:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->DurUntilStartOfStep);
    return 1;
  case 12:
    _0RL_buildDesc_clong(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->VoltTap);
    return 1;
  case 13:
    _0RL_buildDesc_clong(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->ImpCurve);
    return 1;
  case 14:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->ElecEgy);
    return 1;
  case 15:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->SteelMass);
    return 1;
  case 16:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->SlagMass);
    return 1;
  case 17:
    _0RL_buildDesc_cdouble(_newdesc, ((sLFStirrPredRes*)_desc->opq_struct)->Temp);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sLFStirrPredRes(const tcStructDesc *_desc)
{
  return 18;
}

void _0RL_buildDesc_csLFStirrPredRes(tcDescriptor &_desc, const sLFStirrPredRes& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sLFStirrPredRes;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sLFStirrPredRes;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sLFStirrPredRes& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csLFStirrPredRes(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sLFStirrPredRes, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sLFStirrPredRes* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csLFStirrPredRes(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sLFStirrPredRes, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sLFStirrPredRes*& _sp) {
  return _a >>= (const sLFStirrPredRes*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sLFStirrPredRes*& _sp) {
  _sp = (sLFStirrPredRes *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sLFStirrPredRes;
    _0RL_buildDesc_csLFStirrPredRes(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sLFStirrPredRes, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sLFStirrPredRes);
      return 1;
    } else {
      delete (sLFStirrPredRes *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sLFStirrPredRes)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sMetTimeStamp(void* _data) {
  sMetTimeStamp* _0RL_t = (sMetTimeStamp*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sMetTimeStamp(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cdouble(_newdesc, ((sMetTimeStamp*)_desc->opq_struct)->O2_Moment);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sMetTimeStamp*)_desc->opq_struct)->Ar_Moment);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((sMetTimeStamp*)_desc->opq_struct)->N2_Moment);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sMetTimeStamp*)_desc->opq_struct)->Elec_Moment);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sMetTimeStamp*)_desc->opq_struct)->DurSinceHeatAnnouncement);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sMetTimeStamp*)_desc->opq_struct)->DurSinceStartOfHeat);
    return 1;
  case 6:
    _0RL_buildDesc_cMCBS_mCBS__LocalTime(_newdesc, ((sMetTimeStamp*)_desc->opq_struct)->RevDate);
    return 1;
  case 7:
    _0RL_buildDesc_cMCBS_mCBS__LocalTime(_newdesc, ((sMetTimeStamp*)_desc->opq_struct)->ActionDate);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sMetTimeStamp(const tcStructDesc *_desc)
{
  return 8;
}

void _0RL_buildDesc_csMetTimeStamp(tcDescriptor &_desc, const sMetTimeStamp& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sMetTimeStamp;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sMetTimeStamp;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sMetTimeStamp& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csMetTimeStamp(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sMetTimeStamp, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sMetTimeStamp* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csMetTimeStamp(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sMetTimeStamp, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sMetTimeStamp*& _sp) {
  return _a >>= (const sMetTimeStamp*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sMetTimeStamp*& _sp) {
  _sp = (sMetTimeStamp *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sMetTimeStamp;
    _0RL_buildDesc_csMetTimeStamp(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sMetTimeStamp, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sMetTimeStamp);
      return 1;
    } else {
      delete (sMetTimeStamp *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sMetTimeStamp)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sRecipeProperties(void* _data) {
  sRecipeProperties* _0RL_t = (sRecipeProperties*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sRecipeProperties(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_clong(_newdesc, ((sRecipeProperties*)_desc->opq_struct)->RecipeStatus);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sRecipeProperties*)_desc->opq_struct)->HomogDuration);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((sRecipeProperties*)_desc->opq_struct)->TotalMass);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sRecipeProperties*)_desc->opq_struct)->BulkVolume);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sRecipeProperties(const tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_csRecipeProperties(tcDescriptor &_desc, const sRecipeProperties& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sRecipeProperties;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sRecipeProperties;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sRecipeProperties& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csRecipeProperties(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sRecipeProperties, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sRecipeProperties* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csRecipeProperties(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sRecipeProperties, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sRecipeProperties*& _sp) {
  return _a >>= (const sRecipeProperties*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sRecipeProperties*& _sp) {
  _sp = (sRecipeProperties *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sRecipeProperties;
    _0RL_buildDesc_csRecipeProperties(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sRecipeProperties, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sRecipeProperties);
      return 1;
    } else {
      delete (sRecipeProperties *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sRecipeProperties)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csAnalysis__
#define __0RL_tcParser_buildDesc_s0_csAnalysis__
static void
_0RL_tcParser_setElementCount_s0_csAnalysis(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sAnalysis > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csAnalysis(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sAnalysis > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csAnalysis(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csAnalysis(_newdesc, (*((_CORBA_Unbounded_Sequence< sAnalysis > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csAnalysis(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sAnalysis > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csAnalysis;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csAnalysis;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csAnalysis;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqAnalysis& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csAnalysis(tcdesc, _s);
  _a.PR_packFrom(_tc_seqAnalysis, &tcdesc);
}

void _0RL_seq_delete_seqAnalysis(void* _data)
{
  delete (seqAnalysis*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqAnalysis*& _s_out)
{
  return _a >>= (const seqAnalysis*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqAnalysis*& _s_out)
{
  _s_out = 0;
  seqAnalysis* stmp = (seqAnalysis*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqAnalysis;
    _0RL_buildDesc_s0_csAnalysis(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqAnalysis, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqAnalysis);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqAnalysis *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqAnalysis) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csBatch__
#define __0RL_tcParser_buildDesc_s0_csBatch__
static void
_0RL_tcParser_setElementCount_s0_csBatch(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sBatch > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csBatch(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sBatch > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csBatch(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csBatch(_newdesc, (*((_CORBA_Unbounded_Sequence< sBatch > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csBatch(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sBatch > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csBatch;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csBatch;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csBatch;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqBatch& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csBatch(tcdesc, _s);
  _a.PR_packFrom(_tc_seqBatch, &tcdesc);
}

void _0RL_seq_delete_seqBatch(void* _data)
{
  delete (seqBatch*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqBatch*& _s_out)
{
  return _a >>= (const seqBatch*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqBatch*& _s_out)
{
  _s_out = 0;
  seqBatch* stmp = (seqBatch*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqBatch;
    _0RL_buildDesc_s0_csBatch(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqBatch, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqBatch);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqBatch *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqBatch) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sEAFMatFeed(void* _data) {
  sEAFMatFeed* _0RL_t = (sEAFMatFeed*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sEAFMatFeed(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sEAFMatFeed*)_desc->opq_struct)->Phase);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sEAFMatFeed*)_desc->opq_struct)->BasketNo);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((sEAFMatFeed*)_desc->opq_struct)->Step);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFMatFeed*)_desc->opq_struct)->DurStep);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFMatFeed*)_desc->opq_struct)->SpecEgy);
    return 1;
  case 5:
    _0RL_buildDesc_s0_csBatch(_newdesc, ((sEAFMatFeed*)_desc->opq_struct)->MatFeed);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sEAFMatFeed(const tcStructDesc *_desc)
{
  return 6;
}

void _0RL_buildDesc_csEAFMatFeed(tcDescriptor &_desc, const sEAFMatFeed& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sEAFMatFeed;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sEAFMatFeed;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sEAFMatFeed& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csEAFMatFeed(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sEAFMatFeed, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sEAFMatFeed* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csEAFMatFeed(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sEAFMatFeed, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sEAFMatFeed*& _sp) {
  return _a >>= (const sEAFMatFeed*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sEAFMatFeed*& _sp) {
  _sp = (sEAFMatFeed *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sEAFMatFeed;
    _0RL_buildDesc_csEAFMatFeed(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sEAFMatFeed, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sEAFMatFeed);
      return 1;
    } else {
      delete (sEAFMatFeed *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sEAFMatFeed)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csEAFBurnerPredRes__
#define __0RL_tcParser_buildDesc_s0_csEAFBurnerPredRes__
static void
_0RL_tcParser_setElementCount_s0_csEAFBurnerPredRes(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sEAFBurnerPredRes > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csEAFBurnerPredRes(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sEAFBurnerPredRes > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csEAFBurnerPredRes(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csEAFBurnerPredRes(_newdesc, (*((_CORBA_Unbounded_Sequence< sEAFBurnerPredRes > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csEAFBurnerPredRes(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sEAFBurnerPredRes > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csEAFBurnerPredRes;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csEAFBurnerPredRes;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csEAFBurnerPredRes;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqEAFBurnerPredRes& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csEAFBurnerPredRes(tcdesc, _s);
  _a.PR_packFrom(_tc_seqEAFBurnerPredRes, &tcdesc);
}

void _0RL_seq_delete_seqEAFBurnerPredRes(void* _data)
{
  delete (seqEAFBurnerPredRes*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqEAFBurnerPredRes*& _s_out)
{
  return _a >>= (const seqEAFBurnerPredRes*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqEAFBurnerPredRes*& _s_out)
{
  _s_out = 0;
  seqEAFBurnerPredRes* stmp = (seqEAFBurnerPredRes*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqEAFBurnerPredRes;
    _0RL_buildDesc_s0_csEAFBurnerPredRes(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqEAFBurnerPredRes, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqEAFBurnerPredRes);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqEAFBurnerPredRes *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqEAFBurnerPredRes) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csEAFElecPredRes__
#define __0RL_tcParser_buildDesc_s0_csEAFElecPredRes__
static void
_0RL_tcParser_setElementCount_s0_csEAFElecPredRes(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sEAFElecPredRes > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csEAFElecPredRes(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sEAFElecPredRes > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csEAFElecPredRes(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csEAFElecPredRes(_newdesc, (*((_CORBA_Unbounded_Sequence< sEAFElecPredRes > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csEAFElecPredRes(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sEAFElecPredRes > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csEAFElecPredRes;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csEAFElecPredRes;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csEAFElecPredRes;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqEAFElecPredRes& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csEAFElecPredRes(tcdesc, _s);
  _a.PR_packFrom(_tc_seqEAFElecPredRes, &tcdesc);
}

void _0RL_seq_delete_seqEAFElecPredRes(void* _data)
{
  delete (seqEAFElecPredRes*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqEAFElecPredRes*& _s_out)
{
  return _a >>= (const seqEAFElecPredRes*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqEAFElecPredRes*& _s_out)
{
  _s_out = 0;
  seqEAFElecPredRes* stmp = (seqEAFElecPredRes*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqEAFElecPredRes;
    _0RL_buildDesc_s0_csEAFElecPredRes(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqEAFElecPredRes, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqEAFElecPredRes);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqEAFElecPredRes *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqEAFElecPredRes) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csEAFMatFeed__
#define __0RL_tcParser_buildDesc_s0_csEAFMatFeed__
static void
_0RL_tcParser_setElementCount_s0_csEAFMatFeed(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sEAFMatFeed > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csEAFMatFeed(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sEAFMatFeed > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csEAFMatFeed(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csEAFMatFeed(_newdesc, (*((_CORBA_Unbounded_Sequence< sEAFMatFeed > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csEAFMatFeed(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sEAFMatFeed > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csEAFMatFeed;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csEAFMatFeed;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csEAFMatFeed;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqEAFMatFeed& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csEAFMatFeed(tcdesc, _s);
  _a.PR_packFrom(_tc_seqEAFMatFeed, &tcdesc);
}

void _0RL_seq_delete_seqEAFMatFeed(void* _data)
{
  delete (seqEAFMatFeed*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqEAFMatFeed*& _s_out)
{
  return _a >>= (const seqEAFMatFeed*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqEAFMatFeed*& _s_out)
{
  _s_out = 0;
  seqEAFMatFeed* stmp = (seqEAFMatFeed*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqEAFMatFeed;
    _0RL_buildDesc_s0_csEAFMatFeed(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqEAFMatFeed, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqEAFMatFeed);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqEAFMatFeed *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqEAFMatFeed) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csLFElecPredRes__
#define __0RL_tcParser_buildDesc_s0_csLFElecPredRes__
static void
_0RL_tcParser_setElementCount_s0_csLFElecPredRes(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sLFElecPredRes > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csLFElecPredRes(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sLFElecPredRes > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csLFElecPredRes(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csLFElecPredRes(_newdesc, (*((_CORBA_Unbounded_Sequence< sLFElecPredRes > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csLFElecPredRes(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sLFElecPredRes > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csLFElecPredRes;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csLFElecPredRes;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csLFElecPredRes;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqLFElecPredRes& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csLFElecPredRes(tcdesc, _s);
  _a.PR_packFrom(_tc_seqLFElecPredRes, &tcdesc);
}

void _0RL_seq_delete_seqLFElecPredRes(void* _data)
{
  delete (seqLFElecPredRes*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqLFElecPredRes*& _s_out)
{
  return _a >>= (const seqLFElecPredRes*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqLFElecPredRes*& _s_out)
{
  _s_out = 0;
  seqLFElecPredRes* stmp = (seqLFElecPredRes*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqLFElecPredRes;
    _0RL_buildDesc_s0_csLFElecPredRes(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqLFElecPredRes, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqLFElecPredRes);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqLFElecPredRes *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqLFElecPredRes) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csLFStirrPredRes__
#define __0RL_tcParser_buildDesc_s0_csLFStirrPredRes__
static void
_0RL_tcParser_setElementCount_s0_csLFStirrPredRes(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sLFStirrPredRes > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csLFStirrPredRes(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sLFStirrPredRes > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csLFStirrPredRes(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csLFStirrPredRes(_newdesc, (*((_CORBA_Unbounded_Sequence< sLFStirrPredRes > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csLFStirrPredRes(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sLFStirrPredRes > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csLFStirrPredRes;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csLFStirrPredRes;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csLFStirrPredRes;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqLFStirrPredRes& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csLFStirrPredRes(tcdesc, _s);
  _a.PR_packFrom(_tc_seqLFStirrPredRes, &tcdesc);
}

void _0RL_seq_delete_seqLFStirrPredRes(void* _data)
{
  delete (seqLFStirrPredRes*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqLFStirrPredRes*& _s_out)
{
  return _a >>= (const seqLFStirrPredRes*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqLFStirrPredRes*& _s_out)
{
  _s_out = 0;
  seqLFStirrPredRes* stmp = (seqLFStirrPredRes*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqLFStirrPredRes;
    _0RL_buildDesc_s0_csLFStirrPredRes(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqLFStirrPredRes, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqLFStirrPredRes);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqLFStirrPredRes *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqLFStirrPredRes) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sAODGlobalSetpoints(void* _data) {
  sAODGlobalSetpoints* _0RL_t = (sAODGlobalSetpoints*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sAODGlobalSetpoints(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->O2VolStartMatAddn);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->O2VolStartScrapChute);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->O2VolSubLance);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->O2VolTotal);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->O2VolTotalLance);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->N2VolTotal);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->MatFeedRate);
    return 1;
  case 7:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->MatDynFeedRate);
    return 1;
  case 8:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->O2VolSartMatDynAddn);
    return 1;
  case 9:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->AimTapWeightCalc);
    return 1;
  case 10:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->DurStartMatAddn);
    return 1;
  case 11:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->DurSartMatDynAddn);
    return 1;
  case 12:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->DurStartScrapChute);
    return 1;
  case 13:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->DurSubLance);
    return 1;
  case 14:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->O2VolStartMat2ndAddn);
    return 1;
  case 15:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->DurStartMat2ndAddn);
    return 1;
  case 16:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->MatFeedRate2ndAdd);
    return 1;
  case 17:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->O2VolSwN2toAr);
    return 1;
  case 18:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->DurUntilN2ToAr);
    return 1;
  case 19:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->N2VolSwN2toAr);
    return 1;
  case 20:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODGlobalSetpoints*)_desc->opq_struct)->AimSteelMassCalc);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sAODGlobalSetpoints(const tcStructDesc *_desc)
{
  return 21;
}

void _0RL_buildDesc_csAODGlobalSetpoints(tcDescriptor &_desc, const sAODGlobalSetpoints& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sAODGlobalSetpoints;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sAODGlobalSetpoints;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sAODGlobalSetpoints& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csAODGlobalSetpoints(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sAODGlobalSetpoints, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sAODGlobalSetpoints* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csAODGlobalSetpoints(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sAODGlobalSetpoints, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sAODGlobalSetpoints*& _sp) {
  return _a >>= (const sAODGlobalSetpoints*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sAODGlobalSetpoints*& _sp) {
  _sp = (sAODGlobalSetpoints *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sAODGlobalSetpoints;
    _0RL_buildDesc_csAODGlobalSetpoints(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sAODGlobalSetpoints, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sAODGlobalSetpoints);
      return 1;
    } else {
      delete (sAODGlobalSetpoints *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sAODGlobalSetpoints)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csAODGlobalSetpoints__
#define __0RL_tcParser_buildDesc_s0_csAODGlobalSetpoints__
static void
_0RL_tcParser_setElementCount_s0_csAODGlobalSetpoints(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sAODGlobalSetpoints > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csAODGlobalSetpoints(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sAODGlobalSetpoints > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csAODGlobalSetpoints(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csAODGlobalSetpoints(_newdesc, (*((_CORBA_Unbounded_Sequence< sAODGlobalSetpoints > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csAODGlobalSetpoints(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sAODGlobalSetpoints > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csAODGlobalSetpoints;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csAODGlobalSetpoints;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csAODGlobalSetpoints;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqAODGlobalSetpoints& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csAODGlobalSetpoints(tcdesc, _s);
  _a.PR_packFrom(_tc_seqAODGlobalSetpoints, &tcdesc);
}

void _0RL_seq_delete_seqAODGlobalSetpoints(void* _data)
{
  delete (seqAODGlobalSetpoints*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqAODGlobalSetpoints*& _s_out)
{
  return _a >>= (const seqAODGlobalSetpoints*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqAODGlobalSetpoints*& _s_out)
{
  _s_out = 0;
  seqAODGlobalSetpoints* stmp = (seqAODGlobalSetpoints*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqAODGlobalSetpoints;
    _0RL_buildDesc_s0_csAODGlobalSetpoints(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqAODGlobalSetpoints, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqAODGlobalSetpoints);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqAODGlobalSetpoints *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqAODGlobalSetpoints) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sGenRes(void* _data) {
  sGenRes* _0RL_t = (sGenRes*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sGenRes(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_s0_csAnalysis(_newdesc, ((sGenRes*)_desc->opq_struct)->Analysis);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sGenRes*)_desc->opq_struct)->SteelWeight);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((sGenRes*)_desc->opq_struct)->SlagWeight);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sGenRes*)_desc->opq_struct)->Temp);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sGenRes*)_desc->opq_struct)->DurPhase);
    return 1;
  case 5:
    _0RL_buildDesc_csMetTimeStamp(_newdesc, ((sGenRes*)_desc->opq_struct)->MetTimeStamp);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sGenRes(const tcStructDesc *_desc)
{
  return 6;
}

void _0RL_buildDesc_csGenRes(tcDescriptor &_desc, const sGenRes& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sGenRes;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sGenRes;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sGenRes& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csGenRes(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sGenRes, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sGenRes* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csGenRes(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sGenRes, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sGenRes*& _sp) {
  return _a >>= (const sGenRes*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sGenRes*& _sp) {
  _sp = (sGenRes *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sGenRes;
    _0RL_buildDesc_csGenRes(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sGenRes, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sGenRes);
      return 1;
    } else {
      delete (sGenRes *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sGenRes)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sAODPredBlowRes(void* _data) {
  sAODPredBlowRes* _0RL_t = (sAODPredBlowRes*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sAODPredBlowRes(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sAODPredBlowRes*)_desc->opq_struct)->Phase);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sAODPredBlowRes*)_desc->opq_struct)->PhaseNo);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODPredBlowRes*)_desc->opq_struct)->O2Vol);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODPredBlowRes*)_desc->opq_struct)->TopLanceO2Flow);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODPredBlowRes*)_desc->opq_struct)->TopLanceN2Flow);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODPredBlowRes*)_desc->opq_struct)->TopLanceArFlow);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODPredBlowRes*)_desc->opq_struct)->TuyerO2Flow);
    return 1;
  case 7:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODPredBlowRes*)_desc->opq_struct)->TuyerN2Flow);
    return 1;
  case 8:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODPredBlowRes*)_desc->opq_struct)->TuyerArFlow);
    return 1;
  case 9:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODPredBlowRes*)_desc->opq_struct)->DecarbRate);
    return 1;
  case 10:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODPredBlowRes*)_desc->opq_struct)->ChromDeslagRate);
    return 1;
  case 11:
    _0RL_buildDesc_cdouble(_newdesc, ((sAODPredBlowRes*)_desc->opq_struct)->TopLanceHeight);
    return 1;
  case 12:
    _0RL_buildDesc_clong(_newdesc, ((sAODPredBlowRes*)_desc->opq_struct)->PhaseActive);
    return 1;
  case 13:
    _0RL_buildDesc_csGenRes(_newdesc, ((sAODPredBlowRes*)_desc->opq_struct)->GenRes);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sAODPredBlowRes(const tcStructDesc *_desc)
{
  return 14;
}

void _0RL_buildDesc_csAODPredBlowRes(tcDescriptor &_desc, const sAODPredBlowRes& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sAODPredBlowRes;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sAODPredBlowRes;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sAODPredBlowRes& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csAODPredBlowRes(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sAODPredBlowRes, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sAODPredBlowRes* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csAODPredBlowRes(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sAODPredBlowRes, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sAODPredBlowRes*& _sp) {
  return _a >>= (const sAODPredBlowRes*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sAODPredBlowRes*& _sp) {
  _sp = (sAODPredBlowRes *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sAODPredBlowRes;
    _0RL_buildDesc_csAODPredBlowRes(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sAODPredBlowRes, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sAODPredBlowRes);
      return 1;
    } else {
      delete (sAODPredBlowRes *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sAODPredBlowRes)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sPredRes(void* _data) {
  sPredRes* _0RL_t = (sPredRes*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sPredRes(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sPredRes*)_desc->opq_struct)->Phase);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sPredRes*)_desc->opq_struct)->PhaseNo);
    return 1;
  case 2:
    _0RL_buildDesc_csGenRes(_newdesc, ((sPredRes*)_desc->opq_struct)->GenRes);
    return 1;
  case 3:
    _0RL_buildDesc_clong(_newdesc, ((sPredRes*)_desc->opq_struct)->PhaseActive);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sPredRes(const tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_csPredRes(tcDescriptor &_desc, const sPredRes& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sPredRes;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sPredRes;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sPredRes& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csPredRes(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sPredRes, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sPredRes* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csPredRes(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sPredRes, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sPredRes*& _sp) {
  return _a >>= (const sPredRes*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sPredRes*& _sp) {
  _sp = (sPredRes *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sPredRes;
    _0RL_buildDesc_csPredRes(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sPredRes, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sPredRes);
      return 1;
    } else {
      delete (sPredRes *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sPredRes)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csAODPredBlowRes__
#define __0RL_tcParser_buildDesc_s0_csAODPredBlowRes__
static void
_0RL_tcParser_setElementCount_s0_csAODPredBlowRes(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sAODPredBlowRes > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csAODPredBlowRes(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sAODPredBlowRes > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csAODPredBlowRes(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csAODPredBlowRes(_newdesc, (*((_CORBA_Unbounded_Sequence< sAODPredBlowRes > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csAODPredBlowRes(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sAODPredBlowRes > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csAODPredBlowRes;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csAODPredBlowRes;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csAODPredBlowRes;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqAODBlowPredRes& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csAODPredBlowRes(tcdesc, _s);
  _a.PR_packFrom(_tc_seqAODBlowPredRes, &tcdesc);
}

void _0RL_seq_delete_seqAODBlowPredRes(void* _data)
{
  delete (seqAODBlowPredRes*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqAODBlowPredRes*& _s_out)
{
  return _a >>= (const seqAODBlowPredRes*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqAODBlowPredRes*& _s_out)
{
  _s_out = 0;
  seqAODBlowPredRes* stmp = (seqAODBlowPredRes*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqAODBlowPredRes;
    _0RL_buildDesc_s0_csAODPredBlowRes(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqAODBlowPredRes, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqAODBlowPredRes);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqAODBlowPredRes *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqAODBlowPredRes) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csPredRes__
#define __0RL_tcParser_buildDesc_s0_csPredRes__
static void
_0RL_tcParser_setElementCount_s0_csPredRes(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sPredRes > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csPredRes(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sPredRes > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csPredRes(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csPredRes(_newdesc, (*((_CORBA_Unbounded_Sequence< sPredRes > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csPredRes(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sPredRes > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csPredRes;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csPredRes;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csPredRes;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqPredRes& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csPredRes(tcdesc, _s);
  _a.PR_packFrom(_tc_seqPredRes, &tcdesc);
}

void _0RL_seq_delete_seqPredRes(void* _data)
{
  delete (seqPredRes*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqPredRes*& _s_out)
{
  return _a >>= (const seqPredRes*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqPredRes*& _s_out)
{
  _s_out = 0;
  seqPredRes* stmp = (seqPredRes*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqPredRes;
    _0RL_buildDesc_s0_csPredRes(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqPredRes, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqPredRes);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqPredRes *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqPredRes) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sCoolWater(void* _data) {
  sCoolWater* _0RL_t = (sCoolWater*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sCoolWater(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cdouble(_newdesc, ((sCoolWater*)_desc->opq_struct)->WaterFlow);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sCoolWater*)_desc->opq_struct)->OutletTemp);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((sCoolWater*)_desc->opq_struct)->InletTemp);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sCoolWater(const tcStructDesc *_desc)
{
  return 3;
}

void _0RL_buildDesc_csCoolWater(tcDescriptor &_desc, const sCoolWater& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sCoolWater;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sCoolWater;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sCoolWater& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csCoolWater(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sCoolWater, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sCoolWater* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csCoolWater(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sCoolWater, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sCoolWater*& _sp) {
  return _a >>= (const sCoolWater*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sCoolWater*& _sp) {
  _sp = (sCoolWater *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sCoolWater;
    _0RL_buildDesc_csCoolWater(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sCoolWater, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sCoolWater);
      return 1;
    } else {
      delete (sCoolWater *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sCoolWater)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sComputerMode(void* _data) {
  sComputerMode* _0RL_t = (sComputerMode*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sComputerMode(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sComputerMode*)_desc->opq_struct)->Device);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sComputerMode*)_desc->opq_struct)->Status);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sComputerMode(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_csComputerMode(tcDescriptor &_desc, const sComputerMode& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sComputerMode;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sComputerMode;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sComputerMode& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csComputerMode(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sComputerMode, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sComputerMode* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csComputerMode(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sComputerMode, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sComputerMode*& _sp) {
  return _a >>= (const sComputerMode*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sComputerMode*& _sp) {
  _sp = (sComputerMode *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sComputerMode;
    _0RL_buildDesc_csComputerMode(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sComputerMode, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sComputerMode);
      return 1;
    } else {
      delete (sComputerMode *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sComputerMode)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sCoolWaterDevice(void* _data) {
  sCoolWaterDevice* _0RL_t = (sCoolWaterDevice*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sCoolWaterDevice(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_clong(_newdesc, ((sCoolWaterDevice*)_desc->opq_struct)->CoolWaterDeviceNo);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((sCoolWaterDevice*)_desc->opq_struct)->CoolWaterDevice);
    return 1;
  case 2:
    _0RL_buildDesc_csCoolWater(_newdesc, ((sCoolWaterDevice*)_desc->opq_struct)->CoolWaterData);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sCoolWaterDevice(const tcStructDesc *_desc)
{
  return 3;
}

void _0RL_buildDesc_csCoolWaterDevice(tcDescriptor &_desc, const sCoolWaterDevice& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sCoolWaterDevice;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sCoolWaterDevice;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sCoolWaterDevice& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csCoolWaterDevice(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sCoolWaterDevice, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sCoolWaterDevice* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csCoolWaterDevice(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sCoolWaterDevice, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sCoolWaterDevice*& _sp) {
  return _a >>= (const sCoolWaterDevice*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sCoolWaterDevice*& _sp) {
  _sp = (sCoolWaterDevice *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sCoolWaterDevice;
    _0RL_buildDesc_csCoolWaterDevice(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sCoolWaterDevice, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sCoolWaterDevice);
      return 1;
    } else {
      delete (sCoolWaterDevice *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sCoolWaterDevice)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csCoolWaterDevice__
#define __0RL_tcParser_buildDesc_s0_csCoolWaterDevice__
static void
_0RL_tcParser_setElementCount_s0_csCoolWaterDevice(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sCoolWaterDevice > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csCoolWaterDevice(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sCoolWaterDevice > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csCoolWaterDevice(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csCoolWaterDevice(_newdesc, (*((_CORBA_Unbounded_Sequence< sCoolWaterDevice > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csCoolWaterDevice(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sCoolWaterDevice > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csCoolWaterDevice;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csCoolWaterDevice;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csCoolWaterDevice;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqCoolWaterData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csCoolWaterDevice(tcdesc, _s);
  _a.PR_packFrom(_tc_seqCoolWaterData, &tcdesc);
}

void _0RL_seq_delete_seqCoolWaterData(void* _data)
{
  delete (seqCoolWaterData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqCoolWaterData*& _s_out)
{
  return _a >>= (const seqCoolWaterData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqCoolWaterData*& _s_out)
{
  _s_out = 0;
  seqCoolWaterData* stmp = (seqCoolWaterData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqCoolWaterData;
    _0RL_buildDesc_s0_csCoolWaterDevice(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqCoolWaterData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqCoolWaterData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqCoolWaterData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqCoolWaterData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csComputerMode__
#define __0RL_tcParser_buildDesc_s0_csComputerMode__
static void
_0RL_tcParser_setElementCount_s0_csComputerMode(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sComputerMode > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csComputerMode(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sComputerMode > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csComputerMode(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csComputerMode(_newdesc, (*((_CORBA_Unbounded_Sequence< sComputerMode > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csComputerMode(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sComputerMode > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csComputerMode;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csComputerMode;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csComputerMode;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqComputerModes& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csComputerMode(tcdesc, _s);
  _a.PR_packFrom(_tc_seqComputerModes, &tcdesc);
}

void _0RL_seq_delete_seqComputerModes(void* _data)
{
  delete (seqComputerModes*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqComputerModes*& _s_out)
{
  return _a >>= (const seqComputerModes*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqComputerModes*& _s_out)
{
  _s_out = 0;
  seqComputerModes* stmp = (seqComputerModes*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqComputerModes;
    _0RL_buildDesc_s0_csComputerMode(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqComputerModes, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqComputerModes);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqComputerModes *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqComputerModes) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sWireFeeder(void* _data) {
  sWireFeeder* _0RL_t = (sWireFeeder*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sWireFeeder(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_clong(_newdesc, ((sWireFeeder*)_desc->opq_struct)->WireFeederLineNo);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((sWireFeeder*)_desc->opq_struct)->WireFeederMatCode);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((sWireFeeder*)_desc->opq_struct)->WireFeedSpeed);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sWireFeeder*)_desc->opq_struct)->WireFeederAmount);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sWireFeeder(const tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_csWireFeeder(tcDescriptor &_desc, const sWireFeeder& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sWireFeeder;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sWireFeeder;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sWireFeeder& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csWireFeeder(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sWireFeeder, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sWireFeeder* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csWireFeeder(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sWireFeeder, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sWireFeeder*& _sp) {
  return _a >>= (const sWireFeeder*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sWireFeeder*& _sp) {
  _sp = (sWireFeeder *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sWireFeeder;
    _0RL_buildDesc_csWireFeeder(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sWireFeeder, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sWireFeeder);
      return 1;
    } else {
      delete (sWireFeeder *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sWireFeeder)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csWireFeeder__
#define __0RL_tcParser_buildDesc_s0_csWireFeeder__
static void
_0RL_tcParser_setElementCount_s0_csWireFeeder(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sWireFeeder > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csWireFeeder(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sWireFeeder > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csWireFeeder(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csWireFeeder(_newdesc, (*((_CORBA_Unbounded_Sequence< sWireFeeder > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csWireFeeder(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sWireFeeder > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csWireFeeder;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csWireFeeder;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csWireFeeder;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqWireFeeder& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csWireFeeder(tcdesc, _s);
  _a.PR_packFrom(_tc_seqWireFeeder, &tcdesc);
}

void _0RL_seq_delete_seqWireFeeder(void* _data)
{
  delete (seqWireFeeder*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqWireFeeder*& _s_out)
{
  return _a >>= (const seqWireFeeder*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqWireFeeder*& _s_out)
{
  _s_out = 0;
  seqWireFeeder* stmp = (seqWireFeeder*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqWireFeeder;
    _0RL_buildDesc_s0_csWireFeeder(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqWireFeeder, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqWireFeeder);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqWireFeeder *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqWireFeeder) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_cstring__
#define __0RL_tcParser_buildDesc_s0_cstring__
static void
_0RL_tcParser_setElementCount_s0_cstring(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_String*)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cstring(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_String*)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cstring(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_cstring(_newdesc, (*((_CORBA_Unbounded_Sequence_String*)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_cstring(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_String& _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cstring;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cstring;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cstring;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqStringList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_cstring(tcdesc, _s);
  _a.PR_packFrom(_tc_seqStringList, &tcdesc);
}

void _0RL_seq_delete_seqStringList(void* _data)
{
  delete (seqStringList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqStringList*& _s_out)
{
  return _a >>= (const seqStringList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqStringList*& _s_out)
{
  _s_out = 0;
  seqStringList* stmp = (seqStringList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqStringList;
    _0RL_buildDesc_s0_cstring(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqStringList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqStringList);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqStringList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqStringList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sGasData(void* _data) {
  sGasData* _0RL_t = (sGasData*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sGasData(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sGasData*)_desc->opq_struct)->GasType);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sGasData*)_desc->opq_struct)->GasValue);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sGasData(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_csGasData(tcDescriptor &_desc, const sGasData& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sGasData;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sGasData;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sGasData& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csGasData(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sGasData, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sGasData* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csGasData(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sGasData, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sGasData*& _sp) {
  return _a >>= (const sGasData*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sGasData*& _sp) {
  _sp = (sGasData *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sGasData;
    _0RL_buildDesc_csGasData(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sGasData, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sGasData);
      return 1;
    } else {
      delete (sGasData *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sGasData)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csGasData__
#define __0RL_tcParser_buildDesc_s0_csGasData__
static void
_0RL_tcParser_setElementCount_s0_csGasData(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sGasData > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csGasData(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sGasData > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csGasData(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csGasData(_newdesc, (*((_CORBA_Unbounded_Sequence< sGasData > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csGasData(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sGasData > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csGasData;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csGasData;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csGasData;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqGasData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csGasData(tcdesc, _s);
  _a.PR_packFrom(_tc_seqGasData, &tcdesc);
}

void _0RL_seq_delete_seqGasData(void* _data)
{
  delete (seqGasData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqGasData*& _s_out)
{
  return _a >>= (const seqGasData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqGasData*& _s_out)
{
  _s_out = 0;
  seqGasData* stmp = (seqGasData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqGasData;
    _0RL_buildDesc_s0_csGasData(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqGasData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqGasData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqGasData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqGasData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sEAFGasLancePredRes(void* _data) {
  sEAFGasLancePredRes* _0RL_t = (sEAFGasLancePredRes*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sEAFGasLancePredRes(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sEAFGasLancePredRes*)_desc->opq_struct)->Phase);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sEAFGasLancePredRes*)_desc->opq_struct)->BasketNo);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((sEAFGasLancePredRes*)_desc->opq_struct)->Step);
    return 1;
  case 3:
    _0RL_buildDesc_clong(_newdesc, ((sEAFGasLancePredRes*)_desc->opq_struct)->LanceNo);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFGasLancePredRes*)_desc->opq_struct)->DurStep);
    return 1;
  case 5:
    _0RL_buildDesc_s0_csGasData(_newdesc, ((sEAFGasLancePredRes*)_desc->opq_struct)->GasFlow);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFGasLancePredRes*)_desc->opq_struct)->Egy);
    return 1;
  case 7:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFGasLancePredRes*)_desc->opq_struct)->DurUntilEndOfStep);
    return 1;
  case 8:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFGasLancePredRes*)_desc->opq_struct)->DurUntilStartOfStep);
    return 1;
  case 9:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFGasLancePredRes*)_desc->opq_struct)->SpecEgyStep);
    return 1;
  case 10:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFGasLancePredRes*)_desc->opq_struct)->ElecEgyStep);
    return 1;
  case 11:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFGasLancePredRes*)_desc->opq_struct)->SpecEgy);
    return 1;
  case 12:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFGasLancePredRes*)_desc->opq_struct)->BaseMass);
    return 1;
  case 13:
    _0RL_buildDesc_s0_csGasData(_newdesc, ((sEAFGasLancePredRes*)_desc->opq_struct)->GasAmount);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sEAFGasLancePredRes(const tcStructDesc *_desc)
{
  return 14;
}

void _0RL_buildDesc_csEAFGasLancePredRes(tcDescriptor &_desc, const sEAFGasLancePredRes& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sEAFGasLancePredRes;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sEAFGasLancePredRes;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sEAFGasLancePredRes& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csEAFGasLancePredRes(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sEAFGasLancePredRes, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sEAFGasLancePredRes* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csEAFGasLancePredRes(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sEAFGasLancePredRes, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sEAFGasLancePredRes*& _sp) {
  return _a >>= (const sEAFGasLancePredRes*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sEAFGasLancePredRes*& _sp) {
  _sp = (sEAFGasLancePredRes *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sEAFGasLancePredRes;
    _0RL_buildDesc_csEAFGasLancePredRes(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sEAFGasLancePredRes, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sEAFGasLancePredRes);
      return 1;
    } else {
      delete (sEAFGasLancePredRes *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sEAFGasLancePredRes)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csEAFGasLancePredRes__
#define __0RL_tcParser_buildDesc_s0_csEAFGasLancePredRes__
static void
_0RL_tcParser_setElementCount_s0_csEAFGasLancePredRes(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sEAFGasLancePredRes > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csEAFGasLancePredRes(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sEAFGasLancePredRes > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csEAFGasLancePredRes(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csEAFGasLancePredRes(_newdesc, (*((_CORBA_Unbounded_Sequence< sEAFGasLancePredRes > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csEAFGasLancePredRes(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sEAFGasLancePredRes > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csEAFGasLancePredRes;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csEAFGasLancePredRes;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csEAFGasLancePredRes;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqEAFGasLancePredRes& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csEAFGasLancePredRes(tcdesc, _s);
  _a.PR_packFrom(_tc_seqEAFGasLancePredRes, &tcdesc);
}

void _0RL_seq_delete_seqEAFGasLancePredRes(void* _data)
{
  delete (seqEAFGasLancePredRes*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqEAFGasLancePredRes*& _s_out)
{
  return _a >>= (const seqEAFGasLancePredRes*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqEAFGasLancePredRes*& _s_out)
{
  _s_out = 0;
  seqEAFGasLancePredRes* stmp = (seqEAFGasLancePredRes*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqEAFGasLancePredRes;
    _0RL_buildDesc_s0_csEAFGasLancePredRes(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqEAFGasLancePredRes, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqEAFGasLancePredRes);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqEAFGasLancePredRes *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqEAFGasLancePredRes) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sGasAvail(void* _data) {
  sGasAvail* _0RL_t = (sGasAvail*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sGasAvail(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sGasAvail*)_desc->opq_struct)->GasType);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sGasAvail*)_desc->opq_struct)->GasAvail);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sGasAvail(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_csGasAvail(tcDescriptor &_desc, const sGasAvail& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sGasAvail;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sGasAvail;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sGasAvail& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csGasAvail(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sGasAvail, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sGasAvail* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csGasAvail(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sGasAvail, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sGasAvail*& _sp) {
  return _a >>= (const sGasAvail*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sGasAvail*& _sp) {
  _sp = (sGasAvail *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sGasAvail;
    _0RL_buildDesc_csGasAvail(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sGasAvail, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sGasAvail);
      return 1;
    } else {
      delete (sGasAvail *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sGasAvail)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csGasAvail__
#define __0RL_tcParser_buildDesc_s0_csGasAvail__
static void
_0RL_tcParser_setElementCount_s0_csGasAvail(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sGasAvail > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csGasAvail(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sGasAvail > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csGasAvail(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csGasAvail(_newdesc, (*((_CORBA_Unbounded_Sequence< sGasAvail > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csGasAvail(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sGasAvail > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csGasAvail;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csGasAvail;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csGasAvail;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqGasAvail& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csGasAvail(tcdesc, _s);
  _a.PR_packFrom(_tc_seqGasAvail, &tcdesc);
}

void _0RL_seq_delete_seqGasAvail(void* _data)
{
  delete (seqGasAvail*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqGasAvail*& _s_out)
{
  return _a >>= (const seqGasAvail*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqGasAvail*& _s_out)
{
  _s_out = 0;
  seqGasAvail* stmp = (seqGasAvail*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqGasAvail;
    _0RL_buildDesc_s0_csGasAvail(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqGasAvail, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqGasAvail);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqGasAvail *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqGasAvail) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sWasteGas(void* _data) {
  sWasteGas* _0RL_t = (sWasteGas*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sWasteGas(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sWasteGas*)_desc->opq_struct)->WasteGasType);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sWasteGas*)_desc->opq_struct)->WasteGasConc);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sWasteGas(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_csWasteGas(tcDescriptor &_desc, const sWasteGas& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sWasteGas;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sWasteGas;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sWasteGas& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csWasteGas(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sWasteGas, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sWasteGas* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csWasteGas(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sWasteGas, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sWasteGas*& _sp) {
  return _a >>= (const sWasteGas*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sWasteGas*& _sp) {
  _sp = (sWasteGas *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sWasteGas;
    _0RL_buildDesc_csWasteGas(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sWasteGas, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sWasteGas);
      return 1;
    } else {
      delete (sWasteGas *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sWasteGas)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csWasteGas__
#define __0RL_tcParser_buildDesc_s0_csWasteGas__
static void
_0RL_tcParser_setElementCount_s0_csWasteGas(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sWasteGas > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csWasteGas(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sWasteGas > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csWasteGas(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csWasteGas(_newdesc, (*((_CORBA_Unbounded_Sequence< sWasteGas > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csWasteGas(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sWasteGas > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csWasteGas;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csWasteGas;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csWasteGas;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqWasteGas& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csWasteGas(tcdesc, _s);
  _a.PR_packFrom(_tc_seqWasteGas, &tcdesc);
}

void _0RL_seq_delete_seqWasteGas(void* _data)
{
  delete (seqWasteGas*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqWasteGas*& _s_out)
{
  return _a >>= (const seqWasteGas*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqWasteGas*& _s_out)
{
  _s_out = 0;
  seqWasteGas* stmp = (seqWasteGas*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqWasteGas;
    _0RL_buildDesc_s0_csWasteGas(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqWasteGas, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqWasteGas);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqWasteGas *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqWasteGas) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sBlowStatus(void* _data) {
  sBlowStatus* _0RL_t = (sBlowStatus*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sBlowStatus(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sBlowStatus*)_desc->opq_struct)->BlowDevice);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sBlowStatus*)_desc->opq_struct)->BlowStatus);
    return 1;
  case 2:
    _0RL_buildDesc_cMCBS_mCBS__LocalTime(_newdesc, ((sBlowStatus*)_desc->opq_struct)->BlowTime);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sBlowStatus(const tcStructDesc *_desc)
{
  return 3;
}

void _0RL_buildDesc_csBlowStatus(tcDescriptor &_desc, const sBlowStatus& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sBlowStatus;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sBlowStatus;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sBlowStatus& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csBlowStatus(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sBlowStatus, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sBlowStatus* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csBlowStatus(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sBlowStatus, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sBlowStatus*& _sp) {
  return _a >>= (const sBlowStatus*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sBlowStatus*& _sp) {
  _sp = (sBlowStatus *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sBlowStatus;
    _0RL_buildDesc_csBlowStatus(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sBlowStatus, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sBlowStatus);
      return 1;
    } else {
      delete (sBlowStatus *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sBlowStatus)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csBlowStatus__
#define __0RL_tcParser_buildDesc_s0_csBlowStatus__
static void
_0RL_tcParser_setElementCount_s0_csBlowStatus(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sBlowStatus > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csBlowStatus(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sBlowStatus > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csBlowStatus(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csBlowStatus(_newdesc, (*((_CORBA_Unbounded_Sequence< sBlowStatus > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csBlowStatus(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sBlowStatus > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csBlowStatus;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csBlowStatus;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csBlowStatus;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqBlowStatus& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csBlowStatus(tcdesc, _s);
  _a.PR_packFrom(_tc_seqBlowStatus, &tcdesc);
}

void _0RL_seq_delete_seqBlowStatus(void* _data)
{
  delete (seqBlowStatus*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqBlowStatus*& _s_out)
{
  return _a >>= (const seqBlowStatus*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqBlowStatus*& _s_out)
{
  _s_out = 0;
  seqBlowStatus* stmp = (seqBlowStatus*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqBlowStatus;
    _0RL_buildDesc_s0_csBlowStatus(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqBlowStatus, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqBlowStatus);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqBlowStatus *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqBlowStatus) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sStatus(void* _data) {
  sStatus* _0RL_t = (sStatus*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sStatus(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sStatus*)_desc->opq_struct)->Device);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sStatus*)_desc->opq_struct)->Status);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((sStatus*)_desc->opq_struct)->StatusName);
    return 1;
  case 3:
    _0RL_buildDesc_cMCBS_mCBS__LocalTime(_newdesc, ((sStatus*)_desc->opq_struct)->EndTime);
    return 1;
  case 4:
    _0RL_buildDesc_cMCBS_mCBS__LocalTime(_newdesc, ((sStatus*)_desc->opq_struct)->StartTime);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sStatus(const tcStructDesc *_desc)
{
  return 5;
}

void _0RL_buildDesc_csStatus(tcDescriptor &_desc, const sStatus& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sStatus;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sStatus;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sStatus& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csStatus(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sStatus, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sStatus* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csStatus(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sStatus, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sStatus*& _sp) {
  return _a >>= (const sStatus*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sStatus*& _sp) {
  _sp = (sStatus *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sStatus;
    _0RL_buildDesc_csStatus(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sStatus, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sStatus);
      return 1;
    } else {
      delete (sStatus *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sStatus)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csStatus__
#define __0RL_tcParser_buildDesc_s0_csStatus__
static void
_0RL_tcParser_setElementCount_s0_csStatus(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sStatus > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csStatus(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sStatus > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csStatus(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csStatus(_newdesc, (*((_CORBA_Unbounded_Sequence< sStatus > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csStatus(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sStatus > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csStatus;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csStatus;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csStatus;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqStatus& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csStatus(tcdesc, _s);
  _a.PR_packFrom(_tc_seqStatus, &tcdesc);
}

void _0RL_seq_delete_seqStatus(void* _data)
{
  delete (seqStatus*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqStatus*& _s_out)
{
  return _a >>= (const seqStatus*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqStatus*& _s_out)
{
  _s_out = 0;
  seqStatus* stmp = (seqStatus*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqStatus;
    _0RL_buildDesc_s0_csStatus(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqStatus, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqStatus);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqStatus *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqStatus) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sHeatSchedulePlant(void* _data) {
  sHeatSchedulePlant* _0RL_t = (sHeatSchedulePlant*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sHeatSchedulePlant(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sHeatSchedulePlant*)_desc->opq_struct)->Plant);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((sHeatSchedulePlant*)_desc->opq_struct)->TreatID);
    return 1;
  case 2:
    _0RL_buildDesc_cMCBS_mCBS__LocalTime(_newdesc, ((sHeatSchedulePlant*)_desc->opq_struct)->TreatStartPlan);
    return 1;
  case 3:
    _0RL_buildDesc_cMCBS_mCBS__LocalTime(_newdesc, ((sHeatSchedulePlant*)_desc->opq_struct)->TreatEndPlan);
    return 1;
  case 4:
    _0RL_buildDesc_clong(_newdesc, ((sHeatSchedulePlant*)_desc->opq_struct)->PlantNo);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sHeatSchedulePlant(const tcStructDesc *_desc)
{
  return 5;
}

void _0RL_buildDesc_csHeatSchedulePlant(tcDescriptor &_desc, const sHeatSchedulePlant& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sHeatSchedulePlant;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sHeatSchedulePlant;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sHeatSchedulePlant& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csHeatSchedulePlant(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sHeatSchedulePlant, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sHeatSchedulePlant* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csHeatSchedulePlant(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sHeatSchedulePlant, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sHeatSchedulePlant*& _sp) {
  return _a >>= (const sHeatSchedulePlant*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sHeatSchedulePlant*& _sp) {
  _sp = (sHeatSchedulePlant *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sHeatSchedulePlant;
    _0RL_buildDesc_csHeatSchedulePlant(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sHeatSchedulePlant, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sHeatSchedulePlant);
      return 1;
    } else {
      delete (sHeatSchedulePlant *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sHeatSchedulePlant)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csHeatSchedulePlant__
#define __0RL_tcParser_buildDesc_s0_csHeatSchedulePlant__
static void
_0RL_tcParser_setElementCount_s0_csHeatSchedulePlant(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sHeatSchedulePlant > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csHeatSchedulePlant(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sHeatSchedulePlant > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csHeatSchedulePlant(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csHeatSchedulePlant(_newdesc, (*((_CORBA_Unbounded_Sequence< sHeatSchedulePlant > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csHeatSchedulePlant(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sHeatSchedulePlant > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csHeatSchedulePlant;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csHeatSchedulePlant;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csHeatSchedulePlant;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqHeatSchedulePlant& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csHeatSchedulePlant(tcdesc, _s);
  _a.PR_packFrom(_tc_seqHeatSchedulePlant, &tcdesc);
}

void _0RL_seq_delete_seqHeatSchedulePlant(void* _data)
{
  delete (seqHeatSchedulePlant*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqHeatSchedulePlant*& _s_out)
{
  return _a >>= (const seqHeatSchedulePlant*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqHeatSchedulePlant*& _s_out)
{
  _s_out = 0;
  seqHeatSchedulePlant* stmp = (seqHeatSchedulePlant*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqHeatSchedulePlant;
    _0RL_buildDesc_s0_csHeatSchedulePlant(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqHeatSchedulePlant, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqHeatSchedulePlant);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqHeatSchedulePlant *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqHeatSchedulePlant) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sHeatSchedule(void* _data) {
  sHeatSchedule* _0RL_t = (sHeatSchedule*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sHeatSchedule(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sHeatSchedule*)_desc->opq_struct)->HeatId);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((sHeatSchedule*)_desc->opq_struct)->OrderId);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((sHeatSchedule*)_desc->opq_struct)->RouteCode);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((sHeatSchedule*)_desc->opq_struct)->CasterSeqId);
    return 1;
  case 4:
    _0RL_buildDesc_clong(_newdesc, ((sHeatSchedule*)_desc->opq_struct)->CasterSeqNo);
    return 1;
  case 5:
    _0RL_buildDesc_clong(_newdesc, ((sHeatSchedule*)_desc->opq_struct)->ActionFlag);
    return 1;
  case 6:
    _0RL_buildDesc_s0_csHeatSchedulePlant(_newdesc, ((sHeatSchedule*)_desc->opq_struct)->HeatPlant);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sHeatSchedule(const tcStructDesc *_desc)
{
  return 7;
}

void _0RL_buildDesc_csHeatSchedule(tcDescriptor &_desc, const sHeatSchedule& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sHeatSchedule;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sHeatSchedule;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sHeatSchedule& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csHeatSchedule(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sHeatSchedule, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sHeatSchedule* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csHeatSchedule(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sHeatSchedule, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sHeatSchedule*& _sp) {
  return _a >>= (const sHeatSchedule*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sHeatSchedule*& _sp) {
  _sp = (sHeatSchedule *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sHeatSchedule;
    _0RL_buildDesc_csHeatSchedule(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sHeatSchedule, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sHeatSchedule);
      return 1;
    } else {
      delete (sHeatSchedule *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sHeatSchedule)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csHeatSchedule__
#define __0RL_tcParser_buildDesc_s0_csHeatSchedule__
static void
_0RL_tcParser_setElementCount_s0_csHeatSchedule(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sHeatSchedule > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csHeatSchedule(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sHeatSchedule > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csHeatSchedule(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csHeatSchedule(_newdesc, (*((_CORBA_Unbounded_Sequence< sHeatSchedule > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csHeatSchedule(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sHeatSchedule > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csHeatSchedule;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csHeatSchedule;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csHeatSchedule;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqHeatSchedule& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csHeatSchedule(tcdesc, _s);
  _a.PR_packFrom(_tc_seqHeatSchedule, &tcdesc);
}

void _0RL_seq_delete_seqHeatSchedule(void* _data)
{
  delete (seqHeatSchedule*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqHeatSchedule*& _s_out)
{
  return _a >>= (const seqHeatSchedule*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqHeatSchedule*& _s_out)
{
  _s_out = 0;
  seqHeatSchedule* stmp = (seqHeatSchedule*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqHeatSchedule;
    _0RL_buildDesc_s0_csHeatSchedule(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqHeatSchedule, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqHeatSchedule);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqHeatSchedule *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqHeatSchedule) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sOrderData(void* _data) {
  sOrderData* _0RL_t = (sOrderData*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sOrderData(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sOrderData*)_desc->opq_struct)->SteelGradeCode);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((sOrderData*)_desc->opq_struct)->OrderId);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((sOrderData*)_desc->opq_struct)->AimSteelEAF);
    return 1;
  case 3:
    _0RL_buildDesc_clong(_newdesc, ((sOrderData*)_desc->opq_struct)->ActionFlag);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sOrderData*)_desc->opq_struct)->AimSteelCCS);
    return 1;
  case 5:
    _0RL_buildDesc_cstring(_newdesc, ((sOrderData*)_desc->opq_struct)->SlabDimension);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sOrderData(const tcStructDesc *_desc)
{
  return 6;
}

void _0RL_buildDesc_csOrderData(tcDescriptor &_desc, const sOrderData& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sOrderData;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sOrderData;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sOrderData& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csOrderData(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sOrderData, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sOrderData* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csOrderData(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sOrderData, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sOrderData*& _sp) {
  return _a >>= (const sOrderData*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sOrderData*& _sp) {
  _sp = (sOrderData *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sOrderData;
    _0RL_buildDesc_csOrderData(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sOrderData, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sOrderData);
      return 1;
    } else {
      delete (sOrderData *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sOrderData)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csOrderData__
#define __0RL_tcParser_buildDesc_s0_csOrderData__
static void
_0RL_tcParser_setElementCount_s0_csOrderData(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sOrderData > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csOrderData(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sOrderData > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csOrderData(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csOrderData(_newdesc, (*((_CORBA_Unbounded_Sequence< sOrderData > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csOrderData(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sOrderData > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csOrderData;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csOrderData;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csOrderData;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqOrderData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csOrderData(tcdesc, _s);
  _a.PR_packFrom(_tc_seqOrderData, &tcdesc);
}

void _0RL_seq_delete_seqOrderData(void* _data)
{
  delete (seqOrderData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqOrderData*& _s_out)
{
  return _a >>= (const seqOrderData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqOrderData*& _s_out)
{
  _s_out = 0;
  seqOrderData* stmp = (seqOrderData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqOrderData;
    _0RL_buildDesc_s0_csOrderData(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqOrderData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqOrderData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqOrderData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqOrderData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sSampleData(void* _data) {
  sSampleData* _0RL_t = (sSampleData*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sSampleData(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sSampleData*)_desc->opq_struct)->SampleCode);
    return 1;
  case 1:
    _0RL_buildDesc_cMCBS_mCBS__LocalTime(_newdesc, ((sSampleData*)_desc->opq_struct)->SampleTime);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((sSampleData*)_desc->opq_struct)->SampleCounter);
    return 1;
  case 3:
    _0RL_buildDesc_clong(_newdesc, ((sSampleData*)_desc->opq_struct)->ProbeType);
    return 1;
  case 4:
    _0RL_buildDesc_cstring(_newdesc, ((sSampleData*)_desc->opq_struct)->PlantID);
    return 1;
  case 5:
    _0RL_buildDesc_cstring(_newdesc, ((sSampleData*)_desc->opq_struct)->ProcessStage);
    return 1;
  case 6:
    _0RL_buildDesc_cstring(_newdesc, ((sSampleData*)_desc->opq_struct)->SampleId);
    return 1;
  case 7:
    _0RL_buildDesc_cstring(_newdesc, ((sSampleData*)_desc->opq_struct)->SampleMode);
    return 1;
  case 8:
    _0RL_buildDesc_cstring(_newdesc, ((sSampleData*)_desc->opq_struct)->SampleLocation);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sSampleData(const tcStructDesc *_desc)
{
  return 9;
}

void _0RL_buildDesc_csSampleData(tcDescriptor &_desc, const sSampleData& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sSampleData;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sSampleData;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sSampleData& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csSampleData(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sSampleData, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sSampleData* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csSampleData(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sSampleData, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sSampleData*& _sp) {
  return _a >>= (const sSampleData*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sSampleData*& _sp) {
  _sp = (sSampleData *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sSampleData;
    _0RL_buildDesc_csSampleData(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sSampleData, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sSampleData);
      return 1;
    } else {
      delete (sSampleData *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sSampleData)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csSampleData__
#define __0RL_tcParser_buildDesc_s0_csSampleData__
static void
_0RL_tcParser_setElementCount_s0_csSampleData(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sSampleData > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csSampleData(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sSampleData > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csSampleData(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csSampleData(_newdesc, (*((_CORBA_Unbounded_Sequence< sSampleData > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csSampleData(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sSampleData > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csSampleData;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csSampleData;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csSampleData;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqSampleData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csSampleData(tcdesc, _s);
  _a.PR_packFrom(_tc_seqSampleData, &tcdesc);
}

void _0RL_seq_delete_seqSampleData(void* _data)
{
  delete (seqSampleData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqSampleData*& _s_out)
{
  return _a >>= (const seqSampleData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqSampleData*& _s_out)
{
  _s_out = 0;
  seqSampleData* stmp = (seqSampleData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqSampleData;
    _0RL_buildDesc_s0_csSampleData(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqSampleData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqSampleData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqSampleData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqSampleData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sAnalysisData(void* _data) {
  sAnalysisData* _0RL_t = (sAnalysisData*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sAnalysisData(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_csSampleData(_newdesc, ((sAnalysisData*)_desc->opq_struct)->SampleData);
    return 1;
  case 1:
    _0RL_buildDesc_s0_csAnalysis(_newdesc, ((sAnalysisData*)_desc->opq_struct)->Analysis);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sAnalysisData(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_csAnalysisData(tcDescriptor &_desc, const sAnalysisData& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sAnalysisData;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sAnalysisData;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sAnalysisData& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csAnalysisData(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sAnalysisData, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sAnalysisData* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csAnalysisData(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sAnalysisData, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sAnalysisData*& _sp) {
  return _a >>= (const sAnalysisData*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sAnalysisData*& _sp) {
  _sp = (sAnalysisData *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sAnalysisData;
    _0RL_buildDesc_csAnalysisData(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sAnalysisData, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sAnalysisData);
      return 1;
    } else {
      delete (sAnalysisData *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sAnalysisData)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sHeatData(void* _data) {
  sHeatData* _0RL_t = (sHeatData*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sHeatData(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sHeatData*)_desc->opq_struct)->Plant);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((sHeatData*)_desc->opq_struct)->HeatId);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((sHeatData*)_desc->opq_struct)->Device);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((sHeatData*)_desc->opq_struct)->TreatId);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sHeatData(const tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_csHeatData(tcDescriptor &_desc, const sHeatData& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sHeatData;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sHeatData;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sHeatData& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csHeatData(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sHeatData, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sHeatData* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csHeatData(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sHeatData, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sHeatData*& _sp) {
  return _a >>= (const sHeatData*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sHeatData*& _sp) {
  _sp = (sHeatData *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sHeatData;
    _0RL_buildDesc_csHeatData(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sHeatData, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sHeatData);
      return 1;
    } else {
      delete (sHeatData *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sHeatData)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csHeatData__
#define __0RL_tcParser_buildDesc_s0_csHeatData__
static void
_0RL_tcParser_setElementCount_s0_csHeatData(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sHeatData > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csHeatData(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sHeatData > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csHeatData(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csHeatData(_newdesc, (*((_CORBA_Unbounded_Sequence< sHeatData > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csHeatData(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sHeatData > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csHeatData;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csHeatData;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csHeatData;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqHeatData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csHeatData(tcdesc, _s);
  _a.PR_packFrom(_tc_seqHeatData, &tcdesc);
}

void _0RL_seq_delete_seqHeatData(void* _data)
{
  delete (seqHeatData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqHeatData*& _s_out)
{
  return _a >>= (const seqHeatData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqHeatData*& _s_out)
{
  _s_out = 0;
  seqHeatData* stmp = (seqHeatData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqHeatData;
    _0RL_buildDesc_s0_csHeatData(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqHeatData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqHeatData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqHeatData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqHeatData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sGasLanceData(void* _data) {
  sGasLanceData* _0RL_t = (sGasLanceData*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sGasLanceData(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_s0_csGasData(_newdesc, ((sGasLanceData*)_desc->opq_struct)->LanceData);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((sGasLanceData*)_desc->opq_struct)->Device);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sGasLanceData(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_csGasLanceData(tcDescriptor &_desc, const sGasLanceData& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sGasLanceData;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sGasLanceData;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sGasLanceData& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csGasLanceData(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sGasLanceData, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sGasLanceData* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csGasLanceData(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sGasLanceData, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sGasLanceData*& _sp) {
  return _a >>= (const sGasLanceData*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sGasLanceData*& _sp) {
  _sp = (sGasLanceData *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sGasLanceData;
    _0RL_buildDesc_csGasLanceData(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sGasLanceData, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sGasLanceData);
      return 1;
    } else {
      delete (sGasLanceData *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sGasLanceData)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sInjectLanceData(void* _data) {
  sInjectLanceData* _0RL_t = (sInjectLanceData*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sInjectLanceData(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sInjectLanceData*)_desc->opq_struct)->Device);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sInjectLanceData*)_desc->opq_struct)->LanceVal);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((sInjectLanceData*)_desc->opq_struct)->MatNumber);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((sInjectLanceData*)_desc->opq_struct)->ModuleName);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sInjectLanceData(const tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_csInjectLanceData(tcDescriptor &_desc, const sInjectLanceData& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sInjectLanceData;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sInjectLanceData;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sInjectLanceData& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csInjectLanceData(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sInjectLanceData, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sInjectLanceData* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csInjectLanceData(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sInjectLanceData, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sInjectLanceData*& _sp) {
  return _a >>= (const sInjectLanceData*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sInjectLanceData*& _sp) {
  _sp = (sInjectLanceData *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sInjectLanceData;
    _0RL_buildDesc_csInjectLanceData(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sInjectLanceData, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sInjectLanceData);
      return 1;
    } else {
      delete (sInjectLanceData *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sInjectLanceData)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csInjectLanceData__
#define __0RL_tcParser_buildDesc_s0_csInjectLanceData__
static void
_0RL_tcParser_setElementCount_s0_csInjectLanceData(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sInjectLanceData > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csInjectLanceData(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sInjectLanceData > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csInjectLanceData(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csInjectLanceData(_newdesc, (*((_CORBA_Unbounded_Sequence< sInjectLanceData > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csInjectLanceData(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sInjectLanceData > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csInjectLanceData;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csInjectLanceData;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csInjectLanceData;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqInjectLanceData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csInjectLanceData(tcdesc, _s);
  _a.PR_packFrom(_tc_seqInjectLanceData, &tcdesc);
}

void _0RL_seq_delete_seqInjectLanceData(void* _data)
{
  delete (seqInjectLanceData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqInjectLanceData*& _s_out)
{
  return _a >>= (const seqInjectLanceData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqInjectLanceData*& _s_out)
{
  _s_out = 0;
  seqInjectLanceData* stmp = (seqInjectLanceData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqInjectLanceData;
    _0RL_buildDesc_s0_csInjectLanceData(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqInjectLanceData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqInjectLanceData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqInjectLanceData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqInjectLanceData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sInjectLanceMat(void* _data) {
  sInjectLanceMat* _0RL_t = (sInjectLanceMat*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sInjectLanceMat(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sInjectLanceMat*)_desc->opq_struct)->Device);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((sInjectLanceMat*)_desc->opq_struct)->LanceMatCode);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((sInjectLanceMat*)_desc->opq_struct)->MatNumber);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((sInjectLanceMat*)_desc->opq_struct)->ModuleName);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sInjectLanceMat(const tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_csInjectLanceMat(tcDescriptor &_desc, const sInjectLanceMat& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sInjectLanceMat;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sInjectLanceMat;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sInjectLanceMat& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csInjectLanceMat(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sInjectLanceMat, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sInjectLanceMat* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csInjectLanceMat(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sInjectLanceMat, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sInjectLanceMat*& _sp) {
  return _a >>= (const sInjectLanceMat*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sInjectLanceMat*& _sp) {
  _sp = (sInjectLanceMat *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sInjectLanceMat;
    _0RL_buildDesc_csInjectLanceMat(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sInjectLanceMat, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sInjectLanceMat);
      return 1;
    } else {
      delete (sInjectLanceMat *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sInjectLanceMat)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csInjectLanceMat__
#define __0RL_tcParser_buildDesc_s0_csInjectLanceMat__
static void
_0RL_tcParser_setElementCount_s0_csInjectLanceMat(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sInjectLanceMat > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csInjectLanceMat(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sInjectLanceMat > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csInjectLanceMat(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csInjectLanceMat(_newdesc, (*((_CORBA_Unbounded_Sequence< sInjectLanceMat > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csInjectLanceMat(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sInjectLanceMat > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csInjectLanceMat;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csInjectLanceMat;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csInjectLanceMat;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqInjectLanceMat& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csInjectLanceMat(tcdesc, _s);
  _a.PR_packFrom(_tc_seqInjectLanceMat, &tcdesc);
}

void _0RL_seq_delete_seqInjectLanceMat(void* _data)
{
  delete (seqInjectLanceMat*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqInjectLanceMat*& _s_out)
{
  return _a >>= (const seqInjectLanceMat*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqInjectLanceMat*& _s_out)
{
  _s_out = 0;
  seqInjectLanceMat* stmp = (seqInjectLanceMat*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqInjectLanceMat;
    _0RL_buildDesc_s0_csInjectLanceMat(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqInjectLanceMat, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqInjectLanceMat);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqInjectLanceMat *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqInjectLanceMat) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sGasLanceGasAvail(void* _data) {
  sGasLanceGasAvail* _0RL_t = (sGasLanceGasAvail*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sGasLanceGasAvail(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sGasLanceGasAvail*)_desc->opq_struct)->Device);
    return 1;
  case 1:
    _0RL_buildDesc_s0_csGasAvail(_newdesc, ((sGasLanceGasAvail*)_desc->opq_struct)->GasAvail);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sGasLanceGasAvail(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_csGasLanceGasAvail(tcDescriptor &_desc, const sGasLanceGasAvail& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sGasLanceGasAvail;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sGasLanceGasAvail;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sGasLanceGasAvail& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csGasLanceGasAvail(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sGasLanceGasAvail, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sGasLanceGasAvail* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csGasLanceGasAvail(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sGasLanceGasAvail, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sGasLanceGasAvail*& _sp) {
  return _a >>= (const sGasLanceGasAvail*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sGasLanceGasAvail*& _sp) {
  _sp = (sGasLanceGasAvail *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sGasLanceGasAvail;
    _0RL_buildDesc_csGasLanceGasAvail(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sGasLanceGasAvail, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sGasLanceGasAvail);
      return 1;
    } else {
      delete (sGasLanceGasAvail *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sGasLanceGasAvail)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csGasLanceGasAvail__
#define __0RL_tcParser_buildDesc_s0_csGasLanceGasAvail__
static void
_0RL_tcParser_setElementCount_s0_csGasLanceGasAvail(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sGasLanceGasAvail > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csGasLanceGasAvail(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sGasLanceGasAvail > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csGasLanceGasAvail(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csGasLanceGasAvail(_newdesc, (*((_CORBA_Unbounded_Sequence< sGasLanceGasAvail > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csGasLanceGasAvail(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sGasLanceGasAvail > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csGasLanceGasAvail;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csGasLanceGasAvail;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csGasLanceGasAvail;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqGasLanceGasAvail& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csGasLanceGasAvail(tcdesc, _s);
  _a.PR_packFrom(_tc_seqGasLanceGasAvail, &tcdesc);
}

void _0RL_seq_delete_seqGasLanceGasAvail(void* _data)
{
  delete (seqGasLanceGasAvail*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqGasLanceGasAvail*& _s_out)
{
  return _a >>= (const seqGasLanceGasAvail*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqGasLanceGasAvail*& _s_out)
{
  _s_out = 0;
  seqGasLanceGasAvail* stmp = (seqGasLanceGasAvail*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqGasLanceGasAvail;
    _0RL_buildDesc_s0_csGasLanceGasAvail(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqGasLanceGasAvail, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqGasLanceGasAvail);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqGasLanceGasAvail *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqGasLanceGasAvail) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sBatchPrio(void* _data) {
  sBatchPrio* _0RL_t = (sBatchPrio*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sBatchPrio(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_csBatch(_newdesc, ((sBatchPrio*)_desc->opq_struct)->BatchData);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sBatchPrio*)_desc->opq_struct)->ChargPrio);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sBatchPrio(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_csBatchPrio(tcDescriptor &_desc, const sBatchPrio& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sBatchPrio;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sBatchPrio;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sBatchPrio& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csBatchPrio(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sBatchPrio, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sBatchPrio* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csBatchPrio(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sBatchPrio, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sBatchPrio*& _sp) {
  return _a >>= (const sBatchPrio*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sBatchPrio*& _sp) {
  _sp = (sBatchPrio *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sBatchPrio;
    _0RL_buildDesc_csBatchPrio(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sBatchPrio, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sBatchPrio);
      return 1;
    } else {
      delete (sBatchPrio *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sBatchPrio)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csBatchPrio__
#define __0RL_tcParser_buildDesc_s0_csBatchPrio__
static void
_0RL_tcParser_setElementCount_s0_csBatchPrio(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sBatchPrio > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csBatchPrio(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sBatchPrio > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csBatchPrio(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csBatchPrio(_newdesc, (*((_CORBA_Unbounded_Sequence< sBatchPrio > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csBatchPrio(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sBatchPrio > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csBatchPrio;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csBatchPrio;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csBatchPrio;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqBatchPrio& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csBatchPrio(tcdesc, _s);
  _a.PR_packFrom(_tc_seqBatchPrio, &tcdesc);
}

void _0RL_seq_delete_seqBatchPrio(void* _data)
{
  delete (seqBatchPrio*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqBatchPrio*& _s_out)
{
  return _a >>= (const seqBatchPrio*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqBatchPrio*& _s_out)
{
  _s_out = 0;
  seqBatchPrio* stmp = (seqBatchPrio*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqBatchPrio;
    _0RL_buildDesc_s0_csBatchPrio(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqBatchPrio, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqBatchPrio);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqBatchPrio *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqBatchPrio) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csGasLanceData__
#define __0RL_tcParser_buildDesc_s0_csGasLanceData__
static void
_0RL_tcParser_setElementCount_s0_csGasLanceData(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sGasLanceData > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csGasLanceData(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sGasLanceData > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csGasLanceData(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csGasLanceData(_newdesc, (*((_CORBA_Unbounded_Sequence< sGasLanceData > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csGasLanceData(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sGasLanceData > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csGasLanceData;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csGasLanceData;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csGasLanceData;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqGasLanceData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csGasLanceData(tcdesc, _s);
  _a.PR_packFrom(_tc_seqGasLanceData, &tcdesc);
}

void _0RL_seq_delete_seqGasLanceData(void* _data)
{
  delete (seqGasLanceData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqGasLanceData*& _s_out)
{
  return _a >>= (const seqGasLanceData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqGasLanceData*& _s_out)
{
  _s_out = 0;
  seqGasLanceData* stmp = (seqGasLanceData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqGasLanceData;
    _0RL_buildDesc_s0_csGasLanceData(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqGasLanceData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqGasLanceData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqGasLanceData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqGasLanceData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csAnalysisData__
#define __0RL_tcParser_buildDesc_s0_csAnalysisData__
static void
_0RL_tcParser_setElementCount_s0_csAnalysisData(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sAnalysisData > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csAnalysisData(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sAnalysisData > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csAnalysisData(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csAnalysisData(_newdesc, (*((_CORBA_Unbounded_Sequence< sAnalysisData > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csAnalysisData(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sAnalysisData > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csAnalysisData;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csAnalysisData;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csAnalysisData;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqAnalysisData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csAnalysisData(tcdesc, _s);
  _a.PR_packFrom(_tc_seqAnalysisData, &tcdesc);
}

void _0RL_seq_delete_seqAnalysisData(void* _data)
{
  delete (seqAnalysisData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqAnalysisData*& _s_out)
{
  return _a >>= (const seqAnalysisData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqAnalysisData*& _s_out)
{
  _s_out = 0;
  seqAnalysisData* stmp = (seqAnalysisData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqAnalysisData;
    _0RL_buildDesc_s0_csAnalysisData(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqAnalysisData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqAnalysisData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqAnalysisData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqAnalysisData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_LFGlobalSetpoints(void* _data) {
  LFGlobalSetpoints* _0RL_t = (LFGlobalSetpoints*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_LFGlobalSetpoints(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((LFGlobalSetpoints*)_desc->opq_struct)->GasType);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_LFGlobalSetpoints(const tcStructDesc *_desc)
{
  return 1;
}

void _0RL_buildDesc_cLFGlobalSetpoints(tcDescriptor &_desc, const LFGlobalSetpoints& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_LFGlobalSetpoints;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_LFGlobalSetpoints;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const LFGlobalSetpoints& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cLFGlobalSetpoints(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_LFGlobalSetpoints, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, LFGlobalSetpoints* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_cLFGlobalSetpoints(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_LFGlobalSetpoints, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, LFGlobalSetpoints*& _sp) {
  return _a >>= (const LFGlobalSetpoints*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const LFGlobalSetpoints*& _sp) {
  _sp = (LFGlobalSetpoints *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new LFGlobalSetpoints;
    _0RL_buildDesc_cLFGlobalSetpoints(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_LFGlobalSetpoints, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_LFGlobalSetpoints);
      return 1;
    } else {
      delete (LFGlobalSetpoints *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_LFGlobalSetpoints)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sLiqMatReport(void* _data) {
  sLiqMatReport* _0RL_t = (sLiqMatReport*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sLiqMatReport(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_clong(_newdesc, ((sLiqMatReport*)_desc->opq_struct)->LiqMatType);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sLiqMatReport*)_desc->opq_struct)->LiqMatWeight);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sLiqMatReport(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_csLiqMatReport(tcDescriptor &_desc, const sLiqMatReport& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sLiqMatReport;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sLiqMatReport;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sLiqMatReport& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csLiqMatReport(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sLiqMatReport, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sLiqMatReport* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csLiqMatReport(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sLiqMatReport, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sLiqMatReport*& _sp) {
  return _a >>= (const sLiqMatReport*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sLiqMatReport*& _sp) {
  _sp = (sLiqMatReport *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sLiqMatReport;
    _0RL_buildDesc_csLiqMatReport(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sLiqMatReport, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sLiqMatReport);
      return 1;
    } else {
      delete (sLiqMatReport *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sLiqMatReport)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csLiqMatReport__
#define __0RL_tcParser_buildDesc_s0_csLiqMatReport__
static void
_0RL_tcParser_setElementCount_s0_csLiqMatReport(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sLiqMatReport > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csLiqMatReport(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sLiqMatReport > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csLiqMatReport(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csLiqMatReport(_newdesc, (*((_CORBA_Unbounded_Sequence< sLiqMatReport > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csLiqMatReport(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sLiqMatReport > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csLiqMatReport;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csLiqMatReport;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csLiqMatReport;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqLiqMatReport& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csLiqMatReport(tcdesc, _s);
  _a.PR_packFrom(_tc_seqLiqMatReport, &tcdesc);
}

void _0RL_seq_delete_seqLiqMatReport(void* _data)
{
  delete (seqLiqMatReport*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqLiqMatReport*& _s_out)
{
  return _a >>= (const seqLiqMatReport*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqLiqMatReport*& _s_out)
{
  _s_out = 0;
  seqLiqMatReport* stmp = (seqLiqMatReport*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqLiqMatReport;
    _0RL_buildDesc_s0_csLiqMatReport(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqLiqMatReport, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqLiqMatReport);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqLiqMatReport *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqLiqMatReport) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sBOFPredBlowRes(void* _data) {
  sBOFPredBlowRes* _0RL_t = (sBOFPredBlowRes*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sBOFPredBlowRes(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sBOFPredBlowRes*)_desc->opq_struct)->Phase);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sBOFPredBlowRes*)_desc->opq_struct)->PhaseNo);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((sBOFPredBlowRes*)_desc->opq_struct)->PhaseActive);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFPredBlowRes*)_desc->opq_struct)->O2Vol);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFPredBlowRes*)_desc->opq_struct)->TopLanceO2Flow);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFPredBlowRes*)_desc->opq_struct)->TopLanceHeight);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFPredBlowRes*)_desc->opq_struct)->PorousPlugN2Flow);
    return 1;
  case 7:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFPredBlowRes*)_desc->opq_struct)->PorousPlugArFlow);
    return 1;
  case 8:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFPredBlowRes*)_desc->opq_struct)->O2MomentPorPlugs);
    return 1;
  case 9:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFPredBlowRes*)_desc->opq_struct)->DecarbRate);
    return 1;
  case 10:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFPredBlowRes*)_desc->opq_struct)->O2MomentTopLance);
    return 1;
  case 11:
    _0RL_buildDesc_csGenRes(_newdesc, ((sBOFPredBlowRes*)_desc->opq_struct)->GenRes);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sBOFPredBlowRes(const tcStructDesc *_desc)
{
  return 12;
}

void _0RL_buildDesc_csBOFPredBlowRes(tcDescriptor &_desc, const sBOFPredBlowRes& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sBOFPredBlowRes;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sBOFPredBlowRes;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sBOFPredBlowRes& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csBOFPredBlowRes(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sBOFPredBlowRes, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sBOFPredBlowRes* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csBOFPredBlowRes(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sBOFPredBlowRes, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sBOFPredBlowRes*& _sp) {
  return _a >>= (const sBOFPredBlowRes*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sBOFPredBlowRes*& _sp) {
  _sp = (sBOFPredBlowRes *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sBOFPredBlowRes;
    _0RL_buildDesc_csBOFPredBlowRes(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sBOFPredBlowRes, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sBOFPredBlowRes);
      return 1;
    } else {
      delete (sBOFPredBlowRes *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sBOFPredBlowRes)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csBOFPredBlowRes__
#define __0RL_tcParser_buildDesc_s0_csBOFPredBlowRes__
static void
_0RL_tcParser_setElementCount_s0_csBOFPredBlowRes(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sBOFPredBlowRes > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csBOFPredBlowRes(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sBOFPredBlowRes > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csBOFPredBlowRes(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csBOFPredBlowRes(_newdesc, (*((_CORBA_Unbounded_Sequence< sBOFPredBlowRes > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csBOFPredBlowRes(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sBOFPredBlowRes > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csBOFPredBlowRes;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csBOFPredBlowRes;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csBOFPredBlowRes;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqBOFBlowPredRes& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csBOFPredBlowRes(tcdesc, _s);
  _a.PR_packFrom(_tc_seqBOFBlowPredRes, &tcdesc);
}

void _0RL_seq_delete_seqBOFBlowPredRes(void* _data)
{
  delete (seqBOFBlowPredRes*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqBOFBlowPredRes*& _s_out)
{
  return _a >>= (const seqBOFBlowPredRes*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqBOFBlowPredRes*& _s_out)
{
  _s_out = 0;
  seqBOFBlowPredRes* stmp = (seqBOFBlowPredRes*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqBOFBlowPredRes;
    _0RL_buildDesc_s0_csBOFPredBlowRes(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqBOFBlowPredRes, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqBOFBlowPredRes);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqBOFBlowPredRes *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqBOFBlowPredRes) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sInjectData(void* _data) {
  sInjectData* _0RL_t = (sInjectData*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sInjectData(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sInjectData*)_desc->opq_struct)->InjectMatCode);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sInjectData*)_desc->opq_struct)->InjectMatValue);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((sInjectData*)_desc->opq_struct)->InjectType);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sInjectData(const tcStructDesc *_desc)
{
  return 3;
}

void _0RL_buildDesc_csInjectData(tcDescriptor &_desc, const sInjectData& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sInjectData;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sInjectData;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sInjectData& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csInjectData(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sInjectData, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sInjectData* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csInjectData(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sInjectData, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sInjectData*& _sp) {
  return _a >>= (const sInjectData*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sInjectData*& _sp) {
  _sp = (sInjectData *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sInjectData;
    _0RL_buildDesc_csInjectData(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sInjectData, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sInjectData);
      return 1;
    } else {
      delete (sInjectData *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sInjectData)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csInjectData__
#define __0RL_tcParser_buildDesc_s0_csInjectData__
static void
_0RL_tcParser_setElementCount_s0_csInjectData(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sInjectData > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csInjectData(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sInjectData > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csInjectData(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csInjectData(_newdesc, (*((_CORBA_Unbounded_Sequence< sInjectData > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csInjectData(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sInjectData > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csInjectData;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csInjectData;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csInjectData;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqInjectData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csInjectData(tcdesc, _s);
  _a.PR_packFrom(_tc_seqInjectData, &tcdesc);
}

void _0RL_seq_delete_seqInjectData(void* _data)
{
  delete (seqInjectData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqInjectData*& _s_out)
{
  return _a >>= (const seqInjectData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqInjectData*& _s_out)
{
  _s_out = 0;
  seqInjectData* stmp = (seqInjectData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqInjectData;
    _0RL_buildDesc_s0_csInjectData(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqInjectData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqInjectData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqInjectData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqInjectData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sEAFInjectLance(void* _data) {
  sEAFInjectLance* _0RL_t = (sEAFInjectLance*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sEAFInjectLance(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sEAFInjectLance*)_desc->opq_struct)->Phase);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sEAFInjectLance*)_desc->opq_struct)->BasketNo);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((sEAFInjectLance*)_desc->opq_struct)->Step);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFInjectLance*)_desc->opq_struct)->DurStep);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFInjectLance*)_desc->opq_struct)->Egy);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFInjectLance*)_desc->opq_struct)->RemEgy);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFInjectLance*)_desc->opq_struct)->DurUntilEndOfStep);
    return 1;
  case 7:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFInjectLance*)_desc->opq_struct)->DurUntilStartOfStep);
    return 1;
  case 8:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFInjectLance*)_desc->opq_struct)->SpecEgyStep);
    return 1;
  case 9:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFInjectLance*)_desc->opq_struct)->ElecEgyStep);
    return 1;
  case 10:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFInjectLance*)_desc->opq_struct)->SpecEgy);
    return 1;
  case 11:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFInjectLance*)_desc->opq_struct)->BaseMass);
    return 1;
  case 12:
    _0RL_buildDesc_s0_csInjectData(_newdesc, ((sEAFInjectLance*)_desc->opq_struct)->InjectFlow);
    return 1;
  case 13:
    _0RL_buildDesc_s0_csInjectData(_newdesc, ((sEAFInjectLance*)_desc->opq_struct)->InjectAmount);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sEAFInjectLance(const tcStructDesc *_desc)
{
  return 14;
}

void _0RL_buildDesc_csEAFInjectLance(tcDescriptor &_desc, const sEAFInjectLance& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sEAFInjectLance;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sEAFInjectLance;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sEAFInjectLance& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csEAFInjectLance(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sEAFInjectLance, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sEAFInjectLance* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csEAFInjectLance(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sEAFInjectLance, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sEAFInjectLance*& _sp) {
  return _a >>= (const sEAFInjectLance*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sEAFInjectLance*& _sp) {
  _sp = (sEAFInjectLance *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sEAFInjectLance;
    _0RL_buildDesc_csEAFInjectLance(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sEAFInjectLance, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sEAFInjectLance);
      return 1;
    } else {
      delete (sEAFInjectLance *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sEAFInjectLance)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csEAFInjectLance__
#define __0RL_tcParser_buildDesc_s0_csEAFInjectLance__
static void
_0RL_tcParser_setElementCount_s0_csEAFInjectLance(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sEAFInjectLance > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csEAFInjectLance(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sEAFInjectLance > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csEAFInjectLance(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csEAFInjectLance(_newdesc, (*((_CORBA_Unbounded_Sequence< sEAFInjectLance > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csEAFInjectLance(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sEAFInjectLance > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csEAFInjectLance;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csEAFInjectLance;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csEAFInjectLance;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqEAFInjectLance& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csEAFInjectLance(tcdesc, _s);
  _a.PR_packFrom(_tc_seqEAFInjectLance, &tcdesc);
}

void _0RL_seq_delete_seqEAFInjectLance(void* _data)
{
  delete (seqEAFInjectLance*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqEAFInjectLance*& _s_out)
{
  return _a >>= (const seqEAFInjectLance*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqEAFInjectLance*& _s_out)
{
  _s_out = 0;
  seqEAFInjectLance* stmp = (seqEAFInjectLance*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqEAFInjectLance;
    _0RL_buildDesc_s0_csEAFInjectLance(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqEAFInjectLance, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqEAFInjectLance);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqEAFInjectLance *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqEAFInjectLance) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sHMDCalc(void* _data) {
  sHMDCalc* _0RL_t = (sHMDCalc*) _data;
  delete _0RL_t;
}

#ifndef __0RL_tcParser_buildDesc_s0_cdouble__
#define __0RL_tcParser_buildDesc_s0_cdouble__
static void
_0RL_tcParser_setElementCount_s0_cdouble(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Double, 8, 8 > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_cdouble(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Double, 8, 8 > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_cdouble(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _newdesc.p_streamdata = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Double, 8, 8 > *)_desc->opq_seq)->NP_data();
  _contiguous = ((_CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Double, 8, 8 > *)_desc->opq_seq)->length() - _index;


  return 1;
}

static void
_0RL_buildDesc_s0_cdouble(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Double, 8, 8 > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_cdouble;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_cdouble;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_cdouble;
  }
#endif

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sHMDCalc(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_s0_cdouble(_newdesc, ((sHMDCalc*)_desc->opq_struct)->Lime);
    return 1;
  case 1:
    _0RL_buildDesc_s0_csBatchPrio(_newdesc, ((sHMDCalc*)_desc->opq_struct)->Material);
    return 1;
  case 2:
    _0RL_buildDesc_s0_csAnalysis(_newdesc, ((sHMDCalc*)_desc->opq_struct)->Analysis);
    return 1;
  case 3:
    _0RL_buildDesc_s0_cdouble(_newdesc, ((sHMDCalc*)_desc->opq_struct)->Carbide);
    return 1;
  case 4:
    _0RL_buildDesc_s0_cdouble(_newdesc, ((sHMDCalc*)_desc->opq_struct)->Magnesium);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sHMDCalc(const tcStructDesc *_desc)
{
  return 5;
}

void _0RL_buildDesc_csHMDCalc(tcDescriptor &_desc, const sHMDCalc& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sHMDCalc;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sHMDCalc;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sHMDCalc& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csHMDCalc(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sHMDCalc, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sHMDCalc* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csHMDCalc(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sHMDCalc, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sHMDCalc*& _sp) {
  return _a >>= (const sHMDCalc*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sHMDCalc*& _sp) {
  _sp = (sHMDCalc *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sHMDCalc;
    _0RL_buildDesc_csHMDCalc(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sHMDCalc, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sHMDCalc);
      return 1;
    } else {
      delete (sHMDCalc *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sHMDCalc)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sConArcElecData(void* _data) {
  sConArcElecData* _0RL_t = (sConArcElecData*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sConArcElecData(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_clong(_newdesc, ((sConArcElecData*)_desc->opq_struct)->BasketNo);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sConArcElecData*)_desc->opq_struct)->ReactTapNo);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((sConArcElecData*)_desc->opq_struct)->TransfTapNo);
    return 1;
  case 3:
    _0RL_buildDesc_clong(_newdesc, ((sConArcElecData*)_desc->opq_struct)->ArcLenNo);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcElecData*)_desc->opq_struct)->DurUntilEndOfStep);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcElecData*)_desc->opq_struct)->DurUntilStartOfStep);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcElecData*)_desc->opq_struct)->SpecEgyStep);
    return 1;
  case 7:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcElecData*)_desc->opq_struct)->SpecEgy);
    return 1;
  case 8:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcElecData*)_desc->opq_struct)->ElecEgyStep);
    return 1;
  case 9:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcElecData*)_desc->opq_struct)->ElecEgy);
    return 1;
  case 10:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcElecData*)_desc->opq_struct)->EnergyStart);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sConArcElecData(const tcStructDesc *_desc)
{
  return 11;
}

void _0RL_buildDesc_csConArcElecData(tcDescriptor &_desc, const sConArcElecData& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sConArcElecData;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sConArcElecData;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sConArcElecData& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcElecData(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sConArcElecData, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sConArcElecData* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcElecData(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sConArcElecData, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sConArcElecData*& _sp) {
  return _a >>= (const sConArcElecData*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sConArcElecData*& _sp) {
  _sp = (sConArcElecData *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sConArcElecData;
    _0RL_buildDesc_csConArcElecData(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sConArcElecData, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sConArcElecData);
      return 1;
    } else {
      delete (sConArcElecData *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sConArcElecData)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sConArcMediaData(void* _data) {
  sConArcMediaData* _0RL_t = (sConArcMediaData*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sConArcMediaData(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sConArcMediaData*)_desc->opq_struct)->DeviceName);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sConArcMediaData*)_desc->opq_struct)->DeviceNo);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((sConArcMediaData*)_desc->opq_struct)->MediaTypeSelect);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((sConArcMediaData*)_desc->opq_struct)->MediaType);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcMediaData*)_desc->opq_struct)->Flow);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcMediaData*)_desc->opq_struct)->Cons);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sConArcMediaData(const tcStructDesc *_desc)
{
  return 6;
}

void _0RL_buildDesc_csConArcMediaData(tcDescriptor &_desc, const sConArcMediaData& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sConArcMediaData;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sConArcMediaData;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sConArcMediaData& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcMediaData(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sConArcMediaData, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sConArcMediaData* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcMediaData(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sConArcMediaData, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sConArcMediaData*& _sp) {
  return _a >>= (const sConArcMediaData*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sConArcMediaData*& _sp) {
  _sp = (sConArcMediaData *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sConArcMediaData;
    _0RL_buildDesc_csConArcMediaData(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sConArcMediaData, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sConArcMediaData);
      return 1;
    } else {
      delete (sConArcMediaData *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sConArcMediaData)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csConArcElecData__
#define __0RL_tcParser_buildDesc_s0_csConArcElecData__
static void
_0RL_tcParser_setElementCount_s0_csConArcElecData(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sConArcElecData > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csConArcElecData(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sConArcElecData > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csConArcElecData(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csConArcElecData(_newdesc, (*((_CORBA_Unbounded_Sequence< sConArcElecData > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csConArcElecData(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sConArcElecData > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csConArcElecData;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csConArcElecData;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csConArcElecData;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqConArcElecData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csConArcElecData(tcdesc, _s);
  _a.PR_packFrom(_tc_seqConArcElecData, &tcdesc);
}

void _0RL_seq_delete_seqConArcElecData(void* _data)
{
  delete (seqConArcElecData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqConArcElecData*& _s_out)
{
  return _a >>= (const seqConArcElecData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqConArcElecData*& _s_out)
{
  _s_out = 0;
  seqConArcElecData* stmp = (seqConArcElecData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqConArcElecData;
    _0RL_buildDesc_s0_csConArcElecData(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqConArcElecData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqConArcElecData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqConArcElecData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqConArcElecData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csConArcMediaData__
#define __0RL_tcParser_buildDesc_s0_csConArcMediaData__
static void
_0RL_tcParser_setElementCount_s0_csConArcMediaData(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sConArcMediaData > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csConArcMediaData(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sConArcMediaData > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csConArcMediaData(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csConArcMediaData(_newdesc, (*((_CORBA_Unbounded_Sequence< sConArcMediaData > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csConArcMediaData(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sConArcMediaData > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csConArcMediaData;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csConArcMediaData;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csConArcMediaData;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqConArcMediaData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csConArcMediaData(tcdesc, _s);
  _a.PR_packFrom(_tc_seqConArcMediaData, &tcdesc);
}

void _0RL_seq_delete_seqConArcMediaData(void* _data)
{
  delete (seqConArcMediaData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqConArcMediaData*& _s_out)
{
  return _a >>= (const seqConArcMediaData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqConArcMediaData*& _s_out)
{
  _s_out = 0;
  seqConArcMediaData* stmp = (seqConArcMediaData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqConArcMediaData;
    _0RL_buildDesc_s0_csConArcMediaData(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqConArcMediaData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqConArcMediaData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqConArcMediaData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqConArcMediaData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sConArcSetptData(void* _data) {
  sConArcSetptData* _0RL_t = (sConArcSetptData*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sConArcSetptData(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcSetptData*)_desc->opq_struct)->EgyTotal);
    return 1;
  case 1:
    _0RL_buildDesc_s0_csConArcMediaData(_newdesc, ((sConArcSetptData*)_desc->opq_struct)->MediaData);
    return 1;
  case 2:
    _0RL_buildDesc_csConArcElecData(_newdesc, ((sConArcSetptData*)_desc->opq_struct)->ElecData);
    return 1;
  case 3:
    _0RL_buildDesc_s0_csConArcMediaData(_newdesc, ((sConArcSetptData*)_desc->opq_struct)->MatFeedTotalMass);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sConArcSetptData(const tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_csConArcSetptData(tcDescriptor &_desc, const sConArcSetptData& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sConArcSetptData;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sConArcSetptData;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sConArcSetptData& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcSetptData(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sConArcSetptData, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sConArcSetptData* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcSetptData(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sConArcSetptData, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sConArcSetptData*& _sp) {
  return _a >>= (const sConArcSetptData*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sConArcSetptData*& _sp) {
  _sp = (sConArcSetptData *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sConArcSetptData;
    _0RL_buildDesc_csConArcSetptData(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sConArcSetptData, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sConArcSetptData);
      return 1;
    } else {
      delete (sConArcSetptData *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sConArcSetptData)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sConArcMeasData(void* _data) {
  sConArcMeasData* _0RL_t = (sConArcMeasData*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sConArcMeasData(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcMeasData*)_desc->opq_struct)->SlagQuality);
    return 1;
  case 1:
    _0RL_buildDesc_s0_csConArcMediaData(_newdesc, ((sConArcMeasData*)_desc->opq_struct)->MediaData);
    return 1;
  case 2:
    _0RL_buildDesc_csConArcElecData(_newdesc, ((sConArcMeasData*)_desc->opq_struct)->ElecData);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sConArcMeasData(const tcStructDesc *_desc)
{
  return 3;
}

void _0RL_buildDesc_csConArcMeasData(tcDescriptor &_desc, const sConArcMeasData& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sConArcMeasData;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sConArcMeasData;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sConArcMeasData& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcMeasData(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sConArcMeasData, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sConArcMeasData* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcMeasData(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sConArcMeasData, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sConArcMeasData*& _sp) {
  return _a >>= (const sConArcMeasData*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sConArcMeasData*& _sp) {
  _sp = (sConArcMeasData *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sConArcMeasData;
    _0RL_buildDesc_csConArcMeasData(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sConArcMeasData, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sConArcMeasData);
      return 1;
    } else {
      delete (sConArcMeasData *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sConArcMeasData)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csConArcSetptData__
#define __0RL_tcParser_buildDesc_s0_csConArcSetptData__
static void
_0RL_tcParser_setElementCount_s0_csConArcSetptData(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sConArcSetptData > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csConArcSetptData(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sConArcSetptData > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csConArcSetptData(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csConArcSetptData(_newdesc, (*((_CORBA_Unbounded_Sequence< sConArcSetptData > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csConArcSetptData(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sConArcSetptData > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csConArcSetptData;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csConArcSetptData;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csConArcSetptData;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqConArcSetptData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csConArcSetptData(tcdesc, _s);
  _a.PR_packFrom(_tc_seqConArcSetptData, &tcdesc);
}

void _0RL_seq_delete_seqConArcSetptData(void* _data)
{
  delete (seqConArcSetptData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqConArcSetptData*& _s_out)
{
  return _a >>= (const seqConArcSetptData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqConArcSetptData*& _s_out)
{
  _s_out = 0;
  seqConArcSetptData* stmp = (seqConArcSetptData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqConArcSetptData;
    _0RL_buildDesc_s0_csConArcSetptData(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqConArcSetptData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqConArcSetptData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqConArcSetptData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqConArcSetptData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csConArcMeasData__
#define __0RL_tcParser_buildDesc_s0_csConArcMeasData__
static void
_0RL_tcParser_setElementCount_s0_csConArcMeasData(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sConArcMeasData > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csConArcMeasData(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sConArcMeasData > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csConArcMeasData(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csConArcMeasData(_newdesc, (*((_CORBA_Unbounded_Sequence< sConArcMeasData > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csConArcMeasData(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sConArcMeasData > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csConArcMeasData;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csConArcMeasData;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csConArcMeasData;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqConArcMeasData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csConArcMeasData(tcdesc, _s);
  _a.PR_packFrom(_tc_seqConArcMeasData, &tcdesc);
}

void _0RL_seq_delete_seqConArcMeasData(void* _data)
{
  delete (seqConArcMeasData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqConArcMeasData*& _s_out)
{
  return _a >>= (const seqConArcMeasData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqConArcMeasData*& _s_out)
{
  _s_out = 0;
  seqConArcMeasData* stmp = (seqConArcMeasData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqConArcMeasData;
    _0RL_buildDesc_s0_csConArcMeasData(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqConArcMeasData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqConArcMeasData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqConArcMeasData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqConArcMeasData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sEAFMatFeedPredRes(void* _data) {
  sEAFMatFeedPredRes* _0RL_t = (sEAFMatFeedPredRes*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sEAFMatFeedPredRes(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_clong(_newdesc, ((sEAFMatFeedPredRes*)_desc->opq_struct)->BasketNo);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sEAFMatFeedPredRes*)_desc->opq_struct)->Step);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFMatFeedPredRes*)_desc->opq_struct)->DurStep);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFMatFeedPredRes*)_desc->opq_struct)->DurUntilStartOfStep);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFMatFeedPredRes*)_desc->opq_struct)->DurUntilEndOfStep);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFMatFeedPredRes*)_desc->opq_struct)->Egy);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFMatFeedPredRes*)_desc->opq_struct)->SpecEgy);
    return 1;
  case 7:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFMatFeedPredRes*)_desc->opq_struct)->ElecEgyStep);
    return 1;
  case 8:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFMatFeedPredRes*)_desc->opq_struct)->BaseMass);
    return 1;
  case 9:
    _0RL_buildDesc_s0_csBatch(_newdesc, ((sEAFMatFeedPredRes*)_desc->opq_struct)->MatFeedData);
    return 1;
  case 10:
    _0RL_buildDesc_cstring(_newdesc, ((sEAFMatFeedPredRes*)_desc->opq_struct)->PhaseName);
    return 1;
  case 11:
    _0RL_buildDesc_cdouble(_newdesc, ((sEAFMatFeedPredRes*)_desc->opq_struct)->SpecEgyStep);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sEAFMatFeedPredRes(const tcStructDesc *_desc)
{
  return 12;
}

void _0RL_buildDesc_csEAFMatFeedPredRes(tcDescriptor &_desc, const sEAFMatFeedPredRes& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sEAFMatFeedPredRes;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sEAFMatFeedPredRes;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sEAFMatFeedPredRes& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csEAFMatFeedPredRes(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sEAFMatFeedPredRes, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sEAFMatFeedPredRes* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csEAFMatFeedPredRes(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sEAFMatFeedPredRes, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sEAFMatFeedPredRes*& _sp) {
  return _a >>= (const sEAFMatFeedPredRes*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sEAFMatFeedPredRes*& _sp) {
  _sp = (sEAFMatFeedPredRes *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sEAFMatFeedPredRes;
    _0RL_buildDesc_csEAFMatFeedPredRes(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sEAFMatFeedPredRes, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sEAFMatFeedPredRes);
      return 1;
    } else {
      delete (sEAFMatFeedPredRes *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sEAFMatFeedPredRes)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csEAFMatFeedPredRes__
#define __0RL_tcParser_buildDesc_s0_csEAFMatFeedPredRes__
static void
_0RL_tcParser_setElementCount_s0_csEAFMatFeedPredRes(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sEAFMatFeedPredRes > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csEAFMatFeedPredRes(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sEAFMatFeedPredRes > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csEAFMatFeedPredRes(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csEAFMatFeedPredRes(_newdesc, (*((_CORBA_Unbounded_Sequence< sEAFMatFeedPredRes > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csEAFMatFeedPredRes(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sEAFMatFeedPredRes > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csEAFMatFeedPredRes;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csEAFMatFeedPredRes;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csEAFMatFeedPredRes;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqEAFMatFeedPredRes& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csEAFMatFeedPredRes(tcdesc, _s);
  _a.PR_packFrom(_tc_seqEAFMatFeedPredRes, &tcdesc);
}

void _0RL_seq_delete_seqEAFMatFeedPredRes(void* _data)
{
  delete (seqEAFMatFeedPredRes*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqEAFMatFeedPredRes*& _s_out)
{
  return _a >>= (const seqEAFMatFeedPredRes*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqEAFMatFeedPredRes*& _s_out)
{
  _s_out = 0;
  seqEAFMatFeedPredRes* stmp = (seqEAFMatFeedPredRes*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqEAFMatFeedPredRes;
    _0RL_buildDesc_s0_csEAFMatFeedPredRes(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqEAFMatFeedPredRes, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqEAFMatFeedPredRes);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqEAFMatFeedPredRes *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqEAFMatFeedPredRes) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sPhaseStatus(void* _data) {
  sPhaseStatus* _0RL_t = (sPhaseStatus*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sPhaseStatus(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sPhaseStatus*)_desc->opq_struct)->PhaseName);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sPhaseStatus*)_desc->opq_struct)->Status);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sPhaseStatus(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_csPhaseStatus(tcDescriptor &_desc, const sPhaseStatus& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sPhaseStatus;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sPhaseStatus;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sPhaseStatus& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csPhaseStatus(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sPhaseStatus, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sPhaseStatus* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csPhaseStatus(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sPhaseStatus, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sPhaseStatus*& _sp) {
  return _a >>= (const sPhaseStatus*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sPhaseStatus*& _sp) {
  _sp = (sPhaseStatus *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sPhaseStatus;
    _0RL_buildDesc_csPhaseStatus(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sPhaseStatus, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sPhaseStatus);
      return 1;
    } else {
      delete (sPhaseStatus *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sPhaseStatus)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csPhaseStatus__
#define __0RL_tcParser_buildDesc_s0_csPhaseStatus__
static void
_0RL_tcParser_setElementCount_s0_csPhaseStatus(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sPhaseStatus > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csPhaseStatus(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sPhaseStatus > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csPhaseStatus(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csPhaseStatus(_newdesc, (*((_CORBA_Unbounded_Sequence< sPhaseStatus > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csPhaseStatus(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sPhaseStatus > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csPhaseStatus;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csPhaseStatus;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csPhaseStatus;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqPhaseStatus& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csPhaseStatus(tcdesc, _s);
  _a.PR_packFrom(_tc_seqPhaseStatus, &tcdesc);
}

void _0RL_seq_delete_seqPhaseStatus(void* _data)
{
  delete (seqPhaseStatus*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqPhaseStatus*& _s_out)
{
  return _a >>= (const seqPhaseStatus*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqPhaseStatus*& _s_out)
{
  _s_out = 0;
  seqPhaseStatus* stmp = (seqPhaseStatus*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqPhaseStatus;
    _0RL_buildDesc_s0_csPhaseStatus(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqPhaseStatus, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqPhaseStatus);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqPhaseStatus *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqPhaseStatus) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sMaterial(void* _data) {
  sMaterial* _0RL_t = (sMaterial*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sMaterial(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sMaterial*)_desc->opq_struct)->MatCode);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sMaterial*)_desc->opq_struct)->MatWeight);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((sMaterial*)_desc->opq_struct)->Purpose);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sMaterial(const tcStructDesc *_desc)
{
  return 3;
}

void _0RL_buildDesc_csMaterial(tcDescriptor &_desc, const sMaterial& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sMaterial;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sMaterial;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sMaterial& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csMaterial(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sMaterial, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sMaterial* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csMaterial(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sMaterial, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sMaterial*& _sp) {
  return _a >>= (const sMaterial*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sMaterial*& _sp) {
  _sp = (sMaterial *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sMaterial;
    _0RL_buildDesc_csMaterial(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sMaterial, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sMaterial);
      return 1;
    } else {
      delete (sMaterial *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sMaterial)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csMaterial__
#define __0RL_tcParser_buildDesc_s0_csMaterial__
static void
_0RL_tcParser_setElementCount_s0_csMaterial(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sMaterial > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csMaterial(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sMaterial > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csMaterial(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csMaterial(_newdesc, (*((_CORBA_Unbounded_Sequence< sMaterial > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csMaterial(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sMaterial > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csMaterial;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csMaterial;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csMaterial;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqMaterials& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csMaterial(tcdesc, _s);
  _a.PR_packFrom(_tc_seqMaterials, &tcdesc);
}

void _0RL_seq_delete_seqMaterials(void* _data)
{
  delete (seqMaterials*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqMaterials*& _s_out)
{
  return _a >>= (const seqMaterials*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqMaterials*& _s_out)
{
  _s_out = 0;
  seqMaterials* stmp = (seqMaterials*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqMaterials;
    _0RL_buildDesc_s0_csMaterial(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqMaterials, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqMaterials);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqMaterials *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqMaterials) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sStirringData(void* _data) {
  sStirringData* _0RL_t = (sStirringData*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sStirringData(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sStirringData*)_desc->opq_struct)->Device);
    return 1;
  case 1:
    _0RL_buildDesc_s0_csGasData(_newdesc, ((sStirringData*)_desc->opq_struct)->GasData);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sStirringData(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_csStirringData(tcDescriptor &_desc, const sStirringData& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sStirringData;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sStirringData;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sStirringData& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csStirringData(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sStirringData, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sStirringData* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csStirringData(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sStirringData, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sStirringData*& _sp) {
  return _a >>= (const sStirringData*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sStirringData*& _sp) {
  _sp = (sStirringData *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sStirringData;
    _0RL_buildDesc_csStirringData(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sStirringData, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sStirringData);
      return 1;
    } else {
      delete (sStirringData *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sStirringData)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csStirringData__
#define __0RL_tcParser_buildDesc_s0_csStirringData__
static void
_0RL_tcParser_setElementCount_s0_csStirringData(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sStirringData > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csStirringData(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sStirringData > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csStirringData(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csStirringData(_newdesc, (*((_CORBA_Unbounded_Sequence< sStirringData > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csStirringData(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sStirringData > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csStirringData;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csStirringData;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csStirringData;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqStirringData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csStirringData(tcdesc, _s);
  _a.PR_packFrom(_tc_seqStirringData, &tcdesc);
}

void _0RL_seq_delete_seqStirringData(void* _data)
{
  delete (seqStirringData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqStirringData*& _s_out)
{
  return _a >>= (const seqStirringData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqStirringData*& _s_out)
{
  _s_out = 0;
  seqStirringData* stmp = (seqStirringData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqStirringData;
    _0RL_buildDesc_s0_csStirringData(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqStirringData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqStirringData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqStirringData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqStirringData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sProductIdentification(void* _data) {
  sProductIdentification* _0RL_t = (sProductIdentification*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sProductIdentification(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sProductIdentification*)_desc->opq_struct)->HeatId);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((sProductIdentification*)_desc->opq_struct)->TreatId);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((sProductIdentification*)_desc->opq_struct)->OrderId);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((sProductIdentification*)_desc->opq_struct)->Plant);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sProductIdentification(const tcStructDesc *_desc)
{
  return 4;
}

void _0RL_buildDesc_csProductIdentification(tcDescriptor &_desc, const sProductIdentification& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sProductIdentification;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sProductIdentification;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sProductIdentification& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csProductIdentification(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sProductIdentification, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sProductIdentification* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csProductIdentification(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sProductIdentification, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sProductIdentification*& _sp) {
  return _a >>= (const sProductIdentification*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sProductIdentification*& _sp) {
  _sp = (sProductIdentification *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sProductIdentification;
    _0RL_buildDesc_csProductIdentification(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sProductIdentification, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sProductIdentification);
      return 1;
    } else {
      delete (sProductIdentification *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sProductIdentification)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sRecipe(void* _data) {
  sRecipe* _0RL_t = (sRecipe*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sRecipe(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sRecipe*)_desc->opq_struct)->RecipeName);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sRecipe*)_desc->opq_struct)->RecipeNo);
    return 1;
  case 2:
    _0RL_buildDesc_cstring(_newdesc, ((sRecipe*)_desc->opq_struct)->RecipeSource);
    return 1;
  case 3:
    _0RL_buildDesc_s0_csBatchPrio(_newdesc, ((sRecipe*)_desc->opq_struct)->RecipeContent);
    return 1;
  case 4:
    _0RL_buildDesc_csMetTimeStamp(_newdesc, ((sRecipe*)_desc->opq_struct)->TimeStamp);
    return 1;
  case 5:
    _0RL_buildDesc_csProductIdentification(_newdesc, ((sRecipe*)_desc->opq_struct)->Product);
    return 1;
  case 6:
    _0RL_buildDesc_csRecipeProperties(_newdesc, ((sRecipe*)_desc->opq_struct)->RecipeData);
    return 1;
  case 7:
    _0RL_buildDesc_cdouble(_newdesc, ((sRecipe*)_desc->opq_struct)->MatFeedRate);
    return 1;
  case 8:
    _0RL_buildDesc_cdouble(_newdesc, ((sRecipe*)_desc->opq_struct)->O2_Charge_Moment);
    return 1;
  case 9:
    _0RL_buildDesc_cstring(_newdesc, ((sRecipe*)_desc->opq_struct)->RecipeName_Model);
    return 1;
  case 10:
    _0RL_buildDesc_clong(_newdesc, ((sRecipe*)_desc->opq_struct)->RecipeNo_Model);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sRecipe(const tcStructDesc *_desc)
{
  return 11;
}

void _0RL_buildDesc_csRecipe(tcDescriptor &_desc, const sRecipe& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sRecipe;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sRecipe;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sRecipe& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csRecipe(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sRecipe, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sRecipe* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csRecipe(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sRecipe, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sRecipe*& _sp) {
  return _a >>= (const sRecipe*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sRecipe*& _sp) {
  _sp = (sRecipe *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sRecipe;
    _0RL_buildDesc_csRecipe(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sRecipe, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sRecipe);
      return 1;
    } else {
      delete (sRecipe *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sRecipe)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csRecipe__
#define __0RL_tcParser_buildDesc_s0_csRecipe__
static void
_0RL_tcParser_setElementCount_s0_csRecipe(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sRecipe > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csRecipe(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sRecipe > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csRecipe(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csRecipe(_newdesc, (*((_CORBA_Unbounded_Sequence< sRecipe > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csRecipe(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sRecipe > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csRecipe;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csRecipe;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csRecipe;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqRecipeList& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csRecipe(tcdesc, _s);
  _a.PR_packFrom(_tc_seqRecipeList, &tcdesc);
}

void _0RL_seq_delete_seqRecipeList(void* _data)
{
  delete (seqRecipeList*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqRecipeList*& _s_out)
{
  return _a >>= (const seqRecipeList*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqRecipeList*& _s_out)
{
  _s_out = 0;
  seqRecipeList* stmp = (seqRecipeList*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqRecipeList;
    _0RL_buildDesc_s0_csRecipe(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqRecipeList, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqRecipeList);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqRecipeList *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqRecipeList) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csProductIdentification__
#define __0RL_tcParser_buildDesc_s0_csProductIdentification__
static void
_0RL_tcParser_setElementCount_s0_csProductIdentification(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sProductIdentification > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csProductIdentification(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sProductIdentification > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csProductIdentification(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csProductIdentification(_newdesc, (*((_CORBA_Unbounded_Sequence< sProductIdentification > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csProductIdentification(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sProductIdentification > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csProductIdentification;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csProductIdentification;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csProductIdentification;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqProductIdentification& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csProductIdentification(tcdesc, _s);
  _a.PR_packFrom(_tc_seqProductIdentification, &tcdesc);
}

void _0RL_seq_delete_seqProductIdentification(void* _data)
{
  delete (seqProductIdentification*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqProductIdentification*& _s_out)
{
  return _a >>= (const seqProductIdentification*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqProductIdentification*& _s_out)
{
  _s_out = 0;
  seqProductIdentification* stmp = (seqProductIdentification*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqProductIdentification;
    _0RL_buildDesc_s0_csProductIdentification(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqProductIdentification, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqProductIdentification);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqProductIdentification *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqProductIdentification) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csHMDCalc__
#define __0RL_tcParser_buildDesc_s0_csHMDCalc__
static void
_0RL_tcParser_setElementCount_s0_csHMDCalc(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sHMDCalc > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csHMDCalc(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sHMDCalc > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csHMDCalc(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csHMDCalc(_newdesc, (*((_CORBA_Unbounded_Sequence< sHMDCalc > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csHMDCalc(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sHMDCalc > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csHMDCalc;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csHMDCalc;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csHMDCalc;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqHMDCalc& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csHMDCalc(tcdesc, _s);
  _a.PR_packFrom(_tc_seqHMDCalc, &tcdesc);
}

void _0RL_seq_delete_seqHMDCalc(void* _data)
{
  delete (seqHMDCalc*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqHMDCalc*& _s_out)
{
  return _a >>= (const seqHMDCalc*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqHMDCalc*& _s_out)
{
  _s_out = 0;
  seqHMDCalc* stmp = (seqHMDCalc*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqHMDCalc;
    _0RL_buildDesc_s0_csHMDCalc(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqHMDCalc, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqHMDCalc);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqHMDCalc *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqHMDCalc) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sHMDModelResult(void* _data) {
  sHMDModelResult* _0RL_t = (sHMDModelResult*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sHMDModelResult(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_clong(_newdesc, ((sHMDModelResult*)_desc->opq_struct)->TreatmentKind);
    return 1;
  case 1:
    _0RL_buildDesc_s0_csHMDCalc(_newdesc, ((sHMDModelResult*)_desc->opq_struct)->CalcAmount);
    return 1;
  case 2:
    _0RL_buildDesc_s0_csHMDCalc(_newdesc, ((sHMDModelResult*)_desc->opq_struct)->CalcFlow);
    return 1;
  case 3:
    _0RL_buildDesc_s0_cdouble(_newdesc, ((sHMDModelResult*)_desc->opq_struct)->SlagAmount);
    return 1;
  case 4:
    _0RL_buildDesc_s0_cdouble(_newdesc, ((sHMDModelResult*)_desc->opq_struct)->DurationDeslagging);
    return 1;
  case 5:
    _0RL_buildDesc_s0_cdouble(_newdesc, ((sHMDModelResult*)_desc->opq_struct)->TemperatureAfter);
    return 1;
  case 6:
    _0RL_buildDesc_s0_cdouble(_newdesc, ((sHMDModelResult*)_desc->opq_struct)->Cost);
    return 1;
  case 7:
    _0RL_buildDesc_s0_cdouble(_newdesc, ((sHMDModelResult*)_desc->opq_struct)->Duration);
    return 1;
  case 8:
    _0RL_buildDesc_clong(_newdesc, ((sHMDModelResult*)_desc->opq_struct)->IWarn);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sHMDModelResult(const tcStructDesc *_desc)
{
  return 9;
}

void _0RL_buildDesc_csHMDModelResult(tcDescriptor &_desc, const sHMDModelResult& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sHMDModelResult;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sHMDModelResult;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sHMDModelResult& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csHMDModelResult(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sHMDModelResult, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sHMDModelResult* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csHMDModelResult(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sHMDModelResult, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sHMDModelResult*& _sp) {
  return _a >>= (const sHMDModelResult*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sHMDModelResult*& _sp) {
  _sp = (sHMDModelResult *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sHMDModelResult;
    _0RL_buildDesc_csHMDModelResult(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sHMDModelResult, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sHMDModelResult);
      return 1;
    } else {
      delete (sHMDModelResult *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sHMDModelResult)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sRHModelResult(void* _data) {
  sRHModelResult* _0RL_t = (sRHModelResult*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sRHModelResult(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_clong(_newdesc, ((sRHModelResult*)_desc->opq_struct)->PhaseNo);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->TotDurPhase);
    return 1;
  case 2:
    _0RL_buildDesc_s0_csRecipe(_newdesc, ((sRHModelResult*)_desc->opq_struct)->Alloy);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->TempDiffAlloy);
    return 1;
  case 4:
    _0RL_buildDesc_s0_csAnalysis(_newdesc, ((sRHModelResult*)_desc->opq_struct)->Analysis);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->SlagWeight);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->SteelWeight);
    return 1;
  case 7:
    _0RL_buildDesc_cstring(_newdesc, ((sRHModelResult*)_desc->opq_struct)->PhaseName);
    return 1;
  case 8:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->HeatTemp);
    return 1;
  case 9:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->TempDiffPassive);
    return 1;
  case 10:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->OxygenAmount);
    return 1;
  case 11:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->OxygenFlow);
    return 1;
  case 12:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->PowderFlow);
    return 1;
  case 13:
    _0RL_buildDesc_clong(_newdesc, ((sRHModelResult*)_desc->opq_struct)->LanceDist);
    return 1;
  case 14:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->RemDur);
    return 1;
  case 15:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->AlHeat);
    return 1;
  case 16:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->AlAlloy);
    return 1;
  case 17:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->AlDeox);
    return 1;
  case 18:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->VacuumPressure);
    return 1;
  case 19:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->DNTime);
    return 1;
  case 20:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->DHTime);
    return 1;
  case 21:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->TempDiffStep);
    return 1;
  case 22:
    _0RL_buildDesc_cdouble(_newdesc, ((sRHModelResult*)_desc->opq_struct)->LiftGasFlow);
    return 1;
  case 23:
    _0RL_buildDesc_clong(_newdesc, ((sRHModelResult*)_desc->opq_struct)->VacCurve);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sRHModelResult(const tcStructDesc *_desc)
{
  return 24;
}

void _0RL_buildDesc_csRHModelResult(tcDescriptor &_desc, const sRHModelResult& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sRHModelResult;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sRHModelResult;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sRHModelResult& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csRHModelResult(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sRHModelResult, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sRHModelResult* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csRHModelResult(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sRHModelResult, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sRHModelResult*& _sp) {
  return _a >>= (const sRHModelResult*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sRHModelResult*& _sp) {
  _sp = (sRHModelResult *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sRHModelResult;
    _0RL_buildDesc_csRHModelResult(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sRHModelResult, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sRHModelResult);
      return 1;
    } else {
      delete (sRHModelResult *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sRHModelResult)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csRHModelResult__
#define __0RL_tcParser_buildDesc_s0_csRHModelResult__
static void
_0RL_tcParser_setElementCount_s0_csRHModelResult(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sRHModelResult > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csRHModelResult(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sRHModelResult > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csRHModelResult(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csRHModelResult(_newdesc, (*((_CORBA_Unbounded_Sequence< sRHModelResult > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csRHModelResult(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sRHModelResult > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csRHModelResult;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csRHModelResult;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csRHModelResult;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqRHModelResult& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csRHModelResult(tcdesc, _s);
  _a.PR_packFrom(_tc_seqRHModelResult, &tcdesc);
}

void _0RL_seq_delete_seqRHModelResult(void* _data)
{
  delete (seqRHModelResult*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqRHModelResult*& _s_out)
{
  return _a >>= (const seqRHModelResult*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqRHModelResult*& _s_out)
{
  _s_out = 0;
  seqRHModelResult* stmp = (seqRHModelResult*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqRHModelResult;
    _0RL_buildDesc_s0_csRHModelResult(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqRHModelResult, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqRHModelResult);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqRHModelResult *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqRHModelResult) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csHMDModelResult__
#define __0RL_tcParser_buildDesc_s0_csHMDModelResult__
static void
_0RL_tcParser_setElementCount_s0_csHMDModelResult(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sHMDModelResult > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csHMDModelResult(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sHMDModelResult > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csHMDModelResult(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csHMDModelResult(_newdesc, (*((_CORBA_Unbounded_Sequence< sHMDModelResult > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csHMDModelResult(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sHMDModelResult > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csHMDModelResult;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csHMDModelResult;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csHMDModelResult;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqHMDModelResult& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csHMDModelResult(tcdesc, _s);
  _a.PR_packFrom(_tc_seqHMDModelResult, &tcdesc);
}

void _0RL_seq_delete_seqHMDModelResult(void* _data)
{
  delete (seqHMDModelResult*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqHMDModelResult*& _s_out)
{
  return _a >>= (const seqHMDModelResult*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqHMDModelResult*& _s_out)
{
  _s_out = 0;
  seqHMDModelResult* stmp = (seqHMDModelResult*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqHMDModelResult;
    _0RL_buildDesc_s0_csHMDModelResult(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqHMDModelResult, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqHMDModelResult);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqHMDModelResult *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqHMDModelResult) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sElecPhaseData(void* _data) {
  sElecPhaseData* _0RL_t = (sElecPhaseData*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sElecPhaseData(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_clong(_newdesc, ((sElecPhaseData*)_desc->opq_struct)->PhaseNo);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((sElecPhaseData*)_desc->opq_struct)->PhaseName);
    return 1;
  case 2:
    _0RL_buildDesc_clong(_newdesc, ((sElecPhaseData*)_desc->opq_struct)->PhaseType);
    return 1;
  case 3:
    _0RL_buildDesc_cMCBS_mCBS__LocalTime(_newdesc, ((sElecPhaseData*)_desc->opq_struct)->StartTime);
    return 1;
  case 4:
    _0RL_buildDesc_cMCBS_mCBS__LocalTime(_newdesc, ((sElecPhaseData*)_desc->opq_struct)->EndTime);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sElecPhaseData*)_desc->opq_struct)->Duration);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sElecPhaseData*)_desc->opq_struct)->ElecCons);
    return 1;
  case 7:
    _0RL_buildDesc_cdouble(_newdesc, ((sElecPhaseData*)_desc->opq_struct)->ElecConsStart);
    return 1;
  case 8:
    _0RL_buildDesc_s0_csGasData(_newdesc, ((sElecPhaseData*)_desc->opq_struct)->GasData);
    return 1;
  case 9:
    _0RL_buildDesc_s0_csGasData(_newdesc, ((sElecPhaseData*)_desc->opq_struct)->GasDataStart);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sElecPhaseData(const tcStructDesc *_desc)
{
  return 10;
}

void _0RL_buildDesc_csElecPhaseData(tcDescriptor &_desc, const sElecPhaseData& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sElecPhaseData;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sElecPhaseData;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sElecPhaseData& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csElecPhaseData(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sElecPhaseData, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sElecPhaseData* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csElecPhaseData(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sElecPhaseData, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sElecPhaseData*& _sp) {
  return _a >>= (const sElecPhaseData*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sElecPhaseData*& _sp) {
  _sp = (sElecPhaseData *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sElecPhaseData;
    _0RL_buildDesc_csElecPhaseData(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sElecPhaseData, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sElecPhaseData);
      return 1;
    } else {
      delete (sElecPhaseData *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sElecPhaseData)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csElecPhaseData__
#define __0RL_tcParser_buildDesc_s0_csElecPhaseData__
static void
_0RL_tcParser_setElementCount_s0_csElecPhaseData(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sElecPhaseData > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csElecPhaseData(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sElecPhaseData > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csElecPhaseData(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csElecPhaseData(_newdesc, (*((_CORBA_Unbounded_Sequence< sElecPhaseData > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csElecPhaseData(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sElecPhaseData > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csElecPhaseData;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csElecPhaseData;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csElecPhaseData;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqElecPhaseData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csElecPhaseData(tcdesc, _s);
  _a.PR_packFrom(_tc_seqElecPhaseData, &tcdesc);
}

void _0RL_seq_delete_seqElecPhaseData(void* _data)
{
  delete (seqElecPhaseData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqElecPhaseData*& _s_out)
{
  return _a >>= (const seqElecPhaseData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqElecPhaseData*& _s_out)
{
  _s_out = 0;
  seqElecPhaseData* stmp = (seqElecPhaseData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqElecPhaseData;
    _0RL_buildDesc_s0_csElecPhaseData(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqElecPhaseData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqElecPhaseData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqElecPhaseData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqElecPhaseData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sVDModelResult(void* _data) {
  sVDModelResult* _0RL_t = (sVDModelResult*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sVDModelResult(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_clong(_newdesc, ((sVDModelResult*)_desc->opq_struct)->PhaseNo);
    return 1;
  case 1:
    _0RL_buildDesc_cstring(_newdesc, ((sVDModelResult*)_desc->opq_struct)->PhaseName);
    return 1;
  case 2:
    _0RL_buildDesc_s0_csAnalysis(_newdesc, ((sVDModelResult*)_desc->opq_struct)->Analysis);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->SteelWeight);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->SlagWeight);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->HeatTemp);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->TotDurPhase);
    return 1;
  case 7:
    _0RL_buildDesc_s0_csRecipe(_newdesc, ((sVDModelResult*)_desc->opq_struct)->Alloy);
    return 1;
  case 8:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->TempDiffAlloy);
    return 1;
  case 9:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->TempDiffStep);
    return 1;
  case 10:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->TempDiffPassive);
    return 1;
  case 11:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->RemDur);
    return 1;
  case 12:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->AlHeat);
    return 1;
  case 13:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->AlAlloy);
    return 1;
  case 14:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->AlDeox);
    return 1;
  case 15:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->DCTime);
    return 1;
  case 16:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->VacuumPressure);
    return 1;
  case 17:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->DNTime);
    return 1;
  case 18:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->DHTime);
    return 1;
  case 19:
    _0RL_buildDesc_cdouble(_newdesc, ((sVDModelResult*)_desc->opq_struct)->StirringFlow);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sVDModelResult(const tcStructDesc *_desc)
{
  return 20;
}

void _0RL_buildDesc_csVDModelResult(tcDescriptor &_desc, const sVDModelResult& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sVDModelResult;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sVDModelResult;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sVDModelResult& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csVDModelResult(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sVDModelResult, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sVDModelResult* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csVDModelResult(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sVDModelResult, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sVDModelResult*& _sp) {
  return _a >>= (const sVDModelResult*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sVDModelResult*& _sp) {
  _sp = (sVDModelResult *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sVDModelResult;
    _0RL_buildDesc_csVDModelResult(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sVDModelResult, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sVDModelResult);
      return 1;
    } else {
      delete (sVDModelResult *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sVDModelResult)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csVDModelResult__
#define __0RL_tcParser_buildDesc_s0_csVDModelResult__
static void
_0RL_tcParser_setElementCount_s0_csVDModelResult(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sVDModelResult > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csVDModelResult(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sVDModelResult > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csVDModelResult(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csVDModelResult(_newdesc, (*((_CORBA_Unbounded_Sequence< sVDModelResult > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csVDModelResult(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sVDModelResult > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csVDModelResult;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csVDModelResult;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csVDModelResult;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqVDModelResult& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csVDModelResult(tcdesc, _s);
  _a.PR_packFrom(_tc_seqVDModelResult, &tcdesc);
}

void _0RL_seq_delete_seqVDModelResult(void* _data)
{
  delete (seqVDModelResult*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqVDModelResult*& _s_out)
{
  return _a >>= (const seqVDModelResult*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqVDModelResult*& _s_out)
{
  _s_out = 0;
  seqVDModelResult* stmp = (seqVDModelResult*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqVDModelResult;
    _0RL_buildDesc_s0_csVDModelResult(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqVDModelResult, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqVDModelResult);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqVDModelResult *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqVDModelResult) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sConArcBlowData(void* _data) {
  sConArcBlowData* _0RL_t = (sConArcBlowData*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sConArcBlowData(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcBlowData*)_desc->opq_struct)->O2MomentEndStep);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcBlowData*)_desc->opq_struct)->O2Flow);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcBlowData*)_desc->opq_struct)->O2Cons);
    return 1;
  case 3:
    _0RL_buildDesc_clong(_newdesc, ((sConArcBlowData*)_desc->opq_struct)->TopLanceHeight);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcBlowData*)_desc->opq_struct)->PorousPlugN2Flow);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcBlowData*)_desc->opq_struct)->PorousPlugArFlow);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcBlowData*)_desc->opq_struct)->O2Start);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sConArcBlowData(const tcStructDesc *_desc)
{
  return 7;
}

void _0RL_buildDesc_csConArcBlowData(tcDescriptor &_desc, const sConArcBlowData& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sConArcBlowData;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sConArcBlowData;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sConArcBlowData& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcBlowData(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sConArcBlowData, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sConArcBlowData* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcBlowData(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sConArcBlowData, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sConArcBlowData*& _sp) {
  return _a >>= (const sConArcBlowData*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sConArcBlowData*& _sp) {
  _sp = (sConArcBlowData *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sConArcBlowData;
    _0RL_buildDesc_csConArcBlowData(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sConArcBlowData, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sConArcBlowData);
      return 1;
    } else {
      delete (sConArcBlowData *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sConArcBlowData)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sConArcModelResult(void* _data) {
  sConArcModelResult* _0RL_t = (sConArcModelResult*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sConArcModelResult(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sConArcModelResult*)_desc->opq_struct)->Phase);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sConArcModelResult*)_desc->opq_struct)->PhaseNo);
    return 1;
  case 2:
    _0RL_buildDesc_csGenRes(_newdesc, ((sConArcModelResult*)_desc->opq_struct)->GenRes);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcModelResult*)_desc->opq_struct)->BaseMass);
    return 1;
  case 4:
    _0RL_buildDesc_clong(_newdesc, ((sConArcModelResult*)_desc->opq_struct)->PhaseActive);
    return 1;
  case 5:
    _0RL_buildDesc_csConArcElecData(_newdesc, ((sConArcModelResult*)_desc->opq_struct)->ElectricalData);
    return 1;
  case 6:
    _0RL_buildDesc_csConArcBlowData(_newdesc, ((sConArcModelResult*)_desc->opq_struct)->BlowingData);
    return 1;
  case 7:
    _0RL_buildDesc_s0_csConArcMediaData(_newdesc, ((sConArcModelResult*)_desc->opq_struct)->MaterialData);
    return 1;
  case 8:
    _0RL_buildDesc_clong(_newdesc, ((sConArcModelResult*)_desc->opq_struct)->StepNo);
    return 1;
  case 9:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcModelResult*)_desc->opq_struct)->DecarbRate);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sConArcModelResult(const tcStructDesc *_desc)
{
  return 10;
}

void _0RL_buildDesc_csConArcModelResult(tcDescriptor &_desc, const sConArcModelResult& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sConArcModelResult;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sConArcModelResult;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sConArcModelResult& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcModelResult(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sConArcModelResult, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sConArcModelResult* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcModelResult(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sConArcModelResult, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sConArcModelResult*& _sp) {
  return _a >>= (const sConArcModelResult*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sConArcModelResult*& _sp) {
  _sp = (sConArcModelResult *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sConArcModelResult;
    _0RL_buildDesc_csConArcModelResult(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sConArcModelResult, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sConArcModelResult);
      return 1;
    } else {
      delete (sConArcModelResult *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sConArcModelResult)) return 1;
    _sp = 0;
    return 0;
  }
}
void _0RL_delete_sConArcMediaPredRes(void* _data) {
  sConArcMediaPredRes* _0RL_t = (sConArcMediaPredRes*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sConArcMediaPredRes(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_clong(_newdesc, ((sConArcMediaPredRes*)_desc->opq_struct)->StepNo);
    return 1;
  case 1:
    _0RL_buildDesc_s0_csConArcMediaData(_newdesc, ((sConArcMediaPredRes*)_desc->opq_struct)->MediaData);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sConArcMediaPredRes(const tcStructDesc *_desc)
{
  return 2;
}

void _0RL_buildDesc_csConArcMediaPredRes(tcDescriptor &_desc, const sConArcMediaPredRes& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sConArcMediaPredRes;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sConArcMediaPredRes;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sConArcMediaPredRes& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcMediaPredRes(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sConArcMediaPredRes, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sConArcMediaPredRes* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcMediaPredRes(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sConArcMediaPredRes, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sConArcMediaPredRes*& _sp) {
  return _a >>= (const sConArcMediaPredRes*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sConArcMediaPredRes*& _sp) {
  _sp = (sConArcMediaPredRes *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sConArcMediaPredRes;
    _0RL_buildDesc_csConArcMediaPredRes(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sConArcMediaPredRes, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sConArcMediaPredRes);
      return 1;
    } else {
      delete (sConArcMediaPredRes *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sConArcMediaPredRes)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csConArcMediaPredRes__
#define __0RL_tcParser_buildDesc_s0_csConArcMediaPredRes__
static void
_0RL_tcParser_setElementCount_s0_csConArcMediaPredRes(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sConArcMediaPredRes > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csConArcMediaPredRes(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sConArcMediaPredRes > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csConArcMediaPredRes(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csConArcMediaPredRes(_newdesc, (*((_CORBA_Unbounded_Sequence< sConArcMediaPredRes > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csConArcMediaPredRes(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sConArcMediaPredRes > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csConArcMediaPredRes;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csConArcMediaPredRes;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csConArcMediaPredRes;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqConArcMediaPredRes& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csConArcMediaPredRes(tcdesc, _s);
  _a.PR_packFrom(_tc_seqConArcMediaPredRes, &tcdesc);
}

void _0RL_seq_delete_seqConArcMediaPredRes(void* _data)
{
  delete (seqConArcMediaPredRes*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqConArcMediaPredRes*& _s_out)
{
  return _a >>= (const seqConArcMediaPredRes*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqConArcMediaPredRes*& _s_out)
{
  _s_out = 0;
  seqConArcMediaPredRes* stmp = (seqConArcMediaPredRes*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqConArcMediaPredRes;
    _0RL_buildDesc_s0_csConArcMediaPredRes(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqConArcMediaPredRes, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqConArcMediaPredRes);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqConArcMediaPredRes *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqConArcMediaPredRes) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csConArcBlowData__
#define __0RL_tcParser_buildDesc_s0_csConArcBlowData__
static void
_0RL_tcParser_setElementCount_s0_csConArcBlowData(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sConArcBlowData > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csConArcBlowData(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sConArcBlowData > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csConArcBlowData(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csConArcBlowData(_newdesc, (*((_CORBA_Unbounded_Sequence< sConArcBlowData > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csConArcBlowData(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sConArcBlowData > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csConArcBlowData;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csConArcBlowData;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csConArcBlowData;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqConArcBlowData& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csConArcBlowData(tcdesc, _s);
  _a.PR_packFrom(_tc_seqConArcBlowData, &tcdesc);
}

void _0RL_seq_delete_seqConArcBlowData(void* _data)
{
  delete (seqConArcBlowData*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqConArcBlowData*& _s_out)
{
  return _a >>= (const seqConArcBlowData*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqConArcBlowData*& _s_out)
{
  _s_out = 0;
  seqConArcBlowData* stmp = (seqConArcBlowData*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqConArcBlowData;
    _0RL_buildDesc_s0_csConArcBlowData(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqConArcBlowData, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqConArcBlowData);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqConArcBlowData *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqConArcBlowData) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

#ifndef __0RL_tcParser_buildDesc_s0_csConArcModelResult__
#define __0RL_tcParser_buildDesc_s0_csConArcModelResult__
static void
_0RL_tcParser_setElementCount_s0_csConArcModelResult(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sConArcModelResult > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csConArcModelResult(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sConArcModelResult > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csConArcModelResult(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csConArcModelResult(_newdesc, (*((_CORBA_Unbounded_Sequence< sConArcModelResult > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csConArcModelResult(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sConArcModelResult > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csConArcModelResult;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csConArcModelResult;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csConArcModelResult;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqConArcModelResult& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csConArcModelResult(tcdesc, _s);
  _a.PR_packFrom(_tc_seqConArcModelResult, &tcdesc);
}

void _0RL_seq_delete_seqConArcModelResult(void* _data)
{
  delete (seqConArcModelResult*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqConArcModelResult*& _s_out)
{
  return _a >>= (const seqConArcModelResult*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqConArcModelResult*& _s_out)
{
  _s_out = 0;
  seqConArcModelResult* stmp = (seqConArcModelResult*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqConArcModelResult;
    _0RL_buildDesc_s0_csConArcModelResult(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqConArcModelResult, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqConArcModelResult);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqConArcModelResult *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqConArcModelResult) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sLTSStirrPredRes(void* _data) {
  sLTSStirrPredRes* _0RL_t = (sLTSStirrPredRes*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sLTSStirrPredRes(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cstring(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->StirrPhase);
    return 1;
  case 1:
    _0RL_buildDesc_clong(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->StirrIntensity);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->StirrFlow);
    return 1;
  case 3:
    _0RL_buildDesc_cstring(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->GasType);
    return 1;
  case 4:
    _0RL_buildDesc_clong(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->Priority);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->DurStep);
    return 1;
  case 6:
    _0RL_buildDesc_cstring(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->StirrIntensityCode);
    return 1;
  case 7:
    _0RL_buildDesc_clong(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->Enable);
    return 1;
  case 8:
    _0RL_buildDesc_clong(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->Order);
    return 1;
  case 9:
    _0RL_buildDesc_clong(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->isPatternOrActivity);
    return 1;
  case 10:
    _0RL_buildDesc_cdouble(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->DurUntilEndOfStep);
    return 1;
  case 11:
    _0RL_buildDesc_cdouble(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->DurUntilStartOfStep);
    return 1;
  case 12:
    _0RL_buildDesc_clong(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->VoltTap);
    return 1;
  case 13:
    _0RL_buildDesc_clong(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->ImpCurve);
    return 1;
  case 14:
    _0RL_buildDesc_cdouble(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->ElecEgy);
    return 1;
  case 15:
    _0RL_buildDesc_cdouble(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->SteelMass);
    return 1;
  case 16:
    _0RL_buildDesc_cdouble(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->SlagMass);
    return 1;
  case 17:
    _0RL_buildDesc_cdouble(_newdesc, ((sLTSStirrPredRes*)_desc->opq_struct)->Temp);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sLTSStirrPredRes(const tcStructDesc *_desc)
{
  return 18;
}

void _0RL_buildDesc_csLTSStirrPredRes(tcDescriptor &_desc, const sLTSStirrPredRes& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sLTSStirrPredRes;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sLTSStirrPredRes;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sLTSStirrPredRes& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csLTSStirrPredRes(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sLTSStirrPredRes, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sLTSStirrPredRes* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csLTSStirrPredRes(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sLTSStirrPredRes, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sLTSStirrPredRes*& _sp) {
  return _a >>= (const sLTSStirrPredRes*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sLTSStirrPredRes*& _sp) {
  _sp = (sLTSStirrPredRes *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sLTSStirrPredRes;
    _0RL_buildDesc_csLTSStirrPredRes(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sLTSStirrPredRes, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sLTSStirrPredRes);
      return 1;
    } else {
      delete (sLTSStirrPredRes *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sLTSStirrPredRes)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csLTSStirrPredRes__
#define __0RL_tcParser_buildDesc_s0_csLTSStirrPredRes__
static void
_0RL_tcParser_setElementCount_s0_csLTSStirrPredRes(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sLTSStirrPredRes > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csLTSStirrPredRes(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sLTSStirrPredRes > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csLTSStirrPredRes(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csLTSStirrPredRes(_newdesc, (*((_CORBA_Unbounded_Sequence< sLTSStirrPredRes > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csLTSStirrPredRes(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sLTSStirrPredRes > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csLTSStirrPredRes;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csLTSStirrPredRes;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csLTSStirrPredRes;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqLTSStirrPredRes& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csLTSStirrPredRes(tcdesc, _s);
  _a.PR_packFrom(_tc_seqLTSStirrPredRes, &tcdesc);
}

void _0RL_seq_delete_seqLTSStirrPredRes(void* _data)
{
  delete (seqLTSStirrPredRes*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqLTSStirrPredRes*& _s_out)
{
  return _a >>= (const seqLTSStirrPredRes*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqLTSStirrPredRes*& _s_out)
{
  _s_out = 0;
  seqLTSStirrPredRes* stmp = (seqLTSStirrPredRes*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqLTSStirrPredRes;
    _0RL_buildDesc_s0_csLTSStirrPredRes(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqLTSStirrPredRes, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqLTSStirrPredRes);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqLTSStirrPredRes *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqLTSStirrPredRes) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sBOFGlobalSetpoints(void* _data) {
  sBOFGlobalSetpoints* _0RL_t = (sBOFGlobalSetpoints*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sBOFGlobalSetpoints(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->O2VolStartMatAddn);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->O2VolSartMatDynAddn);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->O2VolStartScrapChute);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->O2VolSubLance);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->O2VolTotal);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->O2VolTotalLance);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->N2VolTotal);
    return 1;
  case 7:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->MatFeedRate);
    return 1;
  case 8:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->MatDynFeedRate);
    return 1;
  case 9:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->AimTapWeightCalc);
    return 1;
  case 10:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->DurStartMatAddn);
    return 1;
  case 11:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->DurSartMatDynAddn);
    return 1;
  case 12:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->DurStartScrapChute);
    return 1;
  case 13:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->DurSubLance);
    return 1;
  case 14:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->O2VolStartMat2ndAddn);
    return 1;
  case 15:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->DurStartMat2ndAddn);
    return 1;
  case 16:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->MatFeedRate2ndAdd);
    return 1;
  case 17:
    _0RL_buildDesc_cdouble(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->AimSteelMassCalc);
    return 1;
  case 18:
    _0RL_buildDesc_clong(_newdesc, ((sBOFGlobalSetpoints*)_desc->opq_struct)->ReblowCode);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sBOFGlobalSetpoints(const tcStructDesc *_desc)
{
  return 19;
}

void _0RL_buildDesc_csBOFGlobalSetpoints(tcDescriptor &_desc, const sBOFGlobalSetpoints& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sBOFGlobalSetpoints;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sBOFGlobalSetpoints;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sBOFGlobalSetpoints& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csBOFGlobalSetpoints(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sBOFGlobalSetpoints, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sBOFGlobalSetpoints* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csBOFGlobalSetpoints(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sBOFGlobalSetpoints, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sBOFGlobalSetpoints*& _sp) {
  return _a >>= (const sBOFGlobalSetpoints*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sBOFGlobalSetpoints*& _sp) {
  _sp = (sBOFGlobalSetpoints *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sBOFGlobalSetpoints;
    _0RL_buildDesc_csBOFGlobalSetpoints(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sBOFGlobalSetpoints, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sBOFGlobalSetpoints);
      return 1;
    } else {
      delete (sBOFGlobalSetpoints *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sBOFGlobalSetpoints)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csBOFGlobalSetpoints__
#define __0RL_tcParser_buildDesc_s0_csBOFGlobalSetpoints__
static void
_0RL_tcParser_setElementCount_s0_csBOFGlobalSetpoints(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sBOFGlobalSetpoints > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csBOFGlobalSetpoints(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sBOFGlobalSetpoints > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csBOFGlobalSetpoints(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csBOFGlobalSetpoints(_newdesc, (*((_CORBA_Unbounded_Sequence< sBOFGlobalSetpoints > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csBOFGlobalSetpoints(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sBOFGlobalSetpoints > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csBOFGlobalSetpoints;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csBOFGlobalSetpoints;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csBOFGlobalSetpoints;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqBOFGlobalSetpoints& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csBOFGlobalSetpoints(tcdesc, _s);
  _a.PR_packFrom(_tc_seqBOFGlobalSetpoints, &tcdesc);
}

void _0RL_seq_delete_seqBOFGlobalSetpoints(void* _data)
{
  delete (seqBOFGlobalSetpoints*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqBOFGlobalSetpoints*& _s_out)
{
  return _a >>= (const seqBOFGlobalSetpoints*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqBOFGlobalSetpoints*& _s_out)
{
  _s_out = 0;
  seqBOFGlobalSetpoints* stmp = (seqBOFGlobalSetpoints*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqBOFGlobalSetpoints;
    _0RL_buildDesc_s0_csBOFGlobalSetpoints(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqBOFGlobalSetpoints, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqBOFGlobalSetpoints);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqBOFGlobalSetpoints *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqBOFGlobalSetpoints) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

void _0RL_delete_sConArcGlobalSetpoints(void* _data) {
  sConArcGlobalSetpoints* _0RL_t = (sConArcGlobalSetpoints*) _data;
  delete _0RL_t;
}

static CORBA::Boolean
_0RL_tcParser_getMemberDesc_sConArcGlobalSetpoints(const tcStructDesc *_desc, CORBA::ULong _index, tcDescriptor &_newdesc){
  switch (_index) {
  case 0:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->O2VolStartMatAddn);
    return 1;
  case 1:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->O2VolSartMatDynAddn);
    return 1;
  case 2:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->O2VolStartScrapChute);
    return 1;
  case 3:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->O2VolSubLance);
    return 1;
  case 4:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->O2VolTotal);
    return 1;
  case 5:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->O2VolTotalLance);
    return 1;
  case 6:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->N2VolTotal);
    return 1;
  case 7:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->ArVolTotal);
    return 1;
  case 8:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->MatFeedRate);
    return 1;
  case 9:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->MatDynFeedRate);
    return 1;
  case 10:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->AimTapWeightCalc);
    return 1;
  case 11:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->AimSteelMassCalc);
    return 1;
  case 12:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->DurStartMatAddn);
    return 1;
  case 13:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->DurSartMatDynAddn);
    return 1;
  case 14:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->DurStartScrapChute);
    return 1;
  case 15:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->DurSubLance);
    return 1;
  case 16:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->O2VolStartMat2ndAddn);
    return 1;
  case 17:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->DurStartMat2ndAddn);
    return 1;
  case 18:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->MatFeedRate2ndAdd);
    return 1;
  case 19:
    _0RL_buildDesc_clong(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->ReblowCode);
    return 1;
  case 20:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->DRICons);
    return 1;
  case 21:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->LimeCons);
    return 1;
  case 22:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->DoloCons);
    return 1;
  case 23:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->CoalCons);
    return 1;
  case 24:
    _0RL_buildDesc_cdouble(_newdesc, ((sConArcGlobalSetpoints*)_desc->opq_struct)->EgyTotal);
    return 1;

  default:
    return 0;
  };
}
static CORBA::ULong

_0RL_tcParser_getMemberCount_sConArcGlobalSetpoints(const tcStructDesc *_desc)
{
  return 25;
}

void _0RL_buildDesc_csConArcGlobalSetpoints(tcDescriptor &_desc, const sConArcGlobalSetpoints& _data)
{
  _desc.p_struct.getMemberDesc = _0RL_tcParser_getMemberDesc_sConArcGlobalSetpoints;
  _desc.p_struct.getMemberCount = _0RL_tcParser_getMemberCount_sConArcGlobalSetpoints;
  _desc.p_struct.opq_struct = (void *)&_data;
}



void operator<<=(CORBA::Any& _a, const sConArcGlobalSetpoints& _s) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcGlobalSetpoints(_0RL_tcdesc, _s);
  _a.PR_packFrom(_0RL_tc_sConArcGlobalSetpoints, &_0RL_tcdesc);
}
 
void operator<<=(CORBA::Any& _a, sConArcGlobalSetpoints* _sp) {
  tcDescriptor _0RL_tcdesc;
  _0RL_buildDesc_csConArcGlobalSetpoints(_0RL_tcdesc, *_sp);
  _a.PR_packFrom(_0RL_tc_sConArcGlobalSetpoints, &_0RL_tcdesc);
  delete _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, sConArcGlobalSetpoints*& _sp) {
  return _a >>= (const sConArcGlobalSetpoints*&) _sp;
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, const sConArcGlobalSetpoints*& _sp) {
  _sp = (sConArcGlobalSetpoints *) _a.PR_getCachedData();
  if (_sp == 0) {
    tcDescriptor _0RL_tcdesc;
    _sp = new sConArcGlobalSetpoints;
    _0RL_buildDesc_csConArcGlobalSetpoints(_0RL_tcdesc, *_sp);
    if (_a.PR_unpackTo(_0RL_tc_sConArcGlobalSetpoints, &_0RL_tcdesc)) {
      ((CORBA::Any *)&_a)->PR_setCachedData((void*)_sp, _0RL_delete_sConArcGlobalSetpoints);
      return 1;
    } else {
      delete (sConArcGlobalSetpoints *)_sp; _sp = 0;
      return 0;
    }
  } else {
    CORBA::TypeCode_var _0RL_tctmp = _a.type();
    if (_0RL_tctmp->equivalent(_0RL_tc_sConArcGlobalSetpoints)) return 1;
    _sp = 0;
    return 0;
  }
}
#ifndef __0RL_tcParser_buildDesc_s0_csConArcGlobalSetpoints__
#define __0RL_tcParser_buildDesc_s0_csConArcGlobalSetpoints__
static void
_0RL_tcParser_setElementCount_s0_csConArcGlobalSetpoints(const tcSequenceDesc* _desc, CORBA::ULong _len)
{
  ((_CORBA_Unbounded_Sequence< sConArcGlobalSetpoints > *)_desc->opq_seq)->length(_len);
}

static CORBA::ULong
_0RL_tcParser_getElementCount_s0_csConArcGlobalSetpoints(const tcSequenceDesc* _desc)
{
  return ((_CORBA_Unbounded_Sequence< sConArcGlobalSetpoints > *)_desc->opq_seq)->length();
}

static CORBA::Boolean
_0RL_tcParser_getElementDesc_s0_csConArcGlobalSetpoints(const tcSequenceDesc* _desc, CORBA::ULong _index, tcDescriptor& _newdesc, _CORBA_ULong& _contiguous)
{
  _0RL_buildDesc_csConArcGlobalSetpoints(_newdesc, (*((_CORBA_Unbounded_Sequence< sConArcGlobalSetpoints > *)_desc->opq_seq))[_index]);


  return 1;
}

static void
_0RL_buildDesc_s0_csConArcGlobalSetpoints(tcDescriptor &_desc, const _CORBA_Unbounded_Sequence< sConArcGlobalSetpoints > & _data)
{
  _desc.p_sequence.opq_seq = (void*) &_data;
  _desc.p_sequence.setElementCount =
    _0RL_tcParser_setElementCount_s0_csConArcGlobalSetpoints;
  _desc.p_sequence.getElementCount =
    _0RL_tcParser_getElementCount_s0_csConArcGlobalSetpoints;
  _desc.p_sequence.getElementDesc =
    _0RL_tcParser_getElementDesc_s0_csConArcGlobalSetpoints;
  }
#endif

void operator <<= (CORBA::Any& _a, const seqConArcGlobalSetpoints& _s)
{
  tcDescriptor tcdesc;
  _0RL_buildDesc_s0_csConArcGlobalSetpoints(tcdesc, _s);
  _a.PR_packFrom(_tc_seqConArcGlobalSetpoints, &tcdesc);
}

void _0RL_seq_delete_seqConArcGlobalSetpoints(void* _data)
{
  delete (seqConArcGlobalSetpoints*)_data;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, seqConArcGlobalSetpoints*& _s_out)
{
  return _a >>= (const seqConArcGlobalSetpoints*&) _s_out;
}

CORBA::Boolean operator >>= (const CORBA::Any& _a, const seqConArcGlobalSetpoints*& _s_out)
{
  _s_out = 0;
  seqConArcGlobalSetpoints* stmp = (seqConArcGlobalSetpoints*) _a.PR_getCachedData();
  if( stmp == 0 ) {
    tcDescriptor tcdesc;
    stmp = new seqConArcGlobalSetpoints;
    _0RL_buildDesc_s0_csConArcGlobalSetpoints(tcdesc, *stmp);
    if( _a.PR_unpackTo(_tc_seqConArcGlobalSetpoints, &tcdesc)) {
      ((CORBA::Any*)&_a)->PR_setCachedData((void*)stmp, _0RL_seq_delete_seqConArcGlobalSetpoints);
      _s_out = stmp;
      return 1;
    } else {
      delete (seqConArcGlobalSetpoints *)stmp;
      return 0;
    }
  } else {
    CORBA::TypeCode_var tctmp = _a.type();
    if( tctmp->equivalent(_tc_seqConArcGlobalSetpoints) ) {
      _s_out = stmp;
      return 1;
    } else {
      return 0;
    }
  }
}

static void
_0RL_tcParser_setObjectPtr_iSMC__DataProvider(const tcObjrefDesc *_desc, CORBA::Object_ptr _ptr)
{
  iSMC_DataProvider_ptr _p = iSMC_DataProvider::_narrow(_ptr);
  iSMC_DataProvider_ptr* pp = (iSMC_DataProvider_ptr*)_desc->opq_objref;
  if (_desc->opq_release && !CORBA::is_nil(*pp)) CORBA::release(*pp);
  *pp = _p;
  CORBA::release(_ptr);
}

static CORBA::Object_ptr
_0RL_tcParser_getObjectPtr_iSMC__DataProvider(const tcObjrefDesc *_desc)
{
  return (CORBA::Object_ptr) *((iSMC_DataProvider_ptr*)_desc->opq_objref);
}

void _0RL_buildDesc_ciSMC__DataProvider(tcDescriptor& _desc, const _CORBA_ObjRef_tcDesc_arg< _objref_iSMC_DataProvider, iSMC_DataProvider_Helper> & _d)
{
  _desc.p_objref.opq_objref = (void*) &_d._data;
  _desc.p_objref.opq_release = _d._rel;
  _desc.p_objref.setObjectPtr = _0RL_tcParser_setObjectPtr_iSMC__DataProvider;
  _desc.p_objref.getObjectPtr = _0RL_tcParser_getObjectPtr_iSMC__DataProvider;
}

void _0RL_delete_iSMC__DataProvider(void* _data) {
  CORBA::release((iSMC_DataProvider_ptr) _data);
}

void operator<<=(CORBA::Any& _a, iSMC_DataProvider_ptr _s) {
  tcDescriptor tcd;
  _CORBA_ObjRef_tcDesc_arg< _objref_iSMC_DataProvider, iSMC_DataProvider_Helper>  tmp(_s,0);
  _0RL_buildDesc_ciSMC__DataProvider(tcd, tmp);
  _a.PR_packFrom(_tc_iSMC_DataProvider, &tcd);
}

void operator<<=(CORBA::Any& _a, iSMC_DataProvider_ptr* _sp) {
  _a <<= *_sp;
  CORBA::release(*_sp);
  *_sp = iSMC_DataProvider::_nil();
}

CORBA::Boolean operator>>=(const CORBA::Any& _a, iSMC_DataProvider_ptr& _s) {
  iSMC_DataProvider_ptr sp = (iSMC_DataProvider_ptr) _a.PR_getCachedData();
  if (sp == 0) {
    tcDescriptor tcd;
    iSMC_DataProvider_var tmp;
    _0RL_buildDesc_ciSMC__DataProvider(tcd, tmp);
    if( _a.PR_unpackTo(_tc_iSMC_DataProvider, &tcd) ) {
      if (!omniORB::omniORB_27_CompatibleAnyExtraction) {
        ((CORBA::Any*)&_a)->PR_setCachedData((void*)(iSMC_DataProvider_ptr)tmp,_0RL_delete_iSMC__DataProvider);
      }
      _s = tmp._retn();
      return 1;
    } else {
      _s = iSMC_DataProvider::_nil(); return 0;
    }
  }
  else {
    CORBA::TypeCode_var tc = _a.type();
    if (tc->equivalent(_tc_iSMC_DataProvider)) {
    _s = sp; return 1;
    }
    else {
    _s = iSMC_DataProvider::_nil(); return 0;
    }
  }
}

